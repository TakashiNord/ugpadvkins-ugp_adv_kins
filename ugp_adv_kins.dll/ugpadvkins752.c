/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2009 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Data declarations

extern char aReturnedErrorD[]; // idb
extern char aReturnedAD[]; // idb
extern char Format[]; // idb
extern char aKinematics[11]; // weak
extern char aErrorAdvancedK[]; // idb
extern char aUgpkin[13]; // weak
extern char aNumberOfArgume[]; // idb
extern char aIncorrectNumbe[]; // idb
extern char aSet_rotd_opera[]; // idb
extern char aSet_rotd_mcs_m[]; // idb
extern char aCaxis[6]; // weak
extern char aBaxis[6]; // weak
extern char aAaxis[6]; // weak
extern char aInsufficientNu[]; // idb
extern char aPos_z[6]; // weak
extern char aPos_y[6]; // weak
extern char aPos_x[6]; // weak
extern char aMom_transfer_g[]; // idb
extern char aMom_process_in[]; // idb
extern char aSet_input_poin[]; // idb
extern char a5_axis_head_ta[]; // idb
extern char a5_axis_dual_he[]; // idb
extern char a5_axis_dual_ta[]; // idb
extern char aNegz[]; // idb
extern char aNegy[]; // idb
extern char aNegx[]; // idb
extern char aPosz[]; // idb
extern char aPosy[]; // idb
extern char SubStr[]; // idb
extern char aAlt_pos_a2[11]; // weak
extern char aAlt_pos_a1[11]; // weak
extern char aAlt_pos_z[10]; // weak
extern char aAlt_pos_y[10]; // weak
extern char aAlt_pos_x[10]; // weak
extern char aPos_a2[7]; // weak
extern char aPos_a1[7]; // weak
extern char aUf_attr_read_v[]; // idb
extern char aUf_obj_cycle_b[]; // idb
extern char aNoToolNameObta[34]; // weak
extern char aErrorS[]; // idb
extern char aInvalidNumberO[28]; // weak
extern int dword_100095CC; // weak
extern int dword_100095D0; // weak
extern __int16 word_100095D4; // weak
extern int dword_100095D8; // weak
extern int dword_100095DC; // weak
extern int dword_100095E0; // weak
extern int dword_100095E4; // weak
extern int dword_100095E8; // weak
extern char aUf_mom_exten_4[87]; // weak
extern char aMom_exit_kinem[27]; // weak
extern char aUf_mom_exten_3[81]; // weak
extern char aMom_map_to_rot[24]; // weak
extern char aUf_mom_exten_2[75]; // weak
extern char aMom_rotate_mac[21]; // weak
extern char aUf_mom_exten_1[80]; // weak
extern char aMom_get_tool_a[23]; // weak
extern char aUf_mom_exten_0[69]; // weak
extern char aMom_convert_po[18]; // weak
extern char aOUgnx75Ip32Src[63]; // weak
extern char aUf_mom_extend_[73]; // weak
extern char aMom_load_kinem[20]; // weak
extern char aErrorUgpostAdv[]; // idb
extern _UNKNOWN unk_100098E0; // weak
extern _UNKNOWN unk_10009928; // weak
extern _UNKNOWN unk_10009970; // weak
extern char aWarningSameVal[]; // idb
extern char aComputingT11FT[]; // idb
extern char aComputingT10FT[]; // idb
extern char aAboutAdjusting[]; // idb
extern char aWarningDegener[]; // idb
extern char aInputPoint_4f_[]; // idb
extern char aStartingOld_pc[]; // idb
extern char asc_10009BA4[]; // idb
extern char aInit_t11Init_t[]; // idb
extern char aInit_t10Init_t[]; // idb
extern char aA1FD1FAlpha1FA[]; // idb
extern char aWarningToolAxi[]; // idb
extern char aLocalSecondary[]; // idb
extern char aLocalPrimaryax[]; // idb
extern char aSulzerCase[]; // idb
extern char aMcsysFFFFFFFFF[]; // idb
extern char aTool_vectorFFF[]; // idb
extern char aTool_machine_c[]; // idb
extern char aSecondary_mach[]; // idb
extern char aSecondaryFFF[]; // idb
extern char aPrimary_machin[]; // idb
extern char aPrimaryFFF[]; // idb
extern char aIs_5_axis_head[]; // idb
extern char aIs_5_axis_du_0[21]; // weak
extern char aIs_5_axis_dual[22]; // weak
extern char aIs_orthogonal_[]; // idb
extern char asc_10009E58[]; // idb
extern char aFinalUfuncAlt_[]; // idb
extern char aFinalUfuncMcoo[]; // idb
extern char a400_00[7]; // weak
extern char a0_0[4]; // weak
extern wchar_t asc_10009F24[2]; // weak
extern char aIn[3]; // weak
extern char aNone[5]; // weak
extern char aMom_kin_rapid_[24]; // weak
extern char aMom_kin_pivot_[27]; // weak
extern char aMom_kin_read_a[31]; // weak
extern char aMom_kin_polar_[26]; // weak
extern char aMom_kin_output[20]; // weak
extern char aEnd[4]; // weak
extern char aMom_kin_nurbs_[26]; // weak
extern char a9999_9999[10]; // weak
extern char a0_0001[7]; // weak
extern char aXy[3]; // weak
extern char aFull_circle[12]; // weak
extern char aMom_kin_max_ar[23]; // weak
extern char aMom_kin_min_ar[23]; // weak
extern char aMom_kin_arc_va[24]; // weak
extern char aMom_kin_arc_ou[24]; // weak
extern char a99999_999[10]; // weak
extern char a99_999[7]; // weak
extern char a0_001[6]; // weak
extern char a999_999[8]; // weak
extern char aMom_kin_min_dp[16]; // weak
extern char aMom_kin_max_dp[16]; // weak
extern char aMom_kin_min_fr[16]; // weak
extern char aMom_kin_max_fr[16]; // weak
extern char aMom_kin_min__0[16]; // weak
extern char aMom_kin_max__0[16]; // weak
extern char aMom_kin_min_fp[16]; // weak
extern char aMom_kin_max_fp[16]; // weak
extern char a360_0[6]; // weak
extern char aStandard[9]; // weak
extern char aMagnitude_dete[31]; // weak
extern char aYz[3]; // weak
extern char aMom_kin_4th_13[27]; // weak
extern char aMom_kin_4th_12[27]; // weak
extern char aMom_kin_4th_11[26]; // weak
extern char aMom_kin_4th_10[26]; // weak
extern char aMom_kin_4th__9[26]; // weak
extern char aMom_kin_4th__8[33]; // weak
extern char aMom_kin_4th__7[33]; // weak
extern char aMom_kin_4th__6[33]; // weak
extern char aMom_kin_4th__5[22]; // weak
extern char aMom_kin_4th__4[27]; // weak
extern char aMom_kin_4th__3[27]; // weak
extern char aMom_kin_4th__2[26]; // weak
extern char aMom_kin_4th__1[26]; // weak
extern char aMom_kin_4th__0[27]; // weak
extern char aMom_kin_4th_ax[23]; // weak
extern char aMom_kin_5th_13[27]; // weak
extern char aMom_kin_5th_12[27]; // weak
extern char aMom_kin_5th_11[26]; // weak
extern char aMom_kin_5th_10[26]; // weak
extern char aMom_kin_5th__9[26]; // weak
extern char aMom_kin_5th__8[33]; // weak
extern char aMom_kin_5th__7[33]; // weak
extern char aMom_kin_5th__6[33]; // weak
extern char aMom_kin_5th__5[22]; // weak
extern char aMom_kin_5th__4[27]; // weak
extern char aMom_kin_5th__3[27]; // weak
extern char aMom_kin_5th__2[26]; // weak
extern char aMom_kin_5th__1[26]; // weak
extern char aMom_kin_5th__0[27]; // weak
extern char aMom_kin_5th_ax[23]; // weak
extern char aFront[6]; // weak
extern char aMom_kin_ind__0[32]; // weak
extern char aMom_kin_ind_to[32]; // weak
extern char aMom_kin_indepe[25]; // weak
extern char a3_0[4]; // weak
extern char a0_5[4]; // weak
extern char aMom_kin_flush_[19]; // weak
extern char aMom_kin_clamp_[19]; // weak
extern char aMom_kin_tool_c[25]; // weak
extern char aMom_kin_hol_22[25]; // weak
extern char aMom_kin_hol_21[25]; // weak
extern char aMom_kin_hol_20[25]; // weak
extern char aMom_kin_hol_19[25]; // weak
extern char aMom_kin_hol_18[25]; // weak
extern char aMom_kin_hol_17[25]; // weak
extern char aMom_kin_hol_16[25]; // weak
extern char aMom_kin_hol_15[25]; // weak
extern char aMom_kin_hol_14[25]; // weak
extern char aMom_kin_hol_13[25]; // weak
extern char aMom_kin_hol_12[25]; // weak
extern char aMom_kin_hol_11[25]; // weak
extern char aMom_kin_hol_10[25]; // weak
extern char aMom_kin_hold_9[25]; // weak
extern char aMom_kin_hold_8[25]; // weak
extern char aMom_kin_hold_7[25]; // weak
extern char aMom_kin_hold_6[25]; // weak
extern char aMom_kin_hold_5[25]; // weak
extern char aMom_kin_hold_4[28]; // weak
extern char aMom_kin_hold_3[28]; // weak
extern char aMom_kin_hold_2[28]; // weak
extern char aMom_kin_hold_1[28]; // weak
extern char aMom_kin_hold_0[28]; // weak
extern char aMom_kin_holder[28]; // weak
extern char aKin_4th_to_t_1[28]; // weak
extern char aKin_4th_to_t_0[28]; // weak
extern char aKin_4th_to_tra[28]; // weak
extern char a90_0[5]; // weak
extern char aCartesian[10]; // weak
extern wchar_t aT[2]; // weak
extern char a3_axis_mill[12]; // weak
extern char aMom_kin_gaug_0[25]; // weak
extern char aMom_kin_line_0[26]; // weak
extern char aMom_kin_5th_14[36]; // weak
extern char aMom_kin_tool_t[29]; // weak
extern char aMom_kin_mach_0[27]; // weak
extern char aMom_kin_linear[27]; // weak
extern char aMom_kin_coordi[24]; // weak
extern char aMom_kin_clsf_g[24]; // weak
extern char aMom_kin_wire_t[30]; // weak
extern char aMom_kin_track_[29]; // weak
extern char aMom_kin_machin[21]; // weak
extern char aMom_kin_gauge_[25]; // weak
extern char a1_0[4]; // weak
extern char aMom_msys_z_a_1[18]; // weak
extern char aMom_msys_z_a_0[18]; // weak
extern char aMom_msys_z_axi[18]; // weak
extern char aMom_msys_y_a_1[18]; // weak
extern char aMom_msys_y_a_0[18]; // weak
extern char aMom_msys_y_axi[18]; // weak
extern char aMom_msys_x_a_1[18]; // weak
extern char aMom_msys_x_a_0[18]; // weak
extern char aMom_msys_x_axi[18]; // weak
extern char aMom_msys_ori_1[18]; // weak
extern char aMom_msys_ori_0[18]; // weak
extern char aMom_msys_origi[18]; // weak
extern char aMom_mtsys_z__1[19]; // weak
extern char aMom_mtsys_z__0[19]; // weak
extern char aMom_mtsys_z_ax[19]; // weak
extern char aMom_mtsys_y__1[19]; // weak
extern char aMom_mtsys_y__0[19]; // weak
extern char aMom_mtsys_y_ax[19]; // weak
extern char aMom_mtsys_x__1[19]; // weak
extern char aMom_mtsys_x__0[19]; // weak
extern char aMom_mtsys_x_ax[19]; // weak
extern char aMom_mtsys_or_1[19]; // weak
extern char aMom_mtsys_or_0[19]; // weak
extern char aMom_mtsys_orig[19]; // weak
extern char aMill[5]; // weak
extern char aMom_tool_corne[24]; // weak
extern char aMom_tool_z_off[18]; // weak
extern char aMom_tool_type[14]; // weak
extern char aMom_translat_1[16]; // weak
extern char aMom_translat_0[16]; // weak
extern char aMom_translate_[16]; // weak
extern char aMom_origin_z[13]; // weak
extern char aMom_origin_y[13]; // weak
extern char aMom_origin_x[13]; // weak
extern char aMom_tool_axi_1[16]; // weak
extern char aMom_tool_axi_0[16]; // weak
extern char aMom_tool_axis_[16]; // weak
extern char aMom_mcs_goto_z[15]; // weak
extern char aMom_mcs_goto_y[15]; // weak
extern char aMom_mcs_goto_x[15]; // weak
extern char aWarningTheTo_0[119]; // weak
extern char aWarningTheTool[]; // idb
extern int dword_1000ADA8; // weak
extern _UNKNOWN unk_1000AE58; // weak
extern double dbl_1000C000; // weak
extern char byte_1000C008; // weak
extern char byte_1000C009; // weak
extern char byte_1000C00A; // weak
extern int dword_1000C238; // weak
extern int dword_1000C240; // weak
extern double dbl_1000C248; // weak
extern int dword_1000C2C8; // weak
extern int dword_1000C2CC; // weak
extern int dword_1000C2D0; // weak
extern int dword_1000C2D4; // weak
extern int dword_1000C2D8; // weak
extern int dword_1000C2DC; // weak
extern double dbl_1000C2E0; // weak
extern double dbl_1000C2E8; // weak
extern double dbl_1000C2F0; // weak
extern double dbl_1000C2F8; // weak
extern double dbl_1000C300; // weak
extern double dbl_1000C308; // weak
extern double dbl_1000C310; // weak
extern double dbl_1000C318; // weak
extern double dbl_1000C320; // weak
extern double dbl_1000C328; // weak
extern double dbl_1000C330; // weak
extern double dbl_1000C338; // weak
extern _UNKNOWN unk_1000C340; // weak
extern double dbl_1000C348; // weak
extern int dword_1000C3D8; // weak
extern int dword_1000C3DC; // weak
extern _UNKNOWN unk_1000C3E0; // weak
extern double dbl_1000C460; // weak
extern double dbl_1000C468; // weak
extern double dbl_1000C470; // weak
extern double dbl_1000C478; // weak
extern double dbl_1000C480; // weak
extern double dbl_1000C488; // weak
extern double dbl_1000C490; // weak
extern double dbl_1000C498; // weak
extern double dbl_1000C4A0; // weak
extern double dbl_1000C4A8; // weak
extern double dbl_1000C4B0; // weak
extern double dbl_1000C4B8; // weak
extern double dbl_1000C4C0; // weak
extern double dbl_1000C4C8; // weak
extern double dbl_1000C4D0; // weak
extern double dbl_1000C4D8; // weak
extern int dword_1000C4E0; // weak
extern int dword_1000C4E4; // weak
extern int dword_1000C4E8; // weak
extern int dword_1000C4EC; // weak
extern int dword_1000C4F0; // weak
extern int dword_1000C4F4; // weak
extern int dword_1000C4F8; // weak
extern int dword_1000C4FC; // weak
extern int dword_1000C500; // weak
extern int dword_1000C504; // weak
extern int dword_1000C508; // weak
extern int dword_1000C50C; // weak
extern int dword_1000C510; // weak
extern int dword_1000C514; // weak
extern int dword_1000C518; // weak
extern int dword_1000C51C; // weak
extern int dword_1000C520; // weak
extern int dword_1000C524; // weak
extern int dword_1000C528; // weak
extern int dword_1000C52C; // weak
extern double dbl_1000C530; // weak
extern double dbl_1000C538; // weak
extern int dword_1000C540; // weak
extern int dword_1000C544; // weak
extern int dword_1000C548; // weak
extern int dword_1000C54C; // weak
extern int dword_1000C550; // weak
extern int dword_1000C554; // weak
extern double dbl_1000C558; // weak
extern double dbl_1000C560; // weak
extern double dbl_1000C568; // weak
extern double dbl_1000C570; // weak
extern double dbl_1000C578; // weak
extern double dbl_1000C580; // weak
extern char byte_1000C588; // weak
extern _UNKNOWN unk_1000C590; // weak
extern _UNKNOWN unk_1000C5B8; // weak
extern _UNKNOWN unk_1000C5E0; // weak
extern double dbl_1000C5F8; // weak
extern double dbl_1000C600; // weak
extern double dbl_1000C608; // weak
extern double dbl_1000C610; // weak
extern double dbl_1000C618; // weak
extern double dbl_1000C620; // weak
extern double dbl_1000C628; // weak
extern double dbl_1000C630; // weak
extern double dbl_1000C638; // weak
extern _UNKNOWN unk_1000C640; // weak
extern double dbl_1000C658; // weak
extern int dword_1000C660; // weak
extern double dbl_1000C668; // weak
extern int dword_1000C670; // weak
extern _UNKNOWN unk_1000C67C; // weak
extern int dword_1000C9AC; // weak

//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

// int __usercall sub_10001000<eax>(int a1<eax>, int a2<edx>, int a3<ecx>, int a4<esi>);
int __cdecl sub_10001060(char *Dest); // idb
// int UF_terminate(); weak
int __cdecl sub_100010C0(int, int, int, int); // weak
int __cdecl sub_100012B0(int); // weak
signed int __cdecl sub_10001390(int Str);
int __cdecl sub_10001B00(int); // weak
signed int __cdecl sub_10001C00(int a1, int a2, char *a3, int a4);
int __cdecl ufusr(int a1, int a2);
// int __usercall sub_10001F60<eax>(int a1<eax>, int a2<ecx>, int a3<esi>, char a4);
// int __cdecl sub_10001F90(double); idb
// int __usercall sub_10001FE0<eax>(int result<eax>, int _ECX<ecx>, double a3);
// int __usercall sub_100020C0<eax>(int a1<eax>, int a2<ecx>, int a3);
// int __usercall sub_10002190<eax>(int a1<eax>, int a2<esi>, double a3, double a4, signed int a5);
int __cdecl sub_10002310(int, double, int); // idb
int __cdecl sub_10002390(int, double, int); // idb
double __fastcall sub_100023D0(int a1, int a2, int a3);
signed int __cdecl PtFuncCompare(int a1, int a2);
void __fastcall sub_10002430(int a1, int a2);
double __cdecl sub_10002580(double a1);
// void __usercall sub_100025B0(int a1<edx>, int a2<ebx>);
int __cdecl sub_100026E0(int a1);
int __cdecl sub_10002770(int a1, int a2, int a3, int a4);
// signed int __usercall sub_10002830<eax>(int a1<esi>, signed int a2, int a3, int a4);
// void __usercall sub_10002C00(int a1<eax>, int a2<ecx>, int a3, int a4);
// void __usercall sub_10002DC0(int a1<eax>, int a2);
int __cdecl sub_10002EE0(int a2, int a3);
signed int __cdecl sub_10003100(const void *a1, int a2, int a3);
int __cdecl sub_10003E70(int a1, int a2, int a3, int a4, int a5, int a6);
signed int __cdecl sub_10004090(int a1, const void *a2, int a3, int a4, int a5, int a6, int a7, int a8, const void *a9);
signed int __cdecl sub_10004E60(const void *a1, int a2, int a3);
double __cdecl sub_10005050(int a1, long double *a2);
// signed int __usercall sub_100050E0<eax>(int a1<eax>);
signed int __cdecl sub_10005200(int a1);
int __fastcall sub_10005240(int a1, int a2, char a3);
int __cdecl sub_10005260(int a1, int a2);
int __cdecl sub_10005430(int a1, int a2);
int __cdecl sub_100055A0(int a1, int a2);
int __cdecl sub_100057A0(int a1, int a2);
int __cdecl sub_10005B10(int a1, int a2);
int __cdecl sub_10005E80(int a1, int a2);
int __cdecl sub_10005FC0(int a1, int a2);
int __cdecl sub_100060F0(int a1, int a2);
int __cdecl sub_10006610(int a1, int a2);
int __cdecl sub_100069C0(int a1, int a2);
int __cdecl sub_10006C70(int a1, int a2);
int __cdecl sub_10006F40(int a1, int a2);
_DWORD __cdecl sub_10007190(_DWORD, _DWORD); // weak
int __cdecl sub_10007340(int, char *Str); // idb
_DWORD __cdecl sub_10007590(_DWORD, _DWORD); // weak
_DWORD __cdecl sub_10007690(_DWORD, _DWORD); // weak
int __cdecl sub_10007730(int a1, int a2, int a3);
// double __cdecl floor(double x); idb
int __cdecl sub_10007D1B();
int (*__cdecl sub_10007DE3())(void);
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
// int unknown_libname_1(void); weak
int __cdecl sub_10008182();
// int __cdecl _clean_type_info_names_internal(_DWORD); weak
int __thiscall sub_100081A8(void *this, char a2);
// _DWORD __thiscall __report_gsfailure(_DWORD ecx0, _BYTE _4); weak
// BOOL __stdcall DisableThreadLibraryCalls(HMODULE hLibModule);
// double __cdecl ceil(double);
// void __cdecl qsort(void *Base, size_t NumOfElements, size_t SizeOfElements, int (__cdecl *PtFuncCompare)(const void *, const void *));
// int __cdecl atoi(const char *Str);
// void *__cdecl malloc(size_t Size);
// double __cdecl strtod(const char *Str, char **EndPtr);
// void __cdecl free(void *Memory);
// int sprintf(char *Dest, const char *Format, ...);
// int printf(const char *Format, ...);
// char *__cdecl strstr(const char *Str, const char *SubStr);
// int __cdecl UF_VEC3_cross(_DWORD, _DWORD); weak
// int __cdecl UF_get_fail_message(_DWORD, _DWORD); weak
// int __cdecl UF_MTX3_rotate_about_axis(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_edit_rotation(_DWORD, _DWORD); weak
// int __cdecl UF_VEC3_scale(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_is_parallel(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_z_vec(_DWORD, _DWORD); weak
// int __cdecl UF_VEC3_distance(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_vec_multiply_t(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_is_zero(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_affine_comb(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_is_equal(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_allocate_memory(_DWORD, _DWORD); weak
// int __cdecl UF_free(_DWORD); weak
// int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_dot(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_copy(_DWORD, _DWORD); weak
// int __cdecl UF_VEC3_angle_between(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_vec3_multiply_t(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_add(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_rotation(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_ask_rotation(_DWORD, _DWORD); weak
// int __cdecl UF_MTX3_vec_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_vec3_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_vec_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_copy(_DWORD, _DWORD); weak
// int __cdecl UF_MTX3_x_vec(_DWORD, _DWORD); weak
// int __cdecl UF_MTX3_y_vec(_DWORD, _DWORD); weak
// int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MOM_ask_interp_from_param(_DWORD, _DWORD); weak
// int __cdecl UF_MOM_ask_mom(_DWORD, _DWORD); weak
// int __cdecl UF_MOM_extend_xlator(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_OBJ_cycle_by_name(_DWORD, _DWORD); weak
// int __cdecl UF_ATTR_read_value(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MOM_set_string(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MOM_set_double(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int UF_terminate(void); weak
// int __cdecl UF_MISC_set_program_name(_DWORD); weak
// int UF_initialize(void); weak
// int __cdecl UF_MTX4_csys_to_csys(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl uc1601(_DWORD, _DWORD); weak


//----- (10001000) --------------------------------------------------------
int __usercall sub_10001000<eax>(int a1<eax>, int a2<edx>, int a3<ecx>, int a4<esi>)
{
  char v5; // [sp+0h] [bp-88h]@2

  if ( a4 )
  {
    printf("%s, line %d:  %s\n", a2, a3, a1);
    if ( UF_get_fail_message(a4, &v5) )
    {
      printf("    returned a %d\n", a4);
      return a4;
    }
    printf("    returned error %d:  %s\n", a4, &v5);
  }
  return a4;
}
// 100090B4: using guessed type int __cdecl UF_get_fail_message(_DWORD, _DWORD);

//----- (10001060) --------------------------------------------------------
signed int __cdecl sub_10001060(char *Dest)
{
  signed int result; // eax@2

  UF_MISC_set_program_name("<!<UGPKIN>!>");
  if ( UF_initialize() )
  {
    sprintf(Dest, "ERROR!: Advanced Kinematics Module Unavailable");
    result = 1;
  }
  else
  {
    UF_MISC_set_program_name("Kinematics");
    result = 0;
  }
  return result;
}
// 10009150: using guessed type int __cdecl UF_MISC_set_program_name(_DWORD);
// 10009154: using guessed type int UF_initialize(void);

//----- (100010C0) --------------------------------------------------------
signed int __cdecl sub_100010C0(int a1, int a2, signed int a3, int a4)
{
  signed int result; // eax@4
  signed int v5; // edi@5
  double *v6; // ebx@6
  double v7; // st7@8
  int v8; // esi@15
  void *v9; // ebx@17
  int v10; // esi@17
  double v11; // [sp+4h] [bp-34h]@1
  double v12; // [sp+Ch] [bp-2Ch]@1
  double v13; // [sp+14h] [bp-24h]@1
  double v14; // [sp+1Ch] [bp-1Ch]@1
  double v15; // [sp+24h] [bp-14h]@1
  double v16; // [sp+2Ch] [bp-Ch]@1
  void *Str; // [sp+34h] [bp-4h]@1

  v11 = 0.0;
  v12 = 0.0;
  v13 = 0.0;
  v14 = 0.0;
  v15 = 0.0;
  v16 = 0.0;
  Str = malloc(0x90u);
  if ( a3 > 7 || a3 == 1 )
  {
    ((void (__thiscall *)(signed int))printf)(a3);
    printf(" Number of arguments should be between 1 and 6\n ", " Incorrect number of arguments\n");
    result = 999;
  }
  else
  {
    if ( !(a3 % 2) )
    {
      printf(" Insufficient number of arguments, There should be               atleast 2 arguments\n ");
      return 999;
    }
    v5 = 1;
    if ( a3 > 1 )
    {
      v6 = &v11;
      while ( strcmp(*(const char **)(a4 + 4 * v5), "AAXIS") )
      {
        if ( !strcmp(*(const char **)(a4 + 4 * v5), "BAXIS") )
        {
          v7 = 2.0;
          goto LABEL_13;
        }
        if ( !strcmp(*(const char **)(a4 + 4 * v5), "CAXIS") )
        {
          v7 = 3.0;
          goto LABEL_13;
        }
LABEL_14:
        v6[1] = strtod((const char *)*(_DWORD *)(a4 + 4 * v5 + 4), 0);
        v5 += 2;
        v6 += 2;
        if ( v5 >= a3 )
          goto LABEL_15;
      }
      v7 = 1.0;
LABEL_13:
      *(_QWORD *)v6 = *(_QWORD *)&v7;
      goto LABEL_14;
    }
LABEL_15:
    v8 = sub_10007730(a1, (int)Str, (int)&v11);
    if ( v8 )
    {
      printf(" SET_rotd_mcs_matrix failed in mom_rotate_mach_csys \n ");
      result = v8;
    }
    else
    {
      v9 = Str;
      v10 = sub_10007340(a1, (char *)Str);
      if ( v10 )
      {
        printf(" SET_rotd_operation_data failed in mom_rotate_mach_csys \n ");
        result = v10;
      }
      else
      {
        if ( v9 )
          free(v9);
        result = 0;
      }
    }
  }
  return result;
}
// 100010C0: using guessed type int __cdecl sub_100010C0(int, int, int, int);

//----- (100012B0) --------------------------------------------------------
int __cdecl sub_100012B0(int a1)
{
  int v1; // edi@1
  int result; // eax@2
  int v3; // edi@3
  int v4; // edi@5
  char v5; // [sp+10h] [bp-90h]@3
  char v6; // [sp+40h] [bp-60h]@1
  double v7; // [sp+70h] [bp-30h]@5
  double v8; // [sp+78h] [bp-28h]@7
  _DWORD v9[8]; // [sp+80h] [bp-20h]@7

  v1 = sub_10007190(a1, &v6);
  if ( v1 )
  {
    printf(" SET_input_point failed in mom_map_to_rotated_csys\n ");
    result = v1;
  }
  else
  {
    v3 = sub_10007690(&v6, &v5);
    if ( v3 )
    {
      printf(" mom_process_input_gotos failed in mom_map_to_rotated_csys\n ");
      result = v3;
    }
    else
    {
      v4 = sub_10007590(&v5, &v7);
      if ( v4 )
      {
        printf(" mom_transfer_gotos_rotd_mcsys failed in mom_map_to_rotated_csys\n ");
        result = v4;
      }
      else
      {
        UF_MOM_set_double(a1, "pos_x", LODWORD(v7), HIDWORD(v7));
        UF_MOM_set_double(a1, "pos_y", LODWORD(v8), HIDWORD(v8));
        UF_MOM_set_double(a1, "pos_z", v9[0], v9[1]);
        result = 0;
      }
    }
  }
  return result;
}
// 100012B0: using guessed type int __cdecl sub_100012B0(int);
// 10007190: using guessed type _DWORD __cdecl sub_10007190(_DWORD, _DWORD);
// 10007590: using guessed type _DWORD __cdecl sub_10007590(_DWORD, _DWORD);
// 10007690: using guessed type _DWORD __cdecl sub_10007690(_DWORD, _DWORD);
// 10009148: using guessed type int __cdecl UF_MOM_set_double(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10001390) --------------------------------------------------------
signed int __cdecl sub_10001390(int Str)
{
  int v1; // ebx@1
  void *v2; // edi@1
  int v3; // esi@1
  void *v5; // esi@3
  void *v6; // eax@3
  int v7; // ecx@3
  int v8; // edx@3
  int v9; // eax@3
  int v10; // ecx@3
  int v11; // ecx@3
  double v12; // st6@3
  double v13; // st7@3
  double v14; // st7@3
  double v15; // st6@3
  double v16; // st6@3
  double v17; // st7@3
  __int64 v18; // st7@4
  int v19; // edx@21
  int v20; // edx@21
  int v21; // eax@21
  int v22; // ecx@21
  int v23; // eax@21
  int v24; // ecx@21
  double v25; // st7@22
  double v26; // [sp+Ch] [bp-35Ch]@3
  double v27; // [sp+14h] [bp-354h]@3
  double v28; // [sp+1Ch] [bp-34Ch]@3
  double v29; // [sp+24h] [bp-344h]@3
  double v30; // [sp+2Ch] [bp-33Ch]@3
  double v31; // [sp+34h] [bp-334h]@3
  double v32; // [sp+3Ch] [bp-32Ch]@3
  double v33; // [sp+44h] [bp-324h]@3
  double v34; // [sp+4Ch] [bp-31Ch]@3
  int v35; // [sp+54h] [bp-314h]@16
  double v36; // [sp+5Ch] [bp-30Ch]@21
  int v37; // [sp+64h] [bp-304h]@21
  int v38; // [sp+68h] [bp-300h]@21
  int v39; // [sp+6Ch] [bp-2FCh]@21
  int v40; // [sp+70h] [bp-2F8h]@21
  int v41; // [sp+74h] [bp-2F4h]@21
  int v42; // [sp+78h] [bp-2F0h]@21
  int v43; // [sp+7Ch] [bp-2ECh]@21
  int v44; // [sp+80h] [bp-2E8h]@21
  int v45; // [sp+84h] [bp-2E4h]@21
  int v46; // [sp+88h] [bp-2E0h]@21
  int v47; // [sp+8Ch] [bp-2DCh]@21
  int v48; // [sp+90h] [bp-2D8h]@21
  int v49; // [sp+94h] [bp-2D4h]@21
  int v50; // [sp+98h] [bp-2D0h]@21
  int v51; // [sp+9Ch] [bp-2CCh]@21
  int v52; // [sp+A0h] [bp-2C8h]@21
  int v53; // [sp+A4h] [bp-2C4h]@21
  int v54; // [sp+A8h] [bp-2C0h]@21
  char v55; // [sp+ACh] [bp-2BCh]@21
  double v56; // [sp+B4h] [bp-2B4h]@21
  double v57; // [sp+BCh] [bp-2ACh]@21
  double v58; // [sp+C4h] [bp-2A4h]@21
  double v59; // [sp+CCh] [bp-29Ch]@21
  double v60; // [sp+D4h] [bp-294h]@21
  double v61; // [sp+DCh] [bp-28Ch]@21
  double v62; // [sp+E4h] [bp-284h]@24
  __int64 v63; // [sp+ECh] [bp-27Ch]@3
  __int64 v64; // [sp+F4h] [bp-274h]@3
  double v65; // [sp+FCh] [bp-26Ch]@3
  int v66; // [sp+100h] [bp-268h]@3
  __int64 v67; // [sp+104h] [bp-264h]@3
  __int64 v68; // [sp+10Ch] [bp-25Ch]@3
  __int64 v69; // [sp+114h] [bp-254h]@3
  __int64 v70; // [sp+11Ch] [bp-24Ch]@3
  __int64 v71; // [sp+124h] [bp-244h]@3
  __int64 v72; // [sp+12Ch] [bp-23Ch]@3
  __int64 v73; // [sp+134h] [bp-234h]@3
  __int64 v74; // [sp+13Ch] [bp-22Ch]@3
  __int64 v75; // [sp+144h] [bp-224h]@3
  int v76; // [sp+14Ch] [bp-21Ch]@3
  int v77; // [sp+150h] [bp-218h]@3
  int v78; // [sp+154h] [bp-214h]@3
  int v79; // [sp+158h] [bp-210h]@3
  int v80; // [sp+15Ch] [bp-20Ch]@3
  int v81; // [sp+160h] [bp-208h]@3
  int v82; // [sp+164h] [bp-204h]@3
  int v83; // [sp+168h] [bp-200h]@3
  int v84; // [sp+16Ch] [bp-1FCh]@3
  int v85; // [sp+170h] [bp-1F8h]@3
  int v86; // [sp+174h] [bp-1F4h]@3
  int v87; // [sp+178h] [bp-1F0h]@3
  int v88; // [sp+17Ch] [bp-1ECh]@3
  int v89; // [sp+180h] [bp-1E8h]@3
  int v90; // [sp+184h] [bp-1E4h]@3
  int v91; // [sp+188h] [bp-1E0h]@3
  int v92; // [sp+18Ch] [bp-1DCh]@3
  int v93; // [sp+190h] [bp-1D8h]@3
  int v94; // [sp+194h] [bp-1D4h]@3
  int v95; // [sp+198h] [bp-1D0h]@3
  int v96; // [sp+19Ch] [bp-1CCh]@3
  int v97; // [sp+1A0h] [bp-1C8h]@3
  int v98; // [sp+1A4h] [bp-1C4h]@3
  int v99; // [sp+1A8h] [bp-1C0h]@3
  int v100; // [sp+1ACh] [bp-1BCh]@21
  int v101; // [sp+1B0h] [bp-1B8h]@21
  int v102; // [sp+1B4h] [bp-1B4h]@21
  int v103; // [sp+1B8h] [bp-1B0h]@21
  int v104; // [sp+1BCh] [bp-1ACh]@21
  int v105; // [sp+1C0h] [bp-1A8h]@21
  int v106; // [sp+1C4h] [bp-1A4h]@21
  int v107; // [sp+1C8h] [bp-1A0h]@21
  int v108; // [sp+1CCh] [bp-19Ch]@21
  int v109; // [sp+1D0h] [bp-198h]@21
  int v110; // [sp+1D4h] [bp-194h]@21
  int v111; // [sp+1D8h] [bp-190h]@21
  double v112; // [sp+264h] [bp-104h]@21
  double v113; // [sp+26Ch] [bp-FCh]@21
  double v114; // [sp+274h] [bp-F4h]@3
  double v115; // [sp+27Ch] [bp-ECh]@3
  int v116; // [sp+284h] [bp-E4h]@3
  int v117; // [sp+288h] [bp-E0h]@3
  double v118; // [sp+28Ch] [bp-DCh]@3
  double v119; // [sp+294h] [bp-D4h]@3
  double v120; // [sp+29Ch] [bp-CCh]@3
  double v121; // [sp+2A4h] [bp-C4h]@3
  double v122; // [sp+2ACh] [bp-BCh]@3
  double v123; // [sp+2B4h] [bp-B4h]@3
  double v124; // [sp+2BCh] [bp-ACh]@3
  double v125; // [sp+2C4h] [bp-A4h]@3
  double v126; // [sp+2CCh] [bp-9Ch]@3
  int v127; // [sp+2D4h] [bp-94h]@3
  int v128; // [sp+2D8h] [bp-90h]@3
  int v129; // [sp+2DCh] [bp-8Ch]@3
  int v130; // [sp+2E0h] [bp-88h]@3
  int v131; // [sp+2E4h] [bp-84h]@3
  int v132; // [sp+2E8h] [bp-80h]@3
  int v133; // [sp+2ECh] [bp-7Ch]@3
  int v134; // [sp+2F0h] [bp-78h]@3
  int v135; // [sp+2F4h] [bp-74h]@3
  int v136; // [sp+2F8h] [bp-70h]@3
  int v137; // [sp+2FCh] [bp-6Ch]@3
  int v138; // [sp+300h] [bp-68h]@3
  int v139; // [sp+304h] [bp-64h]@3
  int v140; // [sp+308h] [bp-60h]@3
  int v141; // [sp+30Ch] [bp-5Ch]@3
  int v142; // [sp+310h] [bp-58h]@3
  int v143; // [sp+314h] [bp-54h]@3
  int v144; // [sp+318h] [bp-50h]@3
  int v145; // [sp+31Ch] [bp-4Ch]@3
  int v146; // [sp+320h] [bp-48h]@3
  int v147; // [sp+324h] [bp-44h]@3
  int v148; // [sp+328h] [bp-40h]@3
  int v149; // [sp+32Ch] [bp-3Ch]@3
  int v150; // [sp+330h] [bp-38h]@3
  void *v151; // [sp+334h] [bp-34h]@1
  void *v152; // [sp+338h] [bp-30h]@1
  void *v153; // [sp+33Ch] [bp-2Ch]@1
  void *v154; // [sp+340h] [bp-28h]@1
  void *Memory; // [sp+344h] [bp-24h]@1
  __int64 v156; // [sp+348h] [bp-20h]@4
  __int64 v157; // [sp+350h] [bp-18h]@4
  __int64 v158; // [sp+358h] [bp-10h]@15
  int v159; // [sp+360h] [bp-8h]@1
  int v160; // [sp+364h] [bp-4h]@1
  void *v161; // [sp+370h] [bp+8h]@1

  v3 = Str;
  Memory = malloc(856u);
  sub_10006610(Str, (int)Memory);
  v159 = (int)malloc(0x228u);
  sub_10005260(Str, v159);
  v151 = malloc(0x120u);
  sub_10005430(Str, (int)v151);
  v153 = malloc(0x40u);
  sub_100055A0(Str, (int)v153);
  v1 = (int)malloc(0x1F0u);
  sub_100057A0(Str, v1);
  v160 = (int)malloc(0x1F0u);
  sub_10005B10(Str, v160);
  v152 = malloc(0x98u);
  sub_10005E80(Str, (int)v152);
  v161 = malloc(0x3B0u);
  sub_100060F0(v3, (int)v161);
  v154 = malloc(0x18u);
  sub_10005FC0(v3, (int)v154);
  v2 = malloc(0x24u);
  if ( !v2 )
    return 1;
  v6 = Memory;
  v7 = v159;
  *((_DWORD *)v2 + 2) = v151;
  v8 = (int)v152;
  *(_DWORD *)v2 = v6;
  v9 = (int)v153;
  *((_DWORD *)v2 + 1) = v7;
  v10 = v160;
  *((_DWORD *)v2 + 6) = v8;
  *((_DWORD *)v2 + 3) = v9;
  *((_DWORD *)v2 + 5) = v10;
  v11 = (int)v154;
  *((_DWORD *)v2 + 4) = v1;
  *((_DWORD *)v2 + 7) = v161;
  *((_DWORD *)v2 + 8) = v11;
  sub_100069C0(v3, (int)&v63);
  sub_10006C70(v3, (int)&v63);
  sub_10006F40(v3, (int)&v63);
  v5 = Memory;
  v26 = *(double *)&v63 + *(double *)(v1 + 432);
  v12 = *(double *)(v160 + 432);
  *(_QWORD *)&v114 = v63;
  *(_QWORD *)&v115 = v64;
  v29 = v12 + v26;
  v13 = v26 + *((double *)Memory + 104);
  v117 = v66;
  *(_QWORD *)&v118 = v67;
  v32 = v13;
  v14 = *(double *)(v1 + 440);
  *(_QWORD *)&v119 = v68;
  v27 = v14 + *(double *)&v64;
  v15 = *(double *)(v160 + 440);
  *(_QWORD *)&v121 = v70;
  v30 = v15 + v27;
  v33 = v27 + *((double *)Memory + 105);
  v28 = *(double *)(v1 + 448) + v65;
  v16 = *(double *)(v160 + 448) + v28;
  v116 = LODWORD(v65);
  v31 = v16;
  v17 = v28 + *((double *)Memory + 106);
  *(_QWORD *)&v120 = v69;
  v34 = v17;
  *(_QWORD *)&v122 = v71;
  *(_QWORD *)&v124 = v73;
  *(_QWORD *)&v123 = v72;
  *(_QWORD *)&v125 = v74;
  v127 = v76;
  *(_QWORD *)&v126 = v75;
  v130 = v79;
  v128 = v77;
  v129 = v78;
  v133 = v82;
  v131 = v80;
  v132 = v81;
  v136 = v85;
  v134 = v83;
  v135 = v84;
  v139 = v88;
  v137 = v86;
  v138 = v87;
  v142 = v91;
  v140 = v89;
  v141 = v90;
  v145 = v94;
  v143 = v92;
  v144 = v93;
  v148 = v97;
  v146 = v95;
  v147 = v96;
  v149 = v98;
  v150 = v99;
  if ( strstr((const char *)v161, "POSX") )
  {
    v156 = v67;
    v157 = v68;
    v18 = v69;
  }
  else
  {
    if ( !strstr((const char *)v161, "POSY") )
    {
      if ( !strstr((const char *)v161, "POSZ") )
      {
        if ( strstr((const char *)v161, "NEGX") )
        {
          *(double *)&v156 = -*(double *)&v67;
          *(double *)&v157 = -*(double *)&v68;
          *(double *)&v18 = -*(double *)&v69;
          goto LABEL_15;
        }
        if ( strstr((const char *)v161, "NEGY") )
        {
          *(double *)&v156 = -*(double *)&v70;
          *(double *)&v157 = -*(double *)&v71;
          *(double *)&v18 = -*(double *)&v72;
          goto LABEL_15;
        }
        if ( strstr((const char *)v161, "NEGZ") )
        {
          *(double *)&v156 = -*(double *)&v73;
          *(double *)&v157 = -*(double *)&v74;
          *(double *)&v18 = -*(double *)&v75;
          goto LABEL_15;
        }
      }
      v156 = v73;
      v157 = v74;
      v18 = v75;
      goto LABEL_15;
    }
    v156 = v70;
    v157 = v71;
    v18 = v72;
  }
LABEL_15:
  v158 = v18;
  if ( strstr((const char *)v5, "5_axis_dual_table") )
  {
    v35 = 2;
  }
  else
  {
    if ( strstr((const char *)v5, "5_axis_dual_head") )
    {
      v35 = 1;
    }
    else
    {
      if ( strstr((const char *)v5, "5_axis_head_table") )
        v35 = 3;
    }
  }
  v36 = *((double *)v5 + 100);
  v37 = v100;
  v40 = v103;
  v38 = v101;
  v39 = v102;
  v43 = v106;
  v41 = v104;
  v42 = v105;
  v46 = v109;
  v19 = *(_DWORD *)(v1 + 432);
  v44 = v107;
  v45 = v108;
  v49 = v19;
  v20 = *(_DWORD *)(v1 + 444);
  v47 = v110;
  v21 = *(_DWORD *)(v1 + 436);
  v48 = v111;
  v22 = *(_DWORD *)(v1 + 440);
  v52 = v20;
  v50 = v21;
  v23 = *(_DWORD *)(v1 + 448);
  v51 = v22;
  v24 = *(_DWORD *)(v1 + 452);
  v53 = v23;
  v54 = v24;
  v56 = v113;
  v55 = atoi((const char *)v5 + 133) == 1;
  v57 = *(double *)(v1 + 408);
  v58 = *(double *)(v1 + 416);
  v59 = *(double *)(v160 + 408);
  v60 = *(double *)(v160 + 416);
  v61 = v112;
  if ( strstr((const char *)v5, "5_axis_dual_table") )
    v25 = 0.0;
  else
    v25 = *(double *)(v159 + 536);
  v62 = v25;
  sub_10004090((int)&v127, &v114, (int)&v26, v1 + 456, (int)&v29, v160 + 456, (int)&v32, (int)&v156, &v35);
  free(v2);
  free(v5);
  if ( v159 )
    free((void *)v159);
  if ( v151 )
    free(v151);
  if ( v153 )
    free(v153);
  free((void *)v1);
  free((void *)v160);
  if ( v152 )
    free(v152);
  if ( v161 )
    free(v161);
  if ( v154 )
    free(v154);
  return 0;
}

//----- (10001B00) --------------------------------------------------------
int __cdecl sub_10001B00(int a1)
{
  char v2; // [sp+10h] [bp-208h]@1
  char v3; // [sp+198h] [bp-80h]@1
  double v4; // [sp+1C8h] [bp-50h]@1
  double v5; // [sp+1D0h] [bp-48h]@1
  double v6; // [sp+1D8h] [bp-40h]@1
  double v7; // [sp+1E0h] [bp-38h]@1
  double v8; // [sp+1E8h] [bp-30h]@1
  double v9; // [sp+1F0h] [bp-28h]@1
  double v10; // [sp+1F8h] [bp-20h]@1
  double v11; // [sp+200h] [bp-18h]@1
  double v12; // [sp+208h] [bp-10h]@1
  double v13; // [sp+210h] [bp-8h]@1

  sub_10006F40(a1, (int)&v2);
  sub_100026E0((int)&v2);
  sub_10007190(a1, &v3);
  sub_10004E60(&v3, (int)&v4, (int)&v9);
  UF_MOM_set_double(a1, "pos_x", LODWORD(v4), HIDWORD(v4));
  UF_MOM_set_double(a1, "pos_y", LODWORD(v5), HIDWORD(v5));
  UF_MOM_set_double(a1, "pos_z", LODWORD(v6), HIDWORD(v6));
  UF_MOM_set_double(a1, "pos_a1", LODWORD(v7), HIDWORD(v7));
  UF_MOM_set_double(a1, "pos_a2", LODWORD(v8), HIDWORD(v8));
  UF_MOM_set_double(a1, "alt_pos_x", LODWORD(v9), HIDWORD(v9));
  UF_MOM_set_double(a1, "alt_pos_y", LODWORD(v10), HIDWORD(v10));
  UF_MOM_set_double(a1, "alt_pos_z", LODWORD(v11), HIDWORD(v11));
  UF_MOM_set_double(a1, "alt_pos_a1", LODWORD(v12), HIDWORD(v12));
  UF_MOM_set_double(a1, "alt_pos_a2", LODWORD(v13), HIDWORD(v13));
  return 0;
}
// 10001B00: using guessed type int __cdecl sub_10001B00(int);
// 10007190: using guessed type _DWORD __cdecl sub_10007190(_DWORD, _DWORD);
// 10009148: using guessed type int __cdecl UF_MOM_set_double(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10001C00) --------------------------------------------------------
signed int __cdecl sub_10001C00(int a1, int a2, char *a3, int a4)
{
  char *v5; // eax@6
  char *v6; // edx@6
  char v7; // cl@7
  char *v8; // eax@8
  char *v9; // edx@8
  char v10; // cl@9
  int v11; // eax@16
  char v12; // cl@17
  int v13; // eax@19
  char v14; // cl@20
  char v15; // [sp+8h] [bp-488h]@2
  __int16 v16; // [sp+28h] [bp-468h]@5
  int v17; // [sp+208h] [bp-288h]@1
  int v18; // [sp+290h] [bp-200h]@1
  int v19; // [sp+294h] [bp-1FCh]@1
  __int16 v20; // [sp+298h] [bp-1F8h]@1
  char v21[136]; // [sp+318h] [bp-178h]@13
  char v22[52]; // [sp+3A0h] [bp-F0h]@8
  int v23; // [sp+3D4h] [bp-BCh]@1
  int v24; // [sp+3D8h] [bp-B8h]@1
  int v25; // [sp+3DCh] [bp-B4h]@1
  int v26; // [sp+3E0h] [bp-B0h]@1
  int v27; // [sp+3E4h] [bp-ACh]@1
  char v28[32]; // [sp+45Ch] [bp-34h]@6
  int v29; // [sp+47Ch] [bp-14h]@13
  int v30; // [sp+484h] [bp-Ch]@13
  int v31; // [sp+48Ch] [bp-4h]@1

  v23 = dword_100095D8;
  v24 = dword_100095DC;
  v25 = dword_100095E0;
  v26 = dword_100095E4;
  v27 = dword_100095E8;
  v31 = 0;
  v17 = 2105376;
  v18 = dword_100095CC;
  v19 = dword_100095D0;
  v20 = word_100095D4;
  if ( a3 != (char *)2 )
  {
    memcpy(&v15, "Invalid number of arguments", 0x1Cu);
LABEL_3:
    printf(" ERROR : %s \n ", &v15);
    return 1;
  }
  if ( UF_MOM_ask_string(a1, &v18, &a3) )
  {
    memcpy(&v15, "No Tool Name obtained from UGPost", 0x20u);
    v16 = *(_WORD *)&aNoToolNameObta[32];
    goto LABEL_3;
  }
  v5 = a3;
  v6 = (char *)(v28 - a3);
  do
  {
    v7 = *v5;
    *(_BYTE *)((_DWORD)v6 + (_DWORD)v5) = *v5;
    ++v5;
  }
  while ( v7 );
  v8 = *(char **)(a4 + 4);
  v9 = (char *)(v22 - v8);
  do
  {
    v10 = *v8;
    *(_BYTE *)((_DWORD)v9 + (_DWORD)v8) = *v8;
    ++v8;
  }
  while ( v10 );
  if ( UF_OBJ_cycle_by_name(v28, &v31) )
  {
    printf(" UF_OBJ_cycle_by_name could not get the tool_object_tag \n");
    return 1;
  }
  if ( v31 )
  {
    v30 = (int)v21;
    if ( UF_ATTR_read_value(v31, v22, 5, &v29) )
    {
      printf(" UF_ATTR_read_value could not return tool string \n");
      return 1;
    }
    if ( v29 != 5 )
    {
      v11 = 0;
      do
      {
        v12 = *((_BYTE *)&v17 + v11);
        v21[v11++] = v12;
      }
      while ( v12 );
    }
  }
  else
  {
    v13 = 0;
    do
    {
      v14 = *((_BYTE *)&v17 + v13);
      v21[v13++] = v14;
    }
    while ( v14 );
  }
  UF_MOM_set_string(a1, &v23, v21);
  return 0;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);
// 1000913C: using guessed type int __cdecl UF_OBJ_cycle_by_name(_DWORD, _DWORD);
// 10009140: using guessed type int __cdecl UF_ATTR_read_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 10009144: using guessed type int __cdecl UF_MOM_set_string(_DWORD, _DWORD, _DWORD);
// 100095CC: using guessed type int dword_100095CC;
// 100095D0: using guessed type int dword_100095D0;
// 100095D4: using guessed type __int16 word_100095D4;
// 100095D8: using guessed type int dword_100095D8;
// 100095DC: using guessed type int dword_100095DC;
// 100095E0: using guessed type int dword_100095E0;
// 100095E4: using guessed type int dword_100095E4;
// 100095E8: using guessed type int dword_100095E8;
// 10001C00: using guessed type char var_34[32];
// 10001C00: using guessed type char var_F0[52];
// 10001C00: using guessed type char var_178[136];

//----- (10001DF0) --------------------------------------------------------
int __cdecl ufusr(int a1, int a2)
{
  int result; // eax@2
  int v3; // eax@3
  int v4; // eax@3
  int v5; // eax@3
  int v6; // eax@3
  int v7; // eax@3
  int v8; // eax@3
  char Dest; // [sp+0h] [bp-8Ch]@1
  int v10; // [sp+84h] [bp-8h]@1
  int v11; // [sp+88h] [bp-4h]@3

  v10 = 0;
  if ( sub_10001060(&Dest) )
  {
    printf("ERROR : Ugpost Advanced Kinematics license not found \n");
    uc1601(&Dest, 1);
    result = UF_terminate();
  }
  else
  {
    UF_MOM_ask_interp_from_param(a1, &v10);
    UF_MOM_ask_mom(a1, &v11);
    v3 = UF_MOM_extend_xlator(v11, "MOM_load_kinematics", sub_10001390);
    sub_10001000(
      (int)"UF_MOM_extend_xlator ( mom, \"MOM_load_kinematics\", mom_load_kinematics )",
      (int)"o:\\ugnx75\\ip32\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      113,
      v3);
    v4 = UF_MOM_extend_xlator(v11, "MOM_convert_point", sub_10001B00);
    sub_10001000(
      (int)"UF_MOM_extend_xlator ( mom, \"MOM_convert_point\", mom_convert_point )",
      (int)"o:\\ugnx75\\ip32\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      123,
      v4);
    v5 = UF_MOM_extend_xlator(v11, "MOM_get_tool_attribute", sub_10001C00);
    sub_10001000(
      (int)"UF_MOM_extend_xlator ( mom , \"MOM_get_tool_attribute\", mom_get_tool_attribute )",
      (int)"o:\\ugnx75\\ip32\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      133,
      v5);
    v6 = UF_MOM_extend_xlator(v11, "MOM_rotate_mach_csys", sub_100010C0);
    sub_10001000(
      (int)"UF_MOM_extend_xlator ( mom, \"MOM_rotate_mach_csys\", mom_rotate_mach_csys )",
      (int)"o:\\ugnx75\\ip32\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      143,
      v6);
    v7 = UF_MOM_extend_xlator(v11, "MOM_map_to_rotated_csys", sub_100012B0);
    sub_10001000(
      (int)"UF_MOM_extend_xlator ( mom, \"MOM_map_to_rotated_csys\", mom_map_to_rotated_csys )",
      (int)"o:\\ugnx75\\ip32\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      153,
      v7);
    v8 = UF_MOM_extend_xlator(v11, "MOM_exit_kinematics_module", UF_terminate);
    result = sub_10001000(
               (int)"UF_MOM_extend_xlator ( mom, \"MOM_exit_kinematics_module\", mom_exit_kinematics_module )",
               (int)"o:\\ugnx75\\ip32\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
               163,
               v8);
    dword_1000C240 = v11;
    *(_DWORD *)a2 = 0;
  }
  return result;
}
// 100010B0: using guessed type int UF_terminate();
// 100010C0: using guessed type int __cdecl sub_100010C0(int, int, int, int);
// 100012B0: using guessed type int __cdecl sub_100012B0(int);
// 10001B00: using guessed type int __cdecl sub_10001B00(int);
// 1000912C: using guessed type int __cdecl UF_MOM_ask_interp_from_param(_DWORD, _DWORD);
// 10009130: using guessed type int __cdecl UF_MOM_ask_mom(_DWORD, _DWORD);
// 10009134: using guessed type int __cdecl UF_MOM_extend_xlator(_DWORD, _DWORD, _DWORD);
// 1000914C: using guessed type int UF_terminate(void);
// 10009160: using guessed type int __cdecl uc1601(_DWORD, _DWORD);
// 1000C240: using guessed type int dword_1000C240;

//----- (10001F60) --------------------------------------------------------
int __usercall sub_10001F60<eax>(int a1<eax>, int a2<ecx>, int a3<esi>, char a4)
{
  UF_VEC3_cross(a2, a1);
  return UF_VEC3_unitize(a3, COERCE_UNSIGNED_INT64(1.0e-10), COERCE_UNSIGNED_INT64(1.0e-10) >> 32, &a4, a3);
}
// 100090B0: using guessed type int __cdecl UF_VEC3_cross(_DWORD, _DWORD);
// 10009128: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10001FE0) --------------------------------------------------------
int __usercall sub_10001FE0<eax>(int result<eax>, int _ECX<ecx>, double a3)
{
  __asm
  {
    fld     [ebp+arg_0]
    fld     st
    fcos
    fxch    st(1)
    fsin
    fld     qword ptr [eax]
    fmul    st, st
    fld     qword ptr [eax+8]
    fmul    st, st
    fld     qword ptr [eax+10h]
    fmul    st, st
    fstp    [ebp+var_8]
    fld1
    fld     st
    fsub    st, st(5)
    fld     st(1)
    fsub    st, st(4)
    fmul    st, st(6)
    faddp   st(4), st
    fxch    st(3)
    fstp    qword ptr [ecx]
    fld     qword ptr [eax+8]
    fmul    qword ptr [eax]
    fmul    st, st(3)
    fld     qword ptr [eax+10h]
    fmul    st, st(5)
    faddp   st(1), st
    fstp    qword ptr [ecx+8]
    fld     qword ptr [eax+10h]
    fmul    qword ptr [eax]
    fmul    st, st(3)
    fld     qword ptr [eax+8]
    fmul    st, st(5)
    fsubp   st(1), st
    fstp    qword ptr [ecx+10h]
    fldz
    fst     qword ptr [ecx+18h]
    fld     qword ptr [eax+8]
    fmul    qword ptr [eax]
    fmul    st, st(4)
    fld     qword ptr [eax+10h]
    fmul    st, st(6)
    fsubp   st(1), st
    fstp    qword ptr [ecx+20h]
    fld     st(1)
    fsub    st, st(3)
    fmul    st, st(6)
    faddp   st(3), st
    fxch    st(2)
    fstp    qword ptr [ecx+28h]
    fld     qword ptr [eax+10h]
    fmul    qword ptr [eax+8]
    fmul    st, st(3)
    fld     qword ptr [eax]
    fmul    st, st(5)
    faddp   st(1), st
    fstp    qword ptr [ecx+30h]
    fxch    st(1)
    fst     qword ptr [ecx+38h]
    fld     qword ptr [eax+10h]
    fmul    qword ptr [eax]
    fmul    st, st(3)
    fld     qword ptr [eax+8]
    fmul    st, st(5)
    faddp   st(1), st
    fstp    qword ptr [ecx+40h]
    fld     qword ptr [eax+10h]
    fmul    qword ptr [eax+8]
    fmulp   st(3), st
    fld     qword ptr [eax]
    fmulp   st(4), st
    fxch    st(2)
    fsubrp  st(3), st
    fxch    st(2)
    fstp    qword ptr [ecx+48h]
    fld     st(1)
    fld     [ebp+var_8]
    fsub    st(1), st
    fxch    st(1)
    fmulp   st(4), st
    faddp   st(3), st
    fxch    st(2)
    fstp    qword ptr [ecx+50h]
    fxch    st(1)
    fst     qword ptr [ecx+58h]
    fst     qword ptr [ecx+60h]
    fst     qword ptr [ecx+68h]
    fstp    qword ptr [ecx+70h]
    fstp    qword ptr [ecx+78h]
  }
  return result;
}
// 10001FE6: inconsistent fpu stack

//----- (100020C0) --------------------------------------------------------
int __usercall sub_100020C0<eax>(int a1<eax>, int a2<ecx>, int a3)
{
  int v4; // esi@1
  int v5; // edi@1
  char v6; // [sp+Ch] [bp-120h]@1
  char v7; // [sp+54h] [bp-D8h]@1
  char v8; // [sp+9Ch] [bp-90h]@1
  char v9; // [sp+B4h] [bp-78h]@1
  char v10; // [sp+CCh] [bp-60h]@1
  char v11; // [sp+E4h] [bp-48h]@1
  double v12; // [sp+FCh] [bp-30h]@1
  double v13; // [sp+104h] [bp-28h]@1
  double v14; // [sp+10Ch] [bp-20h]@1
  double v15; // [sp+114h] [bp-18h]@1
  double v16; // [sp+11Ch] [bp-10h]@1
  double v17; // [sp+124h] [bp-8h]@1

  v4 = a1;
  v5 = a2;
  UF_MTX3_copy(a1 + 24, &v7);
  UF_MTX3_copy(v5 + 24, &v6);
  v12 = *(double *)v4;
  v15 = *(double *)v5;
  v13 = *(double *)(v4 + 8);
  v16 = *(double *)(v5 + 8);
  v14 = *(double *)(v4 + 16);
  v17 = *(double *)(v5 + 16);
  UF_MTX3_x_vec(&v7, &v10);
  UF_MTX3_y_vec(&v7, &v8);
  UF_MTX3_x_vec(&v6, &v11);
  UF_MTX3_y_vec(&v6, &v9);
  return UF_MTX4_csys_to_csys(&v12, &v10, &v8, &v15, &v11, &v9, a3);
}
// 1000911C: using guessed type int __cdecl UF_MTX3_copy(_DWORD, _DWORD);
// 10009120: using guessed type int __cdecl UF_MTX3_x_vec(_DWORD, _DWORD);
// 10009124: using guessed type int __cdecl UF_MTX3_y_vec(_DWORD, _DWORD);
// 10009158: using guessed type int __cdecl UF_MTX4_csys_to_csys(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10002190) --------------------------------------------------------
int __usercall sub_10002190<eax>(int a1<eax>, int a2<esi>, double a3, double a4, signed int a5)
{
  int result; // eax@1
  int v6; // edx@1
  int v7; // ecx@1
  int v8; // edx@1
  int v9; // ecx@1
  int v10; // edx@1
  int v11; // ecx@1
  int v12; // edx@1
  int v13; // ecx@1
  int v14; // edx@1
  char v15; // [sp+14h] [bp-258h]@1
  char v16; // [sp+94h] [bp-1D8h]@1
  char v17; // [sp+114h] [bp-158h]@1
  char v18; // [sp+15Ch] [bp-110h]@1
  char v19; // [sp+1DCh] [bp-90h]@1
  double v20; // [sp+1F4h] [bp-78h]@1
  double v21; // [sp+1FCh] [bp-70h]@1
  double v22; // [sp+204h] [bp-68h]@1
  char v23; // [sp+20Ch] [bp-60h]@1
  int v24; // [sp+224h] [bp-48h]@1
  int v25; // [sp+228h] [bp-44h]@1
  int v26; // [sp+22Ch] [bp-40h]@1
  int v27; // [sp+230h] [bp-3Ch]@1
  int v28; // [sp+234h] [bp-38h]@1
  int v29; // [sp+238h] [bp-34h]@1
  double v30; // [sp+244h] [bp-28h]@1
  int v31; // [sp+24Ch] [bp-20h]@1
  int v32; // [sp+250h] [bp-1Ch]@1
  int v33; // [sp+254h] [bp-18h]@1
  int v34; // [sp+258h] [bp-14h]@1
  int v35; // [sp+25Ch] [bp-10h]@1
  int v36; // [sp+260h] [bp-Ch]@1
  double v37; // [sp+264h] [bp-8h]@1

  v6 = *(_DWORD *)(a1 + 4);
  v31 = *(_DWORD *)a1;
  v7 = *(_DWORD *)(a1 + 8);
  v37 = (double)a5;
  v32 = v6;
  v8 = *(_DWORD *)(a1 + 12);
  v33 = v7;
  v9 = *(_DWORD *)(a1 + 16);
  v34 = v8;
  v10 = *(_DWORD *)(a1 + 20);
  v30 = *(double *)(dword_1000C3D8 + 8);
  v35 = v9;
  v20 = 0.0;
  v21 = 0.0;
  v22 = 0.0;
  v36 = v10;
  UF_MTX4_rotation(
    &dword_1000C2C8,
    &dbl_1000C328,
    COERCE_UNSIGNED_INT64(a4 * -57.29577951308235),
    COERCE_UNSIGNED_INT64(a4 * -57.29577951308235) >> 32,
    &v18);
  sub_10005200((int)&v18);
  UF_MTX4_ask_rotation(&v18, &v17);
  UF_MTX3_vec_multiply(&dbl_1000C2F0, &v17, &v23);
  UF_VEC3_unitize(&v23, LODWORD(v30), HIDWORD(v30), &a4, &v23);
  UF_MTX4_vec3_multiply(&v20, &v18, &v19);
  UF_MTX4_rotation(
    &v19,
    &v23,
    COERCE_UNSIGNED_INT64(a3 * -57.29577951308235),
    COERCE_UNSIGNED_INT64(a3 * -57.29577951308235) >> 32,
    &v16);
  sub_10005200((int)&v16);
  UF_MTX4_multiply(&v18, &v16, &v15);
  sub_10005200((int)&v15);
  UF_MTX4_vec_multiply(&v31, &v15, &v24);
  v11 = v25;
  v12 = v26;
  *(_DWORD *)a2 = v24;
  result = v27;
  *(_DWORD *)(a2 + 4) = v11;
  v13 = v28;
  *(_DWORD *)(a2 + 8) = v12;
  v14 = v29;
  *(_DWORD *)(a2 + 12) = result;
  *(_DWORD *)(a2 + 16) = v13;
  *(_DWORD *)(a2 + 20) = v14;
  return result;
}
// 10009104: using guessed type int __cdecl UF_MTX4_rotation(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10009108: using guessed type int __cdecl UF_MTX4_ask_rotation(_DWORD, _DWORD);
// 1000910C: using guessed type int __cdecl UF_MTX3_vec_multiply(_DWORD, _DWORD, _DWORD);
// 10009110: using guessed type int __cdecl UF_MTX4_vec3_multiply(_DWORD, _DWORD, _DWORD);
// 10009114: using guessed type int __cdecl UF_MTX4_multiply(_DWORD, _DWORD, _DWORD);
// 10009118: using guessed type int __cdecl UF_MTX4_vec_multiply(_DWORD, _DWORD, _DWORD);
// 10009128: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1000C2C8: using guessed type int dword_1000C2C8;
// 1000C2F0: using guessed type double dbl_1000C2F0;
// 1000C328: using guessed type double dbl_1000C328;
// 1000C3D8: using guessed type int dword_1000C3D8;

//----- (10002310) --------------------------------------------------------
int __cdecl sub_10002310(int a1, double a2, int a3)
{
  char v4; // [sp+Ch] [bp-E0h]@1
  char v5; // [sp+8Ch] [bp-60h]@1
  char v6; // [sp+D4h] [bp-18h]@1

  UF_MTX4_rotation(
    &dword_1000C540,
    &dbl_1000C2F0,
    COERCE_UNSIGNED_INT64(a2 * 57.29577951308235),
    COERCE_UNSIGNED_INT64(a2 * 57.29577951308235) >> 32,
    &v4);
  sub_10005200((int)&v4);
  UF_MTX4_ask_rotation(&v4, &v5);
  UF_MTX3_vec_multiply(&dword_1000C2C8, &v5, &v6);
  return UF_VEC3_add(a1, &v6, a3);
}
// 10009100: using guessed type int __cdecl UF_VEC3_add(_DWORD, _DWORD, _DWORD);
// 10009104: using guessed type int __cdecl UF_MTX4_rotation(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10009108: using guessed type int __cdecl UF_MTX4_ask_rotation(_DWORD, _DWORD);
// 1000910C: using guessed type int __cdecl UF_MTX3_vec_multiply(_DWORD, _DWORD, _DWORD);
// 1000C2C8: using guessed type int dword_1000C2C8;
// 1000C2F0: using guessed type double dbl_1000C2F0;
// 1000C540: using guessed type int dword_1000C540;

//----- (10002390) --------------------------------------------------------
int __cdecl sub_10002390(int a1, double a2, int a3)
{
  int v4; // ecx@1
  char v5; // [sp+8h] [bp-80h]@1

  sub_10001FE0((int)&dbl_1000C328, (int)&v5, a2);
  sub_10005200(v4);
  return UF_MTX4_vec3_multiply_t(a1, &v5, a3);
}
// 100090FC: using guessed type int __cdecl UF_MTX4_vec3_multiply_t(_DWORD, _DWORD, _DWORD);
// 1000C328: using guessed type double dbl_1000C328;

//----- (100023D0) --------------------------------------------------------
double __fastcall sub_100023D0(int a1, int a2, int a3)
{
  double v4; // [sp+0h] [bp-8h]@1

  UF_VEC3_angle_between(a3, a2, a1, &v4);
  return v4;
}
// 100090F8: using guessed type int __cdecl UF_VEC3_angle_between(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100023F0) --------------------------------------------------------
signed int __cdecl PtFuncCompare(int a1, int a2)
{
  signed int result; // eax@2

  if ( dbl_1000C000 < fabs(*(double *)a1 - *(double *)a2) )
  {
    if ( dbl_1000C000 + *(double *)a2 >= *(double *)a1 )
      result = -1;
    else
      result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1000C000: using guessed type double dbl_1000C000;

//----- (10002430) --------------------------------------------------------
void __fastcall sub_10002430(int a1, int a2)
{
  double v2; // st6@1
  long double v3; // st7@1
  double v4; // st5@4
  double v5; // st5@5
  double v6; // st4@7
  double v7; // st6@12
  double v8; // qt1@14
  double v9; // qt2@20
  long double v10; // st6@20
  double v11; // st7@20

  v3 = dbl_1000C000;
  v2 = 6.283185307179586;
  if ( dbl_1000C000 >= fabs(*(double *)a2 - *(double *)(a2 + 8)) )
  {
    if ( fabs(*(double *)a1 - *(double *)(a1 + 8)) <= dbl_1000C000 )
    {
      if ( fabs(*(double *)a2 - *(double *)a1) > dbl_1000C000 )
      {
        v4 = -dbl_1000C000;
        if ( -dbl_1000C000 <= *(double *)a2 )
        {
          if ( v4 <= *(double *)a1 )
          {
            v7 = dbl_1000C000;
            if ( dbl_1000C000 < *(double *)(a1 + 8) )
              *(double *)(a1 + 8) = *(double *)(a1 + 8) - 6.283185307179586;
            v8 = v7;
            v2 = 6.283185307179586;
            v3 = v8;
          }
          else
          {
            v6 = *(double *)a1 + 6.283185307179586;
            if ( fabs(v6 - *(double *)a2) <= dbl_1000C000 )
            {
              if ( v4 > *(double *)(a1 + 8) )
                *(double *)(a1 + 8) = *(double *)(a1 + 8) + 6.283185307179586;
            }
            else
            {
              *(_QWORD *)a1 = *(_QWORD *)&v6;
              if ( fabs(v6 - *(double *)(a1 + 8)) <= v3 )
                *(double *)(a1 + 8) = 6.283185307179586 - v6;
            }
          }
        }
        else
        {
          v5 = *(double *)a2 + 6.283185307179586;
          *(_QWORD *)a2 = *(_QWORD *)&v5;
          *(double *)(a2 + 8) = 6.283185307179586 - v5;
        }
      }
    }
  }
  if ( fabs(*(double *)a2 - *(double *)a1) <= v3 )
  {
    if ( fabs(*(double *)(a2 + 8) - *(double *)(a1 + 8)) <= v3 )
    {
      if ( -v3 <= *(double *)(a1 + 8) )
      {
        v9 = v2;
        v10 = v3;
        v11 = v9;
        if ( v10 >= *(double *)(a1 + 8) )
        {
          if ( fabs(*(double *)a2) <= v10 )
          {
            if ( fabs(*(double *)a1) <= v10 )
              *(_QWORD *)(a1 + 8) = *(_QWORD *)&v11;
          }
        }
        else
        {
          *(double *)(a1 + 8) = v11 - *(double *)(a1 + 8);
        }
      }
      else
      {
        *(double *)(a1 + 8) = v2 + *(double *)(a1 + 8);
      }
    }
  }
}
// 1000C000: using guessed type double dbl_1000C000;

//----- (10002580) --------------------------------------------------------
double __cdecl sub_10002580(double a1)
{
  double result; // st7@2

  if ( a1 <= 0.0 )
  {
    result = a1;
    if ( a1 < 0.0 )
      result = a1 + 360.0;
  }
  else
  {
    result = a1 - 360.0;
  }
  return result;
}

//----- (100025B0) --------------------------------------------------------
void __usercall sub_100025B0(int a1<edx>, int a2<ebx>)
{
  int v2; // edx@1
  double v3; // st7@1
  int v4; // ecx@1
  int v5; // edx@3
  int v6; // ecx@3
  double v7; // st7@3
  char v8; // [sp+8h] [bp-28h]@6

  v3 = sub_10002580(*(double *)(a1 + 24));
  if ( fabs(*(double *)(v4 + 24) - v3) < fabs(*(double *)(v4 + 24) - *(double *)(v2 + 24)) )
    *(_QWORD *)(v2 + 24) = *(_QWORD *)&v3;
  v7 = sub_10002580(*(double *)(v2 + 32));
  if ( fabs(*(double *)(v6 + 32) - v7) < fabs(*(double *)(v6 + 32) - *(double *)(v5 + 32)) )
    *(_QWORD *)(v5 + 32) = *(_QWORD *)&v7;
  if ( fabs(*(double *)(v6 + 24) - *(double *)(a2 + 24)) < fabs(*(double *)(v6 + 24) - *(double *)(v5 + 24)) )
  {
    memcpy(&v8, (const void *)v5, 0x28u);
    memcpy((void *)v5, (const void *)a2, 0x28u);
    memcpy((void *)a2, &v8, 0x28u);
  }
  if ( *(double *)(dword_1000C3D8 + 104) - dbl_1000C000 >= *(double *)(v5 + 24)
    || *(double *)(dword_1000C3D8 + 112) + dbl_1000C000 <= *(double *)(v5 + 24) )
  {
    if ( *(double *)(dword_1000C3D8 + 120) - dbl_1000C000 < *(double *)(a2 + 24) )
    {
      if ( dbl_1000C000 + *(double *)(dword_1000C3D8 + 128) > *(double *)(a2 + 24) )
      {
        memcpy(&v8, (const void *)v5, 0x28u);
        memcpy((void *)v5, (const void *)a2, 0x28u);
        memcpy((void *)a2, &v8, 0x28u);
      }
    }
  }
}
// 1000C000: using guessed type double dbl_1000C000;
// 1000C3D8: using guessed type int dword_1000C3D8;

//----- (100026E0) --------------------------------------------------------
int __cdecl sub_100026E0(int a1)
{
  int v2; // ecx@1

  v2 = dword_1000C3D8;
  *(_DWORD *)(dword_1000C3D8 + 16) = *(_DWORD *)(a1 + 192);
  *(_DWORD *)(v2 + 20) = *(_DWORD *)(a1 + 196);
  *(_DWORD *)(v2 + 24) = *(_DWORD *)(a1 + 200);
  *(_DWORD *)(v2 + 28) = *(_DWORD *)(a1 + 204);
  *(_DWORD *)(v2 + 32) = *(_DWORD *)(a1 + 208);
  *(_DWORD *)(v2 + 36) = *(_DWORD *)(a1 + 212);
  *(_DWORD *)(v2 + 40) = *(_DWORD *)(a1 + 216);
  *(_DWORD *)(v2 + 44) = *(_DWORD *)(a1 + 220);
  *(_DWORD *)(v2 + 48) = *(_DWORD *)(a1 + 224);
  *(_DWORD *)(v2 + 52) = *(_DWORD *)(a1 + 228);
  *(_DWORD *)(v2 + 56) = *(_DWORD *)(a1 + 232);
  *(_DWORD *)(v2 + 60) = *(_DWORD *)(a1 + 236);
  *(double *)(v2 + 136) = *(double *)(a1 + 376);
  return 0;
}
// 1000C3D8: using guessed type int dword_1000C3D8;

//----- (10002770) --------------------------------------------------------
int __cdecl sub_10002770(int a1, int a2, int a3, int a4)
{
  int result; // eax@2
  char v5; // [sp+8h] [bp-40h]@1
  double v6; // [sp+20h] [bp-28h]@1
  double v7; // [sp+28h] [bp-20h]@1
  double v8; // [sp+30h] [bp-18h]@1
  double v9; // [sp+38h] [bp-10h]@1
  double v10; // [sp+40h] [bp-8h]@2

  UF_VEC3_sub(a2 + 24, a2, &v6);
  UF_VEC3_sub(a1, a2, &v5);
  v9 = v8 * v8 + v7 * v7 + v6 * v6;
  if ( v9 <= 0.0 )
  {
    *(double *)a4 = 0.0;
    UF_VEC3_copy(a2, a3);
    result = 0;
  }
  else
  {
    UF_VEC3_dot(&v6, &v5, &v10);
    *(double *)a4 = v10 / v9;
    *(double *)a3 = *(double *)a4 * v6 + *(double *)a2;
    *(double *)(a3 + 8) = *(double *)a4 * v7 + *(double *)(a2 + 8);
    result = 0;
    *(double *)(a3 + 16) = *(double *)a4 * v8 + *(double *)(a2 + 16);
  }
  return result;
}
// 100090EC: using guessed type int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD);
// 100090F0: using guessed type int __cdecl UF_VEC3_dot(_DWORD, _DWORD, _DWORD);
// 100090F4: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);

//----- (10002830) --------------------------------------------------------
signed int __usercall sub_10002830<eax>(int a1<esi>, signed int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // eax@1
  int v7; // edi@2
  unsigned int v9; // ecx@3
  int v15; // ecx@18
  unsigned __int8 v19; // sf@24
  unsigned __int8 v20; // of@24
  int v21; // eax@25
  signed int result; // eax@27
  signed int v24; // edi@29
  unsigned __int8 v32; // sf@35
  unsigned __int8 v33; // of@35
  int v44; // eax@49
  unsigned int v48; // edi@50
  int v49; // edi@50
  int v50; // ebx@50
  int v53; // edi@54
  int v56; // eax@58
  int v59; // edx@60
  int v60; // edi@61
  int v61; // eax@63
  unsigned int v62; // edx@63
  char v72; // [sp+8h] [bp-24h]@1
  int v73; // [sp+Ch] [bp-20h]@26
  int v74; // [sp+10h] [bp-1Ch]@50
  int v75; // [sp+14h] [bp-18h]@26
  int v76; // [sp+18h] [bp-14h]@44
  int v77; // [sp+1Ch] [bp-10h]@1
  int v78; // [sp+20h] [bp-Ch]@26
  unsigned int v79; // [sp+24h] [bp-8h]@1
  int v80; // [sp+28h] [bp-4h]@25

  v4 = a2;
  v5 = UF_allocate_memory(8 * a2, &v72);
  __asm { fld1 }
  _EDX = a4;
  __asm
  {
    fst     qword ptr [edx]
    fldz
  }
  v77 = v5;
  v79 = 0;
  if ( a2 <= 0 )
  {
LABEL_25:
    v21 = 0;
    v80 = 0;
    if ( a2 > 0 )
    {
      __asm { fld     ds:dbl_100099F0 }
      v75 = a2 - 1;
      _ECX = 0;
      v78 = a1;
      v73 = a3 - a1;
      while ( 1 )
      {
        v24 = 0;
        if ( v21 > 0 )
        {
          do
          {
            _EDX = *(_DWORD *)(a1 + 4 * v24);
            __asm { fld     st(1) }
            _EAX = 0;
            __asm
            {
              fld     st(2)
              fld     qword ptr [ecx+edx]
            }
            if ( v24 >= 2 )
            {
              do
              {
                _EBX = *(_DWORD *)(a1 + 4 * _EAX);
                __asm { fld     qword ptr [ebx+ecx] }
                _EBX = *(_DWORD *)(a1 + 4 * _EAX + 4);
                __asm { fmul    qword ptr [edx] }
                _EAX += 2;
                _EDX += 16;
                __asm
                {
                  fsubp   st(3), st
                  fld     qword ptr [ebx+ecx]
                  fmul    qword ptr [edx-8]
                  fsubp   st(2), st
                }
              }
              while ( _EAX < v24 - 1 );
              v4 = a2;
            }
            if ( _EAX < v24 )
            {
              _EDX = *(_DWORD *)(a1 + 4 * _EAX);
              __asm { fld     qword ptr [edx+ecx] }
              _EDX = *(_DWORD *)(a1 + 4 * v24);
              __asm
              {
                fmul    qword ptr [edx+eax*8]
                fsubp   st(1), st
              }
            }
            _EAX = *(_DWORD *)(a1 + 4 * v24);
            __asm
            {
              fxch    st(1)
              faddp   st(2), st
            }
            ++v24;
            v33 = __SETO__(v24, v80);
            v32 = v24 - v80 < 0;
            __asm
            {
              faddp   st(1), st
              fstp    qword ptr [ecx+eax]
            }
          }
          while ( v32 ^ v33 );
          v21 = v80;
        }
        __asm { fld     st(1) }
        _EDI = v21;
        v79 = v21;
        if ( v21 < v4 )
        {
          do
          {
            _EDX = *(_DWORD *)(a1 + 4 * _EDI);
            __asm { fld     st(2) }
            _EAX = 0;
            __asm
            {
              fld     st(3)
              fld     qword ptr [ecx+edx]
            }
            if ( _ECX >= 16 )
            {
              do
              {
                _EBX = *(_DWORD *)(a1 + 4 * _EAX);
                __asm { fld     qword ptr [ebx+ecx] }
                _EBX = *(_DWORD *)(a1 + 4 * _EAX + 4);
                __asm { fmul    qword ptr [edx] }
                _EAX += 2;
                _EDX += 16;
                __asm
                {
                  fsubp   st(3), st
                  fld     qword ptr [ebx+ecx]
                  fmul    qword ptr [edx-8]
                  fsubp   st(2), st
                }
              }
              while ( _EAX < v80 - 1 );
              v4 = a2;
              _EDI = v79;
            }
            if ( _EAX < v80 )
            {
              _EDX = *(_DWORD *)(a1 + 4 * _EAX);
              __asm { fld     qword ptr [edx+ecx] }
              _EDX = *(_DWORD *)(a1 + 4 * _EDI);
              __asm
              {
                fmul    qword ptr [edx+eax*8]
                fsubp   st(1), st
              }
            }
            _EAX = *(_DWORD *)(a1 + 4 * _EDI);
            __asm
            {
              fxch    st(1)
              faddp   st(2), st
              faddp   st(1), st
              fst     qword ptr [ecx+eax]
            }
            _EAX = v77;
            __asm
            {
              fabs
              fmul    qword ptr [eax+edi*8]
              fcom    st(1)
              fnstsw  ax
            }
            if ( BYTE1(_EAX) & 1 )
            {
              __asm { fstp    st }
            }
            else
            {
              __asm { fstp    st(1) }
              v76 = _EDI;
            }
            ++_EDI;
            v79 = _EDI;
          }
          while ( _EDI < v4 );
          v21 = v80;
        }
        _EDX = v76;
        __asm { fstp    st }
        if ( v21 != v76 )
        {
          v44 = 0;
          v79 = 0;
          if ( v4 >= 4 )
          {
            v49 = *(_DWORD *)(a1 + 4 * v76);
            v50 = *(_DWORD *)v78;
            _EDX = v49 + 24;
            v74 = v49 - *(_DWORD *)v78;
            _EAX = v50 + 8;
            v48 = ((unsigned int)(a2 - 4) >> 2) + 1;
            v79 = 4 * v48;
            _EBX = v74;
            do
            {
              __asm { fld     qword ptr [edx-18h] }
              _EAX += 32;
              __asm { fld     qword ptr [eax-28h] }
              _EDX += 32;
              --v48;
              __asm
              {
                fstp    qword ptr [edx-38h]
                fstp    qword ptr [eax-28h]
                fld     qword ptr [ebx+eax-20h]
                fld     qword ptr [eax-20h]
                fstp    qword ptr [ebx+eax-20h]
                fstp    qword ptr [eax-20h]
                fld     qword ptr [edx-28h]
                fld     qword ptr [eax-18h]
                fstp    qword ptr [edx-28h]
                fstp    qword ptr [eax-18h]
                fld     qword ptr [edx-20h]
                fld     qword ptr [eax-10h]
                fstp    qword ptr [edx-20h]
                fstp    qword ptr [eax-10h]
              }
            }
            while ( v48 );
            v44 = v79;
            v4 = a2;
            _EDX = v76;
          }
          if ( v44 < v4 )
          {
            _EAX = *(_DWORD *)v78 + 8 * v44;
            _EDX = *(_DWORD *)(a1 + 4 * _EDX) - *(_DWORD *)v78;
            v53 = v4 - v79;
            do
            {
              __asm { fld     qword ptr [edx+eax] }
              _EAX += 8;
              --v53;
              __asm
              {
                fld     qword ptr [eax-8]
                fstp    qword ptr [edx+eax-8]
                fstp    qword ptr [eax-8]
              }
            }
            while ( v53 );
            _EDX = v76;
          }
          _EAX = a4;
          __asm
          {
            fld     qword ptr [eax]
            fchs
            fstp    qword ptr [eax]
          }
          _EAX = v77;
          __asm
          {
            fld     qword ptr [ecx+eax]
            fstp    qword ptr [eax+edx*8]
          }
        }
        v56 = v78;
        __asm { fld     st(1) }
        *(_DWORD *)(v78 + v73) = _EDX;
        _EAX = *(_DWORD *)v56;
        __asm { fcomp   qword ptr [ecx+eax] }
        _EDI = _ECX + _EAX;
        __asm { fnstsw  ax }
        if ( !__SETP__(BYTE1(_EAX) & 0x44, 0) )
          __asm { fst     qword ptr [edi] }
        v59 = v80;
        if ( v80 != v4 - 1 )
        {
          __asm
          {
            fld     st(2)
            fdiv    qword ptr [edi]
          }
          v60 = v80 + 1;
          if ( v80 + 1 < v4 )
          {
            if ( v75 >= 4 )
            {
              v61 = v78 + 12;
              v62 = ((unsigned int)(v4 - v60 - 4) >> 2) + 1;
              v60 += 4 * v62;
              do
              {
                _EBX = *(_DWORD *)(v61 - 8);
                __asm { fld     qword ptr [ebx+ecx] }
                _EBX = _ECX + _EBX;
                __asm { fmul    st, st(1) }
                v61 += 16;
                __asm { fstp    qword ptr [ebx] }
                _EBX = *(_DWORD *)(v61 - 20);
                __asm { fld     qword ptr [ebx+ecx] }
                _EBX = _ECX + _EBX;
                __asm
                {
                  fmul    st, st(1)
                  fstp    qword ptr [ebx]
                }
                _EBX = *(_DWORD *)(v61 - 16);
                __asm { fld     qword ptr [ebx+ecx] }
                _EBX = _ECX + _EBX;
                __asm
                {
                  fmul    st, st(1)
                  fstp    qword ptr [ebx]
                }
                _EBX = _ECX + *(_DWORD *)(v61 - 12);
                --v62;
                __asm
                {
                  fld     st
                  fmul    qword ptr [ebx]
                  fstp    qword ptr [ebx]
                }
              }
              while ( v62 );
              v4 = a2;
              v59 = v80;
            }
            while ( v60 < v4 )
            {
              _EAX = *(_DWORD *)(a1 + 4 * v60);
              __asm { fld     qword ptr [eax+ecx] }
              _EAX = _ECX + _EAX;
              __asm { fmul    st, st(1) }
              ++v60;
              __asm { fstp    qword ptr [eax] }
            }
          }
          __asm { fstp    st }
        }
        --v75;
        v78 += 4;
        _ECX += 8;
        v80 = v59 + 1;
        if ( v59 + 1 >= v4 )
          break;
        v21 = v80;
      }
      __asm { fstp    st(1) }
    }
    __asm
    {
      fstp    st
      fstp    st
    }
    UF_free(v77);
    result = 0;
  }
  else
  {
    while ( 1 )
    {
      v7 = 0;
      __asm { fld     st }
      if ( a2 >= 4 )
      {
        _EDX = *(_DWORD *)(a1 + 4 * v79) + 16;
        v9 = ((unsigned int)(a2 - 4) >> 2) + 1;
        v7 = 4 * v9;
        do
        {
          __asm
          {
            fld     qword ptr [edx-10h]
            fabs
            fcom    st(1)
            fnstsw  ax
          }
          if ( HIBYTE(_AX) & 0x41 )
            __asm { fstp    st }
          else
            __asm { fstp    st(1) }
          __asm
          {
            fld     qword ptr [edx-8]
            fabs
            fcom    st(1)
            fnstsw  ax
          }
          if ( HIBYTE(_AX) & 0x41 )
            __asm { fstp    st }
          else
            __asm { fstp    st(1) }
          __asm
          {
            fld     qword ptr [edx]
            fabs
            fcom    st(1)
            fnstsw  ax
          }
          if ( HIBYTE(_AX) & 0x41 )
            __asm { fstp    st }
          else
            __asm { fstp    st(1) }
          __asm
          {
            fld     qword ptr [edx+8]
            fabs
            fcom    st(1)
            fnstsw  ax
          }
          if ( HIBYTE(_AX) & 0x41 )
            __asm { fstp    st }
          else
            __asm { fstp    st(1) }
          _EDX += 32;
          --v9;
        }
        while ( v9 );
      }
      if ( v7 < a2 )
      {
        _EDX = *(_DWORD *)(a1 + 4 * v79) + 8 * v7;
        v15 = a2 - v7;
        do
        {
          __asm
          {
            fld     qword ptr [edx]
            fabs
            fcom    st(1)
            fnstsw  ax
          }
          if ( HIBYTE(_AX) & 0x41 )
            __asm { fstp    st }
          else
            __asm { fstp    st(1) }
          _EDX += 8;
          --v15;
        }
        while ( v15 );
      }
      __asm
      {
        fld     st(1)
        fucomp  st(1)
        fnstsw  ax
      }
      if ( !__SETP__(HIBYTE(_AX) & 0x44, 0) )
        break;
      __asm { fdivr   st, st(2) }
      _ECX = v77;
      v20 = __SETO__(v79 + 1, a2);
      v19 = (signed int)(v79++ + 1 - a2) < 0;
      __asm { fstp    qword ptr [ecx+eax*8-8] }
      if ( !(v19 ^ v20) )
        goto LABEL_25;
    }
    __asm
    {
      fstp    st
      fstp    st
      fstp    st
    }
    UF_free(v77);
    result = 1;
  }
  return result;
}
// 1000284D: inconsistent fpu stack
// 100090E4: using guessed type int __cdecl UF_allocate_memory(_DWORD, _DWORD);
// 100090E8: using guessed type int __cdecl UF_free(_DWORD);

//----- (10002C00) --------------------------------------------------------
void __usercall sub_10002C00(int a1<eax>, int a2<ecx>, int a3, int a4)
{
  int v4; // edx@1
  int v5; // edi@1
  int v6; // eax@2
  int v7; // ebx@2
  int v8; // esi@2
  double v9; // st5@4
  double v10; // st6@4
  int v11; // eax@4
  int v12; // eax@5
  double v13; // st4@5
  unsigned int v14; // eax@7
  int v15; // edx@7
  double v16; // st3@8
  int v17; // esi@16
  int v18; // eax@17
  int v19; // ebx@17
  int v20; // edi@17
  double v21; // st4@18
  double v22; // st5@18
  double v23; // st6@18
  unsigned int v24; // eax@20
  int v25; // edx@20
  int v26; // ebx@20
  int v27; // edi@20
  int v28; // eax@20
  int v29; // edi@20
  int v30; // ST10_4@20
  double v31; // st3@21
  double v32; // st6@25
  double v33; // st6@27
  int i; // [sp+10h] [bp-14h]@2
  int v35; // [sp+14h] [bp-10h]@2
  int v36; // [sp+14h] [bp-10h]@17
  signed int v37; // [sp+18h] [bp-Ch]@1
  int v38; // [sp+18h] [bp-Ch]@17
  int v39; // [sp+1Ch] [bp-8h]@7
  int v40; // [sp+1Ch] [bp-8h]@17
  int v41; // [sp+20h] [bp-4h]@7
  int v42; // [sp+20h] [bp-4h]@18

  v4 = a4;
  v5 = 0;
  v37 = 0;
  if ( a4 > 0 )
  {
    v7 = a3;
    v8 = a4;
    v6 = a1 - a3;
    v35 = a3;
    for ( i = v6; ; v6 = i )
    {
      v11 = *(_DWORD *)(v6 + v7);
      v10 = *(double *)(a2 + 8 * v11);
      *(double *)(a2 + 8 * v11) = *(double *)(a2 + 8 * v5);
      v9 = 0.0;
      if ( v37 )
      {
        v13 = 0.0;
        v12 = v8;
        if ( v8 < v5 )
        {
          if ( v5 - v8 >= 2 )
          {
            v14 = ((unsigned int)(v5 - v8 - 2) >> 1) + 1;
            v39 = *(_DWORD *)v7 + 8 * v8 + 8;
            v15 = a2 + 8 * v8;
            v41 = v8 + 2 * v14;
            do
            {
              v16 = *(double *)(*(_DWORD *)v7 - a2 + v15) * *(double *)v15;
              v15 += 16;
              --v14;
              v9 = v9 - v16;
              v39 += 16;
              v13 = v13 - *(double *)(v15 - 8) * *(double *)(v39 - 16);
            }
            while ( v14 );
            v12 = v41;
            v7 = v35;
          }
          if ( v12 < v5 )
            v10 = v10 - *(double *)(a2 + 8 * v12) * *(double *)(*(_DWORD *)v7 + 8 * v12);
          v4 = a4;
          v10 = v10 + v9 + v13;
        }
      }
      else
      {
        if ( 0.0 != v10 )
        {
          v37 = 1;
          v8 = v5;
        }
      }
      *(_QWORD *)(a2 + 8 * v5++) = *(_QWORD *)&v10;
      v7 += 4;
      v35 = v7;
      if ( v5 >= v4 )
        break;
    }
  }
  v17 = v4 - 1;
  if ( v4 - 1 >= 0 )
  {
    v18 = v4 - v17 - 1;
    v19 = v4;
    v20 = a2 + 8 * v17;
    v38 = v4;
    v40 = a2 + 8 * v17;
    v36 = v4 - v17 - 1;
    do
    {
      v23 = 0.0;
      v22 = 0.0;
      v42 = v19;
      v21 = *(double *)v20;
      if ( v19 >= a4 )
      {
        v32 = v21;
      }
      else
      {
        if ( v18 >= 2 )
        {
          v28 = v20 + 8 - a2;
          v29 = *(_DWORD *)(a3 + 4 * v17);
          v25 = v28 + a2;
          v30 = v29 + v28 + 8;
          v27 = v29 - a2;
          v24 = ((unsigned int)(a4 - 1 - v19 - 1) >> 1) + 1;
          v42 = v19 + 2 * v24;
          v26 = v30;
          do
          {
            v26 += 16;
            v31 = *(double *)(v25 + v27) * *(double *)v25;
            v25 += 16;
            --v24;
            v23 = v23 - v31;
            v22 = v22 - *(double *)(v25 - 8) * *(double *)(v26 - 16);
          }
          while ( v24 );
          v20 = v40;
          v19 = v38;
        }
        if ( v42 < a4 )
          v21 = v21 - *(double *)(*(_DWORD *)(a3 + 4 * v17) + 8 * v42) * *(double *)(a2 + 8 * v42);
        v18 = v36;
        v32 = v23 + v22 + v21;
      }
      v33 = v32 / *(double *)(*(_DWORD *)(a3 + 4 * v17) + 8 * v17);
      --v17;
      ++v18;
      --v19;
      v20 -= 8;
      v36 = v18;
      v38 = v19;
      v40 = v20;
      *(_QWORD *)(v20 + 8) = *(_QWORD *)&v33;
    }
    while ( v17 >= 0 );
  }
}

//----- (10002DC0) --------------------------------------------------------
void __usercall sub_10002DC0(int a1<eax>, int a2)
{
  double v2; // st7@1
  double v3; // st7@1
  signed int v4; // edi@2
  int v5; // esi@2
  char v6; // [sp+0h] [bp-C8h]@1
  char v7; // [sp+10h] [bp-B8h]@1
  double v8; // [sp+18h] [bp-B0h]@1
  double v9; // [sp+20h] [bp-A8h]@1
  double v10; // [sp+28h] [bp-A0h]@1
  double v11; // [sp+30h] [bp-98h]@1
  double v12; // [sp+38h] [bp-90h]@1
  double v13; // [sp+40h] [bp-88h]@1
  double v14; // [sp+48h] [bp-80h]@1
  double v15; // [sp+50h] [bp-78h]@1
  double v16; // [sp+58h] [bp-70h]@1
  double v17; // [sp+60h] [bp-68h]@1
  double v18; // [sp+68h] [bp-60h]@1
  double v19; // [sp+70h] [bp-58h]@1
  double v20; // [sp+78h] [bp-50h]@1
  double v21; // [sp+80h] [bp-48h]@1
  double v22; // [sp+88h] [bp-40h]@1
  double v23; // [sp+90h] [bp-38h]@1
  double *v24; // [sp+98h] [bp-30h]@1
  double *v25; // [sp+9Ch] [bp-2Ch]@1
  double *v26; // [sp+A0h] [bp-28h]@1
  double *v27; // [sp+A4h] [bp-24h]@1
  double v28; // [sp+A8h] [bp-20h]@3
  double v29; // [sp+B0h] [bp-18h]@3
  double v30; // [sp+B8h] [bp-10h]@3
  double v31; // [sp+C0h] [bp-8h]@3

  v20 = *(double *)a1;
  v2 = *(double *)(a1 + 32);
  v25 = &v16;
  v16 = v2;
  v8 = *(double *)(a1 + 64);
  v26 = &v8;
  v12 = *(double *)(a1 + 96);
  v21 = *(double *)(a1 + 8);
  v17 = *(double *)(a1 + 40);
  v9 = *(double *)(a1 + 72);
  v13 = *(double *)(a1 + 104);
  v22 = *(double *)(a1 + 16);
  v18 = *(double *)(a1 + 48);
  v10 = *(double *)(a1 + 80);
  v14 = *(double *)(a1 + 112);
  v23 = *(double *)(a1 + 24);
  v19 = *(double *)(a1 + 56);
  v11 = *(double *)(a1 + 88);
  v3 = *(double *)(a1 + 120);
  v24 = &v20;
  v15 = v3;
  v27 = &v12;
  if ( !sub_10002830((int)&v24, 4, (int)&v6, (int)&v7) )
  {
    v4 = 0;
    v5 = a2 + 64;
    do
    {
      *(_QWORD *)&v28 = 0i64;
      *(_QWORD *)&v29 = 0i64;
      *(_QWORD *)&v30 = 0i64;
      *(_QWORD *)&v31 = 0i64;
      *(&v28 + v4) = 1.0;
      sub_10002C00((int)&v6, (int)&v28, (int)&v24, 4);
      *(_QWORD *)(v5 - 64) = *(_QWORD *)&v28;
      ++v4;
      *(_QWORD *)(v5 - 32) = *(_QWORD *)&v29;
      v5 += 8;
      *(_QWORD *)(v5 - 8) = *(_QWORD *)&v30;
      *(_QWORD *)(v5 + 24) = *(_QWORD *)&v31;
    }
    while ( v4 < 4 );
  }
}

//----- (10002EE0) --------------------------------------------------------
int __cdecl sub_10002EE0(int a2, int a3)
{
  int v6; // eax@5
  signed int v7; // ST10_4@5
  double v8; // ST08_8@5
  int v9; // esi@5
  double v10; // ST00_8@5
  char *v11; // ST10_4@5
  char *v12; // ST0C_4@5
  __int64 v13; // ST04_8@5
  int *v14; // ST10_4@5
  __int64 v15; // ST08_8@5
  int v19; // eax@9
  signed int v20; // ST10_4@9
  double v21; // ST08_8@9
  int v22; // esi@9
  double v23; // ST00_8@9
  char *v24; // ST10_4@9
  char *v25; // ST0C_4@9
  __int64 v26; // ST04_8@9
  int *v27; // ST10_4@9
  __int64 v28; // ST08_8@9
  int result; // eax@12
  double Base; // [sp+20h] [bp-DCh]@8
  double v44; // [sp+B0h] [bp-4Ch]@1
  char v49; // [sp+D8h] [bp-24h]@5
  char v50; // [sp+E0h] [bp-1Ch]@5
  int v51; // [sp+F8h] [bp-4h]@5

  __asm { fldz }
  _EAX = a3;
  __asm
  {
    fst     [ebp+var_4C]
    fstp    [ebp+var_44]
    fld1
    fstp    [ebp+var_3C]
    fld     qword ptr [eax]
    fld     qword ptr [eax+8]
    fld     qword ptr [ecx]
    fst     [ebp+var_34]
    fld     qword ptr [ecx+8]
    fst     [ebp+var_2C]
    fxch    st(3)
    fst     [ebp+var_AC]
    fld     st
    fld     ds:dbl_100099C8
    fmul    st(1), st
    fxch    st(1)
    fst     [ebp+var_A4]
    fld     st(2)
    fld     ds:dbl_100099C0
    fadd    st(1), st
    fxch    st(1)
    fstp    [ebp+var_9C]
    fld     st
    fsubrp  st(4), st
    fxch    st(3)
    fstp    [ebp+var_94]
    fld     st(2)
    fsub    st, st(1)
    fstp    [ebp+var_8C]
    fadd    st, st(2)
    fstp    [ebp+var_84]
    fxch    st(3)
    fst     [ebp+var_7C]
    fld     st
    fmul    st, st(4)
    fst     [ebp+var_74]
    fld     st(1)
    fadd    st, st(3)
    fstp    [ebp+var_6C]
    fld     st(2)
    fsubrp  st(2), st
    fxch    st(1)
    fstp    [ebp+var_64]
    fld     st(1)
    fsub    st, st(1)
    fstp    [ebp+var_5C]
    faddp   st(1), st
    fstp    [ebp+var_54]
    fld     st
    fsub    st, st(3)
    fabs
    fcomp   dbl_1000C000
    fnstsw  ax
  }
  if ( __SETP__(BYTE1(_EAX) & 0x41, 0) )
  {
    __asm
    {
      fstp    st(2)
      fstp    st
    }
    _EBX = 0;
    _EDI = 0;
  }
  else
  {
    __asm
    {
      fxch    st(2)
      fmulp   st(1), st
    }
    _EBX = 0;
    __asm { fstp    qword ptr [ecx+8] }
    _EDI = 0;
  }
  while ( 1 )
  {
    v6 = a2;
    v7 = 0;
    __asm { fstp    [esp+0FCh+var_F4] }
    v9 = (int)&v50;
    __asm
    {
      fld     [ebp+edi*8+var_AC]
      fstp    [esp+0FCh+var_FC]
    }
    sub_10002190(v6, v9, v10, v8, v7);
    __asm { fld     dbl_1000C000 }
    v11 = &v50;
    v12 = &v49;
    __asm { fstp    [esp+0F8h+var_FC+4] }
    UF_VEC3_unitize(&v50, v13, HIDWORD(v13), v12, v11);
    __asm { fld     dbl_1000C000 }
    v14 = &v51;
    __asm { fstp    [esp+0F4h+var_F4] }
    UF_VEC3_is_equal(&v44, &v50, v15, HIDWORD(v15), v14);
    if ( v51 )
    {
      __asm { fld     [ebp+edi*8+var_AC] }
      ++_EBX;
      __asm { fstp    [ebp+ebx*8+var_E4] }
    }
    ++_EDI;
    if ( _EDI >= 6 )
      break;
    __asm { fld     [ebp+var_34] }
  }
  qsort(&Base, _EBX - 1, 8u, (int (__cdecl *)(const void *, const void *))PtFuncCompare);
  __asm { fld     [ebp+Base] }
  _ECX = a3;
  __asm { fstp    qword ptr [ecx] }
  _EBX = 0;
  _EDI = 0;
  do
  {
    __asm { fld     [ebp+var_2C] }
    v19 = a2;
    v20 = 0;
    __asm { fstp    [esp+0FCh+var_F4] }
    v22 = (int)&v50;
    __asm
    {
      fld     [ebp+edi*8+var_7C]
      fstp    [esp+0FCh+var_FC]
    }
    sub_10002190(v19, v22, v23, v21, v20);
    __asm { fld     dbl_1000C000 }
    v24 = &v50;
    v25 = &v49;
    __asm { fstp    [esp+0F8h+var_FC+4] }
    UF_VEC3_unitize(&v50, v26, HIDWORD(v26), v25, v24);
    __asm { fld     dbl_1000C000 }
    v27 = &v51;
    __asm { fstp    [esp+0F4h+var_F4] }
    UF_VEC3_is_equal(&v44, &v50, v28, HIDWORD(v28), v27);
    if ( v51 )
    {
      __asm { fld     [ebp+edi*8+var_7C] }
      ++_EBX;
      __asm { fstp    [ebp+ebx*8+var_E4] }
    }
    ++_EDI;
  }
  while ( _EDI < 6 );
  qsort(&Base, _EBX - 1, 8u, (int (__cdecl *)(const void *, const void *))PtFuncCompare);
  __asm { fld     [ebp+Base] }
  result = a3;
  __asm { fstp    qword ptr [eax+8] }
  return result;
}
// 10002EE9: inconsistent fpu stack
// 100090E0: using guessed type int __cdecl UF_VEC3_is_equal(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10009128: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10003100) --------------------------------------------------------
signed int __cdecl sub_10003100(const void *a1, int a2, int a3)
{
  char v5; // zf@1
  __int64 v7; // ST2C_8@2
  __int64 v8; // ST24_8@2
  __int64 v9; // ST1C_8@2
  __int64 v10; // ST14_8@2
  __int64 v11; // ST0C_8@2
  __int64 v12; // ST04_8@2
  int *v13; // ST30_4@6
  __int64 v14; // ST28_8@6
  signed int result; // eax@7
  int v16; // ecx@8
  int v17; // esi@8
  int *v18; // ST30_4@8
  char *v19; // ST2C_4@8
  __int64 v20; // ST24_8@8
  double v21; // ST2C_8@10
  double v23; // ST2C_8@11
  double v29; // ST2C_8@21
  void (*v38)(const char *, ...); // esi@46
  __int64 v39; // ST2C_8@46
  __int64 v40; // ST24_8@46
  __int64 v41; // ST1C_8@46
  __int64 v42; // ST14_8@46
  __int64 v43; // ST0C_8@46
  __int64 v44; // ST04_8@46
  __int64 v45; // ST2C_8@46
  int v51; // eax@71
  int v53; // eax@72
  int v54; // ecx@72
  int v55; // edx@72
  int v56; // esi@72
  int v57; // esi@72
  int v58; // eax@72
  __int64 v59; // ST2C_8@76
  __int64 v60; // ST24_8@76
  __int64 v61; // ST1C_8@76
  __int64 v62; // ST14_8@76
  __int64 v63; // ST2C_8@76
  __int64 v64; // ST24_8@76
  __int64 v65; // ST1C_8@76
  __int64 v66; // ST14_8@76
  signed int v67; // ST30_4@78
  int v68; // esi@78
  int v69; // eax@78
  double v70; // ST28_8@78
  double v71; // ST20_8@78
  signed int v72; // ST30_4@78
  double v73; // ST28_8@78
  int v74; // esi@78
  int v75; // eax@78
  double v76; // ST20_8@78
  int v77; // ST30_4@80
  double v78; // ST28_8@80
  int v79; // ST30_4@80
  double v80; // ST28_8@80
  signed int v81; // esi@81
  int v82; // eax@82
  int v83; // eax@87
  void (__cdecl *v85)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // esi@88
  int v86; // ST30_4@88
  int *v87; // ST2C_4@88
  __int64 v88; // ST24_8@88
  int v89; // ST30_4@88
  int *v90; // ST2C_4@88
  __int64 v91; // ST24_8@88
  int v92; // ST30_4@88
  double v93; // ST28_8@88
  int v94; // ST30_4@88
  double v95; // ST28_8@88
  void (__cdecl *v96)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // esi@90
  int v97; // ST30_4@90
  double v98; // ST28_8@90
  int *v99; // ST30_4@90
  char *v100; // ST2C_4@90
  __int64 v101; // ST24_8@90
  int v103; // ST30_4@90
  int *v104; // ST2C_4@90
  __int64 v105; // ST24_8@90
  signed int v107; // ST30_4@92
  double v108; // ST28_8@92
  int v109; // esi@92
  int v110; // eax@92
  double v111; // ST20_8@92
  signed int v112; // ST30_4@92
  double v113; // ST28_8@92
  int v114; // esi@92
  int v115; // eax@92
  double v116; // ST20_8@92
  void (__cdecl *v117)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // esi@92
  int *v118; // ST30_4@92
  char *v119; // ST2C_4@92
  __int64 v120; // ST24_8@92
  char *v121; // ST30_4@92
  char *v122; // ST2C_4@92
  __int64 v123; // ST24_8@92
  int v125; // ST30_4@92
  int *v126; // ST2C_4@92
  __int64 v127; // ST24_8@92
  __int64 v129; // ST24_8@93
  char v130; // zf@95
  int *v135[5]; // [sp+28h] [bp-DCh]@90
  int v136; // [sp+2Ch] [bp-D8h]@90
  int v137; // [sp+3Ch] [bp-C8h]@4
  int v138; // [sp+40h] [bp-C4h]@72
  int v139; // [sp+44h] [bp-C0h]@72
  int v140; // [sp+48h] [bp-BCh]@72
  int v141; // [sp+4Ch] [bp-B8h]@72
  int v142; // [sp+50h] [bp-B4h]@72
  char v143; // [sp+54h] [bp-B0h]@4
  char v146; // [sp+7Ch] [bp-88h]@8
  char v147; // [sp+84h] [bp-80h]@92
  double v148; // [sp+8Ch] [bp-78h]@78
  int v150[2]; // [sp+9Ch] [bp-68h]@8
  int v154; // [sp+BCh] [bp-48h]@90
  int v157; // [sp+D4h] [bp-30h]@1
  double v159; // [sp+E0h] [bp-24h]@14
  double v161; // [sp+F0h] [bp-14h]@10
  char v163; // [sp+103h] [bp-1h]@1

  v5 = byte_1000C588 == 0;
  __asm { fldz }
  _EAX = a2;
  _EBX = a3;
  __asm
  {
    fst     qword ptr [ebx]
    fst     qword ptr [eax]
    fst     qword ptr [ebx+8]
  }
  _EDI = a1;
  __asm
  {
    fst     qword ptr [eax+8]
    fst     qword ptr [ebx+10h]
  }
  v163 = 0;
  __asm { fst     qword ptr [eax+10h] }
  v157 = 0;
  __asm
  {
    fst     qword ptr [ebx+18h]
    fst     qword ptr [eax+18h]
    fst     qword ptr [ebx+20h]
    fstp    qword ptr [eax+20h]
  }
  if ( !v5 )
  {
    printf("\n------------------------------------------------------\n");
    __asm
    {
      fld     qword ptr [edi+28h]
      fstp    qword ptr [esp+104h+var_DC]
      fld     qword ptr [edi+20h]
      fstp    [esp+104h+var_E4]
      fld     qword ptr [edi+18h]
      fstp    [esp+104h+var_EC]
      fld     qword ptr [edi+10h]
      fstp    [esp+104h+var_F4]
      fld     qword ptr [edi+8]
      fstp    [esp+104h+var_FC]
      fld     qword ptr [edi]
      fstp    [esp+104h+var_104]
    }
    printf("Starting old_pcoord_t[] = (%f,%f,%f,%f,%f,%f)\n", v12, v11, v10, v9, v8, v7);
  }
  if ( dword_1000C3DC == 3 )
  {
    UF_MTX3_vec_multiply_t(a1, &unk_10009970, &v137);
    UF_MTX3_vec_multiply_t((char *)a1 + 24, &unk_10009970, &v143);
  }
  else
  {
    memcpy(&v137, a1, 0x30u);
    _EDI = a1;
  }
  __asm { fld     dbl_1000C000 }
  v13 = &a3;
  __asm { fstp    [esp+0E0h+var_E4+4] }
  UF_VEC3_is_zero(&v143, v14, HIDWORD(v14), v13);
  if ( a3 )
    return 4;
  __asm { fld     dbl_1000C000 }
  v18 = v150;
  v19 = &v146;
  __asm { fstp    [esp+0E4h+var_E4] }
  UF_VEC3_unitize(&v143, v20, HIDWORD(v20), v19, v18);
  __asm { fld     qword ptr [ebp+var_68] }
  v17 = dword_1000C3D8;
  __asm
  {
    fst     [ebp+var_70]
    fld     [ebp+var_60]
  }
  v16 = *(_DWORD *)dword_1000C3D8;
  __asm
  {
    fst     [ebp+var_90]
    fld     [ebp+var_58]
    fst     [ebp+var_98]
  }
  if ( v16 != 3 )
  {
    __asm
    {
      fld     dbl_1000C298
      fmul    st, st(1)
      fld     dbl_1000C278
      fmul    st, st(3)
      faddp   st(1), st
      fld     dbl_1000C258
      fmul    st, st(4)
      faddp   st(1), st
      fld     dbl_1000C2A0
      fmul    st, st(2)
      fld     dbl_1000C280
      fmul    st, st(4)
      faddp   st(1), st
      fld     dbl_1000C260
      fmul    st, st(5)
      faddp   st(1), st
      fmul    dbl_1000C560
      fsubp   st(1), st
      fld     dbl_1000C4D8
      fmul    st(1), st
      fxch    st(1)
      fstp    [ebp+var_2C]
      fld     dbl_1000C288
      fmul    st, st(2)
      fld     dbl_1000C268
      fmul    st, st(4)
      faddp   st(1), st
      fld     dbl_1000C248
      fmul    st, st(5)
      faddp   st(1), st
      fld     dbl_1000C290
      fmulp   st(3), st
      fld     dbl_1000C270
      fmulp   st(4), st
      fxch    st(2)
      faddp   st(3), st
      fld     dbl_1000C250
      fmulp   st(4), st
      fxch    st(2)
      faddp   st(3), st
      fld     dbl_1000C310
      fld     st
      fabs
      fld     dbl_1000C000
      fcom    st(1)
      fnstsw  ax
      fstp    st(1)
    }
    if ( HIBYTE(_AX) & 1 )
    {
      if ( v16 == 1 )
      {
        __asm { fld     dbl_1000C308 }
      }
      else
      {
        if ( v16 == 2 )
          __asm { fld     dbl_1000C308 }
        else
          __asm { fld     [ebp+var_38] }
      }
      __asm
      {
        fsub    [ebp+var_2C]
        fdiv    st, st(2)
        fstp    [ebp+var_2C]
        fldz
      }
    }
    else
    {
      __asm { fldz }
      v163 = 1;
      __asm { fst     [ebp+var_2C] }
    }
    __asm
    {
      fld     st(5)
      fmul    st, st(6)
      fld     st(4)
      fmul    st, st(5)
      faddp   st(1), st
      fsqrt
      fld     st(4)
      fabs
      fcomp   st(3)
      fnstsw  ax
    }
    if ( __SETP__(HIBYTE(_AX) & 0x41, 0) )
      goto LABEL_115;
    __asm
    {
      fld     st(6)
      fabs
      fcomp   st(3)
      fnstsw  ax
    }
    if ( __SETP__(HIBYTE(_AX) & 0x41, 0) )
    {
LABEL_115:
      __asm
      {
        fxch    st(1)
        fxch    st(6)
        fxch    st(1)
        fxch    st(4)
        fpatan
        fstp    [ebp+var_50]
        fxch    st(2)
        fxch    st(4)
      }
    }
    else
    {
      __asm
      {
        fstp    st(6)
        fstp    st(3)
        fxch    st(2)
        fst     [ebp+var_50]
      }
    }
    __asm
    {
      fld     st(4)
      fabs
      fcomp   st(3)
      fnstsw  ax
    }
    if ( __SETP__(HIBYTE(_AX) & 0x41, 0) )
    {
      __asm
      {
        fld     [ebp+var_2C]
        fdivrp  st(5), st
        fxch    st(4)
      }
    }
    else
    {
      __asm
      {
        fstp    st(4)
        fld     st(3)
      }
    }
    __asm
    {
      fst     [ebp+var_2C]
      fld     st
      fabs
      fld     st(3)
      fld1
      fadd    st(1), st
      fxch    st(2)
      fcompp
      fnstsw  ax
    }
    if ( HIBYTE(_AX) & 0x41 )
    {
      __asm
      {
        fld     st(1)
        fmul    st, st(2)
        fsubr   st, st(1)
        fld     st
        fabs
        fcomp   st(5)
        fnstsw  ax
      }
      if ( !__SETP__(HIBYTE(_AX) & 0x41, 0) )
      {
        __asm
        {
          fstp    st
          fld     st(5)
        }
      }
      __asm
      {
        fld     st(2)
        fsubrp  st(2), st
        fxch    st(1)
        fabs
        fcomp   st(4)
        fnstsw  ax
      }
      if ( __SETP__(HIBYTE(_AX) & 0x41, 0) )
      {
        __asm { fsqrt }
      }
      else
      {
        __asm
        {
          fstp    st
          fld     st(4)
        }
      }
      __asm { fld     st }
      _ECX = 0;
      __asm
      {
        fld     st(2)
        fxch    st(1)
        fpatan
        fadd    [ebp+var_50]
        fstp    [ebp+var_14]
        fchs
        fpatan
        fadd    [ebp+var_50]
        fstp    [ebp+var_C]
        fld     dbl_1000C4D0
        fabs
        fstp    [ebp+var_2C]
      }
    }
    else
    {
      __asm { fstp    st(1) }
      v38 = printf;
      __asm
      {
        fstp    st(4)
        fstp    st
        fstp    st(1)
        fstp    st
        fstp    st
        fld     qword ptr [edi+28h]
        fstp    qword ptr [esp+104h+var_DC]
        fld     qword ptr [edi+20h]
        fstp    [esp+104h+var_E4]
        fld     qword ptr [edi+18h]
        fstp    [esp+104h+var_EC]
        fld     qword ptr [edi+10h]
        fstp    [esp+104h+var_F4]
        fld     qword ptr [edi+8]
        fstp    [esp+104h+var_FC]
        fld     qword ptr [edi]
        fstp    [esp+104h+var_104]
      }
      v38("INPUT Point =%-.4f,%-.4f,%-.4f,%-.8f,%-.8f,%-.8f\n", v44, v43, v42, v41, v40, v39);
      __asm
      {
        fld     [ebp+var_2C]
        fstp    qword ptr [esp+0DCh+var_DC]
      }
      printf("WARNING: Degenerated G_lambda(%f) out of range (-1, 1)\n", v45);
      __asm
      {
        fldz
        fst     [ebp+var_C]
        fst     [ebp+var_14]
      }
      v163 = 1;
      __asm { fld     dbl_1000C000 }
      _ECX = 0;
      __asm
      {
        fld     dbl_1000C4D8
        fld     dbl_1000C310
        fxch    st(1)
        fxch    st(2)
        fxch    st(1)
        fld     dbl_1000C4D0
        fabs
        fstp    [ebp+var_2C]
      }
    }
    while ( 1 )
    {
      __asm
      {
        fld     [ebp+ecx+var_14]
        fsin
        fld     [ebp+ecx+var_14]
        fcos
        fxch    st(3)
        fcom    [ebp+var_2C]
        fnstsw  ax
      }
      if ( HIBYTE(_AX) & 1 )
      {
        __asm
        {
          fstp    st(5)
          fstp    st(4)
          fld     st(3)
          fmul    st, st(3)
          fchs
          fld     st(2)
          fmulp   st(4), st
          fxch    st(1)
          fmul    dbl_1000C560
          fchs
          fstp    [ebp+var_50]
          fld     st(3)
          fmul    dbl_1000C290
          fld     st(2)
          fmul    dbl_1000C288
          faddp   st(1), st
          fld     dbl_1000C558
          fmul    dbl_1000C2A0
          fsubp   st(1), st
          fmul    [ebp+var_98]
          fld     st(4)
          fmul    dbl_1000C270
          fld     st(3)
          fmul    dbl_1000C268
          faddp   st(1), st
          fld     dbl_1000C558
          fmul    dbl_1000C280
          fsubp   st(1), st
          fmul    [ebp+var_90]
          faddp   st(1), st
          fxch    st(4)
          fmul    dbl_1000C250
          fxch    st(2)
          fmul    dbl_1000C248
          faddp   st(2), st
          fld     dbl_1000C558
          fmul    dbl_1000C260
          fsubp   st(2), st
          fxch    st(1)
          fmul    [ebp+var_70]
          faddp   st(3), st
          fxch    st(2)
          fdiv    dbl_1000C4D0
          fstp    [ebp+var_38]
          fld     dbl_1000C310
          fld     dbl_1000C298
          fmul    st, st(1)
          fld     st(2)
          fmul    dbl_1000C290
          faddp   st(1), st
          fld     st(3)
          fmul    dbl_1000C288
          faddp   st(1), st
          fld     [ebp+var_50]
          fld     dbl_1000C2A0
          fmul    st, st(1)
          faddp   st(2), st
          fxch    st(1)
          fmul    [ebp+var_98]
          fld     st(2)
          fmul    dbl_1000C278
          fld     st(4)
          fmul    dbl_1000C270
          faddp   st(1), st
          fld     st(5)
          fmul    dbl_1000C268
          faddp   st(1), st
          fld     st(2)
          fmul    dbl_1000C280
          faddp   st(1), st
          fmul    [ebp+var_90]
          faddp   st(1), st
          fld     st(2)
          fmul    dbl_1000C258
          fxch    st(4)
          fmul    dbl_1000C250
          faddp   st(4), st
          fxch    st(4)
          fmul    dbl_1000C248
          faddp   st(3), st
          fmul    dbl_1000C260
          faddp   st(2), st
          fxch    st(1)
          fmul    [ebp+var_70]
          faddp   st(2), st
          fld     ds:dbl_100099C8
          fdiv    dbl_1000C4D0
          fmulp   st(2), st
          fldz
          fld     dbl_1000C000
          fld     dbl_1000C4D8
          fld     [ebp+var_38]
          fxch    st(3)
          fxch    st(5)
          fxch    st(1)
          fxch    st(4)
          fxch    st(2)
          fxch    st(3)
        }
      }
      else
      {
        __asm
        {
          fstp    st(3)
          fstp    st
          fld     st(3)
          fld     st(4)
        }
      }
      __asm
      {
        fld     st
        fabs
        fcomp   st(4)
        fnstsw  ax
      }
      if ( __SETP__(HIBYTE(_AX) & 0x41, 0) )
        goto LABEL_117;
      __asm
      {
        fld     st(1)
        fabs
        fcomp   st(4)
        fnstsw  ax
      }
      if ( __SETP__(HIBYTE(_AX) & 0x41, 0) )
      {
LABEL_117:
        __asm
        {
          fxch    st(1)
          fpatan
          fstp    [ebp+ecx+var_24]
          fxch    st(3)
        }
      }
      else
      {
        __asm { fstp    st(1) }
        v163 = 1;
        __asm
        {
          fstp    st
          fxch    st(3)
          fst     [ebp+ecx+var_24]
        }
      }
      _ECX += 8;
      if ( _ECX >= 16 )
        break;
      __asm { fxch    st(3) }
    }
    v17 = dword_1000C3D8;
    __asm { fstp    st }
    goto LABEL_63;
  }
  if ( dword_1000C3DC )
  {
    if ( dword_1000C3DC != 1 && dword_1000C3DC != 3 )
    {
      __asm
      {
        fstp    st
        fstp    st
        fstp    st
      }
      return 2;
    }
    __asm
    {
      fld     dbl_1000C300
      fld     st
      fld1
      fsub    st(1), st
      fxch    st(1)
      fabs
      fld     dbl_1000C000
      fcom    st(1)
      fnstsw  ax
      fstp    st(1)
    }
    if ( !(HIBYTE(_AX) & 1) )
      goto LABEL_116;
    __asm
    {
      fld     st(2)
      fmul    st, st(3)
      fsub    st(4), st
      fsubr   st, st(2)
      fdivp   st(4), st
      fld     st(3)
      fabs
      fld     st(1)
      fadd    st, st(3)
      fcompp
      fnstsw  ax
    }
    if ( __SETP__(HIBYTE(_AX) & 5, 0) )
    {
      __asm
      {
        fstp    st(4)
        fstp    st(4)
        fstp    st
        fstp    st(1)
        fstp    st(1)
        fstp    qword ptr [esp+0DCh+var_DC]
      }
      sub_10001F90(v29);
      __asm
      {
        fst     [ebp+var_14]
        fchs
      }
      _ECX = 0;
      __asm
      {
        fstp    [ebp+var_C]
        fld     [ebp+var_60]
        fld     qword ptr [ebp+var_68]
        fld     dbl_1000C000
        fld     dbl_1000C300
        fld1
        fxch    st(3)
        fxch    st(4)
        fxch    st(3)
        fld     dbl_1000C2F8
      }
    }
    else
    {
LABEL_116:
      __asm { fstp    st(3) }
      v163 = 1;
      __asm { fld     dbl_1000C460 }
      _ECX = 0;
      __asm
      {
        fstp    [ebp+var_14]
        fld     dbl_1000C468
        fstp    [ebp+var_C]
        fld     dbl_1000C2F8
      }
    }
    while ( 1 )
    {
      __asm
      {
        fld     [ebp+ecx+var_14]
        fsin
        fld     [ebp+ecx+var_14]
        fcos
        fsubp   st(3), st
        fxch    st(2)
        fmulp   st(3), st
        fld     st(2)
        fmul    dbl_1000C2F0
        fld     st(1)
        fmul    st, st(3)
        faddp   st(1), st
        fxch    st(3)
        fmul    st, st(1)
        fld     dbl_1000C2F0
        fmulp   st(3), st
        fsubrp  st(2), st
        fld     st(1)
        fmul    st, st(5)
        fld     st(3)
        fmul    st, st(7)
        faddp   st(1), st
        fxch    st(3)
        fmul    st, st(5)
        fxch    st(2)
        fmul    st, st(6)
        fsubp   st(2), st
        fld     st(1)
        fabs
        fcomp   st(4)
        fnstsw  ax
      }
      if ( __SETP__(HIBYTE(_AX) & 0x41, 0) )
        goto LABEL_119;
      __asm
      {
        fld     st(2)
        fabs
        fcomp   st(4)
        fnstsw  ax
      }
      if ( __SETP__(HIBYTE(_AX) & 0x41, 0) )
      {
LABEL_119:
        __asm
        {
          fxch    st(2)
          fpatan
        }
      }
      else
      {
        __asm { fstp    st(1) }
        v163 = 1;
        __asm
        {
          fstp    st(1)
          fld     dbl_1000C318[ecx]
        }
      }
      __asm { fstp    [ebp+ecx+var_24] }
      _ECX += 8;
      if ( _ECX >= 16 )
        break;
      __asm
      {
        fld1
        fld     dbl_1000C300
        fxch    st(2)
      }
    }
    __asm { fstp    st(2) }
LABEL_63:
    __asm
    {
      fstp    st(2)
      fstp    st
    }
    if ( !v163 )
      goto LABEL_67;
    goto LABEL_64;
  }
  __asm
  {
    fstp    st
    fstp    st(1)
    fchs
    fstp    [ebp+var_14]
    fld     [ebp+var_58]
    fmul    st, st
    fld     qword ptr [ebp+var_68]
    fmul    st, st
    faddp   st(1), st
    fsqrt
    fst     [ebp+var_70]
    fstp    qword ptr [esp+0DCh+var_DC]
  }
  sub_10001F90(v21);
  __asm
  {
    fst     [ebp+var_C]
    fsubr   [ebp+var_14]
    fabs
    fld     dbl_1000C000
    fcom    st(1)
    fnstsw  ax
    fstp    st(1)
  }
  if ( !(HIBYTE(_AX) & 1) )
  {
    __asm
    {
      fstp    st
      fld     [ebp+var_70]
      fchs
      fstp    qword ptr [esp+0DCh+var_DC]
    }
    sub_10001F90(v23);
    __asm
    {
      fstp    [ebp+var_C]
      fld     dbl_1000C000
    }
  }
  __asm
  {
    fld     qword ptr [ebp+var_68]
    fld     st
    fabs
    fcomp   st(2)
    fnstsw  ax
    fld     [ebp+var_58]
  }
  if ( __SETP__(HIBYTE(_AX) & 0x41, 0) )
    goto LABEL_118;
  __asm
  {
    fld     st
    fabs
    fcomp   st(3)
    fnstsw  ax
  }
  if ( __SETP__(HIBYTE(_AX) & 0x41, 0) )
  {
LABEL_118:
    __asm
    {
      fld     st
      fld     st(2)
      fxch    st(1)
      fpatan
      fstp    [ebp+var_24]
      fxch    st(1)
      fchs
      fxch    st(1)
      fchs
      fpatan
      fstp    [ebp+var_1C]
    }
    goto LABEL_67;
  }
  __asm { fstp    st }
  v163 = 1;
  __asm
  {
    fstp    st
    fld     dbl_1000C318
    fstp    [ebp+var_24]
    fld     dbl_1000C320
    fstp    [ebp+var_1C]
  }
LABEL_64:
  if ( *(_DWORD *)v17 != 3 )
  {
    __asm
    {
      fld     dbl_1000C460
      fstp    [ebp+var_14]
      fld     dbl_1000C468
      fstp    [ebp+var_C]
      fld     dbl_1000C318
      fstp    [ebp+var_24]
      fld     dbl_1000C320
      fstp    [ebp+var_1C]
    }
  }
  v157 = 1;
LABEL_67:
  if ( byte_1000C009 && (*(_DWORD *)v17 == 2 || *(_DWORD *)v17 == 3) )
  {
    __asm { fstp    st }
    sub_10002430((int)&v159, (int)&v161);
    __asm { fld     [ebp+var_14] }
    result = v157;
    __asm
    {
      fstp    dbl_1000C530
      fld     [ebp+var_C]
      fstp    dbl_1000C538
      fld     [ebp+var_24]
      fstp    dbl_1000C2E0
      fld     [ebp+var_1C]
      fstp    dbl_1000C2E8
    }
    return result;
  }
  v51 = *(_DWORD *)v17;
  if ( *(_DWORD *)v17 == 1 )
  {
    _EDI = a2;
    v53 = v137;
    v54 = v138;
    v55 = v139;
    v56 = v140;
    *(_DWORD *)a2 = v137;
    *(_DWORD *)(a2 + 4) = v54;
    *(_DWORD *)(a2 + 8) = v55;
    *(_DWORD *)(a2 + 12) = v56;
    *(_DWORD *)(a2 + 16) = v141;
    v57 = v142;
    *(_DWORD *)(a2 + 20) = v142;
    *(_DWORD *)_EBX = v53;
    v58 = v141;
    *(_DWORD *)(_EBX + 4) = v54;
    *(_DWORD *)(_EBX + 8) = v55;
    *(_DWORD *)(_EBX + 12) = v140;
    *(_DWORD *)(_EBX + 16) = v58;
    *(_DWORD *)(_EBX + 20) = v57;
    goto LABEL_87;
  }
  if ( v51 != 2 && v51 != 3 )
  {
    _EDI = a2;
  }
  else
  {
    __asm { fstp    st }
    if ( byte_1000C588 )
    {
      ((void (__cdecl *)(_DWORD))printf)("About adjusting theta with initial angle...\n");
      __asm
      {
        fld     dbl_1000C2E0
        fld     ds:dbl_10009308
        fmul    st(1), st
        fld     [ebp+var_24]
        fsub    st(2), st
        fld     ds:dbl_100099D8
        fmul    st(3), st
        fxch    st(3)
        fstp    qword ptr [esp+0F4h+var_DC]
        fld     dbl_1000C530
        fmulp   st(2), st
        fld     [ebp+var_14]
        fsub    st(2), st
        fxch    st(2)
        fmul    st, st(3)
        fstp    [esp+0F4h+var_E4]
        fmul    st, st(2)
        fstp    [esp+0F4h+var_EC]
        fmulp   st(1), st
        fstp    [esp+0F4h+var_F4]
      }
      printf("computing t1[0]=%f, t2[0]=%f, (Init_T1[0]*2-t1[0])=%f,(Init_T2[0]*2-t2[0])=%f\n", v62, v61, v60, v59);
      __asm
      {
        fld     dbl_1000C2E8
        fld     ds:dbl_10009308
        fmul    st(1), st
        fld     [ebp+var_1C]
        fsub    st(2), st
        fld     ds:dbl_100099D8
        fmul    st(3), st
        fxch    st(3)
        fstp    qword ptr [esp+0F4h+var_DC]
        fld     dbl_1000C538
        fmulp   st(2), st
        fld     [ebp+var_C]
        fsub    st(2), st
        fxch    st(2)
        fmul    st, st(3)
        fstp    [esp+0F4h+var_E4]
        fmul    st, st(2)
        fstp    [esp+0F4h+var_EC]
        fmulp   st(1), st
        fstp    [esp+0F4h+var_F4]
      }
      printf("computing t1[1]=%f, t2[1]=%f, (Init_T1[1]*2-t1[1])=%f,(Init_T2[1]*2-t2[1])=%f\n", v66, v65, v64, v63);
    }
    sub_10002430((int)&v159, (int)&v161);
    if ( *(_DWORD *)dword_1000C3D8 == 2 )
    {
      __asm
      {
        fld     [ebp+var_14]
        fstp    [ebp+var_78]
        fld     [ebp+var_C]
        fstp    [ebp+var_70]
        fld     [ebp+var_24]
        fstp    [ebp+var_40]
        fld     [ebp+var_1C]
        fstp    [ebp+var_38]
      }
      sub_10002EE0((int)v150, (int)&v148);
      __asm { fld     [ebp+var_78] }
      _EDI = a2;
      __asm
      {
        fst     [ebp+var_14]
        fld     [ebp+var_70]
      }
      v67 = 1;
      __asm
      {
        fstp    [ebp+var_C]
        fld     [ebp+var_40]
      }
      v68 = a2;
      __asm { fst     [ebp+var_24] }
      v69 = (int)&v137;
      __asm
      {
        fld     [ebp+var_38]
        fstp    [ebp+var_1C]
        fstp    [esp+0E8h+var_E4+4]
        fstp    [esp+0E8h+var_EC+4]
      }
      sub_10002190(v69, v68, v71, v70, v67);
      __asm { fld     [ebp+var_38] }
      v72 = 1;
      __asm { fstp    [esp+0E8h+var_E4+4] }
      v74 = _EBX;
      __asm { fld     [ebp+var_70] }
      v75 = (int)&v137;
      __asm { fstp    [esp+0E8h+var_EC+4] }
      sub_10002190(v75, v74, v76, v73, v72);
LABEL_79:
      __asm { fld     dbl_1000C000 }
      goto LABEL_87;
    }
    _EDI = a2;
    __asm { fld     [ebp+var_24] }
    v77 = a2;
    __asm
    {
      fchs
      fstp    [esp+0E0h+var_E4+4]
    }
    sub_10002390((int)&v137, v78, v77);
    __asm
    {
      fld     [ebp+var_1C]
      fchs
    }
    v79 = _EBX;
    __asm { fstp    [esp+0E0h+var_E4+4] }
    sub_10002390((int)&v137, v80, v79);
    if ( dword_1000C3DC != 3 )
      goto LABEL_79;
    v81 = 0;
    do
    {
      v82 = a2;
      if ( v81 )
        v82 = _EBX;
      UF_MTX3_vec_multiply_t(v82, &unk_10009928, v82);
      ++v81;
    }
    while ( v81 < 2 );
    __asm { fld     dbl_1000C000 }
  }
LABEL_87:
  _ECX = dword_1000C3D8;
  v83 = *(_DWORD *)dword_1000C3D8;
  if ( *(_DWORD *)dword_1000C3D8 == 1 )
  {
    v85 = UF_VEC3_affine_comb;
    __asm
    {
      fstp    st
      fld     qword ptr [ecx+90h]
    }
    v86 = _EDI;
    __asm { fadd    qword ptr [ecx+88h] }
    v87 = v150;
    __asm
    {
      fst     [ebp+var_38]
      fstp    [esp+0E4h+var_E4]
    }
    v85(_EDI, v88, HIDWORD(v88), v87, v86);
    __asm { fld     [ebp+var_38] }
    v89 = _EBX;
    v90 = v150;
    __asm { fstp    [esp+0E4h+var_E4] }
    UF_VEC3_affine_comb(_EBX, v91, HIDWORD(v91), v90, v89);
    __asm { fld     [ebp+var_14] }
    v92 = _EDI;
    __asm { fstp    [esp+0E0h+var_E4+4] }
    sub_10002310(_EDI, v93, v92);
    __asm { fld     [ebp+var_C] }
    v94 = _EBX;
    __asm { fstp    [esp+0E0h+var_E4+4] }
    sub_10002310(_EBX, v95, v94);
  }
  else
  {
    if ( v83 == 3 )
    {
      __asm
      {
        fstp    st
        fld     [ebp+var_24]
      }
      v97 = (int)&v154;
      __asm
      {
        fchs
        fstp    [esp+0E0h+var_E4+4]
      }
      sub_10002390((int)v150, v98, v97);
      __asm { fld     dbl_1000C000 }
      v99 = &v154;
      v100 = &v146;
      __asm { fstp    [esp+0E4h+var_E4] }
      UF_VEC3_unitize(&v154, v101, HIDWORD(v101), v100, v99);
      _EDX = dword_1000C3D8;
      __asm { fld     qword ptr [edx+88h] }
      v96 = UF_VEC3_affine_comb;
      v103 = _EDI;
      v104 = &v154;
      __asm { fstp    [esp+0E4h+var_E4] }
      v96(_EDI, v105, HIDWORD(v105), v104, v103);
      _ECX = dword_1000C3D8;
      __asm { fld     qword ptr [ecx+88h] }
      v136 = _EBX;
      v135[0] = &v154;
    }
    else
    {
      if ( v83 != 2 )
        goto LABEL_95;
      __asm { fstp    st }
      v107 = 0;
      __asm
      {
        fld     [ebp+var_24]
        fstp    [esp+0E8h+var_E4+4]
      }
      v109 = (int)&v154;
      __asm { fld     [ebp+var_14] }
      v110 = (int)v150;
      __asm { fstp    [esp+0E8h+var_EC+4] }
      sub_10002190(v110, v109, v111, v108, v107);
      __asm { fld     [ebp+var_1C] }
      v112 = 0;
      __asm { fstp    [esp+0E8h+var_E4+4] }
      v114 = (int)&v147;
      __asm { fld     [ebp+var_C] }
      v115 = (int)v150;
      __asm { fstp    [esp+0E8h+var_EC+4] }
      sub_10002190(v115, v114, v116, v113, v112);
      __asm { fld     dbl_1000C000 }
      v117 = UF_VEC3_unitize;
      v118 = &v154;
      v119 = &v146;
      __asm { fstp    [esp+0E4h+var_E4] }
      v117(&v154, v120, HIDWORD(v120), v119, v118);
      __asm { fld     dbl_1000C000 }
      v121 = &v147;
      v122 = &v146;
      __asm { fstp    [esp+0E4h+var_E4] }
      UF_VEC3_unitize(&v147, v123, HIDWORD(v123), v122, v121);
      _EAX = dword_1000C3D8;
      __asm { fld     qword ptr [eax+88h] }
      v96 = UF_VEC3_affine_comb;
      v125 = _EDI;
      v126 = &v154;
      __asm { fstp    [esp+0E4h+var_E4] }
      v96(_EDI, v127, HIDWORD(v127), v126, v125);
      _EDX = dword_1000C3D8;
      __asm { fld     qword ptr [edx+88h] }
      v136 = _EBX;
      v135[0] = (int *)&v147;
    }
    __asm { fstp    [esp+0E4h+var_E4] }
    v96(_EBX, v129, HIDWORD(v129), v135[0], v136);
  }
  __asm { fld     dbl_1000C000 }
LABEL_95:
  v130 = byte_1000C008 == 0;
  __asm
  {
    fld     [ebp+var_14]
    fld     st
    fld     ds:dbl_100099D8
    fmul    st(1), st
    fxch    st(1)
    fstp    qword ptr [edi+18h]
    fld     [ebp+var_C]
    fld     st
    fmul    st, st(2)
    fstp    qword ptr [ebx+18h]
    fld     [ebp+var_24]
    fld     st
    fmul    st, st(3)
    fstp    qword ptr [edi+20h]
    fld     [ebp+var_1C]
    fmulp   st(3), st
    fxch    st(2)
    fstp    qword ptr [ebx+20h]
  }
  if ( !v130 )
  {
    if ( *(_DWORD *)dword_1000C3D8 != 3 )
    {
      __asm
      {
        fld     qword ptr [edi+20h]
        fld     ds:dbl_10009A30
        fsub    st(1), st
        fxch    st(1)
        fst     qword ptr [edi+20h]
        fld     ds:dbl_10009A28
        fcom    st(1)
        fnstsw  ax
        fld     ds:dbl_100099E8
      }
      if ( HIBYTE(_AX) & 0x41 )
      {
        __asm { fstp    st(2) }
      }
      else
      {
        __asm
        {
          fadd    st(2), st
          fxch    st(2)
          fstp    qword ptr [edi+20h]
        }
      }
      __asm
      {
        fld     qword ptr [ebx+20h]
        fsubrp  st(3), st
        fxch    st(2)
        fst     qword ptr [ebx+20h]
        fcom    st(2)
        fnstsw  ax
        fstp    st(2)
      }
      if ( __SETP__(HIBYTE(_AX) & 5, 0) )
      {
        __asm
        {
          fstp    st(1)
          fstp    st
        }
      }
      else
      {
        __asm
        {
          faddp   st(1), st
          fstp    qword ptr [ebx+20h]
        }
      }
    }
  }
  if ( v163 )
  {
    if ( *(_DWORD *)dword_1000C3D8 != 3 )
    {
      *(_DWORD *)(_EDI + 24) = dword_1000C4F8;
      *(_DWORD *)(_EDI + 28) = dword_1000C4FC;
      *(_DWORD *)(_EDI + 32) = dword_1000C500;
      *(_DWORD *)(_EDI + 36) = dword_1000C504;
      *(_DWORD *)(_EBX + 24) = dword_1000C520;
      *(_DWORD *)(_EBX + 28) = dword_1000C524;
      *(_DWORD *)(_EBX + 32) = dword_1000C528;
      *(_DWORD *)(_EBX + 36) = dword_1000C52C;
    }
  }
  if ( byte_1000C588 )
  {
    __asm
    {
      fsubp   st(2), st
      fxch    st(1)
      fabs
      fcomp   st(2)
      fnstsw  ax
    }
    if ( !__SETP__(HIBYTE(_AX) & 0x41, 0) )
    {
      __asm
      {
        fsub    [ebp+var_1C]
        fabs
        fcompp
        fnstsw  ax
      }
      if ( !__SETP__(HIBYTE(_AX) & 0x41, 0) )
        printf("WARNING: same value of rotary produced:\n");
      goto LABEL_112;
    }
  }
  else
  {
    __asm
    {
      fstp    st
      fstp    st(1)
    }
  }
  __asm
  {
    fstp    st(1)
    fstp    st
  }
LABEL_112:
  __asm { fld     [ebp+var_14] }
  result = v157;
  memcpy(&dword_1000C4E0, (const void *)a2, 0x28u);
  memcpy(&dword_1000C508, (const void *)_EBX, 0x28u);
  __asm
  {
    fstp    dbl_1000C460
    fld     [ebp+var_C]
    fstp    dbl_1000C468
    fld     [ebp+var_24]
    fstp    dbl_1000C318
    fld     [ebp+var_1C]
    fstp    dbl_1000C320
  }
  return result;
}
// 10003110: inconsistent fpu stack
// 100090D4: using guessed type int __cdecl UF_MTX3_vec_multiply_t(_DWORD, _DWORD, _DWORD);
// 100090D8: using guessed type int __cdecl UF_VEC3_is_zero(_DWORD, _DWORD, _DWORD, _DWORD);
// 100090DC: using guessed type int __cdecl UF_VEC3_affine_comb(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10009128: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1000C008: using guessed type char byte_1000C008;
// 1000C009: using guessed type char byte_1000C009;
// 1000C3D8: using guessed type int dword_1000C3D8;
// 1000C3DC: using guessed type int dword_1000C3DC;
// 1000C4E0: using guessed type int dword_1000C4E0;
// 1000C4F8: using guessed type int dword_1000C4F8;
// 1000C4FC: using guessed type int dword_1000C4FC;
// 1000C500: using guessed type int dword_1000C500;
// 1000C504: using guessed type int dword_1000C504;
// 1000C508: using guessed type int dword_1000C508;
// 1000C520: using guessed type int dword_1000C520;
// 1000C524: using guessed type int dword_1000C524;
// 1000C528: using guessed type int dword_1000C528;
// 1000C52C: using guessed type int dword_1000C52C;
// 1000C588: using guessed type char byte_1000C588;

//----- (10003E70) --------------------------------------------------------
int __cdecl sub_10003E70(int a1, int a2, int a3, int a4, int a5, int a6)
{
  double v6; // st6@1
  int result; // eax@3
  double v8; // st5@8
  double v9; // st2@9
  double v10; // st3@9
  double v11; // st4@9
  double v12; // st5@9
  double v13; // st7@9
  double v14; // st4@12
  double v15; // st5@12
  char v16; // [sp+Ch] [bp-70h]@1
  double v17; // [sp+24h] [bp-58h]@1
  double v18; // [sp+2Ch] [bp-50h]@12
  double v19; // [sp+34h] [bp-48h]@12
  double v20; // [sp+3Ch] [bp-40h]@1
  double v21; // [sp+44h] [bp-38h]@12
  double v22; // [sp+4Ch] [bp-30h]@12
  double v23; // [sp+54h] [bp-28h]@1
  double v24; // [sp+5Ch] [bp-20h]@1
  double v25; // [sp+64h] [bp-18h]@1
  double v26; // [sp+6Ch] [bp-10h]@1
  double v27; // [sp+74h] [bp-8h]@1

  UF_VEC3_sub(a1 + 24, a1, &v20);
  UF_VEC3_sub(a1, a2, &v16);
  UF_VEC3_sub(a2 + 24, a2, &v17);
  UF_VEC3_dot(&v20, &v16, &v24);
  UF_VEC3_dot(&v17, &v20, &v25);
  UF_VEC3_dot(&v17, &v16, &v23);
  UF_VEC3_dot(&v17, &v17, &v26);
  UF_VEC3_dot(&v20, &v20, &v27);
  v6 = v26;
  if ( v26 == 0.0 )
  {
    UF_VEC3_copy(a2, a4);
    *(double *)a6 = 0.0;
    if ( 0.0 == v27 )
    {
      UF_VEC3_copy(a1, a3);
      *(double *)a5 = 0.0;
      return 0;
    }
    result = sub_10002770(a4, a1, a3, a5);
    if ( result )
      return result;
    return 0;
  }
  if ( v27 == 0.0 )
  {
    UF_VEC3_copy(a1, a3);
    *(double *)a5 = 0.0;
    return 0;
  }
  v8 = v25 * v25;
  if ( 0.0 != v8 - v27 * v26 )
  {
    v9 = v8;
    v12 = v8 - v27 * v26;
    v10 = v9 / (v27 * v26);
    v11 = v10;
    v13 = v25;
    if ( v10 < 0.0 )
      v11 = -v10;
    if ( 1.0 - (dbl_1000C000 + dbl_1000C000) > v11 )
    {
      v14 = (v26 * v24 - v23 * v25) / v12;
      v15 = v23;
      *(_QWORD *)a5 = *(_QWORD *)&v14;
      *(double *)a6 = (v13 * v14 + v15) / v6;
      *(double *)a3 = *(double *)a5 * v20 + *(double *)a1;
      *(double *)a4 = *(double *)a6 * v17 + *(double *)a2;
      *(double *)(a3 + 8) = *(double *)a5 * v21 + *(double *)(a1 + 8);
      *(double *)(a4 + 8) = *(double *)a6 * v18 + *(double *)(a2 + 8);
      result = 0;
      *(double *)(a3 + 16) = *(double *)a5 * v22 + *(double *)(a1 + 16);
      *(double *)(a4 + 16) = *(double *)a6 * v19 + *(double *)(a2 + 16);
      return result;
    }
  }
  UF_VEC3_copy(a1, a3);
  *(double *)a5 = 0.0;
  result = sub_10002770(a3, a2, a4, a6);
  if ( !result )
    return 0;
  return result;
}
// 100090EC: using guessed type int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD);
// 100090F0: using guessed type int __cdecl UF_VEC3_dot(_DWORD, _DWORD, _DWORD);
// 100090F4: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);
// 1000C000: using guessed type double dbl_1000C000;

//----- (10004090) --------------------------------------------------------
signed int __cdecl sub_10004090(int a1, const void *a2, int a3, int a4, int a5, int a6, int a7, int a8, const void *a9)
{
  int v9; // eax@1
  int v10; // ebx@1
  int v11; // edx@1
  signed int result; // eax@4
  double v13; // ST5C_8@6
  int v14; // esi@13
  char v15; // zf@15
  double v16; // st7@24
  int v17; // edi@25
  double v18; // ST5C_8@31
  double v19; // st7@33
  double v20; // ST5C_8@35
  double v21; // ST5C_8@39
  double v22; // st7@41
  double v23; // st3@41
  double v24; // st4@41
  double v25; // st6@41
  double v26; // st2@41
  double v27; // st5@41
  double v28; // st6@41
  double v29; // st7@41
  double v30; // st5@41
  double v31; // st7@45
  double v32; // st7@50
  double v33; // st7@53
  double v34; // st4@53
  double v35; // st5@53
  double v36; // st6@53
  double v37; // st2@53
  double v38; // st5@53
  double v39; // st6@53
  double v40; // st7@53
  double v41; // st5@53
  double v42; // st7@56
  int v43; // esi@59
  double v44; // st7@61
  int v45; // eax@64
  int v46; // edx@64
  int v47; // ecx@64
  int v48; // eax@64
  int v49; // edx@64
  double v50; // ST5C_8@64
  double v51; // ST5C_8@64
  int v52; // ecx@67
  int v53; // edx@67
  int v54; // ecx@67
  int v55; // edx@67
  int v56; // eax@67
  int v57; // edx@67
  int v58; // ecx@67
  int v59; // edx@67
  int v60; // ecx@67
  int v61; // edx@67
  const char *v62; // [sp+5Ch] [bp-21Ch]@9
  char v63; // [sp+6Ch] [bp-20Ch]@67
  char v64; // [sp+7Ch] [bp-1FCh]@16
  char v65; // [sp+94h] [bp-1E4h]@67
  char v66; // [sp+A4h] [bp-1D4h]@16
  int v67; // [sp+BCh] [bp-1BCh]@64
  int v68; // [sp+C0h] [bp-1B8h]@64
  int v69; // [sp+C4h] [bp-1B4h]@64
  int v70; // [sp+C8h] [bp-1B0h]@64
  int v71; // [sp+CCh] [bp-1ACh]@64
  int v72; // [sp+D0h] [bp-1A8h]@64
  char v73; // [sp+D4h] [bp-1A4h]@64
  char v74; // [sp+ECh] [bp-18Ch]@64
  double v75; // [sp+104h] [bp-174h]@64
  double v76; // [sp+10Ch] [bp-16Ch]@64
  double v77; // [sp+114h] [bp-164h]@64
  char v78; // [sp+11Ch] [bp-15Ch]@41
  double v79; // [sp+134h] [bp-144h]@41
  double v80; // [sp+13Ch] [bp-13Ch]@41
  double v81; // [sp+144h] [bp-134h]@41
  double v82; // [sp+14Ch] [bp-12Ch]@41
  double v83; // [sp+154h] [bp-124h]@41
  double v84; // [sp+15Ch] [bp-11Ch]@41
  double v85; // [sp+164h] [bp-114h]@41
  double v86; // [sp+16Ch] [bp-10Ch]@41
  double v87; // [sp+174h] [bp-104h]@41
  double v88; // [sp+17Ch] [bp-FCh]@41
  double v89; // [sp+184h] [bp-F4h]@41
  double v90; // [sp+18Ch] [bp-ECh]@41
  char v91; // [sp+194h] [bp-E4h]@6
  int v92; // [sp+1ACh] [bp-CCh]@67
  int v93; // [sp+1B0h] [bp-C8h]@67
  int v94; // [sp+1B4h] [bp-C4h]@67
  int v95; // [sp+1B8h] [bp-C0h]@67
  int v96; // [sp+1BCh] [bp-BCh]@67
  int v97; // [sp+1C0h] [bp-B8h]@67
  int v98; // [sp+1C4h] [bp-B4h]@16
  int v99; // [sp+1C8h] [bp-B0h]@67
  int v100; // [sp+1CCh] [bp-ACh]@67
  int v101; // [sp+1D0h] [bp-A8h]@67
  int v102; // [sp+1D4h] [bp-A4h]@67
  int v103; // [sp+1D8h] [bp-A0h]@67
  char v104; // [sp+1DCh] [bp-9Ch]@7
  char v105; // [sp+1F4h] [bp-84h]@41
  double v106; // [sp+20Ch] [bp-6Ch]@1
  double v107; // [sp+214h] [bp-64h]@53
  double v108; // [sp+21Ch] [bp-5Ch]@53
  double v109; // [sp+224h] [bp-54h]@1
  double v110; // [sp+22Ch] [bp-4Ch]@41
  double v111; // [sp+234h] [bp-44h]@41
  double v112; // [sp+23Ch] [bp-3Ch]@17
  double v113; // [sp+244h] [bp-34h]@1
  double v114; // [sp+24Ch] [bp-2Ch]@41
  double v115; // [sp+254h] [bp-24h]@41
  double v116; // [sp+25Ch] [bp-1Ch]@41
  char v117; // [sp+264h] [bp-14h]@41
  int v118; // [sp+268h] [bp-10h]@1
  long double v119; // [sp+26Ch] [bp-Ch]@1
  int v120; // [sp+274h] [bp-4h]@5

  v10 = a3;
  dword_1000C540 = *(_DWORD *)a3;
  dword_1000C544 = *(_DWORD *)(a3 + 4);
  dword_1000C548 = *(_DWORD *)(a3 + 8);
  dword_1000C54C = *(_DWORD *)(a3 + 12);
  dword_1000C550 = *(_DWORD *)(a3 + 16);
  dword_1000C554 = *(_DWORD *)(a3 + 20);
  dword_1000C2C8 = *(_DWORD *)a5;
  dword_1000C2CC = *(_DWORD *)(a5 + 4);
  dword_1000C2D0 = *(_DWORD *)(a5 + 8);
  dword_1000C2D4 = *(_DWORD *)(a5 + 12);
  dword_1000C2D8 = *(_DWORD *)(a5 + 16);
  v11 = *(_DWORD *)(a5 + 20);
  v118 = 0;
  dword_1000C2DC = v11;
  UF_VEC3_copy(a4, &v109);
  UF_VEC3_copy(a6, &v113);
  UF_VEC3_copy(a8, &v106);
  dbl_1000C558 = 0.0;
  dbl_1000C560 = 0.0;
  dbl_1000C568 = 0.0;
  dbl_1000C570 = 0.0;
  memcpy(&unk_1000C340, a9, 0x98u);
  dbl_1000C578 = 0.0;
  dbl_1000C580 = 0.0;
  dbl_1000C000 = dbl_1000C348;
  memcpy(&dbl_1000C470, a2, 0x60u);
  dbl_1000C538 = 0.0;
  dbl_1000C530 = dbl_1000C538;
  dbl_1000C2E8 = dbl_1000C538;
  dbl_1000C2E0 = dbl_1000C538;
  dbl_1000C468 = dbl_1000C538;
  dbl_1000C460 = dbl_1000C538;
  dbl_1000C320 = dbl_1000C538;
  dbl_1000C318 = dbl_1000C538;
  byte_1000C588 = 0;
  dword_1000C3D8 = (int)&unk_1000C340;
  UF_VEC3_unitize(a4, LODWORD(dbl_1000C348), HIDWORD(dbl_1000C348), &v119, &dbl_1000C2F0);
  UF_VEC3_unitize(a6, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), &v119, &dbl_1000C328);
  dword_1000C4E0 = 0;
  dword_1000C4E4 = 0;
  dword_1000C4E8 = 0;
  dword_1000C4EC = 0;
  dword_1000C4F0 = 0;
  dword_1000C4F4 = 0;
  dword_1000C4F8 = 0;
  dword_1000C4FC = 0;
  dword_1000C500 = 0;
  dword_1000C504 = 0;
  dword_1000C508 = 0;
  dword_1000C50C = 0;
  dword_1000C510 = 0;
  dword_1000C514 = 0;
  dword_1000C518 = 0;
  dword_1000C51C = 0;
  dword_1000C520 = 0;
  dword_1000C524 = 0;
  dword_1000C528 = 0;
  dword_1000C52C = 0;
  v9 = *(_DWORD *)dword_1000C3D8;
  byte_1000C009 = 1;
  byte_1000C00A = 1;
  if ( v9 != 1 && v9 != 2 && v9 != 3 )
    return 2;
  UF_VEC3_is_parallel(&v109, &v113, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), &v120);
  BYTE3(a2) = v120 != 0;
  UF_VEC3_is_parallel(&v109, &v106, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), &v120);
  BYTE3(a9) = v120 != 0;
  UF_VEC3_is_parallel(&v113, &v106, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), &v120);
  BYTE3(a3) = v120 != 0;
  if ( !BYTE3(a9) )
  {
    v13 = v119;
    sub_10001F60((int)&v106, (int)&v109, (int)&v91, SLOBYTE(v13));
  }
  UF_VEC3_cross(&v109, &v113);
  UF_VEC3_is_parallel(&v104, &v106, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), &v120);
  byte_1000C008 = v120 != 0;
  if ( byte_1000C588 )
  {
    printf("\n\n======================================================================\n");
    printf("Is_orthogonal_case = %d, ", (unsigned __int8)byte_1000C008);
    if ( *(_DWORD *)dword_1000C3D8 == 2 )
    {
      v62 = "is_5_axis_dual_table\n";
    }
    else
    {
      if ( *(_DWORD *)dword_1000C3D8 == 1 )
        v62 = "is_5_axis_dual_head\n";
      else
        v62 = "is_5_axis_head_table\n";
    }
    printf(v62);
    printf("primary=(%f,%f,%f)\n", *(double *)a4, *(double *)(a4 + 8), *(double *)(a4 + 16));
    printf("primary_machine_center=(%f,%f,%f)\n", *(double *)v10, *(double *)(v10 + 8), *(double *)(v10 + 16));
    printf("secondary=(%f,%f,%f)\n", *(double *)a6, *(double *)(a6 + 8), *(double *)(a6 + 16));
    v14 = a5;
    printf("secondary_machine_center=(%f,%f,%f)\n", *(double *)a5, *(double *)(a5 + 8), *(double *)(a5 + 16));
    printf("tool_machine_center=(%f,%f,%f)\n", *(double *)a7, *(double *)(a7 + 8), *(double *)(a7 + 16));
    printf("tool_vector=(%f,%f,%f)\n", *(double *)a8, *(double *)(a8 + 8), *(double *)(a8 + 16));
    printf(
      "Mcsys= (%f,%f,%f) (%f,%f,%f) (%f,%f,%f)  (%f,%f,%f)\n",
      *(_QWORD *)&dbl_1000C470,
      *(_QWORD *)&dbl_1000C478,
      *(_QWORD *)&dbl_1000C480,
      *(_QWORD *)&dbl_1000C488,
      *(_QWORD *)&dbl_1000C490,
      *(_QWORD *)&dbl_1000C498,
      *(_QWORD *)&dbl_1000C4A0,
      *(_QWORD *)&dbl_1000C4A8,
      *(_QWORD *)&dbl_1000C4B0,
      *(_QWORD *)&dbl_1000C4B8,
      *(_QWORD *)&dbl_1000C4C0,
      *(_QWORD *)&dbl_1000C4C8);
  }
  else
  {
    v14 = a5;
  }
  v15 = *(_DWORD *)dword_1000C3D8 == 3;
  dword_1000C3DC = -1;
  if ( !v15 )
  {
LABEL_23:
    if ( BYTE3(a2) )
    {
      v16 = 0.0;
    }
    else
    {
      v18 = v119;
      sub_10001F60((int)&v113, (int)&v109, (int)&v91, SLOBYTE(v18));
      v16 = sub_100023D0((int)&v91, (int)&v113, (int)&v109);
      v14 = a5;
    }
    dbl_1000C578 = v16;
    if ( BYTE3(a3) )
    {
      printf("WARNING: Tool axis is parallelled with secondary axis that may cause unresolved rotaries");
      v19 = 0.0;
    }
    else
    {
      if ( fabs(v16) <= dbl_1000C000 )
      {
        v20 = v119;
        sub_10001F60((int)&v106, (int)&v113, (int)&v91, SLOBYTE(v20));
        if ( fabs(v119) <= dbl_1000C000 )
          return 3;
        v14 = a5;
      }
      if ( byte_1000C008 )
      {
        v21 = v119;
        sub_10001F60((int)&v106, (int)&v113, (int)&v66, SLOBYTE(v21));
        v19 = sub_100023D0((int)&v66, (int)&v106, (int)&v113);
        v14 = a5;
      }
      else
      {
        v19 = sub_100023D0((int)&v91, (int)&v106, (int)&v113);
      }
    }
    dbl_1000C580 = v19;
    v22 = *(double *)v10 - v109 * 1000000.0;
    v23 = *(double *)v14;
    v24 = *(double *)v14 - v113 * 1000000.0;
    v79 = *(double *)v10 + v109 * 1000000.0;
    v85 = v23 + v113 * 1000000.0;
    v82 = v22;
    v88 = v24;
    v25 = *(double *)(v10 + 8) - v110 * 1000000.0;
    v26 = *(double *)(v14 + 8);
    v27 = *(double *)(v14 + 8) + v114 * 1000000.0;
    v80 = *(double *)(v10 + 8) + v110 * 1000000.0;
    v86 = v27;
    v83 = v25;
    v89 = v26 - v114 * 1000000.0;
    v28 = *(double *)(v10 + 16) - v111 * 1000000.0;
    v29 = *(double *)(v14 + 16) - 1000000.0 * v115;
    v30 = *(double *)(v14 + 16) + 1000000.0 * v115;
    v81 = *(double *)(v10 + 16) + v111 * 1000000.0;
    v87 = v30;
    v84 = v28;
    v90 = v29;
    if ( sub_10003E70((int)&v79, (int)&v85, (int)&v78, (int)&v105, (int)&v116, (int)&v117) )
      return 5;
    UF_VEC3_distance(&v78, &v105, &dbl_1000C558);
    if ( dbl_1000C000 >= dbl_1000C558 )
    {
      v31 = 0.0;
    }
    else
    {
      UF_VEC3_sub(&v105, &v78, &v104);
      UF_VEC3_dot(&v104, &v91, &v112);
      if ( v112 >= 0.0 )
        goto LABEL_48;
      v31 = -dbl_1000C558;
    }
    dbl_1000C558 = v31;
LABEL_48:
    UF_VEC3_distance(&v105, v10, &dbl_1000C560);
    if ( dbl_1000C000 >= dbl_1000C560 )
    {
      v32 = 0.0;
    }
    else
    {
      UF_VEC3_sub(&v105, v10, &v104);
      UF_VEC3_dot(&v104, &v109, &v112);
      if ( v112 >= 0.0 )
        goto LABEL_53;
      v32 = -dbl_1000C560;
    }
    dbl_1000C560 = v32;
LABEL_53:
    v33 = *(double *)v14 - v113 * 1000000.0;
    v34 = *(double *)a7 - v106 * 1000000.0;
    v35 = *(double *)a7 + v106 * 1000000.0;
    v79 = *(double *)v14 + v113 * 1000000.0;
    v85 = v35;
    v82 = v33;
    v88 = v34;
    v36 = *(double *)(v14 + 8) - v114 * 1000000.0;
    v37 = *(double *)(a7 + 8);
    v38 = *(double *)(a7 + 8) + v107 * 1000000.0;
    v80 = *(double *)(v14 + 8) + v114 * 1000000.0;
    v86 = v38;
    v83 = v36;
    v89 = v37 - v107 * 1000000.0;
    v39 = *(double *)(v14 + 16) - v115 * 1000000.0;
    v40 = *(double *)(a7 + 16) - 1000000.0 * v108;
    v41 = *(double *)(a7 + 16) + 1000000.0 * v108;
    v81 = *(double *)(v14 + 16) + v115 * 1000000.0;
    v87 = v41;
    v84 = v39;
    v90 = v40;
    if ( sub_10003E70((int)&v79, (int)&v85, (int)&v78, (int)&v105, (int)&v116, (int)&v117) )
      return 5;
    UF_VEC3_distance(&v78, &v105, &dbl_1000C568);
    if ( dbl_1000C000 >= dbl_1000C568 )
    {
      v42 = 0.0;
    }
    else
    {
      UF_VEC3_sub(&v105, &v78, &v104);
      UF_VEC3_dot(&v104, &v91, &v116);
      if ( v116 >= 0.0 )
        goto LABEL_59;
      v42 = -dbl_1000C568;
    }
    dbl_1000C568 = v42;
LABEL_59:
    v43 = a7;
    UF_VEC3_distance(&v105, a7, &dbl_1000C570);
    if ( dbl_1000C000 >= dbl_1000C570 )
    {
      v44 = 0.0;
    }
    else
    {
      UF_VEC3_sub(&v105, v43, &v104);
      UF_VEC3_dot(&v104, &v113, &v116);
      if ( v116 >= 0.0 )
      {
LABEL_64:
        v45 = *(_DWORD *)(v10 + 8);
        v46 = *(_DWORD *)(v10 + 4);
        v67 = *(_DWORD *)v10;
        v47 = *(_DWORD *)(v10 + 12);
        v69 = v45;
        v48 = *(_DWORD *)(v10 + 20);
        v68 = v46;
        v49 = *(_DWORD *)(v10 + 16);
        v70 = v47;
        v72 = v48;
        v50 = v119;
        v71 = v49;
        sub_10001F60((int)&v113, (int)&v109, (int)&v73, SLOBYTE(v50));
        v75 = v109;
        v76 = v110;
        v77 = v111;
        v51 = v119;
        sub_10001F60((int)&v73, (int)&v109, (int)&v74, SLOBYTE(v51));
        sub_100020C0((int)&v67, a1, (int)&unk_1000C3E0);
        sub_10002DC0((int)&unk_1000C3E0, (int)&dbl_1000C248);
        dbl_1000C310 = sin(dbl_1000C578);
        dbl_1000C4D0 = sin(dbl_1000C580);
        dbl_1000C4D8 = cos(dbl_1000C578);
        dbl_1000C308 = cos(dbl_1000C580);
        if ( byte_1000C588 )
          printf(
            "A1=%f,D1=%f,Alpha1=%f,A2=%f,D2=%f,Alpha2=%f\n",
            *(_QWORD *)&dbl_1000C558,
            *(_QWORD *)&dbl_1000C560,
            dbl_1000C578 * 57.29577951308235,
            *(_QWORD *)&dbl_1000C568,
            *(_QWORD *)&dbl_1000C570,
            dbl_1000C580 * 57.29577951308235);
        if ( *(_DWORD *)dword_1000C3D8 == 2 )
        {
          v52 = *(_DWORD *)(a7 + 4);
          v92 = *(_DWORD *)a7;
          v53 = *(_DWORD *)(a7 + 8);
          v93 = v52;
          v54 = *(_DWORD *)(a7 + 12);
          v94 = v53;
          v55 = *(_DWORD *)(a7 + 16);
          v56 = *(_DWORD *)(a7 + 20);
          v95 = v54;
          v96 = v55;
          v97 = v56;
          v57 = *(_DWORD *)(a8 + 4);
          v98 = *(_DWORD *)a8;
          v58 = *(_DWORD *)(a8 + 8);
          v99 = v57;
          v59 = *(_DWORD *)(a8 + 12);
          v100 = v58;
          v60 = *(_DWORD *)(a8 + 16);
          v101 = v59;
          v61 = *(_DWORD *)(a8 + 20);
          v102 = v60;
          v103 = v61;
          sub_10003100(&v92, (int)&v63, (int)&v65);
          if ( byte_1000C588 )
          {
            printf(
              "Init_T1[0], Init_T2[0] = (%f,%f)\n",
              57.29577951308235 * dbl_1000C530,
              dbl_1000C2E0 * 57.29577951308235);
            printf(
              "Init_T1[1], Init_T2[1] = (%f,%f)\n",
              57.29577951308235 * dbl_1000C538,
              dbl_1000C2E8 * 57.29577951308235);
          }
        }
        result = 0;
        byte_1000C009 = 0;
        return result;
      }
      v44 = -dbl_1000C570;
    }
    dbl_1000C570 = v44;
    goto LABEL_64;
  }
  UF_MTX3_x_vec(&unk_100098E0, &v66);
  UF_MTX3_y_vec(&unk_100098E0, &v64);
  UF_MTX3_z_vec(&unk_100098E0, &v98);
  UF_VEC3_is_equal(a8, &v98, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), &a9);
  if ( !a9 )
  {
    UF_VEC3_is_equal(a8, &v64, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), &v118);
    UF_VEC3_is_equal(&v109, &v98, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), (char *)&v112 + 4);
    if ( byte_1000C008 || !BYTE3(a3) || !v118 || !HIDWORD(v112) )
      return 2;
    dword_1000C3DC = 3;
    UF_MTX3_vec_multiply_t(&dbl_1000C2F0, &unk_10009970, &dbl_1000C2F0);
    UF_MTX3_vec_multiply_t(&dbl_1000C328, &unk_10009970, &dbl_1000C328);
    if ( byte_1000C588 )
    {
      printf("Sulzer case:\n");
      printf(
        "local PrimaryAxis=(%f,%f,%f)\n",
        *(_QWORD *)&dbl_1000C2F0,
        *(_QWORD *)&dbl_1000C2F8,
        *(_QWORD *)&dbl_1000C300);
      printf(
        "local SecondaryAxis=(%f,%f,%f)\n",
        *(_QWORD *)&dbl_1000C328,
        *(_QWORD *)&dbl_1000C330,
        *(_QWORD *)&dbl_1000C338);
    }
    goto LABEL_23;
  }
  UF_VEC3_is_equal(a4, &v66, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), &a5);
  v17 = a6;
  UF_VEC3_is_equal(a6, &v64, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), &a3);
  UF_VEC3_is_equal(v17, &v98, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), &a2);
  if ( a5 && a3 )
  {
    result = v118;
    dword_1000C3DC = 0;
    byte_1000C009 = 0;
  }
  else
  {
    if ( a2 )
    {
      result = v118;
      dword_1000C3DC = 1;
      byte_1000C009 = 0;
    }
    else
    {
      v118 = 2;
      result = 2;
      byte_1000C009 = 0;
    }
  }
  return result;
}
// 100090B0: using guessed type int __cdecl UF_VEC3_cross(_DWORD, _DWORD);
// 100090C8: using guessed type int __cdecl UF_VEC3_is_parallel(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090CC: using guessed type int __cdecl UF_MTX3_z_vec(_DWORD, _DWORD);
// 100090D0: using guessed type int __cdecl UF_VEC3_distance(_DWORD, _DWORD, _DWORD);
// 100090D4: using guessed type int __cdecl UF_MTX3_vec_multiply_t(_DWORD, _DWORD, _DWORD);
// 100090E0: using guessed type int __cdecl UF_VEC3_is_equal(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090EC: using guessed type int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD);
// 100090F0: using guessed type int __cdecl UF_VEC3_dot(_DWORD, _DWORD, _DWORD);
// 100090F4: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);
// 10009120: using guessed type int __cdecl UF_MTX3_x_vec(_DWORD, _DWORD);
// 10009124: using guessed type int __cdecl UF_MTX3_y_vec(_DWORD, _DWORD);
// 10009128: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1000C000: using guessed type double dbl_1000C000;
// 1000C008: using guessed type char byte_1000C008;
// 1000C009: using guessed type char byte_1000C009;
// 1000C00A: using guessed type char byte_1000C00A;
// 1000C248: using guessed type double dbl_1000C248;
// 1000C2C8: using guessed type int dword_1000C2C8;
// 1000C2CC: using guessed type int dword_1000C2CC;
// 1000C2D0: using guessed type int dword_1000C2D0;
// 1000C2D4: using guessed type int dword_1000C2D4;
// 1000C2D8: using guessed type int dword_1000C2D8;
// 1000C2DC: using guessed type int dword_1000C2DC;
// 1000C2E0: using guessed type double dbl_1000C2E0;
// 1000C2E8: using guessed type double dbl_1000C2E8;
// 1000C2F0: using guessed type double dbl_1000C2F0;
// 1000C2F8: using guessed type double dbl_1000C2F8;
// 1000C300: using guessed type double dbl_1000C300;
// 1000C308: using guessed type double dbl_1000C308;
// 1000C310: using guessed type double dbl_1000C310;
// 1000C318: using guessed type double dbl_1000C318;
// 1000C320: using guessed type double dbl_1000C320;
// 1000C328: using guessed type double dbl_1000C328;
// 1000C330: using guessed type double dbl_1000C330;
// 1000C338: using guessed type double dbl_1000C338;
// 1000C348: using guessed type double dbl_1000C348;
// 1000C3D8: using guessed type int dword_1000C3D8;
// 1000C3DC: using guessed type int dword_1000C3DC;
// 1000C460: using guessed type double dbl_1000C460;
// 1000C468: using guessed type double dbl_1000C468;
// 1000C470: using guessed type double dbl_1000C470;
// 1000C478: using guessed type double dbl_1000C478;
// 1000C480: using guessed type double dbl_1000C480;
// 1000C488: using guessed type double dbl_1000C488;
// 1000C490: using guessed type double dbl_1000C490;
// 1000C498: using guessed type double dbl_1000C498;
// 1000C4A0: using guessed type double dbl_1000C4A0;
// 1000C4A8: using guessed type double dbl_1000C4A8;
// 1000C4B0: using guessed type double dbl_1000C4B0;
// 1000C4B8: using guessed type double dbl_1000C4B8;
// 1000C4C0: using guessed type double dbl_1000C4C0;
// 1000C4C8: using guessed type double dbl_1000C4C8;
// 1000C4D0: using guessed type double dbl_1000C4D0;
// 1000C4D8: using guessed type double dbl_1000C4D8;
// 1000C4E0: using guessed type int dword_1000C4E0;
// 1000C4E4: using guessed type int dword_1000C4E4;
// 1000C4E8: using guessed type int dword_1000C4E8;
// 1000C4EC: using guessed type int dword_1000C4EC;
// 1000C4F0: using guessed type int dword_1000C4F0;
// 1000C4F4: using guessed type int dword_1000C4F4;
// 1000C4F8: using guessed type int dword_1000C4F8;
// 1000C4FC: using guessed type int dword_1000C4FC;
// 1000C500: using guessed type int dword_1000C500;
// 1000C504: using guessed type int dword_1000C504;
// 1000C508: using guessed type int dword_1000C508;
// 1000C50C: using guessed type int dword_1000C50C;
// 1000C510: using guessed type int dword_1000C510;
// 1000C514: using guessed type int dword_1000C514;
// 1000C518: using guessed type int dword_1000C518;
// 1000C51C: using guessed type int dword_1000C51C;
// 1000C520: using guessed type int dword_1000C520;
// 1000C524: using guessed type int dword_1000C524;
// 1000C528: using guessed type int dword_1000C528;
// 1000C52C: using guessed type int dword_1000C52C;
// 1000C530: using guessed type double dbl_1000C530;
// 1000C538: using guessed type double dbl_1000C538;
// 1000C540: using guessed type int dword_1000C540;
// 1000C544: using guessed type int dword_1000C544;
// 1000C548: using guessed type int dword_1000C548;
// 1000C54C: using guessed type int dword_1000C54C;
// 1000C550: using guessed type int dword_1000C550;
// 1000C554: using guessed type int dword_1000C554;
// 1000C558: using guessed type double dbl_1000C558;
// 1000C560: using guessed type double dbl_1000C560;
// 1000C568: using guessed type double dbl_1000C568;
// 1000C570: using guessed type double dbl_1000C570;
// 1000C578: using guessed type double dbl_1000C578;
// 1000C580: using guessed type double dbl_1000C580;
// 1000C588: using guessed type char byte_1000C588;

//----- (10004E60) --------------------------------------------------------
signed int __cdecl sub_10004E60(const void *a1, int a2, int a3)
{
  const void *v3; // ebx@1
  signed int v4; // esi@3
  char v5; // zf@8
  char v7; // [sp+34h] [bp-98h]@1
  char v8[40]; // [sp+64h] [bp-68h]@1
  char v9[40]; // [sp+8Ch] [bp-40h]@1
  double v10; // [sp+B4h] [bp-18h]@2
  double v11; // [sp+BCh] [bp-10h]@2
  double v12; // [sp+C4h] [bp-8h]@2
  signed int v13; // [sp+D4h] [bp+8h]@1

  v3 = a1;
  memcpy(&v7, a1, 0x30u);
  UF_VEC3_add(&v7, dword_1000C3D8 + 16, &v7);
  UF_VEC3_sub(&v7, dword_1000C3D8 + 40, &v7);
  v13 = sub_10003100(&v7, (int)v9, (int)v8);
  UF_VEC3_add(v9, dword_1000C3D8 + 64, v9);
  UF_VEC3_add(v8, dword_1000C3D8 + 64, v8);
  if ( *(_BYTE *)(dword_1000C3D8 + 88) )
  {
    v10 = *((double *)v3 + 3);
    v11 = *((double *)v3 + 4);
    v12 = *((double *)v3 + 5);
    UF_VEC3_scale(
      COERCE_UNSIGNED_INT64(*(double *)(dword_1000C3D8 + 96)),
      COERCE_UNSIGNED_INT64(*(double *)(dword_1000C3D8 + 96)) >> 32,
      &v10,
      &v10);
    UF_VEC3_add(v9, &v10, v9);
    UF_VEC3_add(v8, &v10, v8);
  }
  v4 = 0;
  do
  {
    *(double *)&v9[v4] = sub_10005050((int)&v9[v4], (long double *)(dword_1000C3D8 + 8));
    *(double *)&v8[v4] = sub_10005050((int)&v8[v4], (long double *)(dword_1000C3D8 + 8));
    v4 += 8;
  }
  while ( v4 <= 16 );
  if ( byte_1000C00A )
    byte_1000C00A = 0;
  else
    sub_100025B0((int)v9, (int)v8);
  v5 = byte_1000C588 == 0;
  memcpy((void *)a2, v9, 0x28u);
  memcpy((void *)a3, v8, 0x28u);
  memcpy(&unk_1000C5B8, (const void *)a2, 0x28u);
  memcpy(&unk_1000C590, (const void *)a3, 0x28u);
  if ( !v5 )
  {
    printf(
      "final ufunc mcoord[] = (%f,%f,%f), (%f,%f)\n",
      *(double *)a2,
      *(double *)(a2 + 8),
      *(double *)(a2 + 16),
      *(double *)(a2 + 24),
      *(double *)(a2 + 32));
    printf(
      "final ufunc alt_mcoord[] = (%f,%f,%f), (%f,%f)\n",
      *(double *)a3,
      *(double *)(a3 + 8),
      *(double *)(a3 + 16),
      *(double *)(a3 + 24),
      *(double *)(a3 + 32));
  }
  return v13;
}
// 100090C4: using guessed type int __cdecl UF_VEC3_scale(_DWORD, _DWORD, _DWORD, _DWORD);
// 100090EC: using guessed type int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD);
// 10009100: using guessed type int __cdecl UF_VEC3_add(_DWORD, _DWORD, _DWORD);
// 1000C00A: using guessed type char byte_1000C00A;
// 1000C3D8: using guessed type int dword_1000C3D8;
// 1000C588: using guessed type char byte_1000C588;
// 10004E60: using guessed type char var_68[40];
// 10004E60: using guessed type char var_40[40];

//----- (10005050) --------------------------------------------------------
double __cdecl sub_10005050(int a1, long double *a2)
{
  double result; // st7@2
  double v3; // st7@3
  double v4; // st7@3
  double v5; // [sp+8h] [bp-8h]@3

  if ( fabs(fabs(*a2)) > 1.0e-10 )
  {
    v4 = 1.0 / *a2;
    v5 = v4;
    v3 = v4 * *(double *)a1;
    if ( v3 >= 0.000001 )
    {
      result = floor(v3 + 0.5) / v5;
    }
    else
    {
      if ( v3 <= -0.000001 )
        result = ceil(v3 - 0.5) / v5;
      else
        result = 0.0 / v5;
    }
  }
  else
  {
    result = 0.0;
  }
  return result;
}

//----- (100050E0) --------------------------------------------------------
signed int __usercall sub_100050E0<eax>(int a1<eax>)
{
  signed int v1; // ecx@1
  int v2; // esi@1
  double v3; // st4@1
  double v4; // st6@1
  double v5; // qt0@2
  long double v6; // st3@3
  double v7; // st4@4
  double v8; // st6@4
  double v9; // qt1@4
  double v10; // qt2@5
  double v11; // st3@7
  signed int result; // eax@13
  char v13; // [sp+1Ch] [bp-98h]@1
  char v14; // [sp+64h] [bp-50h]@1
  char v15; // [sp+7Ch] [bp-38h]@1
  char v16; // [sp+94h] [bp-20h]@1
  char v17; // [sp+ACh] [bp-8h]@11

  v2 = a1;
  UF_VEC3_copy(a1, &v16);
  UF_VEC3_copy(v2 + 24, &v15);
  UF_VEC3_copy(v2 + 48, &v14);
  UF_MTX3_copy(v2, &v13);
  v4 = 0.0;
  v1 = 0;
  v3 = -1.0;
  while ( 1 )
  {
    v6 = fabs(*(double *)(v2 + 8 * v1));
    if ( v6 > 1.0e-10 )
    {
      v10 = v3;
      v7 = v4;
      v8 = v10;
      if ( fabs(v6 - 1.0) <= 1.0e-10 )
      {
        if ( v7 >= *(double *)(v2 + 8 * v1) )
          v11 = v8;
        else
          v11 = 1.0;
        *(_QWORD *)(v2 + 8 * v1) = *(_QWORD *)&v11;
      }
    }
    else
    {
      v9 = v3;
      v7 = v4;
      v8 = v9;
      *(_QWORD *)(v2 + 8 * v1) = *(_QWORD *)&v7;
    }
    ++v1;
    if ( v1 >= 9 )
      break;
    v5 = v7;
    v3 = v8;
    v4 = v5;
  }
  if ( UF_VEC3_unitize(&v16, COERCE_UNSIGNED_INT64(1.0e-10), COERCE_UNSIGNED_INT64(1.0e-10) >> 32, &v17, &v16)
    && UF_VEC3_unitize(&v15, COERCE_UNSIGNED_INT64(1.0e-10), COERCE_UNSIGNED_INT64(1.0e-10) >> 32, &v17, &v15) )
  {
    ((void (__cdecl *)(char *, char *, char *))UF_VEC3_cross)(&v16, &v15, &v14);
    UF_VEC3_cross(&v14, &v16);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100090B0: using guessed type int __cdecl UF_VEC3_cross(_DWORD, _DWORD);
// 100090F4: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);
// 1000911C: using guessed type int __cdecl UF_MTX3_copy(_DWORD, _DWORD);
// 10009128: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10005200) --------------------------------------------------------
signed int __cdecl sub_10005200(int a1)
{
  signed int v2; // edi@1
  char v3; // [sp+8h] [bp-48h]@1

  UF_MTX4_ask_rotation(a1, &v3);
  v2 = sub_100050E0((int)&v3);
  UF_MTX4_edit_rotation(a1, &v3);
  return v2;
}
// 100090C0: using guessed type int __cdecl UF_MTX4_edit_rotation(_DWORD, _DWORD);
// 10009108: using guessed type int __cdecl UF_MTX4_ask_rotation(_DWORD, _DWORD);

//----- (10005240) --------------------------------------------------------
int __fastcall sub_10005240(int a1, int a2, char a3)
{
  return UF_MOM_ask_string(a2, a1, &a3);
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10005260) --------------------------------------------------------
int __cdecl sub_10005260(int a1, int a2)
{
  int i; // ebx@1
  const char *v3; // esi@1
  char *v4; // eax@3
  int v5; // edx@5
  char v6; // cl@6
  char *v7; // eax@8
  int v8; // edx@10
  char v9; // cl@11
  char *v10; // eax@13
  int v11; // edx@15
  char v12; // cl@16
  char *v13; // eax@18
  int v14; // edx@20
  char v15; // cl@21
  char *v16; // eax@23
  char *v17; // eax@26
  int v19; // [sp+Ch] [bp-20h]@1
  int v20; // [sp+10h] [bp-1Ch]@1
  int v21; // [sp+14h] [bp-18h]@1
  int v22; // [sp+18h] [bp-14h]@1
  int v23; // [sp+1Ch] [bp-10h]@1
  char v24[4]; // [sp+20h] [bp-Ch]@1
  int v25; // [sp+24h] [bp-8h]@2
  char *Str; // [sp+28h] [bp-4h]@2

  v3 = "mom_kin_nurbs_output_type";
  v19 = (int)"mom_kin_output_unit";
  v20 = (int)"mom_kin_polar_radius_side";
  v21 = (int)"mom_kin_read_ahead_next_motion";
  v22 = (int)"mom_kin_pivot_gauge_offset";
  v23 = (int)"mom_kin_rapid_feed_rate";
  *(_DWORD *)v24 = "END";
  for ( i = 0; strcmp(v3, "END"); ++i )
  {
    v25 = UF_MOM_ask_string(a1, v3 + 4, &Str);
    switch ( i )
    {
      case 0:
        v4 = Str;
        if ( !Str )
        {
          v4 = "NONE";
          Str = "NONE";
        }
        v5 = a2 - (_DWORD)v4;
        do
        {
          v6 = *v4;
          v4[v5] = *v4;
          ++v4;
        }
        while ( v6 );
        break;
      case 1:
        v7 = Str;
        if ( !Str )
        {
          v7 = "IN";
          Str = "IN";
        }
        v8 = a2 - (_DWORD)v7 + 133;
        do
        {
          v9 = *v7;
          v7[v8] = *v7;
          ++v7;
        }
        while ( v9 );
        break;
      case 2:
        v10 = Str;
        if ( !Str )
        {
          v10 = "NONE";
          Str = "NONE";
        }
        v11 = a2 - (_DWORD)v10 + 266;
        do
        {
          v12 = *v10;
          v10[v11] = *v10;
          ++v10;
        }
        while ( v12 );
        break;
      case 3:
        v13 = Str;
        if ( !Str )
        {
          v13 = (char *)L"F";
          Str = (char *)L"F";
        }
        v14 = a2 - (_DWORD)v13 + 399;
        do
        {
          v15 = *v13;
          v13[v14] = *v13;
          ++v13;
        }
        while ( v15 );
        break;
      case 4:
        v16 = Str;
        if ( !Str )
        {
          v16 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 536) = strtod(v16, 0);
        break;
      case 5:
        v17 = Str;
        if ( !Str )
        {
          v17 = "400.00";
          Str = "400.00";
        }
        *(double *)(a2 + 544) = strtod(v17, 0);
        break;
      default:
        break;
    }
    v3 = (const char *)*(&v19 + i);
  }
  return v25;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);
// 10009F24: using guessed type wchar_t asc_10009F24[2];

//----- (10005430) --------------------------------------------------------
int __cdecl sub_10005430(int a1, int a2)
{
  int i; // ebx@1
  const char *v3; // esi@1
  char *v4; // eax@3
  int v5; // edx@5
  char v6; // cl@6
  char *v7; // eax@8
  int v8; // edx@10
  char v9; // cl@11
  char *v10; // eax@13
  char *v11; // eax@16
  int v13; // [sp+Ch] [bp-18h]@1
  int v14; // [sp+10h] [bp-14h]@1
  int v15; // [sp+14h] [bp-10h]@1
  char v16[4]; // [sp+18h] [bp-Ch]@1
  int v17; // [sp+1Ch] [bp-8h]@2
  char *Str; // [sp+20h] [bp-4h]@2

  v3 = "mom_kin_arc_output_mode";
  v13 = (int)"mom_kin_arc_valid_plane";
  v14 = (int)"mom_kin_min_arc_radius";
  v15 = (int)"mom_kin_max_arc_radius";
  *(_DWORD *)v16 = "END";
  for ( i = 0; strcmp(v3, "END"); ++i )
  {
    v17 = UF_MOM_ask_string(a1, v3 + 4, &Str);
    switch ( i )
    {
      case 0:
        v4 = Str;
        if ( !Str )
        {
          v4 = "FULL_CIRCLE";
          Str = "FULL_CIRCLE";
        }
        v5 = a2 - (_DWORD)v4;
        do
        {
          v6 = *v4;
          v4[v5] = *v4;
          ++v4;
        }
        while ( v6 );
        break;
      case 1:
        v7 = Str;
        if ( !Str )
        {
          v7 = "XY";
          Str = "XY";
        }
        v8 = a2 - (_DWORD)v7 + 133;
        do
        {
          v9 = *v7;
          v7[v8] = *v7;
          ++v7;
        }
        while ( v9 );
        break;
      case 2:
        v10 = Str;
        if ( !Str )
        {
          v10 = "0.0001";
          Str = "0.0001";
        }
        *(double *)(a2 + 272) = strtod(v10, 0);
        break;
      case 3:
        v11 = Str;
        if ( !Str )
        {
          v11 = "9999.9999";
          Str = "9999.9999";
        }
        *(double *)(a2 + 280) = strtod(v11, 0);
        break;
      default:
        break;
    }
    v3 = (const char *)*(&v13 + i);
  }
  return v17;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (100055A0) --------------------------------------------------------
int __cdecl sub_100055A0(int a1, int a2)
{
  int i; // ebx@1
  const char *v3; // esi@1
  char *v4; // eax@3
  char *v5; // eax@6
  char *v6; // eax@9
  char *v7; // eax@12
  char *v8; // eax@15
  char *v9; // eax@18
  char *v10; // eax@21
  char *v11; // eax@24
  int v13; // [sp+Ch] [bp-28h]@1
  int v14; // [sp+10h] [bp-24h]@1
  int v15; // [sp+14h] [bp-20h]@1
  int v16; // [sp+18h] [bp-1Ch]@1
  int v17; // [sp+1Ch] [bp-18h]@1
  int v18; // [sp+20h] [bp-14h]@1
  int v19; // [sp+24h] [bp-10h]@1
  char v20[4]; // [sp+28h] [bp-Ch]@1
  int v21; // [sp+2Ch] [bp-8h]@2
  char *Str; // [sp+30h] [bp-4h]@2

  v3 = "mom_kin_max_fpm";
  v13 = (int)"mom_kin_min_fpm";
  v14 = (int)"mom_kin_max_fpr";
  v15 = (int)"mom_kin_min_fpr";
  v16 = (int)"mom_kin_max_frn";
  v17 = (int)"mom_kin_min_frn";
  v18 = (int)"mom_kin_max_dpm";
  v19 = (int)"mom_kin_min_dpm";
  *(_DWORD *)v20 = "END";
  for ( i = 0; strcmp(v3, "END"); ++i )
  {
    v21 = UF_MOM_ask_string(a1, v3 + 4, &Str);
    switch ( i )
    {
      case 0:
        v4 = Str;
        if ( !Str )
        {
          v4 = "999.999";
          Str = "999.999";
        }
        *(double *)a2 = strtod(v4, 0);
        break;
      case 1:
        v5 = Str;
        if ( !Str )
        {
          v5 = "0.001";
          Str = "0.001";
        }
        *(double *)(a2 + 32) = strtod(v5, 0);
        break;
      case 2:
        v6 = Str;
        if ( !Str )
        {
          v6 = "99.999";
          Str = "99.999";
        }
        *(double *)(a2 + 8) = strtod(v6, 0);
        break;
      case 3:
        v7 = Str;
        if ( !Str )
        {
          v7 = "0.001";
          Str = "0.001";
        }
        *(double *)(a2 + 40) = strtod(v7, 0);
        break;
      case 4:
        v8 = Str;
        if ( !Str )
        {
          v8 = "99999.999";
          Str = "99999.999";
        }
        *(double *)(a2 + 16) = strtod(v8, 0);
        break;
      case 5:
        v9 = Str;
        if ( !Str )
        {
          v9 = "0.001";
          Str = "0.001";
        }
        *(double *)(a2 + 48) = strtod(v9, 0);
        break;
      case 6:
        v10 = Str;
        if ( !Str )
        {
          v10 = "99.999";
          Str = "99.999";
        }
        *(double *)(a2 + 24) = strtod(v10, 0);
        break;
      case 7:
        v11 = Str;
        if ( !Str )
        {
          v11 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 56) = strtod(v11, 0);
        break;
      default:
        break;
    }
    v3 = (const char *)*(&v13 + i);
  }
  return v21;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (100057A0) --------------------------------------------------------
int __cdecl sub_100057A0(int a1, int a2)
{
  int i; // ebx@1
  const char *v3; // esi@1
  char *v4; // eax@3
  int v5; // edx@5
  char v6; // cl@6
  char *v7; // eax@8
  int v8; // edx@10
  char v9; // cl@11
  char *v10; // eax@13
  int v11; // edx@15
  char v12; // cl@16
  char *v13; // eax@18
  char *v14; // eax@21
  char *v15; // eax@24
  char *v16; // eax@27
  char *v17; // eax@30
  char *v18; // eax@33
  char *v19; // eax@36
  char *v20; // eax@39
  char *v21; // eax@42
  char *v22; // eax@45
  char *v23; // eax@48
  char *v24; // eax@51
  int v26; // [sp+Ch] [bp-44h]@1
  int v27; // [sp+10h] [bp-40h]@1
  int v28; // [sp+14h] [bp-3Ch]@1
  int v29; // [sp+18h] [bp-38h]@1
  int v30; // [sp+1Ch] [bp-34h]@1
  int v31; // [sp+20h] [bp-30h]@1
  int v32; // [sp+24h] [bp-2Ch]@1
  int v33; // [sp+28h] [bp-28h]@1
  int v34; // [sp+2Ch] [bp-24h]@1
  int v35; // [sp+30h] [bp-20h]@1
  int v36; // [sp+34h] [bp-1Ch]@1
  int v37; // [sp+38h] [bp-18h]@1
  int v38; // [sp+3Ch] [bp-14h]@1
  int v39; // [sp+40h] [bp-10h]@1
  char v40[4]; // [sp+44h] [bp-Ch]@1
  int v41; // [sp+48h] [bp-8h]@2
  char *Str; // [sp+4Ch] [bp-4h]@2

  v3 = "mom_kin_4th_axis_plane";
  v26 = (int)"mom_kin_4th_axis_direction";
  v27 = (int)"mom_kin_4th_axis_rotation";
  v28 = (int)"mom_kin_4th_axis_min_incr";
  v29 = (int)"mom_kin_4th_axis_min_limit";
  v30 = (int)"mom_kin_4th_axis_max_limit";
  v31 = (int)"mom_kin_4th_axis_zero";
  v32 = (int)"mom_kin_4th_axis_center_offset_x";
  v33 = (int)"mom_kin_4th_axis_center_offset_y";
  v34 = (int)"mom_kin_4th_axis_center_offset_z";
  v35 = (int)"mom_kin_4th_axis_vector_i";
  v36 = (int)"mom_kin_4th_axis_vector_j";
  v37 = (int)"mom_kin_4th_axis_vector_k";
  v38 = (int)"mom_kin_4th_axis_angles_a1";
  v39 = (int)"mom_kin_4th_axis_angles_a2";
  *(_DWORD *)v40 = "END";
  for ( i = 0; strcmp(v3, "END"); ++i )
  {
    v41 = UF_MOM_ask_string(a1, v3 + 4, &Str);
    switch ( i )
    {
      case 0:
        v4 = Str;
        if ( !Str )
        {
          v4 = "YZ";
          Str = "YZ";
        }
        v5 = a2 - (_DWORD)v4;
        do
        {
          v6 = *v4;
          v4[v5] = *v4;
          ++v4;
        }
        while ( v6 );
        break;
      case 1:
        v7 = Str;
        if ( !Str )
        {
          v7 = "MAGNITUDE_DETERMINES_DIRECTION";
          Str = "MAGNITUDE_DETERMINES_DIRECTION";
        }
        v8 = a2 - (_DWORD)v7 + 133;
        do
        {
          v9 = *v7;
          v7[v8] = *v7;
          ++v7;
        }
        while ( v9 );
        break;
      case 2:
        v10 = Str;
        if ( !Str )
        {
          v10 = "STANDARD";
          Str = "STANDARD";
        }
        v11 = a2 - (_DWORD)v10 + 266;
        do
        {
          v12 = *v10;
          v10[v11] = *v10;
          ++v10;
        }
        while ( v12 );
        break;
      case 3:
        v13 = Str;
        if ( !Str )
        {
          v13 = "0.001";
          Str = "0.001";
        }
        *(double *)(a2 + 400) = strtod(v13, 0);
        break;
      case 4:
        v14 = Str;
        if ( !Str )
        {
          v14 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 408) = strtod(v14, 0);
        break;
      case 5:
        v15 = Str;
        if ( !Str )
        {
          v15 = "360.0";
          Str = "360.0";
        }
        *(double *)(a2 + 416) = strtod(v15, 0);
        break;
      case 6:
        v16 = Str;
        if ( !Str )
        {
          v16 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 424) = strtod(v16, 0);
        break;
      case 7:
        v17 = Str;
        if ( !Str )
        {
          v17 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 432) = strtod(v17, 0);
        break;
      case 8:
        v18 = Str;
        if ( !Str )
        {
          v18 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 440) = strtod(v18, 0);
        break;
      case 9:
        v19 = Str;
        if ( !Str )
        {
          v19 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 448) = strtod(v19, 0);
        break;
      case 10:
        v20 = Str;
        if ( !Str )
        {
          v20 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 456) = strtod(v20, 0);
        break;
      case 11:
        v21 = Str;
        if ( !Str )
        {
          v21 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 464) = strtod(v21, 0);
        break;
      case 12:
        v22 = Str;
        if ( !Str )
        {
          v22 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 472) = strtod(v22, 0);
        break;
      case 13:
        v23 = Str;
        if ( !Str )
        {
          v23 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 480) = strtod(v23, 0);
        break;
      case 14:
        v24 = Str;
        if ( !Str )
        {
          v24 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 488) = strtod(v24, 0);
        break;
      default:
        break;
    }
    v3 = (const char *)*(&v26 + i);
  }
  return v41;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10005B10) --------------------------------------------------------
int __cdecl sub_10005B10(int a1, int a2)
{
  int i; // ebx@1
  const char *v3; // esi@1
  char *v4; // eax@3
  int v5; // edx@5
  char v6; // cl@6
  char *v7; // eax@8
  int v8; // edx@10
  char v9; // cl@11
  char *v10; // eax@13
  int v11; // edx@15
  char v12; // cl@16
  char *v13; // eax@18
  char *v14; // eax@21
  char *v15; // eax@24
  char *v16; // eax@27
  char *v17; // eax@30
  char *v18; // eax@33
  char *v19; // eax@36
  char *v20; // eax@39
  char *v21; // eax@42
  char *v22; // eax@45
  char *v23; // eax@48
  char *v24; // eax@51
  int v26; // [sp+Ch] [bp-44h]@1
  int v27; // [sp+10h] [bp-40h]@1
  int v28; // [sp+14h] [bp-3Ch]@1
  int v29; // [sp+18h] [bp-38h]@1
  int v30; // [sp+1Ch] [bp-34h]@1
  int v31; // [sp+20h] [bp-30h]@1
  int v32; // [sp+24h] [bp-2Ch]@1
  int v33; // [sp+28h] [bp-28h]@1
  int v34; // [sp+2Ch] [bp-24h]@1
  int v35; // [sp+30h] [bp-20h]@1
  int v36; // [sp+34h] [bp-1Ch]@1
  int v37; // [sp+38h] [bp-18h]@1
  int v38; // [sp+3Ch] [bp-14h]@1
  int v39; // [sp+40h] [bp-10h]@1
  char v40[4]; // [sp+44h] [bp-Ch]@1
  int v41; // [sp+48h] [bp-8h]@2
  char *Str; // [sp+4Ch] [bp-4h]@2

  v3 = "mom_kin_5th_axis_plane";
  v26 = (int)"mom_kin_5th_axis_direction";
  v27 = (int)"mom_kin_5th_axis_rotation";
  v28 = (int)"mom_kin_5th_axis_min_incr";
  v29 = (int)"mom_kin_5th_axis_min_limit";
  v30 = (int)"mom_kin_5th_axis_max_limit";
  v31 = (int)"mom_kin_5th_axis_zero";
  v32 = (int)"mom_kin_5th_axis_center_offset_x";
  v33 = (int)"mom_kin_5th_axis_center_offset_y";
  v34 = (int)"mom_kin_5th_axis_center_offset_z";
  v35 = (int)"mom_kin_5th_axis_vector_i";
  v36 = (int)"mom_kin_5th_axis_vector_j";
  v37 = (int)"mom_kin_5th_axis_vector_k";
  v38 = (int)"mom_kin_5th_axis_angles_a1";
  v39 = (int)"mom_kin_5th_axis_angles_a2";
  *(_DWORD *)v40 = "END";
  for ( i = 0; strcmp(v3, "END"); ++i )
  {
    v41 = UF_MOM_ask_string(a1, v3 + 4, &Str);
    switch ( i )
    {
      case 0:
        v4 = Str;
        if ( !Str )
        {
          v4 = "YZ";
          Str = "YZ";
        }
        v5 = a2 - (_DWORD)v4;
        do
        {
          v6 = *v4;
          v4[v5] = *v4;
          ++v4;
        }
        while ( v6 );
        break;
      case 1:
        v7 = Str;
        if ( !Str )
        {
          v7 = "MAGNITUDE_DETERMINES_DIRECTION";
          Str = "MAGNITUDE_DETERMINES_DIRECTION";
        }
        v8 = a2 - (_DWORD)v7 + 133;
        do
        {
          v9 = *v7;
          v7[v8] = *v7;
          ++v7;
        }
        while ( v9 );
        break;
      case 2:
        v10 = Str;
        if ( !Str )
        {
          v10 = "STANDARD";
          Str = "STANDARD";
        }
        v11 = a2 - (_DWORD)v10 + 266;
        do
        {
          v12 = *v10;
          v10[v11] = *v10;
          ++v10;
        }
        while ( v12 );
        break;
      case 3:
        v13 = Str;
        if ( !Str )
        {
          v13 = "0.001";
          Str = "0.001";
        }
        *(double *)(a2 + 400) = strtod(v13, 0);
        break;
      case 4:
        v14 = Str;
        if ( !Str )
        {
          v14 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 408) = strtod(v14, 0);
        break;
      case 5:
        v15 = Str;
        if ( !Str )
        {
          v15 = "360.0";
          Str = "360.0";
        }
        *(double *)(a2 + 416) = strtod(v15, 0);
        break;
      case 6:
        v16 = Str;
        if ( !Str )
        {
          v16 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 424) = strtod(v16, 0);
        break;
      case 7:
        v17 = Str;
        if ( !Str )
        {
          v17 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 432) = strtod(v17, 0);
        break;
      case 8:
        v18 = Str;
        if ( !Str )
        {
          v18 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 440) = strtod(v18, 0);
        break;
      case 9:
        v19 = Str;
        if ( !Str )
        {
          v19 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 448) = strtod(v19, 0);
        break;
      case 10:
        v20 = Str;
        if ( !Str )
        {
          v20 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 456) = strtod(v20, 0);
        break;
      case 11:
        v21 = Str;
        if ( !Str )
        {
          v21 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 464) = strtod(v21, 0);
        break;
      case 12:
        v22 = Str;
        if ( !Str )
        {
          v22 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 472) = strtod(v22, 0);
        break;
      case 13:
        v23 = Str;
        if ( !Str )
        {
          v23 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 480) = strtod(v23, 0);
        break;
      case 14:
        v24 = Str;
        if ( !Str )
        {
          v24 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 488) = strtod(v24, 0);
        break;
      default:
        break;
    }
    v3 = (const char *)*(&v26 + i);
  }
  return v41;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10005E80) --------------------------------------------------------
int __cdecl sub_10005E80(int a1, int a2)
{
  int i; // edi@1
  const char *v3; // esi@1
  char *v4; // eax@5
  char *v5; // eax@8
  char *v6; // eax@11
  int v7; // edx@13
  char v8; // cl@14
  int v10; // [sp+Ch] [bp-14h]@1
  int v11; // [sp+10h] [bp-10h]@1
  char v12[4]; // [sp+14h] [bp-Ch]@1
  int v13; // [sp+18h] [bp-8h]@2
  char *Str; // [sp+1Ch] [bp-4h]@2

  v3 = "mom_kin_independent_head";
  v10 = (int)"mom_kin_ind_to_dependent_head_x";
  v11 = (int)"mom_kin_ind_to_dependent_head_z";
  *(_DWORD *)v12 = "END";
  for ( i = 0; strcmp(v3, "END"); ++i )
  {
    v13 = UF_MOM_ask_string(a1, v3 + 4, &Str);
    if ( i )
    {
      if ( i == 1 )
      {
        v5 = Str;
        if ( !Str )
        {
          v5 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 136) = strtod(v5, 0);
      }
      else
      {
        if ( i == 2 )
        {
          v4 = Str;
          if ( !Str )
          {
            v4 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 144) = strtod(v4, 0);
        }
      }
    }
    else
    {
      v6 = Str;
      if ( !Str )
      {
        v6 = "FRONT";
        Str = "FRONT";
      }
      v7 = a2 - (_DWORD)v6;
      do
      {
        v8 = *v6;
        v6[v7] = *v6;
        ++v6;
      }
      while ( v8 );
    }
    v3 = (const char *)*(&v10 + i);
  }
  return v13;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10005FC0) --------------------------------------------------------
int __cdecl sub_10005FC0(int a1, int a2)
{
  int i; // edi@1
  const char *v3; // esi@1
  char *v4; // eax@5
  char *v5; // eax@8
  char *v6; // eax@11
  int v8; // [sp+Ch] [bp-14h]@1
  int v9; // [sp+10h] [bp-10h]@1
  char v10[4]; // [sp+14h] [bp-Ch]@1
  int v11; // [sp+18h] [bp-8h]@2
  char *Str; // [sp+1Ch] [bp-4h]@2

  v3 = "mom_kin_tool_change_time";
  v8 = (int)"mom_kin_clamp_time";
  v9 = (int)"mom_kin_flush_time";
  *(_DWORD *)v10 = "END";
  for ( i = 0; strcmp(v3, "END"); ++i )
  {
    v11 = UF_MOM_ask_string(a1, v3 + 4, &Str);
    if ( i )
    {
      if ( i == 1 )
      {
        v5 = Str;
        if ( !Str )
        {
          v5 = "0.5";
          Str = "0.5";
        }
        *(double *)(a2 + 8) = strtod(v5, 0);
      }
      else
      {
        if ( i == 2 )
        {
          v4 = Str;
          if ( !Str )
          {
            v4 = "0.5";
            Str = "0.5";
          }
          *(double *)(a2 + 16) = strtod(v4, 0);
        }
      }
    }
    else
    {
      v6 = Str;
      if ( !Str )
      {
        v6 = "3.0";
        Str = "3.0";
      }
      *(double *)a2 = strtod(v6, 0);
    }
    v3 = (const char *)*(&v8 + i);
  }
  return v11;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (100060F0) --------------------------------------------------------
int __cdecl sub_100060F0(int a1, int a2)
{
  int i; // ebx@1
  const char *v3; // esi@1
  char *v4; // eax@3
  int v5; // edx@5
  char v6; // cl@6
  char *v7; // eax@8
  int v8; // edx@10
  char v9; // cl@11
  char *v10; // eax@13
  int v11; // edx@15
  char v12; // cl@16
  char *v13; // eax@18
  int v14; // edx@20
  char v15; // cl@21
  char *v16; // eax@23
  int v17; // edx@25
  char v18; // cl@26
  char *v19; // eax@28
  int v20; // edx@30
  char v21; // cl@31
  char *v22; // eax@33
  char *v23; // eax@36
  char *v24; // eax@39
  char *v25; // eax@42
  char *v26; // eax@45
  char *v27; // eax@48
  char *v28; // eax@51
  char *v29; // eax@54
  char *v30; // eax@57
  char *v31; // eax@60
  char *v32; // eax@63
  char *v33; // eax@66
  char *v34; // eax@69
  char *v35; // eax@72
  char *v36; // eax@75
  char *v37; // eax@78
  char *v38; // eax@81
  char *v39; // eax@84
  int v41; // [sp+Ch] [bp-68h]@1
  int v42; // [sp+10h] [bp-64h]@1
  int v43; // [sp+14h] [bp-60h]@1
  int v44; // [sp+18h] [bp-5Ch]@1
  int v45; // [sp+1Ch] [bp-58h]@1
  int v46; // [sp+20h] [bp-54h]@1
  int v47; // [sp+24h] [bp-50h]@1
  int v48; // [sp+28h] [bp-4Ch]@1
  int v49; // [sp+2Ch] [bp-48h]@1
  int v50; // [sp+30h] [bp-44h]@1
  int v51; // [sp+34h] [bp-40h]@1
  int v52; // [sp+38h] [bp-3Ch]@1
  int v53; // [sp+3Ch] [bp-38h]@1
  int v54; // [sp+40h] [bp-34h]@1
  int v55; // [sp+44h] [bp-30h]@1
  int v56; // [sp+48h] [bp-2Ch]@1
  int v57; // [sp+4Ch] [bp-28h]@1
  int v58; // [sp+50h] [bp-24h]@1
  int v59; // [sp+54h] [bp-20h]@1
  int v60; // [sp+58h] [bp-1Ch]@1
  int v61; // [sp+5Ch] [bp-18h]@1
  int v62; // [sp+60h] [bp-14h]@1
  int v63; // [sp+64h] [bp-10h]@1
  char v64[4]; // [sp+68h] [bp-Ch]@1
  int v65; // [sp+6Ch] [bp-8h]@2
  char *Str; // [sp+70h] [bp-4h]@2

  v3 = "mom_kin_holder1_orientation";
  v41 = (int)"mom_kin_holder2_orientation";
  v42 = (int)"mom_kin_holder3_orientation";
  v43 = (int)"mom_kin_holder4_orientation";
  v44 = (int)"mom_kin_holder5_orientation";
  v45 = (int)"mom_kin_holder6_orientation";
  v46 = (int)"mom_kin_holder1_offset_x";
  v47 = (int)"mom_kin_holder1_offset_y";
  v48 = (int)"mom_kin_holder1_offset_z";
  v49 = (int)"mom_kin_holder2_offset_x";
  v50 = (int)"mom_kin_holder2_offset_y";
  v51 = (int)"mom_kin_holder2_offset_z";
  v52 = (int)"mom_kin_holder3_offset_x";
  v53 = (int)"mom_kin_holder3_offset_y";
  v54 = (int)"mom_kin_holder3_offset_z";
  v55 = (int)"mom_kin_holder4_offset_x";
  v56 = (int)"mom_kin_holder4_offset_y";
  v57 = (int)"mom_kin_holder4_offset_z";
  v58 = (int)"mom_kin_holder5_offset_x";
  v59 = (int)"mom_kin_holder5_offset_y";
  v60 = (int)"mom_kin_holder5_offset_z";
  v61 = (int)"mom_kin_holder6_offset_x";
  v62 = (int)"mom_kin_holder6_offset_y";
  v63 = (int)"mom_kin_holder6_offset_z";
  *(_DWORD *)v64 = "END";
  for ( i = 0; strcmp(v3, "END"); ++i )
  {
    v65 = UF_MOM_ask_string(a1, v3 + 4, &Str);
    switch ( i )
    {
      case 0:
        v4 = Str;
        if ( !Str )
        {
          v4 = "POSZ";
          Str = "POSZ";
        }
        v5 = a2 - (_DWORD)v4;
        do
        {
          v6 = *v4;
          v4[v5] = *v4;
          ++v4;
        }
        while ( v6 );
        break;
      case 1:
        v7 = Str;
        if ( !Str )
        {
          v7 = "POSZ";
          Str = "POSZ";
        }
        v8 = a2 - (_DWORD)v7 + 133;
        do
        {
          v9 = *v7;
          v7[v8] = *v7;
          ++v7;
        }
        while ( v9 );
        break;
      case 2:
        v10 = Str;
        if ( !Str )
        {
          v10 = "POSZ";
          Str = "POSZ";
        }
        v11 = a2 - (_DWORD)v10 + 266;
        do
        {
          v12 = *v10;
          v10[v11] = *v10;
          ++v10;
        }
        while ( v12 );
        break;
      case 3:
        v13 = Str;
        if ( !Str )
        {
          v13 = "POSZ";
          Str = "POSZ";
        }
        v14 = a2 - (_DWORD)v13 + 399;
        do
        {
          v15 = *v13;
          v13[v14] = *v13;
          ++v13;
        }
        while ( v15 );
        break;
      case 4:
        v16 = Str;
        if ( !Str )
        {
          v16 = "POSZ";
          Str = "POSZ";
        }
        v17 = a2 - (_DWORD)v16 + 532;
        do
        {
          v18 = *v16;
          v16[v17] = *v16;
          ++v16;
        }
        while ( v18 );
        break;
      case 5:
        v19 = Str;
        if ( !Str )
        {
          v19 = "POSZ";
          Str = "POSZ";
        }
        v20 = a2 - (_DWORD)v19 + 665;
        do
        {
          v21 = *v19;
          v19[v20] = *v19;
          ++v19;
        }
        while ( v21 );
        break;
      case 6:
        v22 = Str;
        if ( !Str )
        {
          v22 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 800) = strtod(v22, 0);
        break;
      case 7:
        v23 = Str;
        if ( !Str )
        {
          v23 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 808) = strtod(v23, 0);
        break;
      case 8:
        v24 = Str;
        if ( !Str )
        {
          v24 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 816) = strtod(v24, 0);
        break;
      case 9:
        v25 = Str;
        if ( !Str )
        {
          v25 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 824) = strtod(v25, 0);
        break;
      case 10:
        v26 = Str;
        if ( !Str )
        {
          v26 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 832) = strtod(v26, 0);
        break;
      case 11:
        v27 = Str;
        if ( !Str )
        {
          v27 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 840) = strtod(v27, 0);
        break;
      case 12:
        v28 = Str;
        if ( !Str )
        {
          v28 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 848) = strtod(v28, 0);
        break;
      case 13:
        v29 = Str;
        if ( !Str )
        {
          v29 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 856) = strtod(v29, 0);
        break;
      case 14:
        v30 = Str;
        if ( !Str )
        {
          v30 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 864) = strtod(v30, 0);
        break;
      case 15:
        v31 = Str;
        if ( !Str )
        {
          v31 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 872) = strtod(v31, 0);
        break;
      case 16:
        v32 = Str;
        if ( !Str )
        {
          v32 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 880) = strtod(v32, 0);
        break;
      case 17:
        v33 = Str;
        if ( !Str )
        {
          v33 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 888) = strtod(v33, 0);
        break;
      case 18:
        v34 = Str;
        if ( !Str )
        {
          v34 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 896) = strtod(v34, 0);
        break;
      case 19:
        v35 = Str;
        if ( !Str )
        {
          v35 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 904) = strtod(v35, 0);
        break;
      case 20:
        v36 = Str;
        if ( !Str )
        {
          v36 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 912) = strtod(v36, 0);
        break;
      case 21:
        v37 = Str;
        if ( !Str )
        {
          v37 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 920) = strtod(v37, 0);
        break;
      case 22:
        v38 = Str;
        if ( !Str )
        {
          v38 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 928) = strtod(v38, 0);
        break;
      case 23:
        v39 = Str;
        if ( !Str )
        {
          v39 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 936) = strtod(v39, 0);
        break;
      default:
        break;
    }
    v3 = (const char *)*(&v41 + i);
  }
  return v65;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10006610) --------------------------------------------------------
int __cdecl sub_10006610(int a1, int a2)
{
  int v2; // edi@1
  const char *v3; // esi@1
  char *v4; // eax@3
  int v5; // edx@5
  char v6; // cl@6
  char *v7; // eax@8
  int v8; // edx@10
  char v9; // cl@11
  char *v10; // eax@13
  int v11; // edx@15
  char v12; // cl@16
  char *v13; // eax@18
  int v14; // edx@20
  char v15; // cl@21
  char *v16; // eax@23
  int v17; // edx@25
  char v18; // cl@26
  char *v19; // eax@28
  int v20; // edx@30
  char v21; // cl@31
  char *v22; // eax@33
  char *v23; // eax@36
  char *v24; // eax@39
  char *v25; // eax@42
  char *v26; // ecx@45
  int v27; // eax@46
  char *v28; // ecx@50
  int v29; // eax@51
  char *v30; // ecx@55
  int v31; // eax@56
  char v33; // [sp+8h] [bp-98h]@51
  char v34; // [sp+24h] [bp-7Ch]@56
  char v35; // [sp+40h] [bp-60h]@46
  int v36; // [sp+5Ch] [bp-44h]@1
  int v37; // [sp+60h] [bp-40h]@1
  int v38; // [sp+64h] [bp-3Ch]@1
  int v39; // [sp+68h] [bp-38h]@1
  int v40; // [sp+6Ch] [bp-34h]@1
  int v41; // [sp+70h] [bp-30h]@1
  int v42; // [sp+74h] [bp-2Ch]@1
  int v43; // [sp+78h] [bp-28h]@1
  int v44; // [sp+7Ch] [bp-24h]@1
  int v45; // [sp+80h] [bp-20h]@1
  int v46; // [sp+84h] [bp-1Ch]@1
  int v47; // [sp+88h] [bp-18h]@1
  int v48; // [sp+8Ch] [bp-14h]@1
  char v49[4]; // [sp+90h] [bp-10h]@1
  int v50; // [sp+94h] [bp-Ch]@2
  int i; // [sp+98h] [bp-8h]@1
  char *Str; // [sp+9Ch] [bp-4h]@2

  v3 = "mom_kin_machine_type";
  v2 = 0;
  v46 = (int)"mom_kin_gauge_to_pivot_x";
  v48 = (int)"mom_kin_gauge_to_pivot_x";
  v36 = (int)"mom_kin_machine_type";
  v37 = (int)"mom_kin_track_center_of_ball";
  v38 = (int)"mom_kin_wire_tilt_output_type";
  v39 = (int)"mom_kin_clsf_generation";
  v40 = (int)"mom_kin_coordinate_type";
  v41 = (int)"mom_kin_linearization_flag";
  v42 = (int)"mom_kin_machine_resolution";
  v43 = (int)"mom_kin_tool_tracking_height";
  v44 = (int)"mom_kin_5th_axis_inclination_to_4th";
  v45 = (int)"mom_kin_linearization_tol";
  v47 = (int)"mom_kin_gauge_to_pivot_y";
  *(_DWORD *)v49 = "END";
  for ( i = 0; strcmp(v3, "END"); ++i )
  {
    v50 = UF_MOM_ask_string(a1, v3 + 4, &Str);
    switch ( v2 )
    {
      case 0:
        v4 = Str;
        if ( !Str )
        {
          v4 = "3_axis_mill";
          Str = "3_axis_mill";
        }
        v5 = a2 - (_DWORD)v4;
        do
        {
          v6 = *v4;
          v4[v5] = *v4;
          ++v4;
        }
        while ( v6 );
        break;
      case 1:
        v7 = Str;
        if ( !Str )
        {
          v7 = (char *)L"T";
          Str = (char *)L"T";
        }
        v8 = a2 - (_DWORD)v7 + 133;
        do
        {
          v9 = *v7;
          v7[v8] = *v7;
          ++v7;
        }
        while ( v9 );
        break;
      case 2:
        v10 = Str;
        if ( !Str )
        {
          v10 = "NONE";
          Str = "NONE";
        }
        v11 = a2 - (_DWORD)v10 + 266;
        do
        {
          v12 = *v10;
          v10[v11] = *v10;
          ++v10;
        }
        while ( v12 );
        break;
      case 3:
        v13 = Str;
        if ( !Str )
        {
          v13 = (char *)L"F";
          Str = (char *)L"F";
        }
        v14 = a2 - (_DWORD)v13 + 399;
        do
        {
          v15 = *v13;
          v13[v14] = *v13;
          ++v13;
        }
        while ( v15 );
        break;
      case 4:
        v16 = Str;
        if ( !Str )
        {
          v16 = "CARTESIAN";
          Str = "CARTESIAN";
        }
        v17 = a2 - (_DWORD)v16 + 532;
        do
        {
          v18 = *v16;
          v16[v17] = *v16;
          ++v16;
        }
        while ( v18 );
        break;
      case 5:
        v19 = Str;
        if ( !Str )
        {
          v19 = (char *)L"F";
          Str = (char *)L"F";
        }
        v20 = a2 - (_DWORD)v19 + 665;
        do
        {
          v21 = *v19;
          v19[v20] = *v19;
          ++v19;
        }
        while ( v21 );
        break;
      case 6:
        v22 = Str;
        if ( !Str )
        {
          v22 = "0.0001";
          Str = "0.0001";
        }
        *(double *)(a2 + 800) = strtod(v22, 0);
        break;
      case 7:
        v23 = Str;
        if ( !Str )
        {
          v23 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 808) = strtod(v23, 0);
        break;
      case 8:
        v24 = Str;
        if ( !Str )
        {
          v24 = "90.0";
          Str = "90.0";
        }
        *(double *)(a2 + 816) = strtod(v24, 0);
        break;
      case 9:
        v25 = Str;
        if ( !Str )
        {
          v25 = "0.0001";
          Str = "0.0001";
        }
        *(double *)(a2 + 824) = strtod(v25, 0);
        break;
      case 10:
        v26 = Str;
        if ( !Str )
        {
          memcpy(&v35, "kin_4th_to_tracking_point_x", 0x1Cu);
          v27 = sub_10005240((int)&v35, a1, 0);
          v26 = Str;
          if ( !Str || v27 )
          {
            v26 = "0.0";
            Str = "0.0";
          }
        }
        *(double *)(a2 + 832) = strtod(v26, 0);
        break;
      case 11:
        v28 = Str;
        if ( !Str )
        {
          memcpy(&v33, "kin_4th_to_tracking_point_y", 0x1Cu);
          v29 = sub_10005240((int)&v33, a1, 0);
          v28 = Str;
          if ( !Str || v29 )
          {
            v28 = "0.0";
            Str = "0.0";
          }
        }
        *(double *)(a2 + 840) = strtod(v28, 0);
        break;
      case 12:
        v30 = Str;
        if ( !Str )
        {
          memcpy(&v34, "kin_4th_to_tracking_point_z", 0x1Cu);
          v31 = sub_10005240((int)&v34, a1, 0);
          v30 = Str;
          if ( !Str || v31 )
          {
            v30 = "0.0";
            Str = "0.0";
          }
        }
        *(double *)(a2 + 848) = strtod(v30, 0);
        break;
      default:
        break;
    }
    v3 = (const char *)*(&v37 + i);
    v2 = i + 1;
  }
  return v50;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);
// 10009F24: using guessed type wchar_t asc_10009F24[2];
// 1000A858: using guessed type wchar_t aT[2];

//----- (100069C0) --------------------------------------------------------
int __cdecl sub_100069C0(int a1, int a2)
{
  int i; // ebx@1
  const char *v3; // esi@1
  char *v4; // eax@3
  char *v5; // eax@6
  char *v6; // eax@9
  char *v7; // eax@12
  char *v8; // eax@15
  char *v9; // eax@18
  char *v10; // eax@21
  char *v11; // eax@24
  char *v12; // eax@27
  char *v13; // eax@30
  char *v14; // eax@33
  char *v15; // eax@36
  int v17; // [sp+Ch] [bp-38h]@1
  int v18; // [sp+10h] [bp-34h]@1
  int v19; // [sp+14h] [bp-30h]@1
  int v20; // [sp+18h] [bp-2Ch]@1
  int v21; // [sp+1Ch] [bp-28h]@1
  int v22; // [sp+20h] [bp-24h]@1
  int v23; // [sp+24h] [bp-20h]@1
  int v24; // [sp+28h] [bp-1Ch]@1
  int v25; // [sp+2Ch] [bp-18h]@1
  int v26; // [sp+30h] [bp-14h]@1
  int v27; // [sp+34h] [bp-10h]@1
  char v28[4]; // [sp+38h] [bp-Ch]@1
  int v29; // [sp+3Ch] [bp-8h]@2
  char *Str; // [sp+40h] [bp-4h]@2

  v3 = "mom_msys_origin_x";
  v17 = (int)"mom_msys_origin_y";
  v18 = (int)"mom_msys_origin_z";
  v19 = (int)"mom_msys_x_axis_i";
  v20 = (int)"mom_msys_x_axis_j";
  v21 = (int)"mom_msys_x_axis_k";
  v22 = (int)"mom_msys_y_axis_i";
  v23 = (int)"mom_msys_y_axis_j";
  v24 = (int)"mom_msys_y_axis_k";
  v25 = (int)"mom_msys_z_axis_i";
  v26 = (int)"mom_msys_z_axis_j";
  v27 = (int)"mom_msys_z_axis_k";
  *(_DWORD *)v28 = "END";
  for ( i = 0; strcmp(v3, "END"); ++i )
  {
    v29 = UF_MOM_ask_string(a1, v3 + 4, &Str);
    switch ( i )
    {
      case 0:
        v4 = Str;
        if ( !Str )
        {
          v4 = "0.0";
          Str = "0.0";
        }
        *(double *)a2 = strtod(v4, 0);
        break;
      case 1:
        v5 = Str;
        if ( !Str )
        {
          v5 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 8) = strtod(v5, 0);
        break;
      case 2:
        v6 = Str;
        if ( !Str )
        {
          v6 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 16) = strtod(v6, 0);
        break;
      case 3:
        v7 = Str;
        if ( !Str )
        {
          v7 = "1.0";
          Str = "1.0";
        }
        *(double *)(a2 + 24) = strtod(v7, 0);
        break;
      case 4:
        v8 = Str;
        if ( !Str )
        {
          v8 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 32) = strtod(v8, 0);
        break;
      case 5:
        v9 = Str;
        if ( !Str )
        {
          v9 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 40) = strtod(v9, 0);
        break;
      case 6:
        v10 = Str;
        if ( !Str )
        {
          v10 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 48) = strtod(v10, 0);
        break;
      case 7:
        v11 = Str;
        if ( !Str )
        {
          v11 = "1.0";
          Str = "1.0";
        }
        *(double *)(a2 + 56) = strtod(v11, 0);
        break;
      case 8:
        v12 = Str;
        if ( !Str )
        {
          v12 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 64) = strtod(v12, 0);
        break;
      case 9:
        v13 = Str;
        if ( !Str )
        {
          v13 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 72) = strtod(v13, 0);
        break;
      case 10:
        v14 = Str;
        if ( !Str )
        {
          v14 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 80) = strtod(v14, 0);
        break;
      case 11:
        v15 = Str;
        if ( !Str )
        {
          v15 = "1.0";
          Str = "1.0";
        }
        *(double *)(a2 + 88) = strtod(v15, 0);
        break;
      default:
        break;
    }
    v3 = (const char *)*(&v17 + i);
  }
  return v29;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10006C70) --------------------------------------------------------
int __cdecl sub_10006C70(int a1, int a2)
{
  int i; // ebx@1
  const char *v3; // esi@1
  char *v4; // eax@3
  char *v5; // eax@6
  char *v6; // eax@9
  char *v7; // eax@12
  char *v8; // eax@15
  char *v9; // eax@18
  char *v10; // eax@21
  char *v11; // eax@24
  char *v12; // eax@27
  char *v13; // eax@30
  char *v14; // eax@33
  char *v15; // eax@36
  int v17; // [sp+Ch] [bp-38h]@1
  int v18; // [sp+10h] [bp-34h]@1
  int v19; // [sp+14h] [bp-30h]@1
  int v20; // [sp+18h] [bp-2Ch]@1
  int v21; // [sp+1Ch] [bp-28h]@1
  int v22; // [sp+20h] [bp-24h]@1
  int v23; // [sp+24h] [bp-20h]@1
  int v24; // [sp+28h] [bp-1Ch]@1
  int v25; // [sp+2Ch] [bp-18h]@1
  int v26; // [sp+30h] [bp-14h]@1
  int v27; // [sp+34h] [bp-10h]@1
  char v28[4]; // [sp+38h] [bp-Ch]@1
  int v29; // [sp+3Ch] [bp-8h]@2
  char *Str; // [sp+40h] [bp-4h]@2

  v3 = "mom_mtsys_origin_x";
  v17 = (int)"mom_mtsys_origin_y";
  v18 = (int)"mom_mtsys_origin_z";
  v19 = (int)"mom_mtsys_x_axis_i";
  v20 = (int)"mom_mtsys_x_axis_j";
  v21 = (int)"mom_mtsys_x_axis_k";
  v22 = (int)"mom_mtsys_y_axis_i";
  v23 = (int)"mom_mtsys_y_axis_j";
  v24 = (int)"mom_mtsys_y_axis_k";
  v25 = (int)"mom_mtsys_z_axis_i";
  v26 = (int)"mom_mtsys_z_axis_j";
  v27 = (int)"mom_mtsys_z_axis_k";
  *(_DWORD *)v28 = "END";
  for ( i = 0; strcmp(v3, "END"); ++i )
  {
    v29 = UF_MOM_ask_string(a1, v3 + 4, &Str);
    switch ( i )
    {
      case 0:
        v4 = Str;
        if ( !Str )
        {
          v4 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 96) = strtod(v4, 0);
        break;
      case 1:
        v5 = Str;
        if ( !Str )
        {
          v5 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 104) = strtod(v5, 0);
        break;
      case 2:
        v6 = Str;
        if ( !Str )
        {
          v6 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 112) = strtod(v6, 0);
        break;
      case 3:
        v7 = Str;
        if ( !Str )
        {
          v7 = "1.0";
          Str = "1.0";
        }
        *(double *)(a2 + 120) = strtod(v7, 0);
        break;
      case 4:
        v8 = Str;
        if ( !Str )
        {
          v8 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 128) = strtod(v8, 0);
        break;
      case 5:
        v9 = Str;
        if ( !Str )
        {
          v9 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 136) = strtod(v9, 0);
        break;
      case 6:
        v10 = Str;
        if ( !Str )
        {
          v10 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 144) = strtod(v10, 0);
        break;
      case 7:
        v11 = Str;
        if ( !Str )
        {
          v11 = "1.0";
          Str = "1.0";
        }
        *(double *)(a2 + 152) = strtod(v11, 0);
        break;
      case 8:
        v12 = Str;
        if ( !Str )
        {
          v12 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 160) = strtod(v12, 0);
        break;
      case 9:
        v13 = Str;
        if ( !Str )
        {
          v13 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 168) = strtod(v13, 0);
        break;
      case 10:
        v14 = Str;
        if ( !Str )
        {
          v14 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 176) = strtod(v14, 0);
        break;
      case 11:
        v15 = Str;
        if ( !Str )
        {
          v15 = "1.0";
          Str = "1.0";
        }
        *(double *)(a2 + 184) = strtod(v15, 0);
        break;
      default:
        break;
    }
    v3 = (const char *)*(&v17 + i);
  }
  return v29;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10006F40) --------------------------------------------------------
int __cdecl sub_10006F40(int a1, int a2)
{
  int i; // ebx@1
  const char *v3; // esi@1
  char *v4; // eax@3
  char *v5; // eax@6
  char *v6; // eax@9
  char *v7; // eax@12
  char *v8; // eax@15
  char *v9; // eax@18
  char *v10; // eax@21
  int v11; // edx@23
  char v12; // cl@24
  char *v13; // eax@26
  char *v14; // eax@29
  int v16; // [sp+Ch] [bp-28h]@1
  int v17; // [sp+10h] [bp-24h]@1
  int v18; // [sp+14h] [bp-20h]@1
  int v19; // [sp+18h] [bp-1Ch]@1
  int v20; // [sp+1Ch] [bp-18h]@1
  int v21; // [sp+20h] [bp-14h]@1
  int v22; // [sp+24h] [bp-10h]@1
  int v23; // [sp+28h] [bp-Ch]@1
  char v24[4]; // [sp+2Ch] [bp-8h]@1
  char *Str; // [sp+30h] [bp-4h]@2

  v3 = "mom_origin_x";
  v16 = (int)"mom_origin_y";
  v17 = (int)"mom_origin_z";
  v18 = (int)"mom_translate_x";
  v19 = (int)"mom_translate_y";
  v20 = (int)"mom_translate_z";
  v21 = (int)"mom_tool_type";
  v22 = (int)"mom_tool_z_offset";
  v23 = (int)"mom_tool_corner1_radius";
  *(_DWORD *)v24 = "END";
  for ( i = 0; strcmp(v3, "END"); ++i )
  {
    UF_MOM_ask_string(a1, v3 + 4, &Str);
    switch ( i )
    {
      case 0:
        v4 = Str;
        if ( !Str )
        {
          v4 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 216) = strtod(v4, 0);
        break;
      case 1:
        v5 = Str;
        if ( !Str )
        {
          v5 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 224) = strtod(v5, 0);
        break;
      case 2:
        v6 = Str;
        if ( !Str )
        {
          v6 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 232) = strtod(v6, 0);
        break;
      case 3:
        v7 = Str;
        if ( !Str )
        {
          v7 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 192) = strtod(v7, 0);
        break;
      case 4:
        v8 = Str;
        if ( !Str )
        {
          v8 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 200) = strtod(v8, 0);
        break;
      case 5:
        v9 = Str;
        if ( !Str )
        {
          v9 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 208) = strtod(v9, 0);
        break;
      case 6:
        v10 = Str;
        if ( !Str )
        {
          v10 = "MILL";
          Str = "MILL";
        }
        v11 = a2 - (_DWORD)v10 + 240;
        do
        {
          v12 = *v10;
          v10[v11] = *v10;
          ++v10;
        }
        while ( v12 );
        break;
      case 7:
        v13 = Str;
        if ( !Str )
        {
          v13 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 376) = strtod(v13, 0);
        break;
      case 8:
        v14 = Str;
        if ( !Str )
        {
          v14 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 384) = strtod(v14, 0);
        break;
      default:
        break;
    }
    v3 = (const char *)*(&v16 + i);
  }
  return 0;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10007190) --------------------------------------------------------
int __cdecl sub_10007190(int a1, int a2)
{
  int i; // ebx@1
  const char *v3; // esi@1
  char *v4; // eax@3
  char *v5; // eax@6
  char *v6; // eax@9
  char *v7; // eax@12
  char *v8; // eax@15
  char *v9; // eax@18
  int v11; // [sp+Ch] [bp-20h]@1
  int v12; // [sp+10h] [bp-1Ch]@1
  int v13; // [sp+14h] [bp-18h]@1
  int v14; // [sp+18h] [bp-14h]@1
  int v15; // [sp+1Ch] [bp-10h]@1
  char v16[4]; // [sp+20h] [bp-Ch]@1
  int v17; // [sp+24h] [bp-8h]@2
  char *Str; // [sp+28h] [bp-4h]@2

  v3 = "mom_mcs_goto_x";
  v11 = (int)"mom_mcs_goto_y";
  v12 = (int)"mom_mcs_goto_z";
  v13 = (int)"mom_tool_axis_i";
  v14 = (int)"mom_tool_axis_j";
  v15 = (int)"mom_tool_axis_k";
  *(_DWORD *)v16 = "END";
  for ( i = 0; strcmp(v3, "END"); ++i )
  {
    v17 = UF_MOM_ask_string(a1, v3 + 4, &Str);
    switch ( i )
    {
      case 0:
        v4 = Str;
        if ( !Str )
        {
          v4 = "0.0";
          Str = "0.0";
        }
        *(double *)a2 = strtod(v4, 0);
        break;
      case 1:
        v5 = Str;
        if ( !Str )
        {
          v5 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 8) = strtod(v5, 0);
        break;
      case 2:
        v6 = Str;
        if ( !Str )
        {
          v6 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 16) = strtod(v6, 0);
        break;
      case 3:
        v7 = Str;
        if ( !Str )
        {
          v7 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 24) = strtod(v7, 0);
        break;
      case 4:
        v8 = Str;
        if ( !Str )
        {
          v8 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 32) = strtod(v8, 0);
        break;
      case 5:
        v9 = Str;
        if ( !Str )
        {
          v9 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 40) = strtod(v9, 0);
        break;
      default:
        break;
    }
    v3 = (const char *)*(&v11 + i);
  }
  return v17;
}
// 10007190: using guessed type _DWORD __cdecl sub_10007190(_DWORD, _DWORD);
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10007340) --------------------------------------------------------
int __cdecl sub_10007340(int a1, char *Str)
{
  int v2; // ebx@1
  const char *v3; // edi@1
  char *i; // esi@1
  const char *v5; // eax@3
  const char *v6; // eax@6
  const char *v7; // eax@9
  const char *v8; // eax@12
  const char *v9; // eax@15
  const char *v10; // eax@18
  const char *v11; // eax@21
  const char *v12; // eax@24
  const char *v13; // eax@27
  int result; // eax@31
  int v15; // [sp+10h] [bp-28h]@1
  int v16; // [sp+14h] [bp-24h]@1
  int v17; // [sp+18h] [bp-20h]@1
  int v18; // [sp+1Ch] [bp-1Ch]@1
  int v19; // [sp+20h] [bp-18h]@1
  int v20; // [sp+24h] [bp-14h]@1
  int v21; // [sp+28h] [bp-10h]@1
  int v22; // [sp+2Ch] [bp-Ch]@1
  char v23[4]; // [sp+30h] [bp-8h]@1
  int v24; // [sp+34h] [bp-4h]@2

  v3 = "mom_origin_x";
  v15 = (int)"mom_origin_y";
  v16 = (int)"mom_origin_z";
  v17 = (int)"mom_translate_x";
  v18 = (int)"mom_translate_y";
  v19 = (int)"mom_translate_z";
  v20 = (int)"mom_tool_z_offset";
  v21 = (int)"mom_kin_track_center_of_ball";
  v22 = (int)"mom_tool_corner1_radius";
  *(_DWORD *)v23 = "END";
  v2 = 0;
  for ( i = Str; strcmp(v3, "END"); ++v2 )
  {
    v24 = UF_MOM_ask_string(a1, v3 + 4, &Str);
    switch ( v2 )
    {
      case 0:
        v5 = Str;
        if ( !Str )
        {
          v5 = "0.0";
          Str = "0.0";
        }
        *(double *)i = strtod(v5, 0);
        break;
      case 1:
        v6 = Str;
        if ( !Str )
        {
          v6 = "0.0";
          Str = "0.0";
        }
        *((double *)i + 1) = strtod(v6, 0);
        break;
      case 2:
        v7 = Str;
        if ( !Str )
        {
          v7 = "0.0";
          Str = "0.0";
        }
        *((double *)i + 2) = strtod(v7, 0);
        break;
      case 3:
        v8 = Str;
        if ( !Str )
        {
          v8 = "0.0";
          Str = "0.0";
        }
        *((double *)i + 12) = strtod(v8, 0);
        break;
      case 4:
        v9 = Str;
        if ( !Str )
        {
          v9 = "0.0";
          Str = "0.0";
        }
        *((double *)i + 13) = strtod(v9, 0);
        break;
      case 5:
        v10 = Str;
        if ( !Str )
        {
          v10 = "0.0";
          Str = "0.0";
        }
        *((double *)i + 14) = strtod(v10, 0);
        break;
      case 6:
        v11 = Str;
        if ( !Str )
        {
          v11 = "0.0";
          Str = "0.0";
        }
        *((double *)i + 15) = strtod(v11, 0);
        break;
      case 7:
        v12 = Str;
        if ( !Str )
        {
          v12 = "0.0";
          Str = "0.0";
        }
        *((_DWORD *)i + 32) = (signed int)strtod(v12, 0);
        break;
      case 8:
        v13 = Str;
        if ( !Str )
        {
          v13 = "0.0";
          Str = "0.0";
        }
        *((double *)i + 17) = strtod(v13, 0);
        break;
      default:
        break;
    }
    v3 = (const char *)*(&v15 + v2);
  }
  result = v24;
  memcpy(&unk_1000C5E0, i, 0x90u);
  return result;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10007590) --------------------------------------------------------
int __cdecl sub_10007590(int a1, int a2)
{
  int v2; // esi@1
  int v4; // ebx@5
  double v5; // [sp+18h] [bp-78h]@1
  double v6; // [sp+20h] [bp-70h]@1
  double v7; // [sp+28h] [bp-68h]@1
  double v8; // [sp+30h] [bp-60h]@1
  double v9; // [sp+38h] [bp-58h]@1
  double v10; // [sp+40h] [bp-50h]@1
  double v11; // [sp+48h] [bp-48h]@1
  double v12; // [sp+50h] [bp-40h]@1
  double v13; // [sp+58h] [bp-38h]@1
  char v14; // [sp+60h] [bp-30h]@5
  char v15; // [sp+78h] [bp-18h]@5

  v5 = dbl_1000C5F8;
  v8 = dbl_1000C610;
  v2 = a1;
  v11 = dbl_1000C628;
  v6 = dbl_1000C600;
  v9 = dbl_1000C618;
  v12 = dbl_1000C630;
  v7 = dbl_1000C608;
  v10 = dbl_1000C620;
  v13 = dbl_1000C638;
  if ( !dword_1000C670 )
  {
    UF_VEC3_is_equal(
      a1 + 24,
      &dbl_1000C628,
      COERCE_UNSIGNED_INT64(0.00000001),
      COERCE_UNSIGNED_INT64(0.00000001) >> 32,
      &a1);
    if ( !a1 )
    {
      printf("WARNING  The tool axis is not matching with the                 rotated MCS-Z axis. The output may be INCORRECT\n");
      uc1601(
        "WARNING  The tool axis is not matching with the *                     rotated MCS-Z axis. The output may be INCORRECT\n",
        1);
    }
    dword_1000C670 = 1;
  }
  UF_VEC3_copy(v2, &v15);
  UF_VEC3_copy(v2 + 24, &v14);
  v4 = a2;
  UF_MTX3_vec_multiply(v2, &v5, a2);
  UF_MTX3_vec_multiply(v2 + 24, &v5, v4 + 24);
  return 0;
}
// 10007590: using guessed type _DWORD __cdecl sub_10007590(_DWORD, _DWORD);
// 100090E0: using guessed type int __cdecl UF_VEC3_is_equal(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090F4: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);
// 1000910C: using guessed type int __cdecl UF_MTX3_vec_multiply(_DWORD, _DWORD, _DWORD);
// 10009160: using guessed type int __cdecl uc1601(_DWORD, _DWORD);
// 1000C5F8: using guessed type double dbl_1000C5F8;
// 1000C600: using guessed type double dbl_1000C600;
// 1000C608: using guessed type double dbl_1000C608;
// 1000C610: using guessed type double dbl_1000C610;
// 1000C618: using guessed type double dbl_1000C618;
// 1000C620: using guessed type double dbl_1000C620;
// 1000C628: using guessed type double dbl_1000C628;
// 1000C630: using guessed type double dbl_1000C630;
// 1000C638: using guessed type double dbl_1000C638;
// 1000C670: using guessed type int dword_1000C670;

//----- (10007690) --------------------------------------------------------
int __cdecl sub_10007690(int a1, int a2)
{
  char v3; // [sp+1Ch] [bp-18h]@1

  UF_VEC3_add(a1, &unk_1000C640, a2);
  UF_VEC3_sub(a1, &unk_1000C5E0, a2);
  UF_VEC3_copy(a1 + 24, a2 + 24);
  UF_VEC3_scale(LODWORD(dbl_1000C658), HIDWORD(dbl_1000C658), a2 + 24, &v3);
  UF_VEC3_add(a2, &v3, a2);
  if ( dword_1000C660 == 1 )
  {
    UF_VEC3_scale(LODWORD(dbl_1000C668), HIDWORD(dbl_1000C668), a2 + 24, &v3);
    UF_VEC3_add(a2, &v3, a2);
  }
  return 0;
}
// 10007690: using guessed type _DWORD __cdecl sub_10007690(_DWORD, _DWORD);
// 100090C4: using guessed type int __cdecl UF_VEC3_scale(_DWORD, _DWORD, _DWORD, _DWORD);
// 100090EC: using guessed type int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD);
// 100090F4: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);
// 10009100: using guessed type int __cdecl UF_VEC3_add(_DWORD, _DWORD, _DWORD);
// 1000C658: using guessed type double dbl_1000C658;
// 1000C660: using guessed type int dword_1000C660;
// 1000C668: using guessed type double dbl_1000C668;

//----- (10007730) --------------------------------------------------------
int __cdecl sub_10007730(int a1, int a2, int a3)
{
  char *v3; // edi@1
  int v4; // esi@1
  double v5; // st6@1
  long double v6; // st7@1
  int v8; // edi@10
  char *v9; // esi@11
  char v11; // [sp+18h] [bp-150h]@1
  char v12; // [sp+F0h] [bp-78h]@5
  long double v13; // [sp+108h] [bp-60h]@1
  double v14; // [sp+110h] [bp-58h]@1
  double v15; // [sp+118h] [bp-50h]@1
  double v16; // [sp+120h] [bp-48h]@1
  double v17; // [sp+128h] [bp-40h]@1
  double v18; // [sp+130h] [bp-38h]@1
  double v19; // [sp+138h] [bp-30h]@1
  double v20; // [sp+140h] [bp-28h]@1
  double v21; // [sp+148h] [bp-20h]@1
  double v22; // [sp+150h] [bp-18h]@1
  long double v23; // [sp+158h] [bp-10h]@5
  int v24; // [sp+160h] [bp-8h]@1
  int v25; // [sp+164h] [bp-4h]@1

  v14 = 1.0;
  v15 = 0.0;
  v16 = 0.0;
  v17 = 0.0;
  v19 = 0.0;
  v20 = 0.0;
  v21 = 0.0;
  v18 = 1.0;
  v22 = 1.0;
  v6 = asin(1.0) * 0.01111111111111111;
  v25 = 0;
  v13 = v6;
  v3 = &v11;
  v5 = -1.0;
  v4 = a3 + 8;
  v24 = 3;
  do
  {
    if ( (signed int)*(double *)(v4 - 8) == 1 )
    {
      v23 = v6 * *(double *)v4 * v5;
      UF_MTX3_x_vec(&v14, &v12);
    }
    else
    {
      if ( (signed int)*(double *)(v4 - 8) == 2 )
      {
        v23 = v6 * *(double *)v4 * v5;
        UF_MTX3_y_vec(&v14, &v12);
      }
      else
      {
        if ( (signed int)*(double *)(v4 - 8) != 3 )
          goto LABEL_9;
        v23 = v6 * *(double *)v4 * v5;
        UF_MTX3_z_vec(&v14, &v12);
      }
    }
    UF_MTX3_rotate_about_axis(&v12, LODWORD(v23), HIDWORD(v23), v3);
    v6 = v13;
    ++v25;
    v5 = -1.0;
    v3 += 72;
LABEL_9:
    v4 += 16;
  }
  while ( v24-- != 1 );
  v8 = v25;
  if ( v25 > 0 )
  {
    v9 = &v11;
    do
    {
      UF_MTX3_multiply(&v14, v9, &v14);
      v9 += 72;
      --v8;
    }
    while ( v8 );
  }
  *(_QWORD *)(a2 + 24) = *(_QWORD *)&v14;
  *(_QWORD *)(a2 + 48) = *(_QWORD *)&v17;
  dword_1000C670 = 0;
  *(_QWORD *)(a2 + 72) = *(_QWORD *)&v20;
  *(_QWORD *)(a2 + 32) = *(_QWORD *)&v15;
  *(_QWORD *)(a2 + 56) = *(_QWORD *)&v18;
  *(_QWORD *)(a2 + 80) = *(_QWORD *)&v21;
  *(_QWORD *)(a2 + 40) = *(_QWORD *)&v16;
  *(_QWORD *)(a2 + 64) = *(_QWORD *)&v19;
  *(_QWORD *)(a2 + 88) = *(_QWORD *)&v22;
  return 0;
}
// 10007730: could not find valid save-restore pair for edi
// 10007730: could not find valid save-restore pair for esi
// 100090B8: using guessed type int __cdecl UF_MTX3_rotate_about_axis(_DWORD, _DWORD, _DWORD, _DWORD);
// 100090BC: using guessed type int __cdecl UF_MTX3_multiply(_DWORD, _DWORD, _DWORD);
// 100090CC: using guessed type int __cdecl UF_MTX3_z_vec(_DWORD, _DWORD);
// 10009120: using guessed type int __cdecl UF_MTX3_x_vec(_DWORD, _DWORD);
// 10009124: using guessed type int __cdecl UF_MTX3_y_vec(_DWORD, _DWORD);
// 1000C670: using guessed type int dword_1000C670;

//----- (10007D1B) --------------------------------------------------------
int __cdecl sub_10007D1B()
{
  return _clean_type_info_names_internal(&unk_1000C67C);
}
// 10008190: using guessed type int __cdecl _clean_type_info_names_internal(_DWORD);

//----- (10007DE3) --------------------------------------------------------
int (*__cdecl sub_10007DE3())(void)
{
  int (*result)(void); // eax@1
  unsigned int v1; // edi@1

  result = (int (*)(void))&unk_1000AE58;
  v1 = (unsigned int)&unk_1000AE58;
  if ( &unk_1000AE58 < &unk_1000AE58 )
  {
    do
    {
      result = *(int (**)(void))v1;
      if ( *(_DWORD *)v1 )
        result = (int (*)(void))result();
      v1 += 4;
    }
    while ( v1 < (unsigned int)&unk_1000AE58 );
  }
  return result;
}

//----- (10007F96) --------------------------------------------------------
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
  if ( fdwReason == 1 )
  {
    if ( !dword_1000ADA8 )
      DisableThreadLibraryCalls(hinstDLL);
  }
  return 1;
}
// 1000ADA8: using guessed type int dword_1000ADA8;

//----- (10008182) --------------------------------------------------------
int __cdecl sub_10008182()
{
  dword_1000C9AC = unknown_libname_1();
  return 0;
}
// 10008120: using guessed type int unknown_libname_1(void);
// 1000C9AC: using guessed type int dword_1000C9AC;

//----- (100081A8) --------------------------------------------------------
int __thiscall sub_100081A8(void *this, char a2)
{
  if ( this == (void *)dword_1000C238 )
    __asm { rep retn }
  return __report_gsfailure(this, a2);
}
// 100081BE: using guessed type _DWORD __thiscall __report_gsfailure(_DWORD ecx0, _BYTE _4);
// 1000C238: using guessed type int dword_1000C238;

// ALL OK, 55 function(s) have been successfully decompiled
