/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2009 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Data declarations

extern _UNKNOWN unk_10009110; // weak
extern _UNKNOWN unk_10009158; // weak
extern _UNKNOWN unk_100091A0; // weak
extern double dbl_1000A010; // weak
extern char byte_1000A018; // weak
extern char byte_1000A019; // weak
extern char byte_1000A01A; // weak
extern char aInit_t11Init_t[]; // idb
extern char aInit_t10Init_t[]; // idb
extern char aA1FD1FAlpha1FA[]; // idb
extern char aWarningToolAxi[]; // idb
extern char aLocalSecondary[]; // idb
extern char aLocalPrimaryax[]; // idb
extern char aSulzerCase[]; // idb
extern char aMcsysFFFFFFFFF[]; // idb
extern char aTool_vectorFFF[]; // idb
extern char aTool_machine_c[]; // idb
extern char aSecondary_mach[]; // idb
extern char aSecondaryFFF[]; // idb
extern char aPrimary_machin[]; // idb
extern char aPrimaryFFF[]; // idb
extern char aIs_5_axis_head[]; // idb
extern char aIs_5_axis_du_0[21]; // weak
extern char aIs_5_axis_dual[22]; // weak
extern char aIs_orthogonal_[]; // idb
extern char Format[]; // idb
extern char aFinalUfuncAlt_[]; // idb
extern char aFinalUfuncMcoo[]; // idb
extern char aWarningSameVal[]; // idb
extern char aComputingT11FT[]; // idb
extern char aComputingT10FT[]; // idb
extern char aAboutAdjusting[]; // idb
extern char aWarningDegener[]; // idb
extern char aInputPoint_4f_[]; // idb
extern char aStartingOld_pc[]; // idb
extern char asc_1000A4CC[]; // idb
extern char aKin_4th_to_t_1[28]; // weak
extern char aKin_4th_to_t_0[28]; // weak
extern char aKin_4th_to_tra[28]; // weak
extern char a90_0[5]; // weak
extern char a0_0[4]; // weak
extern char a0_0001[7]; // weak
extern char aCartesian[10]; // weak
extern wchar_t asc_1000A57C[2]; // weak
extern char aNone[5]; // weak
extern wchar_t aT[2]; // weak
extern char a3_axis_mill[12]; // weak
extern char aMom_kin_gaug_0[25]; // weak
extern char aMom_kin_line_0[26]; // weak
extern char aMom_kin_5th_14[36]; // weak
extern char aMom_kin_tool_t[29]; // weak
extern char aMom_kin_mach_0[27]; // weak
extern char aMom_kin_linear[27]; // weak
extern char aMom_kin_coordi[24]; // weak
extern char aMom_kin_clsf_g[24]; // weak
extern char aMom_kin_wire_t[30]; // weak
extern char aMom_kin_track_[29]; // weak
extern char aEnd[4]; // weak
extern char aMom_kin_machin[21]; // weak
extern char aMom_kin_gauge_[25]; // weak
extern char a400_00[7]; // weak
extern char aIn[3]; // weak
extern char aMom_kin_rapid_[24]; // weak
extern char aMom_kin_pivot_[27]; // weak
extern char aMom_kin_read_a[31]; // weak
extern char aMom_kin_polar_[26]; // weak
extern char aMom_kin_output[20]; // weak
extern char aMom_kin_nurbs_[26]; // weak
extern char a9999_9999[10]; // weak
extern char aXy[3]; // weak
extern char aFull_circle[12]; // weak
extern char aMom_kin_max_ar[23]; // weak
extern char aMom_kin_min_ar[23]; // weak
extern char aMom_kin_arc_va[24]; // weak
extern char aMom_kin_arc_ou[24]; // weak
extern char a99999_999[10]; // weak
extern char a99_999[7]; // weak
extern char a0_001[6]; // weak
extern char a999_999[8]; // weak
extern char aMom_kin_min_dp[16]; // weak
extern char aMom_kin_max_dp[16]; // weak
extern char aMom_kin_min_fr[16]; // weak
extern char aMom_kin_max_fr[16]; // weak
extern char aMom_kin_min__0[16]; // weak
extern char aMom_kin_max__0[16]; // weak
extern char aMom_kin_min_fp[16]; // weak
extern char aMom_kin_max_fp[16]; // weak
extern char a360_0[6]; // weak
extern char aStandard[9]; // weak
extern char aMagnitude_dete[31]; // weak
extern char aYz[3]; // weak
extern char aMom_kin_4th_13[27]; // weak
extern char aMom_kin_4th_12[27]; // weak
extern char aMom_kin_4th_11[26]; // weak
extern char aMom_kin_4th_10[26]; // weak
extern char aMom_kin_4th__9[26]; // weak
extern char aMom_kin_4th__8[33]; // weak
extern char aMom_kin_4th__7[33]; // weak
extern char aMom_kin_4th__6[33]; // weak
extern char aMom_kin_4th__5[22]; // weak
extern char aMom_kin_4th__4[27]; // weak
extern char aMom_kin_4th__3[27]; // weak
extern char aMom_kin_4th__2[26]; // weak
extern char aMom_kin_4th__1[26]; // weak
extern char aMom_kin_4th__0[27]; // weak
extern char aMom_kin_4th_ax[23]; // weak
extern char aMom_kin_5th_13[27]; // weak
extern char aMom_kin_5th_12[27]; // weak
extern char aMom_kin_5th_11[26]; // weak
extern char aMom_kin_5th_10[26]; // weak
extern char aMom_kin_5th__9[26]; // weak
extern char aMom_kin_5th__8[33]; // weak
extern char aMom_kin_5th__7[33]; // weak
extern char aMom_kin_5th__6[33]; // weak
extern char aMom_kin_5th__5[22]; // weak
extern char aMom_kin_5th__4[27]; // weak
extern char aMom_kin_5th__3[27]; // weak
extern char aMom_kin_5th__2[26]; // weak
extern char aMom_kin_5th__1[26]; // weak
extern char aMom_kin_5th__0[27]; // weak
extern char aMom_kin_5th_ax[23]; // weak
extern char aFront[6]; // weak
extern char aMom_kin_ind__0[32]; // weak
extern char aMom_kin_ind_to[32]; // weak
extern char aMom_kin_indepe[25]; // weak
extern char a3_0[4]; // weak
extern char a0_5[4]; // weak
extern char aMom_kin_flush_[19]; // weak
extern char aMom_kin_clamp_[19]; // weak
extern char aMom_kin_tool_c[25]; // weak
extern char aPosz[]; // idb
extern char aMom_kin_hol_22[25]; // weak
extern char aMom_kin_hol_21[25]; // weak
extern char aMom_kin_hol_20[25]; // weak
extern char aMom_kin_hol_19[25]; // weak
extern char aMom_kin_hol_18[25]; // weak
extern char aMom_kin_hol_17[25]; // weak
extern char aMom_kin_hol_16[25]; // weak
extern char aMom_kin_hol_15[25]; // weak
extern char aMom_kin_hol_14[25]; // weak
extern char aMom_kin_hol_13[25]; // weak
extern char aMom_kin_hol_12[25]; // weak
extern char aMom_kin_hol_11[25]; // weak
extern char aMom_kin_hol_10[25]; // weak
extern char aMom_kin_hold_9[25]; // weak
extern char aMom_kin_hold_8[25]; // weak
extern char aMom_kin_hold_7[25]; // weak
extern char aMom_kin_hold_6[25]; // weak
extern char aMom_kin_hold_5[25]; // weak
extern char aMom_kin_hold_4[28]; // weak
extern char aMom_kin_hold_3[28]; // weak
extern char aMom_kin_hold_2[28]; // weak
extern char aMom_kin_hold_1[28]; // weak
extern char aMom_kin_hold_0[28]; // weak
extern char aMom_kin_holder[28]; // weak
extern char a1_0[4]; // weak
extern char aMom_msys_z_a_1[18]; // weak
extern char aMom_msys_z_a_0[18]; // weak
extern char aMom_msys_z_axi[18]; // weak
extern char aMom_msys_y_a_1[18]; // weak
extern char aMom_msys_y_a_0[18]; // weak
extern char aMom_msys_y_axi[18]; // weak
extern char aMom_msys_x_a_1[18]; // weak
extern char aMom_msys_x_a_0[18]; // weak
extern char aMom_msys_x_axi[18]; // weak
extern char aMom_msys_ori_1[18]; // weak
extern char aMom_msys_ori_0[18]; // weak
extern char aMom_msys_origi[18]; // weak
extern char aMom_mtsys_z__1[19]; // weak
extern char aMom_mtsys_z__0[19]; // weak
extern char aMom_mtsys_z_ax[19]; // weak
extern char aMom_mtsys_y__1[19]; // weak
extern char aMom_mtsys_y__0[19]; // weak
extern char aMom_mtsys_y_ax[19]; // weak
extern char aMom_mtsys_x__1[19]; // weak
extern char aMom_mtsys_x__0[19]; // weak
extern char aMom_mtsys_x_ax[19]; // weak
extern char aMom_mtsys_or_1[19]; // weak
extern char aMom_mtsys_or_0[19]; // weak
extern char aMom_mtsys_orig[19]; // weak
extern char aMill[5]; // weak
extern char aMom_tool_corne[24]; // weak
extern char aMom_tool_z_off[18]; // weak
extern char aMom_tool_type[14]; // weak
extern char aMom_translat_1[16]; // weak
extern char aMom_translat_0[16]; // weak
extern char aMom_translate_[16]; // weak
extern char aMom_origin_z[13]; // weak
extern char aMom_origin_y[13]; // weak
extern char aMom_origin_x[13]; // weak
extern char aMom_tool_axi_1[16]; // weak
extern char aMom_tool_axi_0[16]; // weak
extern char aMom_tool_axis_[16]; // weak
extern char aMom_mcs_goto_z[15]; // weak
extern char aMom_mcs_goto_y[15]; // weak
extern char aMom_mcs_goto_x[15]; // weak
extern char aWarningTheTo_0[119]; // weak
extern char aWarningTheTool[]; // idb
extern char aUf_mom_exten_4[87]; // weak
extern char aMom_exit_kinem[27]; // weak
extern char aUf_mom_exten_3[81]; // weak
extern char aMom_map_to_rot[24]; // weak
extern char aUf_mom_exten_2[75]; // weak
extern char aMom_rotate_mac[21]; // weak
extern char aUf_mom_exten_1[80]; // weak
extern char aMom_get_tool_a[23]; // weak
extern char aUf_mom_exten_0[69]; // weak
extern char aMom_convert_po[18]; // weak
extern char aZV18projsBatch[73]; // weak
extern char aUf_mom_extend_[73]; // weak
extern char aMom_load_kinem[20]; // weak
extern char aErrorUgpostAdv[]; // idb
extern char aReturnedErrorD[]; // idb
extern char aReturnedAD[]; // idb
extern char aSLineDS[]; // idb
extern char aErrorKinematic[]; // idb
extern char aUf_get_release[31]; // weak
extern char aKinematics[11]; // weak
extern char aErrorAdvancedK[]; // idb
extern char aUgpkin[13]; // weak
extern char aRemainingDaysD[]; // idb
extern char aS[]; // idb
extern char aYourLicenseHas[85]; // weak
extern char aExpirationDate[]; // idb
extern char a02d02d04d[]; // idb
extern char aNumberOfArgume[]; // idb
extern char aIncorrectNumbe[]; // idb
extern char aSet_rotd_opera[]; // idb
extern char aSet_rotd_mcs_m[]; // idb
extern char aCaxis[6]; // weak
extern char aBaxis[6]; // weak
extern char aAaxis[6]; // weak
extern char aInsufficientNu[]; // idb
extern char aPos_z[6]; // weak
extern char aPos_y[6]; // weak
extern char aPos_x[6]; // weak
extern char aMom_transfer_g[]; // idb
extern char aMom_process_in[]; // idb
extern char aSet_input_poin[]; // idb
extern char a5_axis_head_ta[]; // idb
extern char a5_axis_dual_he[]; // idb
extern char a5_axis_dual_ta[]; // idb
extern char aNegz[]; // idb
extern char aNegy[]; // idb
extern char aNegx[]; // idb
extern char aPosy[]; // idb
extern char SubStr[]; // idb
extern char aAlt_pos_a2[11]; // weak
extern char aAlt_pos_a1[11]; // weak
extern char aAlt_pos_z[10]; // weak
extern char aAlt_pos_y[10]; // weak
extern char aAlt_pos_x[10]; // weak
extern char aPos_a2[7]; // weak
extern char aPos_a1[7]; // weak
extern char aUf_attr_read_v[]; // idb
extern char aUf_obj_cycle_b[]; // idb
extern char aErrorS[]; // idb
extern char aNoToolNameObta[34]; // weak
extern char aInvalidNumberO[28]; // weak
extern char aTool_attribute[20]; // weak
extern int dword_1000BB84; // weak
extern int dword_1000BB88; // weak
extern __int16 word_1000BB8C; // weak
extern int dword_1000BB90; // weak
extern double dbl_1000BBA0; // weak
extern double dbl_1000BBA8; // weak
extern double dbl_1000BBB0; // weak
extern double dbl_1000BBB8; // weak
extern int dword_1000BBC0; // weak
extern int dword_1000BBC4; // weak
extern int dword_1000BBC8; // weak
extern int dword_1000BBCC; // weak
extern int dword_1000BBD0; // weak
extern int dword_1000BBD4; // weak
extern double dbl_1000BBD8; // weak
extern double dbl_1000BBE0; // weak
extern _UNKNOWN unk_1000BBE8; // weak
extern int dword_1000BC00; // weak
extern _UNKNOWN unk_1000BC08; // weak
extern _UNKNOWN unk_1000BC20; // weak
extern int dword_1000BC38; // weak
extern int dword_1000BC3C; // weak
extern int dword_1000BC40; // weak
extern int dword_1000BC44; // weak
extern _UNKNOWN unk_1000BC48; // weak
extern _UNKNOWN unk_1000BC70; // weak
extern double dbl_1000BCF0; // weak
extern double dbl_1000BCF8; // weak
extern double dbl_1000BD00; // weak
extern double dbl_1000BD08; // weak
extern double dbl_1000BD10; // weak
extern double dbl_1000BD18; // weak
extern double dbl_1000BD20; // weak
extern double dbl_1000BD28; // weak
extern double dbl_1000BD30; // weak
extern double dbl_1000BD38; // weak
extern double dbl_1000BD40; // weak
extern double dbl_1000BD48; // weak
extern int dword_1000BD70; // weak
extern int dword_1000BD74; // weak
extern int dword_1000BD78; // weak
extern int dword_1000BD7C; // weak
extern int dword_1000BD80; // weak
extern int dword_1000BD84; // weak
extern int dword_1000BD88; // weak
extern int dword_1000BD8C; // weak
extern int dword_1000BD90; // weak
extern int dword_1000BD94; // weak
extern int dword_1000BD98; // weak
extern int dword_1000BD9C; // weak
extern int dword_1000BDA0; // weak
extern int dword_1000BDA4; // weak
extern int dword_1000BDA8; // weak
extern int dword_1000BDAC; // weak
extern __int64 qword_1000BDB0; // weak
extern __int64 qword_1000BDB8; // weak
extern __int64 qword_1000BDC0; // weak
extern int dword_1000BDC8; // weak
extern int dword_1000BDCC; // weak
extern _UNKNOWN unk_1000BDD0; // weak
extern __int64 qword_1000BDF8; // weak
extern __int64 qword_1000BE00; // weak
extern __int64 qword_1000BE08; // weak
extern __int64 qword_1000BE10; // weak
extern _UNKNOWN unk_1000BE18; // weak
extern __int64 qword_1000BE20; // weak
extern _UNKNOWN unk_1000BEB0; // weak
extern int dword_1000BEC8; // weak
extern int dword_1000BECC; // weak
extern int dword_1000BED0; // weak
extern int dword_1000BED4; // weak
extern __int64 qword_1000BED8; // weak
extern __int64 qword_1000BEE0; // weak
extern double dbl_1000BEE8; // weak
extern int dword_1000BEF0; // weak
extern double dbl_1000BEF8; // weak
extern double dbl_1000BF00; // weak
extern double dbl_1000BF10; // weak
extern double dbl_1000BF18; // weak
extern double dbl_1000BF20; // weak
extern double dbl_1000BF28; // weak
extern double dbl_1000BF30; // weak
extern double dbl_1000BF38; // weak
extern char byte_1000BF40; // weak
extern _UNKNOWN unk_1000BF48; // weak
extern int dword_1000BF60; // weak
extern int dword_1000BF64; // weak
extern int dword_1000BF78; // weak
extern int dword_1000BF7C; // weak
extern int dword_1000BF90; // weak
extern int dword_1000BF94; // weak
extern _UNKNOWN unk_1000BFA8; // weak
extern int dword_1000BFC0; // weak
extern int dword_1000BFC4; // weak
extern int dword_1000BFC8; // weak
extern int dword_1000BFD0; // weak
extern int dword_1000BFD4; // weak
extern int dword_1000BFDC; // weak
extern int dword_1000BFE0; // weak
extern int dword_1000BFF4; // weak

//-------------------------------------------------------------------------
// Function declarations

signed int __cdecl sub_10001000(const void *a1, const void *a2, int a3, int a4, int a5, int a6, const void *a7, const void *a8, const void *a9);
int __cdecl sub_10001F10(int a1, int a2, char a3, int a4, int a5);
signed int __cdecl sub_10001F50(int a1, int a2);
int __cdecl sub_10002060(const void *a1, const void *a2, int a3);
double __cdecl sub_10002140(int a1, int a2, int a3);
signed int __cdecl sub_10002170(int a1, int a2, int a3);
void __cdecl sub_100023B0(int a1, int a2, int a3, int a4);
double __cdecl sub_10002500(double a1);
int __cdecl sub_10002530(int a1);
signed int __cdecl sub_10002590(const void *a1, int a2, void *a3);
// int __cdecl sub_100035B0(double); idb
int __cdecl sub_10003600(const void *a1, double a2, double a3, void *a4, signed int a5);
int __cdecl sub_100037A0(int, double, int, int, int); // idb
int __cdecl sub_10003820(int a1, long double a2, int a3);
int __cdecl sub_10003870(long double a1, int a2, int a3);
int __cdecl sub_10003990(const void *a1, int a2, int a3);
signed int __cdecl PtFuncCompare(int a1, int a2);
void __cdecl sub_10003CD0(int a1, int a2);
int __cdecl sub_10003EC0(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_10004150(int a1, int a2, int a3, int a4);
signed int __cdecl sub_10004230(int a1, int a2, int a3, int a4);
int __cdecl sub_10004510(int a1, int a2, int a3, int a4);
double __cdecl sub_10004600(int a1, long double *a2);
signed int __cdecl sub_100046A0(int a1);
signed int __cdecl sub_100046E0(int a1);
int __cdecl sub_10004810(int a1, int a2);
int __cdecl sub_10004C90(int a1, int a2, char a3);
int __cdecl sub_10004CB0(int, char *Str); // idb
int __cdecl sub_10004EF0(int, char *Str); // idb
int __cdecl sub_100050A0(int, char *Str); // idb
int __cdecl sub_100052F0(int a1, int a2);
int __cdecl sub_10005700(int a1, int a2);
int __cdecl sub_10005B10(int, char *Str); // idb
int __cdecl sub_10005C60(int, char *Str); // idb
int __cdecl sub_10005DA0(int a1, int a2);
int __cdecl sub_100063B0(int a1, int a2);
int __cdecl sub_100066D0(int a1, int a2);
int __cdecl sub_10006A00(int, char *Str); // idb
int __cdecl sub_10006CA0(int, char *Str); // idb
int __cdecl sub_10006E90(int a1, int a2);
int __cdecl sub_10007130(int a1, int a2);
int __cdecl sub_10007220(int a1, int a2);
int __cdecl sub_100072C0(int a1, int a2, int a3);
int __cdecl ufusr(int a1, int a2);
int __cdecl sub_10007670(int a1, int a2, int a3, int a4);
int __cdecl sub_100076F0(char *Dest); // idb
signed int __cdecl sub_100077B0();
// int UF_terminate(); weak
signed int __cdecl sub_100078F0(int a1, int a2, signed int a3, int a4);
int __cdecl sub_10007B50(int a1);
signed int __cdecl sub_10007C40(int a1);
int __cdecl sub_100081E0(int a1);
signed int __cdecl sub_10008300(int a1, int a2, int a3, int a4);
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
// BOOL __stdcall DisableThreadLibraryCalls(HMODULE hLibModule);
// char *__cdecl strstr(const char *Str, const char *SubStr);
// int __cdecl atoi(const char *Str);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Memory);
// time_t __cdecl mktime(struct tm *Tm);
// struct tm *__cdecl localtime(const time_t *Time);
// time_t __cdecl time(time_t *Time);
// int sprintf(char *Dest, const char *Format, ...);
// double __cdecl strtod(const char *Str, char **EndPtr);
// double __cdecl ceil(double x); idb
// double __cdecl floor(double x); idb
// void __cdecl qsort(void *Base, size_t NumOfElements, size_t SizeOfElements, int (__cdecl *PtFuncCompare)(const void *, const void *));
// int printf(const char *Format, ...);
// int __cdecl UF_MTX4_vec3_multiply_t(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_free(_DWORD); weak
// int __cdecl UF_MTX4_rotation(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_ask_rotation(_DWORD, _DWORD); weak
// int __cdecl UF_allocate_memory(_DWORD, _DWORD); weak
// int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_rotate_about_axis(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MOM_extend_xlator(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_edit_rotation(_DWORD, _DWORD); weak
// int __cdecl UF_MTX4_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_vec3_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_get_fail_message(_DWORD, _DWORD); weak
// int __cdecl UF_get_release(_DWORD); weak
// int UF_initialize(void); weak
// int __cdecl UF_MISC_set_program_name(_DWORD); weak
// int __cdecl UF_MOM_set_double(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MOM_set_string(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_ATTR_read_value(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_OBJ_cycle_by_name(_DWORD, _DWORD); weak
// int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_dot(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_vec_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_is_zero(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_affine_comb(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_add(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_scale(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_angle_between(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_copy(_DWORD, _DWORD); weak
// int __cdecl UF_MTX4_csys_to_csys(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_copy(_DWORD, _DWORD); weak
// int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_is_parallel(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_cross(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_x_vec(_DWORD, _DWORD); weak
// int __cdecl UF_MTX3_y_vec(_DWORD, _DWORD); weak
// int __cdecl UF_MTX3_z_vec(_DWORD, _DWORD); weak
// int __cdecl UF_VEC3_is_equal(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_vec_multiply_t(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_distance(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_vec_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MOM_ask_mom(_DWORD, _DWORD); weak
// int __cdecl UF_MOM_ask_interp_from_param(_DWORD, _DWORD); weak
// int UF_terminate(void); weak
// int __cdecl uc1601(_DWORD, _DWORD); weak


//----- (10001000) --------------------------------------------------------
signed int __cdecl sub_10001000(const void *a1, const void *a2, int a3, int a4, int a5, int a6, const void *a7, const void *a8, const void *a9)
{
  int v9; // eax@1
  signed int result; // eax@4
  int (*v11)(const char *, ...); // edi@8
  const void *v12; // esi@13
  double v13; // st7@38
  signed int v14; // eax@41
  int v15; // edx@41
  double v16; // st7@42
  char *v17; // ecx@42
  double v18; // st7@42
  double v19; // st6@42
  double v20; // st6@42
  int v21; // ecx@42
  int v22; // ecx@42
  double v23; // st7@42
  signed int v24; // eax@53
  int v25; // edx@53
  double v26; // st7@54
  char *v27; // ecx@54
  double v28; // st7@54
  double v29; // st6@54
  double v30; // st6@54
  int v31; // ecx@54
  int v32; // ecx@54
  double v33; // st7@54
  void (*v34)(const char *, ...); // ebx@66
  const char *v35; // [sp+1Ch] [bp-244h]@9
  char v36; // [sp+2Fh] [bp-231h]@5
  char v37; // [sp+30h] [bp-230h]@5
  char v38; // [sp+36h] [bp-22Ah]@5
  char v39; // [sp+37h] [bp-229h]@5
  long double v40; // [sp+38h] [bp-228h]@1
  double v41; // [sp+40h] [bp-220h]@25
  double v42; // [sp+48h] [bp-218h]@1
  double v43; // [sp+50h] [bp-210h]@1
  double v44; // [sp+68h] [bp-1F8h]@1
  int v45; // [sp+80h] [bp-1E0h]@16
  int v46; // [sp+84h] [bp-1DCh]@25
  char v47; // [sp+88h] [bp-1D8h]@7
  double v48; // [sp+98h] [bp-1C8h]@54
  char v49; // [sp+A0h] [bp-1C0h]@1
  char v50; // [sp+B8h] [bp-1A8h]@43
  char v51; // [sp+D0h] [bp-190h]@6
  double v52; // [sp+E0h] [bp-180h]@42
  char v53; // [sp+E8h] [bp-178h]@16
  double v54; // [sp+F8h] [bp-168h]@42
  char v55; // [sp+118h] [bp-148h]@43
  char v56; // [sp+130h] [bp-130h]@43
  double v57; // [sp+138h] [bp-128h]@42
  char v58; // [sp+140h] [bp-120h]@16
  double v59; // [sp+150h] [bp-110h]@42
  int v60; // [sp+168h] [bp-F8h]@42
  int v61; // [sp+16Ch] [bp-F4h]@42
  char v62; // [sp+170h] [bp-F0h]@43
  double v63; // [sp+180h] [bp-E0h]@42
  int v64; // [sp+198h] [bp-C8h]@42
  int v65; // [sp+19Ch] [bp-C4h]@42
  char v66; // [sp+1A0h] [bp-C0h]@43
  double v67; // [sp+1B0h] [bp-B0h]@42
  char v68; // [sp+1D0h] [bp-90h]@16
  char v69; // [sp+1E8h] [bp-78h]@69
  char v70; // [sp+200h] [bp-60h]@65
  char v71; // [sp+218h] [bp-48h]@65
  char v72; // [sp+230h] [bp-30h]@65
  char v73; // [sp+248h] [bp-18h]@65

  memcpy(&unk_1000BBE8, (const void *)a3, 0x18u);
  memcpy(&unk_1000BC08, (const void *)a5, 0x18u);
  LODWORD(v42) = 0;
  UF_VEC3_copy(a4, &v44);
  UF_VEC3_copy(a6, &v43);
  UF_VEC3_copy(a8, &v49);
  byte_1000BF40 = 0;
  *(_QWORD *)&dbl_1000BF10 = 0i64;
  *(_QWORD *)&dbl_1000BF18 = 0i64;
  *(_QWORD *)&dbl_1000BF20 = 0i64;
  *(_QWORD *)&dbl_1000BF28 = 0i64;
  *(_QWORD *)&dbl_1000BF30 = 0i64;
  *(_QWORD *)&dbl_1000BF38 = 0i64;
  memcpy(&unk_1000BE18, a9, 0x98u);
  dword_1000BEF0 = (int)&unk_1000BE18;
  *(_QWORD *)&dbl_1000A010 = qword_1000BE20;
  memcpy(&dword_1000BD70, a2, 0x60u);
  *(_QWORD *)&dbl_1000BBB8 = 0i64;
  *(_QWORD *)&dbl_1000BBB0 = 0i64;
  *(_QWORD *)&dbl_1000BBA8 = 0i64;
  *(_QWORD *)&dbl_1000BBA0 = 0i64;
  qword_1000BE10 = 0i64;
  qword_1000BE08 = 0i64;
  qword_1000BE00 = 0i64;
  qword_1000BDF8 = 0i64;
  UF_VEC3_unitize(a4, qword_1000BE20, HIDWORD(qword_1000BE20), &v40, &qword_1000BED8);
  UF_VEC3_unitize(a6, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v40, &dword_1000BBC0);
  byte_1000A019 = 1;
  memset(&unk_1000BC20, 0, 0x28u);
  memset(&unk_1000BEB0, 0, 0x28u);
  byte_1000A01A = 1;
  v9 = *(_DWORD *)dword_1000BEF0;
  if ( *(_DWORD *)dword_1000BEF0 != 1 && v9 != 2 && v9 != 3 )
    return 2;
  UF_VEC3_is_parallel(&v44, &v43, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v37);
  v39 = v37;
  UF_VEC3_is_parallel(&v44, &v49, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v37);
  v38 = v37;
  UF_VEC3_is_parallel(&v43, &v49, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v37);
  v36 = v37;
  if ( !v38 )
    sub_10001F10((int)&v44, (int)&v49, SLOBYTE(v40), SHIDWORD(v40), (int)&v51);
  UF_VEC3_cross(&v44, &v43, &v47);
  UF_VEC3_is_parallel(&v47, &v49, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v37);
  byte_1000A018 = v37;
  if ( byte_1000BF40 )
  {
    v11 = printf;
    ((void (__cdecl *)(_DWORD))printf)("\n\n======================================================================\n");
    printf("Is_orthogonal_case = %d, ", (unsigned __int8)byte_1000A018);
    if ( *(_DWORD *)dword_1000BEF0 == 2 )
    {
      v35 = "is_5_axis_dual_table\n";
    }
    else
    {
      if ( *(_DWORD *)dword_1000BEF0 == 1 )
        v35 = "is_5_axis_dual_head\n";
      else
        v35 = "is_5_axis_head_table\n";
    }
    printf(v35);
    printf(
      "primary=(%f,%f,%f)\n",
      *(_DWORD *)a4,
      *(_DWORD *)(a4 + 4),
      *(_DWORD *)(a4 + 8),
      *(_DWORD *)(a4 + 12),
      *(_DWORD *)(a4 + 16),
      *(_DWORD *)(a4 + 20));
    printf(
      "primary_machine_center=(%f,%f,%f)\n",
      *(_DWORD *)a3,
      *(_DWORD *)(a3 + 4),
      *(_DWORD *)(a3 + 8),
      *(_DWORD *)(a3 + 12),
      *(_DWORD *)(a3 + 16),
      *(_DWORD *)(a3 + 20));
    printf(
      "secondary=(%f,%f,%f)\n",
      *(_DWORD *)a6,
      *(_DWORD *)(a6 + 4),
      *(_DWORD *)(a6 + 8),
      *(_DWORD *)(a6 + 12),
      *(_DWORD *)(a6 + 16),
      *(_DWORD *)(a6 + 20));
    printf(
      "secondary_machine_center=(%f,%f,%f)\n",
      *(_DWORD *)a5,
      *(_DWORD *)(a5 + 4),
      *(_DWORD *)(a5 + 8),
      *(_DWORD *)(a5 + 12),
      *(_DWORD *)(a5 + 16),
      *(_DWORD *)(a5 + 20));
    printf(
      "tool_machine_center=(%f,%f,%f)\n",
      *(_DWORD *)a7,
      *((_DWORD *)a7 + 1),
      *((_DWORD *)a7 + 2),
      *((_DWORD *)a7 + 3),
      *((_DWORD *)a7 + 4),
      *((_DWORD *)a7 + 5));
    v12 = a8;
    printf(
      "tool_vector=(%f,%f,%f)\n",
      *(_DWORD *)a8,
      *((_DWORD *)a8 + 1),
      *((_DWORD *)a8 + 2),
      *((_DWORD *)a8 + 3),
      *((_DWORD *)a8 + 4),
      *((_DWORD *)a8 + 5));
    printf(
      "Mcsys= (%f,%f,%f) (%f,%f,%f) (%f,%f,%f)  (%f,%f,%f)\n",
      dword_1000BD70,
      dword_1000BD74,
      dword_1000BD78,
      dword_1000BD7C,
      dword_1000BD80,
      dword_1000BD84,
      dword_1000BD88,
      dword_1000BD8C,
      dword_1000BD90,
      dword_1000BD94,
      dword_1000BD98,
      dword_1000BD9C,
      dword_1000BDA0,
      dword_1000BDA4,
      dword_1000BDA8,
      dword_1000BDAC,
      qword_1000BDB0,
      qword_1000BDB8,
      qword_1000BDC0,
      dword_1000BDC8,
      dword_1000BDCC);
  }
  else
  {
    v11 = printf;
    v12 = a8;
  }
  dword_1000BC00 = -1;
  if ( *(_DWORD *)dword_1000BEF0 == 3 )
  {
    UF_MTX3_x_vec(&unk_10009110, &v53);
    UF_MTX3_y_vec(&unk_10009110, &v58);
    UF_MTX3_z_vec(&unk_10009110, &v68);
    UF_VEC3_is_equal(v12, &v68, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v45);
    if ( v45 )
    {
      UF_VEC3_is_equal(a4, &v53, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), (char *)&v42 + 4);
      UF_VEC3_is_equal(a6, &v58, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v46);
      UF_VEC3_is_equal(a6, &v68, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v41);
      if ( HIDWORD(v42) && v46 )
      {
        result = LODWORD(v42);
        dword_1000BC00 = 0;
        byte_1000A019 = 0;
      }
      else
      {
        if ( LODWORD(v41) )
        {
          result = LODWORD(v42);
          dword_1000BC00 = 1;
          byte_1000A019 = 0;
        }
        else
        {
          LODWORD(v42) = 2;
          result = 2;
          byte_1000A019 = 0;
        }
      }
      return result;
    }
    UF_VEC3_is_equal(v12, &v58, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v42);
    UF_VEC3_is_equal(&v44, &v68, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), (char *)&v42 + 4);
    if ( byte_1000A018 || !v36 || !LODWORD(v42) || !HIDWORD(v42) )
      return 2;
    dword_1000BC00 = 3;
    UF_MTX3_vec_multiply_t(&qword_1000BED8, &unk_100091A0, &qword_1000BED8);
    UF_MTX3_vec_multiply_t(&dword_1000BBC0, &unk_100091A0, &dword_1000BBC0);
    if ( byte_1000BF40 )
    {
      ((void (__cdecl *)(_DWORD))v11)("Sulzer case:\n");
      v11("local PrimaryAxis=(%f,%f,%f)\n", qword_1000BED8, qword_1000BEE0, *(_QWORD *)&dbl_1000BEE8);
      v11(
        "local SecondaryAxis=(%f,%f,%f)\n",
        dword_1000BBC0,
        dword_1000BBC4,
        dword_1000BBC8,
        dword_1000BBCC,
        dword_1000BBD0,
        dword_1000BBD4);
    }
  }
  if ( v39 )
  {
    *(_QWORD *)&dbl_1000BF30 = 0i64;
  }
  else
  {
    sub_10001F10((int)&v44, (int)&v43, SLOBYTE(v40), SHIDWORD(v40), (int)&v51);
    dbl_1000BF30 = sub_10002140((int)&v44, (int)&v43, (int)&v51);
  }
  if ( v36 )
  {
    ((void (__cdecl *)(_DWORD))v11)("WARNING: Tool axis is parallelled with secondary axis that may cause unresolved rotaries");
    *(_QWORD *)&dbl_1000BF38 = 0i64;
  }
  else
  {
    if ( fabs(dbl_1000BF30) <= dbl_1000A010 )
    {
      sub_10001F10((int)&v43, (int)&v49, SLOBYTE(v40), SHIDWORD(v40), (int)&v51);
      if ( fabs(v40) <= dbl_1000A010 )
        return 3;
    }
    if ( byte_1000A018 )
    {
      sub_10001F10((int)&v43, (int)&v49, SLOBYTE(v40), SHIDWORD(v40), (int)&v53);
      v13 = sub_10002140((int)&v43, (int)&v49, (int)&v53);
    }
    else
    {
      v13 = sub_10002140((int)&v43, (int)&v49, (int)&v51);
    }
    dbl_1000BF38 = v13;
  }
  v15 = a3 - (_DWORD)&v44;
  v14 = 0;
  do
  {
    v16 = *(double *)((char *)&v44 + v14) * 1000000.0;
    v17 = (char *)&v44 + v14;
    v14 += 8;
    *(double *)((char *)&v52 + v14) = v16 + *(double *)&v17[v15];
    v18 = *(double *)&v17[v15] - v16;
    *(_QWORD *)((char *)&v54 + v14) = *(_QWORD *)&v18;
    v19 = *(double *)((char *)&v42 + v14) * 1000000.0;
    *(double *)((char *)&v57 + v14) = v19 + *(double *)(v14 + a5 - 8);
    v20 = *(double *)(v14 + a5 - 8) - v19;
    *(int *)((char *)&v64 + v14) = *(_DWORD *)((char *)&v52 + v14);
    v21 = *(_DWORD *)((char *)&v52 + v14 + 4);
    v41 = v20;
    *(_QWORD *)((char *)&v59 + v14) = *(_QWORD *)&v20;
    *(int *)((char *)&v65 + v14) = v21;
    v22 = *(_DWORD *)((char *)&v57 + v14);
    *(_QWORD *)((char *)&v67 + v14) = *(_QWORD *)&v18;
    v23 = v41;
    *(int *)((char *)&v60 + v14) = v22;
    *(int *)((char *)&v61 + v14) = *(_DWORD *)((char *)&v57 + v14 + 4);
    *(_QWORD *)((char *)&v63 + v14) = *(_QWORD *)&v23;
  }
  while ( v14 < 24 );
  if ( sub_10003EC0((int)&v66, (int)&v62, (int)&v55, (int)&v50, (int)&v57, (int)&v56) )
  {
    result = 5;
  }
  else
  {
    UF_VEC3_distance(&v55, &v50, &dbl_1000BF10);
    if ( dbl_1000A010 >= dbl_1000BF10 )
    {
      *(_QWORD *)&dbl_1000BF10 = 0i64;
    }
    else
    {
      UF_VEC3_sub(&v50, &v55, &v47);
      UF_VEC3_dot(&v47, &v51, &v41);
      if ( v41 < 0.0 )
        dbl_1000BF10 = -dbl_1000BF10;
    }
    UF_VEC3_distance(&v50, a3, &dbl_1000BF18);
    if ( dbl_1000A010 >= dbl_1000BF18 )
    {
      *(_QWORD *)&dbl_1000BF18 = 0i64;
    }
    else
    {
      UF_VEC3_sub(&v50, a3, &v47);
      UF_VEC3_dot(&v47, &v44, &v41);
      if ( v41 < 0.0 )
        dbl_1000BF18 = -dbl_1000BF18;
    }
    v25 = a5 - (_DWORD)&v43;
    v24 = 0;
    do
    {
      v26 = *(double *)((char *)&v43 + v24) * 1000000.0;
      v27 = (char *)&v43 + v24;
      v24 += 8;
      *(double *)((char *)&v52 + v24) = v26 + *(double *)&v27[v25];
      v28 = *(double *)&v27[v25] - v26;
      *(_QWORD *)((char *)&v54 + v24) = *(_QWORD *)&v28;
      v29 = *(double *)((char *)&v48 + v24) * 1000000.0;
      *(double *)((char *)&v57 + v24) = v29 + *(double *)(a7 + v24 - 8);
      v30 = *(double *)(a7 + v24 - 8) - v29;
      *(int *)((char *)&v64 + v24) = *(_DWORD *)((char *)&v52 + v24);
      v31 = *(_DWORD *)((char *)&v52 + v24 + 4);
      v41 = v30;
      *(_QWORD *)((char *)&v59 + v24) = *(_QWORD *)&v30;
      *(int *)((char *)&v65 + v24) = v31;
      v32 = *(_DWORD *)((char *)&v57 + v24);
      *(_QWORD *)((char *)&v67 + v24) = *(_QWORD *)&v28;
      v33 = v41;
      *(int *)((char *)&v60 + v24) = v32;
      *(int *)((char *)&v61 + v24) = *(_DWORD *)((char *)&v57 + v24 + 4);
      *(_QWORD *)((char *)&v63 + v24) = *(_QWORD *)&v33;
    }
    while ( v24 < 24 );
    if ( sub_10003EC0((int)&v66, (int)&v62, (int)&v55, (int)&v50, (int)&v57, (int)&v56) )
    {
      result = 5;
    }
    else
    {
      UF_VEC3_distance(&v55, &v50, &dbl_1000BF20);
      if ( dbl_1000A010 >= dbl_1000BF20 )
      {
        *(_QWORD *)&dbl_1000BF20 = 0i64;
      }
      else
      {
        UF_VEC3_sub(&v50, &v55, &v47);
        UF_VEC3_dot(&v47, &v51, &v41);
        if ( v41 < 0.0 )
          dbl_1000BF20 = -dbl_1000BF20;
      }
      UF_VEC3_distance(&v50, a7, &dbl_1000BF28);
      if ( dbl_1000A010 >= dbl_1000BF28 )
      {
        *(_QWORD *)&dbl_1000BF28 = 0i64;
      }
      else
      {
        UF_VEC3_sub(&v50, a7, &v47);
        UF_VEC3_dot(&v47, &v43, &v41);
        if ( v41 < 0.0 )
          dbl_1000BF28 = -dbl_1000BF28;
      }
      memcpy(&v70, (const void *)a3, 0x18u);
      sub_10001F10((int)&v44, (int)&v43, SLOBYTE(v40), SHIDWORD(v40), (int)&v71);
      memcpy(&v73, &v44, 0x18u);
      sub_10001F10((int)&v44, (int)&v71, SLOBYTE(v40), SHIDWORD(v40), (int)&v72);
      sub_10002060(a1, &v70, (int)&unk_1000BC70);
      sub_10001F50((int)&unk_1000BC70, (int)&dbl_1000BCF0);
      dbl_1000BBE0 = sin(dbl_1000BF30);
      dbl_1000BBD8 = sin(dbl_1000BF38);
      dbl_1000BEF8 = cos(dbl_1000BF30);
      dbl_1000BF00 = cos(dbl_1000BF38);
      if ( byte_1000BF40 )
      {
        v34 = printf;
        printf(
          "A1=%f,D1=%f,Alpha1=%f,A2=%f,D2=%f,Alpha2=%f\n",
          *(_QWORD *)&dbl_1000BF10,
          *(_QWORD *)&dbl_1000BF18,
          dbl_1000BF30 * 57.29577951308235,
          *(_QWORD *)&dbl_1000BF20,
          *(_QWORD *)&dbl_1000BF28);
      }
      else
      {
        v34 = printf;
      }
      if ( *(_DWORD *)dword_1000BEF0 == 2 )
      {
        memcpy(&v68, a7, 0x18u);
        memcpy(&v69, a8, 0x18u);
        sub_10002590(&v68, (int)&v58, &v53);
        if ( byte_1000BF40 )
        {
          v34(
            "Init_T1[0], Init_T2[0] = (%f,%f)\n",
            COERCE_UNSIGNED_INT64(dbl_1000BBB0 * 57.29577951308235),
            COERCE_UNSIGNED_INT64(dbl_1000BBB0 * 57.29577951308235) >> 32,
            COERCE_UNSIGNED_INT64(dbl_1000BBA0 * 57.29577951308235),
            COERCE_UNSIGNED_INT64(dbl_1000BBA0 * 57.29577951308235) >> 32);
          v34(
            "Init_T1[1], Init_T2[1] = (%f,%f)\n",
            COERCE_UNSIGNED_INT64(dbl_1000BBB8 * 57.29577951308235),
            COERCE_UNSIGNED_INT64(dbl_1000BBB8 * 57.29577951308235) >> 32,
            COERCE_UNSIGNED_INT64(dbl_1000BBA8 * 57.29577951308235),
            COERCE_UNSIGNED_INT64(dbl_1000BBA8 * 57.29577951308235) >> 32);
        }
      }
      byte_1000A019 = 0;
      result = 0;
    }
  }
  return result;
}
// 100090A4: using guessed type int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD);
// 100090A8: using guessed type int __cdecl UF_VEC3_dot(_DWORD, _DWORD, _DWORD);
// 100090CC: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);
// 100090D0: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090D4: using guessed type int __cdecl UF_VEC3_is_parallel(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090D8: using guessed type int __cdecl UF_VEC3_cross(_DWORD, _DWORD, _DWORD);
// 100090DC: using guessed type int __cdecl UF_MTX3_x_vec(_DWORD, _DWORD);
// 100090E0: using guessed type int __cdecl UF_MTX3_y_vec(_DWORD, _DWORD);
// 100090E4: using guessed type int __cdecl UF_MTX3_z_vec(_DWORD, _DWORD);
// 100090E8: using guessed type int __cdecl UF_VEC3_is_equal(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090EC: using guessed type int __cdecl UF_MTX3_vec_multiply_t(_DWORD, _DWORD, _DWORD);
// 100090F0: using guessed type int __cdecl UF_VEC3_distance(_DWORD, _DWORD, _DWORD);
// 1000A010: using guessed type double dbl_1000A010;
// 1000A018: using guessed type char byte_1000A018;
// 1000A019: using guessed type char byte_1000A019;
// 1000A01A: using guessed type char byte_1000A01A;
// 1000BBA0: using guessed type double dbl_1000BBA0;
// 1000BBA8: using guessed type double dbl_1000BBA8;
// 1000BBB0: using guessed type double dbl_1000BBB0;
// 1000BBB8: using guessed type double dbl_1000BBB8;
// 1000BBC0: using guessed type int dword_1000BBC0;
// 1000BBC4: using guessed type int dword_1000BBC4;
// 1000BBC8: using guessed type int dword_1000BBC8;
// 1000BBCC: using guessed type int dword_1000BBCC;
// 1000BBD0: using guessed type int dword_1000BBD0;
// 1000BBD4: using guessed type int dword_1000BBD4;
// 1000BBD8: using guessed type double dbl_1000BBD8;
// 1000BBE0: using guessed type double dbl_1000BBE0;
// 1000BC00: using guessed type int dword_1000BC00;
// 1000BCF0: using guessed type double dbl_1000BCF0;
// 1000BD70: using guessed type int dword_1000BD70;
// 1000BD74: using guessed type int dword_1000BD74;
// 1000BD78: using guessed type int dword_1000BD78;
// 1000BD7C: using guessed type int dword_1000BD7C;
// 1000BD80: using guessed type int dword_1000BD80;
// 1000BD84: using guessed type int dword_1000BD84;
// 1000BD88: using guessed type int dword_1000BD88;
// 1000BD8C: using guessed type int dword_1000BD8C;
// 1000BD90: using guessed type int dword_1000BD90;
// 1000BD94: using guessed type int dword_1000BD94;
// 1000BD98: using guessed type int dword_1000BD98;
// 1000BD9C: using guessed type int dword_1000BD9C;
// 1000BDA0: using guessed type int dword_1000BDA0;
// 1000BDA4: using guessed type int dword_1000BDA4;
// 1000BDA8: using guessed type int dword_1000BDA8;
// 1000BDAC: using guessed type int dword_1000BDAC;
// 1000BDB0: using guessed type __int64 qword_1000BDB0;
// 1000BDB8: using guessed type __int64 qword_1000BDB8;
// 1000BDC0: using guessed type __int64 qword_1000BDC0;
// 1000BDC8: using guessed type int dword_1000BDC8;
// 1000BDCC: using guessed type int dword_1000BDCC;
// 1000BDF8: using guessed type __int64 qword_1000BDF8;
// 1000BE00: using guessed type __int64 qword_1000BE00;
// 1000BE08: using guessed type __int64 qword_1000BE08;
// 1000BE10: using guessed type __int64 qword_1000BE10;
// 1000BE20: using guessed type __int64 qword_1000BE20;
// 1000BED8: using guessed type __int64 qword_1000BED8;
// 1000BEE0: using guessed type __int64 qword_1000BEE0;
// 1000BEE8: using guessed type double dbl_1000BEE8;
// 1000BEF0: using guessed type int dword_1000BEF0;
// 1000BEF8: using guessed type double dbl_1000BEF8;
// 1000BF00: using guessed type double dbl_1000BF00;
// 1000BF10: using guessed type double dbl_1000BF10;
// 1000BF18: using guessed type double dbl_1000BF18;
// 1000BF20: using guessed type double dbl_1000BF20;
// 1000BF28: using guessed type double dbl_1000BF28;
// 1000BF30: using guessed type double dbl_1000BF30;
// 1000BF38: using guessed type double dbl_1000BF38;
// 1000BF40: using guessed type char byte_1000BF40;

//----- (10001F10) --------------------------------------------------------
int __cdecl sub_10001F10(int a1, int a2, char a3, int a4, int a5)
{
  int v6; // esi@1

  v6 = a5;
  UF_VEC3_cross(a1, a2, a5);
  return UF_VEC3_unitize(v6, -640172613, 1037794527, &a3, v6);
}
// 100090D0: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090D8: using guessed type int __cdecl UF_VEC3_cross(_DWORD, _DWORD, _DWORD);

//----- (10001F50) --------------------------------------------------------
signed int __cdecl sub_10001F50(int a1, int a2)
{
  signed int result; // eax@1
  char *v3; // ebx@2
  int v4; // esi@2
  int v5; // eax@3
  signed int v6; // edx@3
  int v7; // ecx@3
  int v8; // edi@4
  signed int v10; // [sp+Ch] [bp-CCh]@2
  char *v11; // [sp+10h] [bp-C8h]@1
  char *v12; // [sp+14h] [bp-C4h]@1
  char *v13; // [sp+18h] [bp-C0h]@1
  char *v14; // [sp+1Ch] [bp-BCh]@1
  char v15[32]; // [sp+20h] [bp-B8h]@2
  char v16; // [sp+40h] [bp-98h]@1
  char v17; // [sp+50h] [bp-88h]@1
  char v18; // [sp+58h] [bp-80h]@1
  char v19; // [sp+78h] [bp-60h]@1
  char v20; // [sp+98h] [bp-40h]@1
  char v21; // [sp+B8h] [bp-20h]@1

  memcpy(&v21, (const void *)(a1 + 96), 0x20u);
  memcpy(&v19, (const void *)(a1 + 64), 0x20u);
  memcpy(&v20, (const void *)(a1 + 32), 0x20u);
  memcpy(&v18, (const void *)a1, 0x20u);
  v11 = &v18;
  v12 = &v20;
  v13 = &v19;
  v14 = &v21;
  result = sub_10004230((int)&v11, 4, (int)&v16, (int)&v17);
  if ( !result )
  {
    v4 = a2;
    v3 = &v15[-a2];
    v10 = 4;
    do
    {
      memset(v15, 0, sizeof(v15));
      *(_DWORD *)&v3[v4] = 0;
      *(_DWORD *)&v3[v4 + 4] = 1072693248;
      sub_10004510((int)&v11, 4, (int)&v16, (int)v15);
      v5 = (int)v15;
      v7 = v4;
      v6 = 4;
      do
      {
        v8 = *(_DWORD *)v5;
        v5 += 8;
        *(_DWORD *)v7 = v8;
        *(_DWORD *)(v7 + 4) = *(_DWORD *)(v5 - 4);
        v7 += 32;
        --v6;
      }
      while ( v6 );
      v4 += 8;
      result = v10 - 1;
    }
    while ( v10-- != 1 );
  }
  return result;
}
// 10001F50: using guessed type char var_B8[32];

//----- (10002060) --------------------------------------------------------
int __cdecl sub_10002060(const void *a1, const void *a2, int a3)
{
  char v4; // [sp+10h] [bp-120h]@1
  char v5; // [sp+28h] [bp-108h]@1
  char v6; // [sp+40h] [bp-F0h]@1
  char v7; // [sp+58h] [bp-D8h]@1
  char v8; // [sp+70h] [bp-C0h]@1
  char v9; // [sp+88h] [bp-A8h]@1
  char v10; // [sp+A0h] [bp-90h]@1
  char v11; // [sp+E8h] [bp-48h]@1

  UF_MTX3_copy((char *)a2 + 24, &v10);
  UF_MTX3_copy((char *)a1 + 24, &v11);
  memcpy(&v9, a1, 0x18u);
  memcpy(&v7, a2, 0x18u);
  UF_MTX3_x_vec(&v10, &v5);
  UF_MTX3_y_vec(&v10, &v4);
  UF_MTX3_x_vec(&v11, &v6);
  UF_MTX3_y_vec(&v11, &v8);
  return UF_MTX4_csys_to_csys(&v7, &v5, &v4, &v9, &v6, &v8, a3);
}
// 100090C4: using guessed type int __cdecl UF_MTX3_copy(_DWORD, _DWORD);
// 100090C8: using guessed type int __cdecl UF_MTX4_csys_to_csys(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090DC: using guessed type int __cdecl UF_MTX3_x_vec(_DWORD, _DWORD);
// 100090E0: using guessed type int __cdecl UF_MTX3_y_vec(_DWORD, _DWORD);

//----- (10002140) --------------------------------------------------------
double __cdecl sub_10002140(int a1, int a2, int a3)
{
  double v4; // [sp+0h] [bp-8h]@1

  UF_VEC3_angle_between(a1, a2, a3, &v4);
  return v4;
}
// 100090C0: using guessed type int __cdecl UF_VEC3_angle_between(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10002170) --------------------------------------------------------
signed int __cdecl sub_10002170(int a1, int a2, int a3)
{
  int v3; // eax@1
  int v4; // edx@2
  int v5; // ecx@2
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  signed int v9; // esi@3
  double v10; // st7@5
  int v11; // eax@5
  signed int v13; // [sp+Ch] [bp-9Ch]@1
  int v14; // [sp+10h] [bp-98h]@2
  int v15; // [sp+14h] [bp-94h]@2
  int v16; // [sp+18h] [bp-90h]@2
  int v17; // [sp+1Ch] [bp-8Ch]@2
  int v18; // [sp+20h] [bp-88h]@2
  int v19; // [sp+24h] [bp-84h]@2
  char v20[40]; // [sp+28h] [bp-80h]@1
  char v21[40]; // [sp+50h] [bp-58h]@1
  char v22; // [sp+78h] [bp-30h]@1

  memcpy(&v22, (const void *)a1, 0x30u);
  UF_VEC3_add(&v22, dword_1000BEF0 + 16, &v22);
  UF_VEC3_sub(&v22, dword_1000BEF0 + 40, &v22);
  v13 = sub_10002590(&v22, (int)v20, v21);
  UF_VEC3_add(v20, dword_1000BEF0 + 64, v20);
  UF_VEC3_add(v21, dword_1000BEF0 + 64, v21);
  v3 = dword_1000BEF0;
  if ( *(_BYTE *)(dword_1000BEF0 + 88) )
  {
    v4 = *(_DWORD *)(a1 + 28);
    v14 = *(_DWORD *)(a1 + 24);
    v5 = *(_DWORD *)(a1 + 32);
    v15 = v4;
    v6 = *(_DWORD *)(a1 + 36);
    v16 = v5;
    v7 = *(_DWORD *)(a1 + 40);
    v17 = v6;
    v8 = *(_DWORD *)(a1 + 44);
    v18 = v7;
    v19 = v8;
    UF_VEC3_scale(*(_DWORD *)(dword_1000BEF0 + 96), *(_DWORD *)(dword_1000BEF0 + 100), &v14, &v14);
    UF_VEC3_add(v20, &v14, v20);
    UF_VEC3_add(v21, &v14, v21);
    v3 = dword_1000BEF0;
  }
  v9 = 0;
  while ( 1 )
  {
    v10 = sub_10004600((int)&v20[v9], (long double *)(v3 + 8));
    v11 = dword_1000BEF0;
    *(_QWORD *)&v20[v9] = *(_QWORD *)&v10;
    *(double *)&v21[v9] = sub_10004600((int)&v21[v9], (long double *)(v11 + 8));
    v9 += 8;
    if ( v9 > 16 )
      break;
    v3 = dword_1000BEF0;
  }
  if ( byte_1000A01A )
    byte_1000A01A = 0;
  else
    sub_100023B0((int)&unk_1000BC48, (int)&unk_1000BDD0, (int)v20, (int)v21);
  memcpy((void *)a2, v20, 0x28u);
  memcpy((void *)a3, v21, 0x28u);
  memcpy(&unk_1000BC48, (const void *)a2, 0x28u);
  memcpy(&unk_1000BDD0, (const void *)a3, 0x28u);
  if ( byte_1000BF40 )
  {
    printf(
      "final ufunc mcoord[] = (%f,%f,%f), (%f,%f)\n",
      *(_DWORD *)a2,
      *(_DWORD *)(a2 + 4),
      *(_DWORD *)(a2 + 8),
      *(_DWORD *)(a2 + 12),
      *(_DWORD *)(a2 + 16),
      *(_DWORD *)(a2 + 20),
      *(_DWORD *)(a2 + 24),
      *(_DWORD *)(a2 + 28),
      *(_DWORD *)(a2 + 32),
      *(_DWORD *)(a2 + 36));
    printf(
      "final ufunc alt_mcoord[] = (%f,%f,%f), (%f,%f)\n",
      *(_DWORD *)a3,
      *(_DWORD *)(a3 + 4),
      *(_DWORD *)(a3 + 8),
      *(_DWORD *)(a3 + 12),
      *(_DWORD *)(a3 + 16),
      *(_DWORD *)(a3 + 20),
      *(_DWORD *)(a3 + 24),
      *(_DWORD *)(a3 + 28),
      *(_DWORD *)(a3 + 32),
      *(_DWORD *)(a3 + 36));
  }
  return v13;
}
// 100090A4: using guessed type int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD);
// 100090B8: using guessed type int __cdecl UF_VEC3_add(_DWORD, _DWORD, _DWORD);
// 100090BC: using guessed type int __cdecl UF_VEC3_scale(_DWORD, _DWORD, _DWORD, _DWORD);
// 1000A01A: using guessed type char byte_1000A01A;
// 1000BEF0: using guessed type int dword_1000BEF0;
// 1000BF40: using guessed type char byte_1000BF40;
// 10002170: using guessed type char var_58[40];
// 10002170: using guessed type char var_80[40];

//----- (100023B0) --------------------------------------------------------
void __cdecl sub_100023B0(int a1, int a2, int a3, int a4)
{
  double v4; // st7@1
  double v5; // st7@3
  char v6; // [sp+10h] [bp-28h]@6

  v4 = sub_10002500(*(double *)(a3 + 24));
  if ( fabs(*(double *)(a1 + 24) - v4) < fabs(*(double *)(a1 + 24) - *(double *)(a3 + 24)) )
    *(_QWORD *)(a3 + 24) = *(_QWORD *)&v4;
  v5 = sub_10002500(*(double *)(a3 + 32));
  if ( fabs(*(double *)(a1 + 32) - v5) < fabs(*(double *)(a1 + 32) - *(double *)(a3 + 32)) )
    *(_QWORD *)(a3 + 32) = *(_QWORD *)&v5;
  if ( fabs(*(double *)(a1 + 24) - *(double *)(a4 + 24)) < fabs(*(double *)(a1 + 24) - *(double *)(a3 + 24)) )
  {
    memcpy(&v6, (const void *)a3, 0x28u);
    memcpy((void *)a3, (const void *)a4, 0x28u);
    memcpy((void *)a4, &v6, 0x28u);
  }
  if ( *(double *)(dword_1000BEF0 + 104) - dbl_1000A010 >= *(double *)(a3 + 24)
    || *(double *)(dword_1000BEF0 + 112) + dbl_1000A010 <= *(double *)(a3 + 24) )
  {
    if ( *(double *)(dword_1000BEF0 + 120) - dbl_1000A010 < *(double *)(a4 + 24) )
    {
      if ( *(double *)(dword_1000BEF0 + 128) + dbl_1000A010 > *(double *)(a4 + 24) )
      {
        memcpy(&v6, (const void *)a3, 0x28u);
        memcpy((void *)a3, (const void *)a4, 0x28u);
        memcpy((void *)a4, &v6, 0x28u);
      }
    }
  }
}
// 1000A010: using guessed type double dbl_1000A010;
// 1000BEF0: using guessed type int dword_1000BEF0;

//----- (10002500) --------------------------------------------------------
double __cdecl sub_10002500(double a1)
{
  double result; // st7@1

  result = a1;
  if ( a1 <= 0.0 )
  {
    if ( a1 < 0.0 )
      result = a1 + 360.0;
  }
  else
  {
    result = a1 - 360.0;
  }
  return result;
}

//----- (10002530) --------------------------------------------------------
int __cdecl sub_10002530(int a1)
{
  memcpy((void *)(dword_1000BEF0 + 16), (const void *)(a1 + 192), 0x18u);
  memcpy((void *)(dword_1000BEF0 + 40), (const void *)(a1 + 216), 0x18u);
  *(_DWORD *)(dword_1000BEF0 + 136) = *(_DWORD *)(a1 + 376);
  *(_DWORD *)(dword_1000BEF0 + 140) = *(_DWORD *)(a1 + 380);
  return 0;
}
// 1000BEF0: using guessed type int dword_1000BEF0;

//----- (10002590) --------------------------------------------------------
signed int __cdecl sub_10002590(const void *a1, int a2, void *a3)
{
  int v3; // eax@1
  signed int v4; // edx@1
  int v5; // ecx@1
  int v6; // esi@1
  const void *v7; // edi@3
  signed int result; // eax@9
  int v9; // ecx@10
  double v10; // st7@12
  double v11; // st7@13
  double v12; // st7@22
  signed int v13; // ecx@25
  long double v14; // st7@26
  long double v15; // st7@26
  long double v16; // st6@26
  long double v17; // st7@26
  long double v18; // st7@26
  int v19; // eax@28
  double v20; // st6@35
  long double v21; // st7@42
  long double v22; // st6@49
  long double v23; // st6@52
  signed int v24; // ecx@55
  long double v25; // st7@55
  long double v26; // st6@56
  long double v27; // st6@56
  long double v28; // st6@57
  int v29; // eax@72
  signed int v30; // edi@81
  int v31; // eax@82
  int v32; // eax@85
  int v33; // edi@86
  double v34; // st7@93
  __int16 v35; // fps@93
  char v36; // c0@93
  double v37; // st7@95
  __int16 v38; // fps@95
  char v39; // c0@95
  char v40; // [sp+2Fh] [bp-D9h]@1
  double v41; // [sp+30h] [bp-D8h]@21
  double v42; // [sp+30h] [bp-D8h]@32
  double v43; // [sp+30h] [bp-D8h]@45
  double v44; // [sp+30h] [bp-D8h]@57
  double v45; // [sp+38h] [bp-D0h]@12
  double v46; // [sp+40h] [bp-C8h]@12
  double v47; // [sp+48h] [bp-C0h]@16
  double v48; // [sp+50h] [bp-B8h]@16
  double v49; // [sp+58h] [bp-B0h]@22
  long double v50; // [sp+60h] [bp-A8h]@10
  double v51; // [sp+68h] [bp-A0h]@21
  double v52; // [sp+70h] [bp-98h]@79
  long double v53; // [sp+80h] [bp-88h]@10
  int v54[2]; // [sp+88h] [bp-80h]@10
  double v55; // [sp+90h] [bp-78h]@10
  long double v56; // [sp+98h] [bp-70h]@10
  double v57; // [sp+A0h] [bp-68h]@26
  double v58; // [sp+A8h] [bp-60h]@79
  int v59; // [sp+BCh] [bp-4Ch]@1
  double v60; // [sp+C0h] [bp-48h]@10
  double v61; // [sp+C8h] [bp-40h]@10
  int v62; // [sp+D4h] [bp-34h]@8
  int v63; // [sp+D8h] [bp-30h]@6
  char v64; // [sp+F0h] [bp-18h]@6

  v6 = (int)a3;
  v40 = 0;
  v59 = 0;
  v3 = a2;
  v5 = (int)((char *)a3 - a2);
  v4 = 5;
  do
  {
    *(_DWORD *)(v5 + v3) = 0;
    *(_DWORD *)(v5 + v3 + 4) = 0;
    *(_DWORD *)v3 = 0;
    *(_DWORD *)(v3 + 4) = 0;
    v3 += 8;
    --v4;
  }
  while ( v4 );
  v7 = a1;
  if ( byte_1000BF40 )
  {
    printf("\n------------------------------------------------------\n");
    printf(
      "Starting old_pcoord_t[] = (%f,%f,%f,%f,%f,%f)\n",
      *(_DWORD *)a1,
      *((_DWORD *)a1 + 1),
      *((_DWORD *)a1 + 2),
      *((_DWORD *)a1 + 3),
      *((_DWORD *)a1 + 4),
      *((_DWORD *)a1 + 5),
      *((_DWORD *)a1 + 6),
      *((_DWORD *)a1 + 7),
      *((_DWORD *)a1 + 8),
      *((_DWORD *)a1 + 9),
      *((_DWORD *)a1 + 10),
      *((_DWORD *)a1 + 11));
  }
  if ( dword_1000BC00 == 3 )
  {
    UF_MTX3_vec_multiply_t(a1, &unk_100091A0, &v63);
    UF_MTX3_vec_multiply_t((char *)a1 + 24, &unk_100091A0, &v64);
  }
  else
  {
    memcpy(&v63, a1, 0x30u);
    v6 = (int)a3;
    v7 = a1;
  }
  UF_VEC3_is_zero(&v64, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v62);
  if ( v62 )
    return 4;
  UF_VEC3_unitize(&v64, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v61, v54);
  *(_QWORD *)&v53 = *(_QWORD *)v54;
  v50 = v56;
  v60 = v55;
  v9 = *(_DWORD *)dword_1000BEF0;
  if ( *(_DWORD *)dword_1000BEF0 != 3 )
  {
    v49 = dbl_1000BD30 * v56 + dbl_1000BD10 * v55 + dbl_1000BCF0 * *(double *)v54;
    v42 = dbl_1000BD38 * v56 + dbl_1000BD18 * v55 + dbl_1000BCF8 * *(double *)v54;
    if ( fabs(dbl_1000BBE0) > dbl_1000A010 )
    {
      if ( v9 == 1 )
      {
        v20 = dbl_1000BF00;
      }
      else
      {
        if ( v9 == 2 )
          v20 = dbl_1000BF00;
        else
          v20 = v61;
      }
      v57 = (v20
           - (dbl_1000BD40 * v56
            + dbl_1000BD20 * v55
            + dbl_1000BD00 * *(double *)v54
            - (dbl_1000BD48 * v56 + dbl_1000BD28 * v55 + dbl_1000BD08 * *(double *)v54) * dbl_1000BF18)
           * dbl_1000BEF8)
          / dbl_1000BBE0;
    }
    else
    {
      *(_QWORD *)&v57 = 0i64;
      v40 = 1;
    }
    v51 = sqrt(v42 * v42 + v49 * v49);
    if ( fabs(v49) > dbl_1000A010 || fabs(v42) > dbl_1000A010 )
      v21 = atan2(v49, v42);
    else
      v21 = 0.0;
    if ( fabs(v51) > dbl_1000A010 )
      v43 = v57 / v51;
    else
      *(_QWORD *)&v43 = 0i64;
    if ( dbl_1000A010 + 1.0 >= fabs(v43) )
    {
      v22 = 1.0 - v43 * v43;
      if ( fabs(v22) <= dbl_1000A010 )
        v22 = 0.0;
      if ( fabs(v43 - 1.0) > dbl_1000A010 )
        v23 = sqrt(v22);
      else
        v23 = 0.0;
      v45 = atan2(v23, v43) + v21;
      v46 = atan2(-v23, v43) + v21;
    }
    else
    {
      printf(
        "INPUT Point =%-.4f,%-.4f,%-.4f,%-.8f,%-.8f,%-.8f\n",
        *(_DWORD *)v7,
        *((_DWORD *)v7 + 1),
        *((_DWORD *)v7 + 2),
        *((_DWORD *)v7 + 3),
        *((_DWORD *)v7 + 4),
        *((_DWORD *)v7 + 5),
        *((_DWORD *)v7 + 6),
        *((_DWORD *)v7 + 7),
        *((_DWORD *)v7 + 8),
        *((_DWORD *)v7 + 9),
        *((_DWORD *)v7 + 10),
        *((_DWORD *)v7 + 11));
      printf("WARNING: Degenerated G_lambda(%f) out of range (-1, 1)\n", *(_QWORD *)&v43);
      v40 = 1;
      *(_QWORD *)&v46 = 0i64;
      *(_QWORD *)&v45 = 0i64;
    }
    v24 = 0;
    v25 = fabs(dbl_1000BBD8);
    do
    {
      v27 = *(double *)((char *)&v45 + v24);
      v49 = sin(v27);
      v26 = cos(v27);
      if ( v25 > dbl_1000A010 )
      {
        v57 = v26 * dbl_1000BEF8;
        v51 = -(dbl_1000BBE0 * dbl_1000BF18);
        v28 = ((v49 * dbl_1000BD38 + v26 * dbl_1000BD30 - dbl_1000BF10 * dbl_1000BD48) * v50
             + (v49 * dbl_1000BD18 + v26 * dbl_1000BD10 - dbl_1000BF10 * dbl_1000BD28) * v60
             + (v49 * dbl_1000BCF8 + v26 * dbl_1000BCF0 - dbl_1000BF10 * dbl_1000BD08) * v53)
            / dbl_1000BBD8;
        v44 = -(((dbl_1000BBE0 * dbl_1000BD40
                + v57 * dbl_1000BD38
                + -(v49 * dbl_1000BEF8) * dbl_1000BD30
                + v51 * dbl_1000BD48)
               * v50
               + (dbl_1000BBE0 * dbl_1000BD20
                + v57 * dbl_1000BD18
                + -(v49 * dbl_1000BEF8) * dbl_1000BD10
                + v51 * dbl_1000BD28)
               * v60
               + (dbl_1000BBE0 * dbl_1000BD00
                + v57 * dbl_1000BCF8
                + -(v49 * dbl_1000BEF8) * dbl_1000BCF0
                + v51 * dbl_1000BD08)
               * v53)
              / dbl_1000BBD8);
      }
      else
      {
        v28 = 0.0;
        *(_QWORD *)&v44 = 0i64;
      }
      if ( fabs(v28) > dbl_1000A010 || fabs(v44) > dbl_1000A010 )
      {
        *(double *)((char *)&v47 + v24) = atan2(v44, v28);
      }
      else
      {
        *(_DWORD *)((char *)&v47 + v24) = 0;
        *(_DWORD *)((char *)&v47 + v24 + 4) = 0;
        v40 = 1;
      }
      v24 += 8;
    }
    while ( v24 < 16 );
    goto LABEL_64;
  }
  if ( dword_1000BC00 )
  {
    if ( dword_1000BC00 != 1 && dword_1000BC00 != 3 )
      return 2;
    *(_QWORD *)&v41 = qword_1000BED8;
    v51 = dbl_1000BEE8;
    *(_QWORD *)&v50 = qword_1000BEE0;
    if ( fabs(dbl_1000BEE8 - 1.0) <= dbl_1000A010
      || (v49 = (v56 - dbl_1000BEE8 * dbl_1000BEE8) / (1.0 - dbl_1000BEE8 * dbl_1000BEE8),
          v12 = fabs(v49),
          dbl_1000A010 + 1.0 < v12) )
    {
      *(_QWORD *)&v45 = qword_1000BE08;
      v40 = 1;
      *(_QWORD *)&v46 = qword_1000BE10;
    }
    else
    {
      sub_100035B0(v49);
      v45 = v12;
      v46 = -v12;
    }
    v13 = 0;
    do
    {
      v15 = *(double *)((char *)&v45 + v13);
      v16 = sin(v15);
      v17 = (1.0 - cos(v15)) * v51;
      v49 = v17 * v41 + v16 * v50;
      v18 = v17 * v50 - v16 * v41;
      v57 = v18 * v60 + v49 * v53;
      v14 = v49 * v60 - v18 * v53;
      if ( fabs(v14) > dbl_1000A010 || fabs(v57) > dbl_1000A010 )
      {
        *(double *)((char *)&v47 + v13) = atan2(v57, v14);
      }
      else
      {
        v19 = *(_DWORD *)((char *)&qword_1000BDF8 + v13 + 4);
        *(_DWORD *)((char *)&v47 + v13) = *(_DWORD *)((char *)&qword_1000BDF8 + v13);
        *(_DWORD *)((char *)&v47 + v13 + 4) = v19;
        v40 = 1;
      }
      v13 += 8;
    }
    while ( v13 < 16 );
LABEL_64:
    if ( v40 )
      goto LABEL_65;
    goto LABEL_68;
  }
  v45 = asin(-v55);
  v10 = sqrt(v56 * v56 + *(double *)v54 * *(double *)v54);
  sub_100035B0(v10);
  v46 = v10;
  if ( fabs(v45 - v10) <= dbl_1000A010 )
  {
    v11 = -sqrt(v50 * v50 + v53 * v53);
    sub_100035B0(v11);
    v46 = v11;
  }
  if ( fabs(v53) <= dbl_1000A010 && fabs(v50) <= dbl_1000A010 )
  {
    *(_QWORD *)&v47 = qword_1000BDF8;
    *(_QWORD *)&v48 = qword_1000BE00;
    v40 = 1;
LABEL_65:
    if ( *(_DWORD *)dword_1000BEF0 != 3 )
    {
      *(_QWORD *)&v45 = qword_1000BE08;
      *(_QWORD *)&v46 = qword_1000BE10;
      *(_QWORD *)&v47 = qword_1000BDF8;
      *(_QWORD *)&v48 = qword_1000BE00;
    }
    v59 = 1;
    goto LABEL_68;
  }
  v47 = atan2(v50, v53);
  v48 = atan2(-v50, -v53);
LABEL_68:
  if ( byte_1000A019 && (*(_DWORD *)dword_1000BEF0 == 2 || *(_DWORD *)dword_1000BEF0 == 3) )
  {
    sub_10003CD0((int)&v45, (int)&v47);
    dbl_1000BBB0 = v45;
    dbl_1000BBB8 = v46;
    dbl_1000BBA0 = v47;
    dbl_1000BBA8 = v48;
    result = v59;
  }
  else
  {
    v29 = *(_DWORD *)dword_1000BEF0;
    if ( *(_DWORD *)dword_1000BEF0 == 1 )
    {
      memcpy((void *)a2, &v63, 0x18u);
      memcpy(a3, &v63, 0x18u);
      v6 = (int)a3;
    }
    else
    {
      if ( v29 == 2 || v29 == 3 )
      {
        if ( byte_1000BF40 )
        {
          ((void (__cdecl *)(_DWORD))printf)("About adjusting theta with initial angle...\n");
          printf(
            "computing t1[0]=%f, t2[0]=%f, (Init_T1[0]*2-t1[0])=%f,(Init_T2[0]*2-t2[0])=%f\n",
            v45 * 57.29577951308235,
            v47 * 57.29577951308235,
            (dbl_1000BBB0 + dbl_1000BBB0 - v45) * 57.29577951308235,
            (dbl_1000BBA0 + dbl_1000BBA0 - v47) * 57.29577951308235);
          printf(
            "computing t1[1]=%f, t2[1]=%f, (Init_T1[1]*2-t1[1])=%f,(Init_T2[1]*2-t2[1])=%f\n",
            v46 * 57.29577951308235,
            v48 * 57.29577951308235,
            (dbl_1000BBB8 + dbl_1000BBB8 - v46) * 57.29577951308235,
            (dbl_1000BBA8 + dbl_1000BBA8 - v48) * 57.29577951308235);
        }
        sub_10003CD0((int)&v45, (int)&v47);
        if ( *(_DWORD *)dword_1000BEF0 == 2 )
        {
          v57 = v45;
          v58 = v46;
          v51 = v47;
          v52 = v48;
          sub_10003990(v54, (int)&v57, (int)&v51);
          v48 = v52;
          v46 = v58;
          v45 = v57;
          v47 = v51;
          sub_10003600(&v63, v57, v51, (void *)a2, 1);
          sub_10003600(&v63, v58, v52, (void *)v6, 1);
        }
        else
        {
          sub_10003820((int)&v63, -v47, a2);
          sub_10003820((int)&v63, -v48, v6);
          if ( dword_1000BC00 == 3 )
          {
            v30 = 0;
            do
            {
              v31 = a2;
              if ( v30 )
                v31 = v6;
              UF_MTX3_vec_multiply_t(v31, &unk_10009158, v31);
              ++v30;
            }
            while ( v30 < 2 );
          }
        }
      }
    }
    v32 = *(_DWORD *)dword_1000BEF0;
    if ( *(_DWORD *)dword_1000BEF0 == 1 )
    {
      v51 = *(double *)(dword_1000BEF0 + 144) + *(double *)(dword_1000BEF0 + 136);
      v33 = HIDWORD(v51);
      UF_VEC3_affine_comb(a2, LODWORD(v51), HIDWORD(v51), v54, a2);
      UF_VEC3_affine_comb(v6, LODWORD(v51), v33, v54, v6);
      sub_100037A0(a2, v45, 0, 0, a2);
      sub_100037A0(v6, v46, 0, 0, v6);
    }
    else
    {
      if ( v32 == 3 )
      {
        sub_10003820((int)v54, -v47, (int)&v51);
        UF_VEC3_unitize(&v51, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v61, &v51);
        UF_VEC3_affine_comb(a2, *(_DWORD *)(dword_1000BEF0 + 136), *(_DWORD *)(dword_1000BEF0 + 140), &v51, a2);
        UF_VEC3_affine_comb(v6, *(_DWORD *)(dword_1000BEF0 + 136), *(_DWORD *)(dword_1000BEF0 + 140), &v51, v6);
      }
      else
      {
        if ( v32 == 2 )
        {
          sub_10003600(v54, v45, v47, &v51, 0);
          sub_10003600(v54, v46, v48, &v57, 0);
          UF_VEC3_unitize(&v51, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v61, &v51);
          UF_VEC3_unitize(&v57, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v61, &v57);
          UF_VEC3_affine_comb(a2, *(_DWORD *)(dword_1000BEF0 + 136), *(_DWORD *)(dword_1000BEF0 + 140), &v51, a2);
          UF_VEC3_affine_comb(v6, *(_DWORD *)(dword_1000BEF0 + 136), *(_DWORD *)(dword_1000BEF0 + 140), &v57, v6);
        }
      }
    }
    *(double *)(a2 + 24) = v45 * 57.29577951308235;
    *(double *)(v6 + 24) = v46 * 57.29577951308235;
    *(double *)(a2 + 32) = v47 * 57.29577951308235;
    *(double *)(v6 + 32) = v48 * 57.29577951308235;
    if ( byte_1000A018 )
    {
      if ( *(_DWORD *)dword_1000BEF0 != 3 )
      {
        v34 = *(double *)(a2 + 32) - 90.0;
        UNDEF(v35);
        *(_QWORD *)(a2 + 32) = *(_QWORD *)&v34;
        if ( v36 )
          *(double *)(a2 + 32) = v34 + 360.0;
        v37 = *(double *)(v6 + 32) - 90.0;
        UNDEF(v38);
        *(_QWORD *)(v6 + 32) = *(_QWORD *)&v37;
        if ( v39 )
          *(double *)(v6 + 32) = v37 + 360.0;
      }
    }
    if ( v40 )
    {
      if ( *(_DWORD *)dword_1000BEF0 != 3 )
      {
        *(_DWORD *)(a2 + 24) = dword_1000BC38;
        *(_DWORD *)(a2 + 28) = dword_1000BC3C;
        *(_DWORD *)(a2 + 32) = dword_1000BC40;
        *(_DWORD *)(a2 + 36) = dword_1000BC44;
        *(_DWORD *)(v6 + 24) = dword_1000BEC8;
        *(_DWORD *)(v6 + 28) = dword_1000BECC;
        *(_DWORD *)(v6 + 32) = dword_1000BED0;
        *(_DWORD *)(v6 + 36) = dword_1000BED4;
      }
    }
    if ( byte_1000BF40 )
    {
      if ( fabs(v45 - v46) <= dbl_1000A010 )
      {
        if ( fabs(v47 - v48) <= dbl_1000A010 )
          printf("WARNING: same value of rotary produced:\n");
      }
    }
    memcpy(&unk_1000BC20, (const void *)a2, 0x28u);
    memcpy(&unk_1000BEB0, a3, 0x28u);
    qword_1000BE08 = *(_QWORD *)&v45;
    qword_1000BDF8 = *(_QWORD *)&v47;
    qword_1000BE10 = *(_QWORD *)&v46;
    result = v59;
    qword_1000BE00 = *(_QWORD *)&v48;
  }
  return result;
}
// 100090B0: using guessed type int __cdecl UF_VEC3_is_zero(_DWORD, _DWORD, _DWORD, _DWORD);
// 100090B4: using guessed type int __cdecl UF_VEC3_affine_comb(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090D0: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090EC: using guessed type int __cdecl UF_MTX3_vec_multiply_t(_DWORD, _DWORD, _DWORD);
// 1000A010: using guessed type double dbl_1000A010;
// 1000A018: using guessed type char byte_1000A018;
// 1000A019: using guessed type char byte_1000A019;
// 1000BBA0: using guessed type double dbl_1000BBA0;
// 1000BBA8: using guessed type double dbl_1000BBA8;
// 1000BBB0: using guessed type double dbl_1000BBB0;
// 1000BBB8: using guessed type double dbl_1000BBB8;
// 1000BBD8: using guessed type double dbl_1000BBD8;
// 1000BBE0: using guessed type double dbl_1000BBE0;
// 1000BC00: using guessed type int dword_1000BC00;
// 1000BC38: using guessed type int dword_1000BC38;
// 1000BC3C: using guessed type int dword_1000BC3C;
// 1000BC40: using guessed type int dword_1000BC40;
// 1000BC44: using guessed type int dword_1000BC44;
// 1000BCF0: using guessed type double dbl_1000BCF0;
// 1000BCF8: using guessed type double dbl_1000BCF8;
// 1000BD00: using guessed type double dbl_1000BD00;
// 1000BD08: using guessed type double dbl_1000BD08;
// 1000BD10: using guessed type double dbl_1000BD10;
// 1000BD18: using guessed type double dbl_1000BD18;
// 1000BD20: using guessed type double dbl_1000BD20;
// 1000BD28: using guessed type double dbl_1000BD28;
// 1000BD30: using guessed type double dbl_1000BD30;
// 1000BD38: using guessed type double dbl_1000BD38;
// 1000BD40: using guessed type double dbl_1000BD40;
// 1000BD48: using guessed type double dbl_1000BD48;
// 1000BDF8: using guessed type __int64 qword_1000BDF8;
// 1000BE00: using guessed type __int64 qword_1000BE00;
// 1000BE08: using guessed type __int64 qword_1000BE08;
// 1000BE10: using guessed type __int64 qword_1000BE10;
// 1000BEC8: using guessed type int dword_1000BEC8;
// 1000BECC: using guessed type int dword_1000BECC;
// 1000BED0: using guessed type int dword_1000BED0;
// 1000BED4: using guessed type int dword_1000BED4;
// 1000BED8: using guessed type __int64 qword_1000BED8;
// 1000BEE0: using guessed type __int64 qword_1000BEE0;
// 1000BEE8: using guessed type double dbl_1000BEE8;
// 1000BEF0: using guessed type int dword_1000BEF0;
// 1000BEF8: using guessed type double dbl_1000BEF8;
// 1000BF00: using guessed type double dbl_1000BF00;
// 1000BF10: using guessed type double dbl_1000BF10;
// 1000BF18: using guessed type double dbl_1000BF18;
// 1000BF40: using guessed type char byte_1000BF40;

//----- (10003600) --------------------------------------------------------
int __cdecl sub_10003600(const void *a1, double a2, double a3, void *a4, signed int a5)
{
  int result; // eax@1
  int v6; // ST48_4@1
  int v7; // ST4C_4@1
  int v8; // [sp+1Ch] [bp-258h]@1
  int v9; // [sp+20h] [bp-254h]@1
  int v10; // [sp+24h] [bp-250h]@1
  int v11; // [sp+28h] [bp-24Ch]@1
  int v12; // [sp+2Ch] [bp-248h]@1
  int v13; // [sp+30h] [bp-244h]@1
  char v14; // [sp+34h] [bp-240h]@1
  char v15; // [sp+4Ch] [bp-228h]@1
  char v16; // [sp+54h] [bp-220h]@1
  double v17; // [sp+6Ch] [bp-208h]@1
  char v18; // [sp+74h] [bp-200h]@1
  char v19; // [sp+8Ch] [bp-1E8h]@1
  char v20; // [sp+ACh] [bp-1C8h]@1
  char v21; // [sp+12Ch] [bp-148h]@1
  char v22; // [sp+174h] [bp-100h]@1
  char v23; // [sp+1F4h] [bp-80h]@1

  memcpy(&v16, a1, 0x18u);
  v17 = (double)a5;
  v6 = *(_DWORD *)(dword_1000BEF0 + 8);
  v7 = *(_DWORD *)(dword_1000BEF0 + 12);
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  UF_MTX4_rotation(
    &unk_1000BC08,
    &dword_1000BBC0,
    COERCE_UNSIGNED_INT64(a3 * -57.29577951308235),
    COERCE_UNSIGNED_INT64(a3 * -57.29577951308235) >> 32,
    &v20);
  sub_100046A0((int)&v20);
  UF_MTX4_ask_rotation(&v20, &v21);
  UF_MTX3_vec_multiply(&dword_1000BED8, &v21, &v14);
  UF_VEC3_unitize(&v14, v6, v7, &v15, &v14);
  UF_MTX4_vec3_multiply(&v8, &v20, &v18);
  UF_MTX4_rotation(
    &v18,
    &v14,
    COERCE_UNSIGNED_INT64(a2 * -57.29577951308235),
    COERCE_UNSIGNED_INT64(a2 * -57.29577951308235) >> 32,
    &v22);
  sub_100046A0((int)&v22);
  UF_MTX4_multiply(&v20, &v22, &v23);
  sub_100046A0((int)&v23);
  result = UF_MTX4_vec_multiply(&v16, &v23, &v19);
  memcpy(a4, &v19, 0x18u);
  return result;
}
// 1000905C: using guessed type int __cdecl UF_MTX4_rotation(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10009060: using guessed type int __cdecl UF_MTX4_ask_rotation(_DWORD, _DWORD);
// 1000907C: using guessed type int __cdecl UF_MTX4_multiply(_DWORD, _DWORD, _DWORD);
// 10009080: using guessed type int __cdecl UF_MTX4_vec3_multiply(_DWORD, _DWORD, _DWORD);
// 100090AC: using guessed type int __cdecl UF_MTX4_vec_multiply(_DWORD, _DWORD, _DWORD);
// 100090D0: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090F4: using guessed type int __cdecl UF_MTX3_vec_multiply(_DWORD, _DWORD, _DWORD);
// 1000BBC0: using guessed type int dword_1000BBC0;
// 1000BED8: using guessed type int dword_1000BED8;
// 1000BEF0: using guessed type int dword_1000BEF0;

//----- (100037A0) --------------------------------------------------------
int __cdecl sub_100037A0(int a1, double a2, int a3, int a4, int a5)
{
  char v6; // [sp+Ch] [bp-E0h]@1
  char v7; // [sp+24h] [bp-C8h]@1
  char v8; // [sp+6Ch] [bp-80h]@1

  UF_MTX4_rotation(
    &unk_1000BBE8,
    &dword_1000BED8,
    COERCE_UNSIGNED_INT64(a2 * 57.29577951308235),
    COERCE_UNSIGNED_INT64(a2 * 57.29577951308235) >> 32,
    &v8);
  sub_100046A0((int)&v8);
  UF_MTX4_ask_rotation(&v8, &v7);
  UF_MTX3_vec_multiply(&unk_1000BC08, &v7, &v6);
  return UF_VEC3_add(a1, &v6, a5);
}
// 1000905C: using guessed type int __cdecl UF_MTX4_rotation(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10009060: using guessed type int __cdecl UF_MTX4_ask_rotation(_DWORD, _DWORD);
// 100090B8: using guessed type int __cdecl UF_VEC3_add(_DWORD, _DWORD, _DWORD);
// 100090F4: using guessed type int __cdecl UF_MTX3_vec_multiply(_DWORD, _DWORD, _DWORD);
// 1000BED8: using guessed type int dword_1000BED8;

//----- (10003820) --------------------------------------------------------
int __cdecl sub_10003820(int a1, long double a2, int a3)
{
  int v4; // [sp+0h] [bp-80h]@1

  sub_10003870(a2, (int)&dword_1000BBC0, (int)&v4);
  sub_100046A0((int)&v4);
  return UF_MTX4_vec3_multiply_t(a1, &v4, a3);
}
// 10009054: using guessed type int __cdecl UF_MTX4_vec3_multiply_t(_DWORD, _DWORD, _DWORD);
// 1000BBC0: using guessed type int dword_1000BBC0;

//----- (10003870) --------------------------------------------------------
int __cdecl sub_10003870(long double a1, int a2, int a3)
{
  int result; // eax@1
  long double v4; // st7@1
  int v5; // ecx@1
  long double v6; // st6@1
  double v7; // ST08_8@1
  double v8; // ST10_8@1
  long double v9; // st4@1
  long double v10; // st3@1
  long double v11; // st4@1
  long double v12; // st3@1

  v4 = cos(a1);
  v5 = a2;
  result = a3;
  v6 = sin(a1);
  v7 = *(double *)(a2 + 8) * *(double *)(a2 + 8);
  v8 = *(double *)(a2 + 16) * *(double *)(a2 + 16);
  *(long double *)a3 = (1.0 - *(double *)a2 * *(double *)a2) * v4 + *(double *)a2 * *(double *)a2;
  *(long double *)(a3 + 8) = *(double *)(v5 + 8) * *(double *)v5 * (1.0 - v4) + v6 * *(double *)(v5 + 16);
  v9 = *(double *)(v5 + 16) * *(double *)v5 * (1.0 - v4);
  v10 = v6 * *(double *)(a2 + 8);
  *(_DWORD *)(a3 + 24) = 0;
  *(_DWORD *)(a3 + 28) = 0;
  *(long double *)(a3 + 16) = v9 - v10;
  *(long double *)(a3 + 32) = *(double *)(v5 + 8) * *(double *)v5 * (1.0 - v4) - v6 * *(double *)(v5 + 16);
  *(long double *)(a3 + 40) = (1.0 - v7) * v4 + v7;
  v11 = *(double *)(v5 + 16) * *(double *)(v5 + 8) * (1.0 - v4);
  v12 = v6 * *(double *)a2;
  *(_DWORD *)(a3 + 56) = 0;
  *(_DWORD *)(a3 + 60) = 0;
  *(long double *)(a3 + 48) = v11 + v12;
  *(long double *)(a3 + 64) = *(double *)(v5 + 16) * *(double *)v5 * (1.0 - v4) + v6 * *(double *)(a2 + 8);
  *(long double *)(a3 + 72) = *(double *)(v5 + 16) * *(double *)(v5 + 8) * (1.0 - v4) - v6 * *(double *)a2;
  *(_DWORD *)(a3 + 88) = 0;
  *(_DWORD *)(a3 + 96) = 0;
  *(_DWORD *)(a3 + 104) = 0;
  *(_DWORD *)(a3 + 112) = 0;
  *(_DWORD *)(a3 + 120) = 0;
  *(_DWORD *)(a3 + 92) = 0;
  *(_DWORD *)(a3 + 100) = 0;
  *(_DWORD *)(a3 + 108) = 0;
  *(_DWORD *)(a3 + 116) = 0;
  *(_DWORD *)(a3 + 124) = 1072693248;
  *(long double *)(a3 + 80) = (1.0 - v8) * v4 + v8;
  return result;
}

//----- (10003990) --------------------------------------------------------
int __cdecl sub_10003990(const void *a1, int a2, int a3)
{
  int v3; // ecx@1
  int v4; // edx@1
  double v5; // ST54_8@1
  double v6; // qax@1
  double v7; // qax@1
  int v8; // ebx@3
  int *v9; // edi@3
  double *v10; // esi@3
  int v11; // edx@5
  int v13; // ebx@7
  int *v14; // edi@7
  __int64 *v15; // esi@7
  int v16; // edx@7
  int v17; // edx@9
  int result; // eax@11
  int v20; // edx@11
  signed int v21; // [sp+10h] [bp-E8h]@3
  signed int v22; // [sp+10h] [bp-E8h]@7
  double v23; // [sp+18h] [bp-E0h]@1
  double v24; // [sp+20h] [bp-D8h]@1
  double v25; // [sp+28h] [bp-D0h]@1
  int v26; // [sp+30h] [bp-C8h]@1
  int v27; // [sp+34h] [bp-C4h]@1
  int v28; // [sp+38h] [bp-C0h]@1
  int v29; // [sp+3Ch] [bp-BCh]@1
  int v30; // [sp+40h] [bp-B8h]@1
  int v31; // [sp+44h] [bp-B4h]@1
  int v32; // [sp+48h] [bp-B0h]@4
  char v33; // [sp+60h] [bp-98h]@4
  int Base; // [sp+68h] [bp-90h]@3
  int v35; // [sp+6Ch] [bp-8Ch]@7
  double v36; // [sp+98h] [bp-60h]@1
  double v37; // [sp+A0h] [bp-58h]@1
  double v38; // [sp+A8h] [bp-50h]@1
  double v39; // [sp+B0h] [bp-48h]@1
  double v40; // [sp+B8h] [bp-40h]@1
  double v41; // [sp+C0h] [bp-38h]@1
  double v42; // [sp+C8h] [bp-30h]@1
  double v43; // [sp+D0h] [bp-28h]@1
  double v44; // [sp+D8h] [bp-20h]@1
  double v45; // [sp+E0h] [bp-18h]@1
  double v46; // [sp+E8h] [bp-10h]@1
  double v47; // [sp+F0h] [bp-8h]@1

  v3 = *(_DWORD *)(a2 + 8);
  v4 = *(_DWORD *)(a2 + 12);
  v42 = *(double *)a2;
  LODWORD(v5) = v3;
  HIDWORD(v5) = v4;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v23 = v42 * -1.0;
  v43 = v42 * -1.0;
  HIDWORD(v6) = *(_DWORD *)(a3 + 4);
  LODWORD(v25) = *(_DWORD *)a3;
  LODWORD(v7) = *(_DWORD *)(a3 + 8);
  HIDWORD(v25) = HIDWORD(v6);
  HIDWORD(v7) = *(_DWORD *)(a3 + 12);
  v24 = v7;
  v44 = v42 + 3.141592653589793;
  v36 = v5;
  v29 = 0;
  v30 = 0;
  v31 = 1072693248;
  v45 = 3.141592653589793 - v42;
  v46 = 3.141592653589793 - v42 * -1.0;
  v47 = v42 * -1.0 + 3.141592653589793;
  v37 = v5 * -1.0;
  v38 = v5 + 3.141592653589793;
  v39 = 3.141592653589793 - v5;
  v40 = 3.141592653589793 - v5 * -1.0;
  v41 = v5 * -1.0 + 3.141592653589793;
  if ( fabs(v25 - v6) <= dbl_1000A010 )
    *(double *)(a3 + 8) = v24 * -1.0;
  v8 = 0;
  v9 = &Base;
  v10 = &v42;
  v21 = 6;
  do
  {
    sub_10003600(a1, *v10, v25, &v32, 0);
    UF_VEC3_unitize(&v32, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v33, &v32);
    UF_VEC3_is_equal(&v26, &v32, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v23);
    if ( LODWORD(v23) )
    {
      v11 = *((_DWORD *)v10 + 1);
      *v9 = *(_DWORD *)v10;
      v9[1] = v11;
      ++v8;
      v9 += 2;
    }
    ++v10;
  }
  while ( v21-- != 1 );
  qsort(&Base, v8 - 1, 8u, (int (__cdecl *)(const void *, const void *))PtFuncCompare);
  v16 = v35;
  *(_DWORD *)a2 = Base;
  *(_DWORD *)(a2 + 4) = v16;
  v13 = 0;
  v14 = &Base;
  v15 = (__int64 *)&v36;
  v22 = 6;
  do
  {
    sub_10003600(a1, *(double *)v15, v24, &v32, 0);
    UF_VEC3_unitize(&v32, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v33, &v32);
    UF_VEC3_is_equal(&v26, &v32, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v23);
    if ( LODWORD(v23) )
    {
      v17 = *((_DWORD *)v15 + 1);
      *v14 = *(_DWORD *)v15;
      v14[1] = v17;
      ++v13;
      v14 += 2;
    }
    ++v15;
  }
  while ( v22-- != 1 );
  qsort(&Base, v13 - 1, 8u, (int (__cdecl *)(const void *, const void *))PtFuncCompare);
  result = a2;
  v20 = v35;
  *(_DWORD *)(a2 + 8) = Base;
  *(_DWORD *)(a2 + 12) = v20;
  return result;
}
// 100090D0: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090E8: using guessed type int __cdecl UF_VEC3_is_equal(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1000A010: using guessed type double dbl_1000A010;

//----- (10003C90) --------------------------------------------------------
signed int __cdecl PtFuncCompare(int a1, int a2)
{
  signed int result; // eax@2

  if ( fabs(*(double *)a1 - *(double *)a2) > dbl_1000A010 )
  {
    if ( dbl_1000A010 + *(double *)a2 >= *(double *)a1 )
      result = -1;
    else
      result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1000A010: using guessed type double dbl_1000A010;

//----- (10003CD0) --------------------------------------------------------
void __cdecl sub_10003CD0(int a1, int a2)
{
  double v2; // st7@5
  long double v3; // st7@6
  double v4; // st7@11
  double v5; // [sp+0h] [bp-8h]@4

  if ( fabs(*(double *)a1 - *(double *)(a1 + 8)) <= dbl_1000A010 )
  {
    if ( fabs(*(double *)a2 - *(double *)(a2 + 8)) <= dbl_1000A010 )
    {
      if ( fabs(*(double *)a1 - *(double *)a2) > dbl_1000A010 )
      {
        v5 = -dbl_1000A010;
        if ( *(double *)a1 >= v5 )
        {
          if ( *(double *)a2 >= v5 )
          {
            if ( dbl_1000A010 < *(double *)(a2 + 8) )
              *(double *)(a2 + 8) = *(double *)(a2 + 8) - 6.283185307179586;
          }
          else
          {
            v4 = *(double *)a2 + 6.283185307179586;
            if ( fabs(v4 - *(double *)a1) <= dbl_1000A010 )
            {
              if ( *(double *)(a2 + 8) < v5 )
                *(double *)(a2 + 8) = *(double *)(a2 + 8) + 6.283185307179586;
            }
            else
            {
              *(_QWORD *)a2 = *(_QWORD *)&v4;
              if ( fabs(v4 - *(double *)(a2 + 8)) <= dbl_1000A010 )
                *(double *)(a2 + 8) = 6.283185307179586 - v4;
            }
          }
        }
        else
        {
          v2 = *(double *)a1 + 6.283185307179586;
          *(_QWORD *)a1 = *(_QWORD *)&v2;
          *(double *)(a1 + 8) = 6.283185307179586 - v2;
        }
      }
    }
  }
  v3 = *(double *)a1;
  if ( fabs(v3 - *(double *)a2) <= dbl_1000A010 )
  {
    if ( fabs(*(double *)(a1 + 8) - *(double *)(a2 + 8)) <= dbl_1000A010 )
    {
      if ( -dbl_1000A010 <= *(double *)(a2 + 8) )
      {
        if ( dbl_1000A010 >= *(double *)(a2 + 8) )
        {
          if ( fabs(v3) <= dbl_1000A010 )
          {
            if ( fabs(*(long double *)a2) <= dbl_1000A010 )
            {
              *(_DWORD *)(a2 + 8) = 1413754136;
              *(_DWORD *)(a2 + 12) = 1075388923;
            }
          }
        }
        else
        {
          *(double *)(a2 + 8) = 6.283185307179586 - *(double *)(a2 + 8);
        }
      }
      else
      {
        *(double *)(a2 + 8) = *(double *)(a2 + 8) + 6.283185307179586;
      }
    }
  }
}
// 1000A010: using guessed type double dbl_1000A010;

//----- (10003EC0) --------------------------------------------------------
int __cdecl sub_10003EC0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  char v6; // c3@2
  int result; // eax@3
  double v8; // st7@9
  int v9; // eax@12
  double v10; // st6@12
  double v11; // st7@12
  double v12; // st7@12
  double v13; // st7@13
  double v14; // st7@13
  char v15; // zf@13
  double v16; // [sp+10h] [bp-78h]@1
  double v17; // [sp+18h] [bp-70h]@1
  double v18; // [sp+20h] [bp-68h]@1
  double v19; // [sp+28h] [bp-60h]@1
  double v20; // [sp+30h] [bp-58h]@1
  double v21; // [sp+38h] [bp-50h]@8
  char v22[24]; // [sp+40h] [bp-48h]@1
  char v23[24]; // [sp+58h] [bp-30h]@1
  char v24; // [sp+70h] [bp-18h]@1

  UF_VEC3_sub(a1 + 24, a1, v22);
  UF_VEC3_sub(a1, a2, &v24);
  UF_VEC3_sub(a2 + 24, a2, v23);
  UF_VEC3_dot(v22, &v24, &v20);
  UF_VEC3_dot(v23, v22, &v17);
  UF_VEC3_dot(v23, &v24, &v19);
  UF_VEC3_dot(v23, v23, &v16);
  UF_VEC3_dot(v22, v22, &v18);
  if ( v16 != 0.0 )
  {
    if ( v18 == 0.0 )
    {
      UF_VEC3_copy(a1, a3);
      *(_DWORD *)a5 = 0;
      *(_DWORD *)(a5 + 4) = 0;
      return 0;
    }
    v21 = v17 * v17 - v18 * v16;
    if ( v21 != 0.0 )
    {
      v8 = v17 * v17 / (v18 * v16);
      if ( v8 < 0.0 )
        v8 = -v8;
      if ( v8 < 1.0 - (dbl_1000A010 + dbl_1000A010) )
      {
        v10 = (v16 * v20 - v19 * v17) / v21;
        *(_QWORD *)a5 = *(_QWORD *)&v10;
        v9 = a1;
        v11 = v10 * v17;
        LODWORD(v17) = a2 - a1;
        v12 = (v11 + v19) / v16;
        LODWORD(v16) = 3;
        *(_QWORD *)a6 = *(_QWORD *)&v12;
        do
        {
          v13 = *(double *)(&v22[v9] - a1) * *(double *)a5;
          v9 += 8;
          *(double *)(a3 - a1 + v9 - 8) = v13 + *(double *)(v9 - 8);
          v14 = *(double *)(&v23[v9 - 8] - a1) * *(double *)a6 + *(double *)(LODWORD(v17) + v9 - 8);
          v15 = LODWORD(v16)-- == 1;
          *(_QWORD *)(a4 - a1 + v9 - 8) = *(_QWORD *)&v14;
        }
        while ( !v15 );
        return 0;
      }
    }
    UF_VEC3_copy(a1, a3);
    *(_DWORD *)a5 = 0;
    *(_DWORD *)(a5 + 4) = 0;
    result = sub_10004150(a3, a2, a4, a6);
    if ( result )
      return result;
    return 0;
  }
  UF_VEC3_copy(a2, a4);
  v6 = v18 == 0.0;
  *(_DWORD *)a6 = 0;
  *(_DWORD *)(a6 + 4) = 0;
  if ( v6 )
  {
    UF_VEC3_copy(a1, a3);
    *(_DWORD *)a5 = 0;
    *(_DWORD *)(a5 + 4) = 0;
    return 0;
  }
  result = sub_10004150(a4, a1, a3, a5);
  if ( !result )
    return 0;
  return result;
}
// 100090A4: using guessed type int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD);
// 100090A8: using guessed type int __cdecl UF_VEC3_dot(_DWORD, _DWORD, _DWORD);
// 100090CC: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);
// 1000A010: using guessed type double dbl_1000A010;
// 10003EC0: using guessed type char var_48[24];
// 10003EC0: using guessed type char var_30[24];

//----- (10004150) --------------------------------------------------------
int __cdecl sub_10004150(int a1, int a2, int a3, int a4)
{
  int v4; // eax@2
  signed int v5; // esi@2
  double v6; // st7@3
  int result; // eax@4
  double v8; // [sp+8h] [bp-40h]@2
  double v9; // [sp+10h] [bp-38h]@1
  double v10; // [sp+18h] [bp-30h]@1
  double v11; // [sp+20h] [bp-28h]@1
  double v12; // [sp+28h] [bp-20h]@1
  char v13; // [sp+30h] [bp-18h]@1

  UF_VEC3_sub(a2 + 24, a2, &v10);
  UF_VEC3_sub(a1, a2, &v13);
  v9 = v12 * v12 + v11 * v11 + v10 * v10;
  if ( v9 <= 0.0 )
  {
    *(_DWORD *)a4 = 0;
    *(_DWORD *)(a4 + 4) = 0;
    UF_VEC3_copy(a2, a3);
    result = 0;
  }
  else
  {
    UF_VEC3_dot(&v10, &v13, &v8);
    v4 = a2;
    v5 = 3;
    *(double *)a4 = v8 / v9;
    do
    {
      v6 = *(double *)((char *)&v10 + v4 - a2) * *(double *)a4;
      v4 += 8;
      --v5;
      *(double *)(a3 - a2 + v4 - 8) = v6 + *(double *)(v4 - 8);
    }
    while ( v5 );
    result = 0;
  }
  return result;
}
// 100090A4: using guessed type int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD);
// 100090A8: using guessed type int __cdecl UF_VEC3_dot(_DWORD, _DWORD, _DWORD);
// 100090CC: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);

//----- (10004230) --------------------------------------------------------
signed int __cdecl sub_10004230(int a1, int a2, int a3, int a4)
{
  int v4; // ecx@1
  int v5; // ebx@1
  int v6; // esi@1
  long double **v7; // edx@2
  long double *v8; // ecx@3
  int v9; // edi@3
  long double v10; // st7@4
  int v11; // ecx@9
  int v12; // edx@10
  int v13; // edi@10
  signed int result; // eax@11
  int v15; // esi@13
  int v16; // eax@15
  double v17; // st7@15
  int v18; // edx@16
  int v19; // edi@16
  int v20; // ebx@17
  int v21; // eax@19
  int v22; // edx@20
  int v23; // edi@22
  long double v24; // st7@22
  int v25; // eax@23
  int v26; // edx@23
  int v27; // esi@23
  int v28; // ebx@24
  long double v29; // st7@26
  int v30; // esi@31
  int v31; // ebx@32
  int v32; // edx@32
  double v33; // st7@32
  int v34; // edx@34
  int v35; // edx@36
  int v36; // edx@38
  int v37; // esi@38
  int v38; // eax@39
  int v39; // [sp+10h] [bp-30h]@9
  int v40; // [sp+14h] [bp-2Ch]@30
  int v41; // [sp+18h] [bp-28h]@10
  int v42; // [sp+1Ch] [bp-24h]@1
  int v43; // [sp+20h] [bp-20h]@2
  int v44; // [sp+20h] [bp-20h]@14
  int v45; // [sp+20h] [bp-20h]@21
  int v46; // [sp+24h] [bp-1Ch]@20
  int v47; // [sp+28h] [bp-18h]@21
  double v48; // [sp+28h] [bp-18h]@37
  char v49; // [sp+34h] [bp-Ch]@1
  long double v50; // [sp+38h] [bp-8h]@3

  v5 = a2;
  v4 = UF_allocate_memory(8 * a2, &v49);
  v6 = 0;
  *(_DWORD *)a4 = 0;
  v42 = v4;
  *(_DWORD *)(a4 + 4) = 1072693248;
  if ( a2 <= 0 )
  {
LABEL_9:
    v11 = 0;
    v39 = 0;
    if ( a2 > 0 )
    {
      v12 = a1;
      v13 = a1;
      v41 = a1;
      while ( 1 )
      {
        v15 = 0;
        if ( v11 > 0 )
        {
          v44 = v12;
          do
          {
            v16 = *(_DWORD *)v12;
            v17 = *(double *)(v11 + *(_DWORD *)v12);
            if ( v15 > 0 )
            {
              v18 = a1;
              v19 = v15;
              do
              {
                v16 += 8;
                v20 = *(_DWORD *)v18 + v11;
                v18 += 4;
                --v19;
                v17 = v17 - *(double *)v20 * *(double *)(v16 - 8);
              }
              while ( v19 );
              v12 = v44;
              v5 = a2;
              v13 = v41;
            }
            v21 = *(_DWORD *)v12;
            ++v15;
            v12 += 4;
            *(_QWORD *)(v11 + v21) = *(_QWORD *)&v17;
            v44 = v12;
          }
          while ( v15 < v39 );
        }
        v22 = v39;
        *(_QWORD *)&v50 = 0i64;
        v46 = v39;
        if ( v39 < v5 )
        {
          v47 = v13;
          v45 = v11 + v42;
          do
          {
            v23 = *(_DWORD *)v13;
            v24 = *(double *)(v11 + v23);
            if ( v11 > 0 )
            {
              v26 = a1;
              v27 = v39;
              v25 = v23;
              do
              {
                v28 = *(_DWORD *)v26;
                v25 += 8;
                v26 += 4;
                --v27;
                v24 = v24 - *(double *)(v28 + v11) * *(double *)(v25 - 8);
              }
              while ( v27 );
              v22 = v46;
              v5 = a2;
            }
            *(_QWORD *)(v11 + v23) = *(_QWORD *)&v24;
            v29 = fabs(v24) * *(double *)v45;
            if ( v29 >= v50 )
            {
              v50 = v29;
              v40 = v22;
            }
            ++v22;
            v13 = v47 + 4;
            v46 = v22;
            v47 += 4;
            v45 += 8;
          }
          while ( v22 < v5 );
          v13 = v41;
        }
        if ( v39 != v40 )
        {
          v30 = 0;
          do
          {
            v31 = *(_DWORD *)v13 + 8 * v30;
            v32 = 8 * v30 + *(_DWORD *)(a1 + 4 * v40);
            v33 = *(double *)v32;
            *(_DWORD *)v32 = *(_DWORD *)v31;
            *(_DWORD *)(v32 + 4) = *(_DWORD *)(v31 + 4);
            v13 = v41;
            *(_QWORD *)(8 * v30 + *(_DWORD *)v41) = *(_QWORD *)&v33;
            v5 = a2;
            ++v30;
          }
          while ( v30 < a2 );
          *(double *)a4 = -*(double *)a4;
          *(_DWORD *)(v42 + 8 * v40) = *(_DWORD *)(v11 + v42);
          *(_DWORD *)(v42 + 8 * v40 + 4) = *(_DWORD *)(v11 + v42 + 4);
        }
        *(_DWORD *)(a3 - a1 + v13) = v40;
        v34 = v11 + *(_DWORD *)v13;
        if ( *(double *)(v11 + *(_DWORD *)v13) == 0.0 )
        {
          *(_DWORD *)v34 = 210911779;
          *(_DWORD *)(v34 + 4) = 1002937505;
        }
        v35 = v39;
        if ( v39 != v5 - 1 )
        {
          v48 = 1.0 / *(double *)(*(_DWORD *)v13 + v11);
          if ( v39 + 1 < v5 )
          {
            v36 = v13 + 4;
            v37 = v5 - (v39 + 1);
            do
            {
              v38 = *(_DWORD *)v36;
              v36 += 4;
              --v37;
              *(double *)(v11 + v38) = v48 * *(double *)(v38 + v11);
            }
            while ( v37 );
            v35 = v39;
          }
        }
        v13 += 4;
        v11 += 8;
        v39 = v35 + 1;
        v41 = v13;
        if ( v35 + 1 >= v5 )
          break;
        v12 = a1;
      }
    }
    UF_free(v42);
    result = 0;
  }
  else
  {
    v7 = (long double **)a1;
    v43 = v4;
    while ( 1 )
    {
      v8 = *v7;
      *(_QWORD *)&v50 = 0i64;
      v9 = a2;
      do
      {
        v10 = fabs(*v8);
        if ( v10 > v50 )
          v50 = v10;
        ++v8;
        --v9;
      }
      while ( v9 );
      if ( v50 == 0.0 )
        break;
      ++v6;
      ++v7;
      v43 += 8;
      *(long double *)(v43 - 8) = 1.0 / v50;
      if ( v6 >= a2 )
        goto LABEL_9;
    }
    UF_free(v42);
    result = 1;
  }
  return result;
}
// 10009058: using guessed type int __cdecl UF_free(_DWORD);
// 10009064: using guessed type int __cdecl UF_allocate_memory(_DWORD, _DWORD);

//----- (10004510) --------------------------------------------------------
int __cdecl sub_10004510(int a1, int a2, int a3, int a4)
{
  int v4; // edx@1
  int v5; // ecx@1
  int v6; // ebp@1
  int v7; // esi@1
  int v8; // eax@2
  int v9; // ebx@2
  int v10; // edi@2
  int v11; // eax@4
  double v12; // st7@4
  int v13; // eax@6
  int v14; // esi@6
  double v15; // st6@7
  int result; // eax@13
  int v17; // ebx@14
  int v18; // ebp@14
  double v19; // st7@15
  int v20; // edx@16
  int v21; // esi@16
  double v22; // st6@17
  int v23; // edx@19
  signed int v24; // [sp+10h] [bp-4h]@1
  int i; // [sp+20h] [bp+Ch]@2

  v5 = a4;
  v6 = a1;
  v7 = a2;
  v4 = 0;
  v24 = 0;
  if ( a2 > 0 )
  {
    v10 = a4;
    v8 = a3 - a1;
    v9 = a1;
    for ( i = a3 - a1; ; v8 = i )
    {
      v11 = *(_DWORD *)(v8 + v9);
      v12 = *(double *)(v5 + 8 * v11);
      *(_DWORD *)(v5 + 8 * v11) = *(_DWORD *)(v5 + 8 * v4);
      *(_DWORD *)(v5 + 8 * v11 + 4) = *(_DWORD *)(v5 + 8 * v4 + 4);
      if ( v24 )
      {
        if ( v10 < v4 )
        {
          v13 = v5 + 8 * v10;
          v14 = v4 - a4;
          do
          {
            v15 = *(double *)(*(_DWORD *)v9 - v5 + v13) * *(double *)v13;
            v13 += 8;
            --v14;
            v12 = v12 - v15;
          }
          while ( v14 );
          v7 = a2;
          v10 = a4;
        }
      }
      else
      {
        if ( v12 != 0.0 )
        {
          v10 = v4;
          v24 = 1;
          a4 = v4;
        }
      }
      *(_QWORD *)(v5 + 8 * v4++) = *(_QWORD *)&v12;
      v9 += 4;
      if ( v4 >= v7 )
        break;
    }
    v6 = a1;
  }
  result = v7 - 1;
  if ( v7 - 1 >= 0 )
  {
    v17 = v7;
    v18 = v6 + 4 * result;
    do
    {
      v19 = *(double *)(v5 + 8 * result);
      if ( v17 < v7 )
      {
        v20 = v5 + 8 * result + 8;
        v21 = v7 - v17;
        do
        {
          v22 = *(double *)(v20 + *(_DWORD *)v18 - v5) * *(double *)v20;
          v20 += 8;
          --v21;
          v19 = v19 - v22;
        }
        while ( v21 );
        v7 = a2;
      }
      v23 = *(_DWORD *)v18;
      --result;
      --v17;
      v18 -= 4;
      *(double *)(v5 + 8 * result + 8) = v19 / *(double *)(v23 + 8 * result + 8);
    }
    while ( result >= 0 );
  }
  return result;
}

//----- (10004600) --------------------------------------------------------
double __cdecl sub_10004600(int a1, long double *a2)
{
  double result; // st7@2
  double v3; // st7@3
  double v4; // st7@3
  double v5; // [sp+8h] [bp-8h]@3

  if ( fabs(fabs(*a2)) > 1.0e-10 )
  {
    v4 = 1.0 / *a2;
    v5 = v4;
    v3 = v4 * *(double *)a1;
    if ( v3 >= 0.000001 )
    {
      result = floor(v3 + 0.5) / v5;
    }
    else
    {
      if ( v3 <= -0.000001 )
        result = ceil(v3 - 0.5) / v5;
      else
        result = 0.0 / v5;
    }
  }
  else
  {
    result = 0.0;
  }
  return result;
}

//----- (100046A0) --------------------------------------------------------
signed int __cdecl sub_100046A0(int a1)
{
  signed int v2; // edi@1
  char v3; // [sp+8h] [bp-48h]@1

  UF_MTX4_ask_rotation(a1, &v3);
  v2 = sub_100046E0((int)&v3);
  UF_MTX4_edit_rotation(a1, &v3);
  return v2;
}
// 10009060: using guessed type int __cdecl UF_MTX4_ask_rotation(_DWORD, _DWORD);
// 10009078: using guessed type int __cdecl UF_MTX4_edit_rotation(_DWORD, _DWORD);

//----- (100046E0) --------------------------------------------------------
signed int __cdecl sub_100046E0(int a1)
{
  signed int v1; // ecx@1
  int v2; // esi@1
  long double v3; // st7@2
  double v4; // st7@6
  signed int result; // eax@12
  char v6; // [sp+10h] [bp-98h]@10
  char v7; // [sp+18h] [bp-90h]@1
  char v8; // [sp+30h] [bp-78h]@1
  char v9; // [sp+48h] [bp-60h]@1
  char v10; // [sp+60h] [bp-48h]@1

  v2 = a1;
  UF_VEC3_copy(a1, &v7);
  UF_VEC3_copy(a1 + 24, &v8);
  UF_VEC3_copy(a1 + 48, &v9);
  UF_MTX3_copy(a1, &v10);
  v1 = 9;
  do
  {
    v3 = *(double *)v2;
    if ( fabs(v3) > 1.0e-10 )
    {
      if ( fabs(fabs(v3) - 1.0) <= 1.0e-10 )
      {
        if ( *(double *)v2 <= 0.0 )
          v4 = -1.0;
        else
          v4 = 1.0;
        *(_QWORD *)v2 = *(_QWORD *)&v4;
      }
    }
    else
    {
      *(_DWORD *)v2 = 0;
      *(_DWORD *)(v2 + 4) = 0;
    }
    v2 += 8;
    --v1;
  }
  while ( v1 );
  if ( UF_VEC3_unitize(&v7, -640172613, 1037794527, &v6, &v7) && UF_VEC3_unitize(&v8, -640172613, 1037794527, &v6, &v8) )
  {
    UF_VEC3_cross(&v7, &v8, &v9);
    UF_VEC3_cross(&v9, &v7, &v8);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100090C4: using guessed type int __cdecl UF_MTX3_copy(_DWORD, _DWORD);
// 100090CC: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);
// 100090D0: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090D8: using guessed type int __cdecl UF_VEC3_cross(_DWORD, _DWORD, _DWORD);

//----- (10004810) --------------------------------------------------------
int __cdecl sub_10004810(int a1, int a2)
{
  int v2; // edi@1
  char *v3; // edi@3
  char *v4; // edi@6
  char *v5; // edi@9
  char *v6; // edi@12
  char *v7; // edi@15
  char *v8; // edi@18
  char *v9; // eax@21
  char *v10; // eax@24
  char *v11; // eax@27
  char *v12; // eax@30
  char *v13; // ecx@33
  int v14; // eax@34
  char *v15; // ecx@38
  int v16; // eax@39
  char *v17; // ecx@43
  int v18; // eax@44
  int result; // eax@49
  char *Str; // [sp+Ch] [bp-98h]@2
  int v21; // [sp+10h] [bp-94h]@1
  int v22; // [sp+14h] [bp-90h]@2
  int v23; // [sp+18h] [bp-8Ch]@1
  int v24; // [sp+1Ch] [bp-88h]@1
  int v25; // [sp+20h] [bp-84h]@1
  int v26; // [sp+24h] [bp-80h]@1
  int v27; // [sp+28h] [bp-7Ch]@1
  int v28; // [sp+2Ch] [bp-78h]@1
  int v29; // [sp+30h] [bp-74h]@1
  int v30; // [sp+34h] [bp-70h]@1
  int v31; // [sp+38h] [bp-6Ch]@1
  int v32; // [sp+3Ch] [bp-68h]@1
  int v33; // [sp+40h] [bp-64h]@1
  int v34; // [sp+44h] [bp-60h]@1
  int v35; // [sp+48h] [bp-5Ch]@1
  char v36[4]; // [sp+4Ch] [bp-58h]@1
  char v37; // [sp+50h] [bp-54h]@34
  char v38; // [sp+6Ch] [bp-38h]@44
  char v39; // [sp+88h] [bp-1Ch]@39

  v2 = (int)"mom_kin_machine_type";
  v33 = (int)"mom_kin_gauge_to_pivot_x";
  v35 = (int)"mom_kin_gauge_to_pivot_x";
  v23 = (int)"mom_kin_machine_type";
  v24 = (int)"mom_kin_track_center_of_ball";
  v25 = (int)"mom_kin_wire_tilt_output_type";
  v26 = (int)"mom_kin_clsf_generation";
  v27 = (int)"mom_kin_coordinate_type";
  v28 = (int)"mom_kin_linearization_flag";
  v29 = (int)"mom_kin_machine_resolution";
  v30 = (int)"mom_kin_tool_tracking_height";
  v31 = (int)"mom_kin_5th_axis_inclination_to_4th";
  v32 = (int)"mom_kin_linearization_tol";
  v34 = (int)"mom_kin_gauge_to_pivot_y";
  *(_DWORD *)v36 = "END";
  v21 = 0;
  if ( strcmp("mom_kin_machine_type", "END") )
  {
    do
    {
      v22 = UF_MOM_ask_string(a1, v2 + 4, &Str);
      switch ( v21 )
      {
        case 0:
          v3 = Str;
          if ( !Str )
          {
            v3 = "3_axis_mill";
            Str = "3_axis_mill";
          }
          strcpy((char *)a2, v3);
          break;
        case 1:
          v4 = Str;
          if ( !Str )
          {
            v4 = (char *)L"T";
            Str = (char *)L"T";
          }
          strcpy((char *)(a2 + 133), v4);
          break;
        case 2:
          v5 = Str;
          if ( !Str )
          {
            v5 = "NONE";
            Str = "NONE";
          }
          strcpy((char *)(a2 + 266), v5);
          break;
        case 3:
          v6 = Str;
          if ( !Str )
          {
            v6 = (char *)L"F";
            Str = (char *)L"F";
          }
          strcpy((char *)(a2 + 399), v6);
          break;
        case 4:
          v7 = Str;
          if ( !Str )
          {
            v7 = "CARTESIAN";
            Str = "CARTESIAN";
          }
          strcpy((char *)(a2 + 532), v7);
          break;
        case 5:
          v8 = Str;
          if ( !Str )
          {
            v8 = (char *)L"F";
            Str = (char *)L"F";
          }
          strcpy((char *)(a2 + 665), v8);
          break;
        case 6:
          v9 = Str;
          if ( !Str )
          {
            v9 = "0.0001";
            Str = "0.0001";
          }
          *(double *)(a2 + 800) = strtod(v9, 0);
          break;
        case 7:
          v10 = Str;
          if ( !Str )
          {
            v10 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 808) = strtod(v10, 0);
          break;
        case 8:
          v11 = Str;
          if ( !Str )
          {
            v11 = "90.0";
            Str = "90.0";
          }
          *(double *)(a2 + 816) = strtod(v11, 0);
          break;
        case 9:
          v12 = Str;
          if ( !Str )
          {
            v12 = "0.0001";
            Str = "0.0001";
          }
          *(double *)(a2 + 824) = strtod(v12, 0);
          break;
        case 10:
          v13 = Str;
          if ( !Str )
          {
            memcpy(&v37, "kin_4th_to_tracking_point_x", 0x1Cu);
            v14 = sub_10004C90(a1, (int)&v37, 0);
            v13 = Str;
            if ( !Str || v14 )
            {
              v13 = "0.0";
              Str = "0.0";
            }
          }
          *(double *)(a2 + 832) = strtod(v13, 0);
          break;
        case 11:
          v15 = Str;
          if ( !Str )
          {
            memcpy(&v39, "kin_4th_to_tracking_point_y", 0x1Cu);
            v16 = sub_10004C90(a1, (int)&v39, 0);
            v15 = Str;
            if ( !Str || v16 )
            {
              v15 = "0.0";
              Str = "0.0";
            }
          }
          *(double *)(a2 + 840) = strtod(v15, 0);
          break;
        case 12:
          v17 = Str;
          if ( !Str )
          {
            memcpy(&v38, "kin_4th_to_tracking_point_z", 0x1Cu);
            v18 = sub_10004C90(a1, (int)&v38, 0);
            v17 = Str;
            if ( !Str || v18 )
            {
              v17 = "0.0";
              Str = "0.0";
            }
          }
          *(double *)(a2 + 848) = strtod(v17, 0);
          break;
        default:
          break;
      }
      ++v21;
      v2 = *(&v23 + v21);
    }
    while ( strcmp((const char *)*(&v23 + v21), "END") );
    result = v22;
  }
  else
  {
    result = v22;
  }
  return result;
}
// 10009068: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);
// 1000A57C: using guessed type wchar_t asc_1000A57C[2];
// 1000A588: using guessed type wchar_t aT[2];

//----- (10004C90) --------------------------------------------------------
int __cdecl sub_10004C90(int a1, int a2, char a3)
{
  return UF_MOM_ask_string(a1, a2, &a3);
}
// 10009068: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10004CB0) --------------------------------------------------------
int __cdecl sub_10004CB0(int a1, char *Str)
{
  int v2; // ebx@1
  const char *v3; // edi@1
  char *v4; // ebp@2
  const char *v5; // edi@4
  const char *v6; // edi@7
  const char *v7; // edi@10
  const char *v8; // edi@13
  const char *v9; // eax@16
  const char *v10; // eax@19
  int result; // eax@23
  int v12; // ST1C_4@24
  int v13; // [sp+Ch] [bp-20h]@3
  int v14; // [sp+14h] [bp-18h]@1
  int v15; // [sp+18h] [bp-14h]@1
  int v16; // [sp+1Ch] [bp-10h]@1
  int v17; // [sp+20h] [bp-Ch]@1
  int v18; // [sp+24h] [bp-8h]@1
  char v19[4]; // [sp+28h] [bp-4h]@1

  v3 = "mom_kin_nurbs_output_type";
  v14 = (int)"mom_kin_output_unit";
  v15 = (int)"mom_kin_polar_radius_side";
  v16 = (int)"mom_kin_read_ahead_next_motion";
  v17 = (int)"mom_kin_pivot_gauge_offset";
  v18 = (int)"mom_kin_rapid_feed_rate";
  *(_DWORD *)v19 = "END";
  v2 = 0;
  if ( strcmp("mom_kin_nurbs_output_type", "END") )
  {
    v4 = Str;
    do
    {
      v13 = UF_MOM_ask_string(a1, v3 + 4, &Str);
      switch ( v2 )
      {
        case 0:
          v5 = Str;
          if ( !Str )
          {
            v5 = "NONE";
            Str = "NONE";
          }
          strcpy(v4, v5);
          break;
        case 1:
          v6 = Str;
          if ( !Str )
          {
            v6 = "IN";
            Str = "IN";
          }
          strcpy(v4 + 133, v6);
          break;
        case 2:
          v7 = Str;
          if ( !Str )
          {
            v7 = "NONE";
            Str = "NONE";
          }
          strcpy(v4 + 266, v7);
          break;
        case 3:
          v8 = Str;
          if ( !Str )
          {
            v8 = (const char *)L"F";
            Str = (char *)L"F";
          }
          strcpy(v4 + 399, v8);
          break;
        case 4:
          v9 = Str;
          if ( !Str )
          {
            v9 = "0.0";
            Str = "0.0";
          }
          *((double *)v4 + 67) = strtod(v9, 0);
          break;
        case 5:
          v10 = Str;
          if ( !Str )
          {
            v10 = "400.00";
            Str = "400.00";
          }
          *((double *)v4 + 68) = strtod(v10, 0);
          break;
        default:
          break;
      }
      v3 = (const char *)*(&v14 + v2++);
    }
    while ( strcmp(v3, "END") );
    result = v13;
  }
  else
  {
    result = v12;
  }
  return result;
}
// 10009068: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);
// 1000A57C: using guessed type wchar_t asc_1000A57C[2];

//----- (10004EF0) --------------------------------------------------------
int __cdecl sub_10004EF0(int a1, char *Str)
{
  int v2; // ebx@1
  const char *v3; // edi@1
  char *v4; // ebp@2
  const char *v5; // edi@4
  const char *v6; // edi@7
  const char *v7; // eax@10
  const char *v8; // eax@13
  int result; // eax@17
  int v10; // ST1C_4@18
  int v11; // [sp+Ch] [bp-18h]@3
  int v12; // [sp+14h] [bp-10h]@1
  int v13; // [sp+18h] [bp-Ch]@1
  int v14; // [sp+1Ch] [bp-8h]@1
  char v15[4]; // [sp+20h] [bp-4h]@1

  v3 = "mom_kin_arc_output_mode";
  v12 = (int)"mom_kin_arc_valid_plane";
  v13 = (int)"mom_kin_min_arc_radius";
  v14 = (int)"mom_kin_max_arc_radius";
  *(_DWORD *)v15 = "END";
  v2 = 0;
  if ( strcmp("mom_kin_arc_output_mode", "END") )
  {
    v4 = Str;
    do
    {
      v11 = UF_MOM_ask_string(a1, v3 + 4, &Str);
      switch ( v2 )
      {
        case 0:
          v5 = Str;
          if ( !Str )
          {
            v5 = "FULL_CIRCLE";
            Str = "FULL_CIRCLE";
          }
          strcpy(v4, v5);
          break;
        case 1:
          v6 = Str;
          if ( !Str )
          {
            v6 = "XY";
            Str = "XY";
          }
          strcpy(v4 + 133, v6);
          break;
        case 2:
          v7 = Str;
          if ( !Str )
          {
            v7 = "0.0001";
            Str = "0.0001";
          }
          *((double *)v4 + 34) = strtod(v7, 0);
          break;
        case 3:
          v8 = Str;
          if ( !Str )
          {
            v8 = "9999.9999";
            Str = "9999.9999";
          }
          *((double *)v4 + 35) = strtod(v8, 0);
          break;
        default:
          break;
      }
      v3 = (const char *)*(&v12 + v2++);
    }
    while ( strcmp(v3, "END") );
    result = v11;
  }
  else
  {
    result = v10;
  }
  return result;
}
// 10009068: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (100050A0) --------------------------------------------------------
int __cdecl sub_100050A0(int a1, char *Str)
{
  int v2; // ebx@1
  const char *v3; // edi@1
  char *v4; // ebp@2
  const char *v5; // eax@4
  const char *v6; // eax@7
  const char *v7; // eax@10
  const char *v8; // eax@13
  const char *v9; // eax@16
  const char *v10; // eax@19
  const char *v11; // eax@22
  const char *v12; // eax@25
  int result; // eax@29
  int v14; // ST1C_4@30
  int v15; // [sp+Ch] [bp-28h]@3
  int v16; // [sp+14h] [bp-20h]@1
  int v17; // [sp+18h] [bp-1Ch]@1
  int v18; // [sp+1Ch] [bp-18h]@1
  int v19; // [sp+20h] [bp-14h]@1
  int v20; // [sp+24h] [bp-10h]@1
  int v21; // [sp+28h] [bp-Ch]@1
  int v22; // [sp+2Ch] [bp-8h]@1
  char v23[4]; // [sp+30h] [bp-4h]@1

  v3 = "mom_kin_max_fpm";
  v16 = (int)"mom_kin_min_fpm";
  v17 = (int)"mom_kin_max_fpr";
  v18 = (int)"mom_kin_min_fpr";
  v19 = (int)"mom_kin_max_frn";
  v20 = (int)"mom_kin_min_frn";
  v21 = (int)"mom_kin_max_dpm";
  v22 = (int)"mom_kin_min_dpm";
  *(_DWORD *)v23 = "END";
  v2 = 0;
  if ( strcmp("mom_kin_max_fpm", "END") )
  {
    v4 = Str;
    do
    {
      v15 = UF_MOM_ask_string(a1, v3 + 4, &Str);
      switch ( v2 )
      {
        case 0:
          v5 = Str;
          if ( !Str )
          {
            v5 = "999.999";
            Str = "999.999";
          }
          *(double *)v4 = strtod(v5, 0);
          break;
        case 1:
          v6 = Str;
          if ( !Str )
          {
            v6 = "0.001";
            Str = "0.001";
          }
          *((double *)v4 + 4) = strtod(v6, 0);
          break;
        case 2:
          v7 = Str;
          if ( !Str )
          {
            v7 = "99.999";
            Str = "99.999";
          }
          *((double *)v4 + 1) = strtod(v7, 0);
          break;
        case 3:
          v8 = Str;
          if ( !Str )
          {
            v8 = "0.001";
            Str = "0.001";
          }
          *((double *)v4 + 5) = strtod(v8, 0);
          break;
        case 4:
          v9 = Str;
          if ( !Str )
          {
            v9 = "99999.999";
            Str = "99999.999";
          }
          *((double *)v4 + 2) = strtod(v9, 0);
          break;
        case 5:
          v10 = Str;
          if ( !Str )
          {
            v10 = "0.001";
            Str = "0.001";
          }
          *((double *)v4 + 6) = strtod(v10, 0);
          break;
        case 6:
          v11 = Str;
          if ( !Str )
          {
            v11 = "99.999";
            Str = "99.999";
          }
          *((double *)v4 + 3) = strtod(v11, 0);
          break;
        case 7:
          v12 = Str;
          if ( !Str )
          {
            v12 = "0.0";
            Str = "0.0";
          }
          *((double *)v4 + 7) = strtod(v12, 0);
          break;
        default:
          break;
      }
      v3 = (const char *)*(&v16 + v2++);
    }
    while ( strcmp(v3, "END") );
    result = v15;
  }
  else
  {
    result = v14;
  }
  return result;
}
// 10009068: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (100052F0) --------------------------------------------------------
int __cdecl sub_100052F0(int a1, int a2)
{
  int v2; // edi@1
  char *v3; // edi@3
  char *v4; // edi@6
  char *v5; // edi@9
  char *v6; // eax@12
  char *v7; // eax@15
  char *v8; // eax@18
  char *v9; // eax@21
  char *v10; // eax@24
  char *v11; // eax@27
  char *v12; // eax@30
  char *v13; // eax@33
  char *v14; // eax@36
  char *v15; // eax@39
  char *v16; // eax@42
  char *v17; // eax@45
  char *Str; // [sp+Ch] [bp-4Ch]@2
  int v20; // [sp+10h] [bp-48h]@1
  int v21; // [sp+14h] [bp-44h]@2
  int v22; // [sp+18h] [bp-40h]@1
  int v23; // [sp+1Ch] [bp-3Ch]@1
  int v24; // [sp+20h] [bp-38h]@1
  int v25; // [sp+24h] [bp-34h]@1
  int v26; // [sp+28h] [bp-30h]@1
  int v27; // [sp+2Ch] [bp-2Ch]@1
  int v28; // [sp+30h] [bp-28h]@1
  int v29; // [sp+34h] [bp-24h]@1
  int v30; // [sp+38h] [bp-20h]@1
  int v31; // [sp+3Ch] [bp-1Ch]@1
  int v32; // [sp+40h] [bp-18h]@1
  int v33; // [sp+44h] [bp-14h]@1
  int v34; // [sp+48h] [bp-10h]@1
  int v35; // [sp+4Ch] [bp-Ch]@1
  int v36; // [sp+50h] [bp-8h]@1
  char v37[4]; // [sp+54h] [bp-4h]@1

  v2 = (int)"mom_kin_4th_axis_plane";
  v22 = (int)"mom_kin_4th_axis_plane";
  v23 = (int)"mom_kin_4th_axis_direction";
  v24 = (int)"mom_kin_4th_axis_rotation";
  v25 = (int)"mom_kin_4th_axis_min_incr";
  v26 = (int)"mom_kin_4th_axis_min_limit";
  v27 = (int)"mom_kin_4th_axis_max_limit";
  v28 = (int)"mom_kin_4th_axis_zero";
  v29 = (int)"mom_kin_4th_axis_center_offset_x";
  v30 = (int)"mom_kin_4th_axis_center_offset_y";
  v31 = (int)"mom_kin_4th_axis_center_offset_z";
  v32 = (int)"mom_kin_4th_axis_vector_i";
  v33 = (int)"mom_kin_4th_axis_vector_j";
  v34 = (int)"mom_kin_4th_axis_vector_k";
  v35 = (int)"mom_kin_4th_axis_angles_a1";
  v36 = (int)"mom_kin_4th_axis_angles_a2";
  *(_DWORD *)v37 = "END";
  v20 = 0;
  if ( strcmp("mom_kin_4th_axis_plane", "END") )
  {
    do
    {
      v21 = UF_MOM_ask_string(a1, v2 + 4, &Str);
      switch ( v20 )
      {
        case 0:
          v3 = Str;
          if ( !Str )
          {
            v3 = "YZ";
            Str = "YZ";
          }
          strcpy((char *)a2, v3);
          break;
        case 1:
          v4 = Str;
          if ( !Str )
          {
            v4 = "MAGNITUDE_DETERMINES_DIRECTION";
            Str = "MAGNITUDE_DETERMINES_DIRECTION";
          }
          strcpy((char *)(a2 + 133), v4);
          break;
        case 2:
          v5 = Str;
          if ( !Str )
          {
            v5 = "STANDARD";
            Str = "STANDARD";
          }
          strcpy((char *)(a2 + 266), v5);
          break;
        case 3:
          v6 = Str;
          if ( !Str )
          {
            v6 = "0.001";
            Str = "0.001";
          }
          *(double *)(a2 + 400) = strtod(v6, 0);
          break;
        case 4:
          v7 = Str;
          if ( !Str )
          {
            v7 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 408) = strtod(v7, 0);
          break;
        case 5:
          v8 = Str;
          if ( !Str )
          {
            v8 = "360.0";
            Str = "360.0";
          }
          *(double *)(a2 + 416) = strtod(v8, 0);
          break;
        case 6:
          v9 = Str;
          if ( !Str )
          {
            v9 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 424) = strtod(v9, 0);
          break;
        case 7:
          v10 = Str;
          if ( !Str )
          {
            v10 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 432) = strtod(v10, 0);
          break;
        case 8:
          v11 = Str;
          if ( !Str )
          {
            v11 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 440) = strtod(v11, 0);
          break;
        case 9:
          v12 = Str;
          if ( !Str )
          {
            v12 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 448) = strtod(v12, 0);
          break;
        case 10:
          v13 = Str;
          if ( !Str )
          {
            v13 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 456) = strtod(v13, 0);
          break;
        case 11:
          v14 = Str;
          if ( !Str )
          {
            v14 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 464) = strtod(v14, 0);
          break;
        case 12:
          v15 = Str;
          if ( !Str )
          {
            v15 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 472) = strtod(v15, 0);
          break;
        case 13:
          v16 = Str;
          if ( !Str )
          {
            v16 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 480) = strtod(v16, 0);
          break;
        case 14:
          v17 = Str;
          if ( !Str )
          {
            v17 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 488) = strtod(v17, 0);
          break;
        default:
          break;
      }
      ++v20;
      v2 = *(&v22 + v20);
    }
    while ( strcmp((const char *)*(&v22 + v20), "END") );
  }
  return v21;
}
// 10009068: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10005700) --------------------------------------------------------
int __cdecl sub_10005700(int a1, int a2)
{
  int v2; // edi@1
  char *v3; // edi@3
  char *v4; // edi@6
  char *v5; // edi@9
  char *v6; // eax@12
  char *v7; // eax@15
  char *v8; // eax@18
  char *v9; // eax@21
  char *v10; // eax@24
  char *v11; // eax@27
  char *v12; // eax@30
  char *v13; // eax@33
  char *v14; // eax@36
  char *v15; // eax@39
  char *v16; // eax@42
  char *v17; // eax@45
  char *Str; // [sp+Ch] [bp-4Ch]@2
  int v20; // [sp+10h] [bp-48h]@1
  int v21; // [sp+14h] [bp-44h]@2
  int v22; // [sp+18h] [bp-40h]@1
  int v23; // [sp+1Ch] [bp-3Ch]@1
  int v24; // [sp+20h] [bp-38h]@1
  int v25; // [sp+24h] [bp-34h]@1
  int v26; // [sp+28h] [bp-30h]@1
  int v27; // [sp+2Ch] [bp-2Ch]@1
  int v28; // [sp+30h] [bp-28h]@1
  int v29; // [sp+34h] [bp-24h]@1
  int v30; // [sp+38h] [bp-20h]@1
  int v31; // [sp+3Ch] [bp-1Ch]@1
  int v32; // [sp+40h] [bp-18h]@1
  int v33; // [sp+44h] [bp-14h]@1
  int v34; // [sp+48h] [bp-10h]@1
  int v35; // [sp+4Ch] [bp-Ch]@1
  int v36; // [sp+50h] [bp-8h]@1
  char v37[4]; // [sp+54h] [bp-4h]@1

  v2 = (int)"mom_kin_5th_axis_plane";
  v22 = (int)"mom_kin_5th_axis_plane";
  v23 = (int)"mom_kin_5th_axis_direction";
  v24 = (int)"mom_kin_5th_axis_rotation";
  v25 = (int)"mom_kin_5th_axis_min_incr";
  v26 = (int)"mom_kin_5th_axis_min_limit";
  v27 = (int)"mom_kin_5th_axis_max_limit";
  v28 = (int)"mom_kin_5th_axis_zero";
  v29 = (int)"mom_kin_5th_axis_center_offset_x";
  v30 = (int)"mom_kin_5th_axis_center_offset_y";
  v31 = (int)"mom_kin_5th_axis_center_offset_z";
  v32 = (int)"mom_kin_5th_axis_vector_i";
  v33 = (int)"mom_kin_5th_axis_vector_j";
  v34 = (int)"mom_kin_5th_axis_vector_k";
  v35 = (int)"mom_kin_5th_axis_angles_a1";
  v36 = (int)"mom_kin_5th_axis_angles_a2";
  *(_DWORD *)v37 = "END";
  v20 = 0;
  if ( strcmp("mom_kin_5th_axis_plane", "END") )
  {
    do
    {
      v21 = UF_MOM_ask_string(a1, v2 + 4, &Str);
      switch ( v20 )
      {
        case 0:
          v3 = Str;
          if ( !Str )
          {
            v3 = "YZ";
            Str = "YZ";
          }
          strcpy((char *)a2, v3);
          break;
        case 1:
          v4 = Str;
          if ( !Str )
          {
            v4 = "MAGNITUDE_DETERMINES_DIRECTION";
            Str = "MAGNITUDE_DETERMINES_DIRECTION";
          }
          strcpy((char *)(a2 + 133), v4);
          break;
        case 2:
          v5 = Str;
          if ( !Str )
          {
            v5 = "STANDARD";
            Str = "STANDARD";
          }
          strcpy((char *)(a2 + 266), v5);
          break;
        case 3:
          v6 = Str;
          if ( !Str )
          {
            v6 = "0.001";
            Str = "0.001";
          }
          *(double *)(a2 + 400) = strtod(v6, 0);
          break;
        case 4:
          v7 = Str;
          if ( !Str )
          {
            v7 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 408) = strtod(v7, 0);
          break;
        case 5:
          v8 = Str;
          if ( !Str )
          {
            v8 = "360.0";
            Str = "360.0";
          }
          *(double *)(a2 + 416) = strtod(v8, 0);
          break;
        case 6:
          v9 = Str;
          if ( !Str )
          {
            v9 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 424) = strtod(v9, 0);
          break;
        case 7:
          v10 = Str;
          if ( !Str )
          {
            v10 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 432) = strtod(v10, 0);
          break;
        case 8:
          v11 = Str;
          if ( !Str )
          {
            v11 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 440) = strtod(v11, 0);
          break;
        case 9:
          v12 = Str;
          if ( !Str )
          {
            v12 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 448) = strtod(v12, 0);
          break;
        case 10:
          v13 = Str;
          if ( !Str )
          {
            v13 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 456) = strtod(v13, 0);
          break;
        case 11:
          v14 = Str;
          if ( !Str )
          {
            v14 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 464) = strtod(v14, 0);
          break;
        case 12:
          v15 = Str;
          if ( !Str )
          {
            v15 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 472) = strtod(v15, 0);
          break;
        case 13:
          v16 = Str;
          if ( !Str )
          {
            v16 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 480) = strtod(v16, 0);
          break;
        case 14:
          v17 = Str;
          if ( !Str )
          {
            v17 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 488) = strtod(v17, 0);
          break;
        default:
          break;
      }
      ++v20;
      v2 = *(&v22 + v20);
    }
    while ( strcmp((const char *)*(&v22 + v20), "END") );
  }
  return v21;
}
// 10009068: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10005B10) --------------------------------------------------------
int __cdecl sub_10005B10(int a1, char *Str)
{
  int v2; // ebp@1
  const char *v3; // edi@1
  char *v4; // ebx@2
  const char *v5; // eax@6
  const char *v6; // eax@9
  const char *v7; // edi@12
  int v9; // [sp+10h] [bp-14h]@16
  int v10; // [sp+18h] [bp-Ch]@1
  int v11; // [sp+1Ch] [bp-8h]@1
  char v12[4]; // [sp+20h] [bp-4h]@1

  v3 = "mom_kin_independent_head";
  v10 = (int)"mom_kin_ind_to_dependent_head_x";
  v11 = (int)"mom_kin_ind_to_dependent_head_z";
  *(_DWORD *)v12 = "END";
  v2 = 0;
  if ( strcmp("mom_kin_independent_head", "END") )
  {
    v4 = Str;
    do
    {
      v9 = UF_MOM_ask_string(a1, v3 + 4, &Str);
      if ( v2 )
      {
        if ( v2 == 1 )
        {
          v6 = Str;
          if ( !Str )
          {
            v6 = "0.0";
            Str = "0.0";
          }
          *((double *)v4 + 17) = strtod(v6, 0);
        }
        else
        {
          if ( v2 == 2 )
          {
            v5 = Str;
            if ( !Str )
            {
              v5 = "0.0";
              Str = "0.0";
            }
            *((double *)v4 + 18) = strtod(v5, 0);
          }
        }
      }
      else
      {
        v7 = Str;
        if ( !Str )
        {
          v7 = "FRONT";
          Str = "FRONT";
        }
        strcpy(v4, v7);
      }
      v3 = (const char *)*(&v10 + v2++);
    }
    while ( strcmp(v3, "END") );
  }
  return v9;
}
// 10009068: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10005C60) --------------------------------------------------------
int __cdecl sub_10005C60(int a1, char *Str)
{
  int v2; // ebp@1
  const char *v3; // edi@1
  char *v4; // ebx@2
  const char *v5; // eax@6
  const char *v6; // eax@9
  const char *v7; // eax@12
  int v9; // [sp+10h] [bp-14h]@16
  int v10; // [sp+18h] [bp-Ch]@1
  int v11; // [sp+1Ch] [bp-8h]@1
  char v12[4]; // [sp+20h] [bp-4h]@1

  v3 = "mom_kin_tool_change_time";
  v10 = (int)"mom_kin_clamp_time";
  v11 = (int)"mom_kin_flush_time";
  *(_DWORD *)v12 = "END";
  v2 = 0;
  if ( strcmp("mom_kin_tool_change_time", "END") )
  {
    v4 = Str;
    do
    {
      v9 = UF_MOM_ask_string(a1, v3 + 4, &Str);
      if ( v2 )
      {
        if ( v2 == 1 )
        {
          v6 = Str;
          if ( !Str )
          {
            v6 = "0.5";
            Str = "0.5";
          }
          *((double *)v4 + 1) = strtod(v6, 0);
        }
        else
        {
          if ( v2 == 2 )
          {
            v5 = Str;
            if ( !Str )
            {
              v5 = "0.5";
              Str = "0.5";
            }
            *((double *)v4 + 2) = strtod(v5, 0);
          }
        }
      }
      else
      {
        v7 = Str;
        if ( !Str )
        {
          v7 = "3.0";
          Str = "3.0";
        }
        *(double *)v4 = strtod(v7, 0);
      }
      v3 = (const char *)*(&v10 + v2++);
    }
    while ( strcmp(v3, "END") );
  }
  return v9;
}
// 10009068: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10005DA0) --------------------------------------------------------
int __cdecl sub_10005DA0(int a1, int a2)
{
  int v2; // edi@1
  char *v3; // edi@3
  char *v4; // edi@6
  char *v5; // edi@9
  char *v6; // edi@12
  char *v7; // edi@15
  char *v8; // edi@18
  char *v9; // eax@21
  char *v10; // eax@24
  char *v11; // eax@27
  char *v12; // eax@30
  char *v13; // eax@33
  char *v14; // eax@36
  char *v15; // eax@39
  char *v16; // eax@42
  char *v17; // eax@45
  char *v18; // eax@48
  char *v19; // eax@51
  char *v20; // eax@54
  char *v21; // eax@57
  char *v22; // eax@60
  char *v23; // eax@63
  char *v24; // eax@66
  char *v25; // eax@69
  char *v26; // eax@72
  char *Str; // [sp+10h] [bp-70h]@2
  int v29; // [sp+14h] [bp-6Ch]@1
  int v30; // [sp+18h] [bp-68h]@2
  int v31; // [sp+1Ch] [bp-64h]@1
  int v32; // [sp+20h] [bp-60h]@1
  int v33; // [sp+24h] [bp-5Ch]@1
  int v34; // [sp+28h] [bp-58h]@1
  int v35; // [sp+2Ch] [bp-54h]@1
  int v36; // [sp+30h] [bp-50h]@1
  int v37; // [sp+34h] [bp-4Ch]@1
  int v38; // [sp+38h] [bp-48h]@1
  int v39; // [sp+3Ch] [bp-44h]@1
  int v40; // [sp+40h] [bp-40h]@1
  int v41; // [sp+44h] [bp-3Ch]@1
  int v42; // [sp+48h] [bp-38h]@1
  int v43; // [sp+4Ch] [bp-34h]@1
  int v44; // [sp+50h] [bp-30h]@1
  int v45; // [sp+54h] [bp-2Ch]@1
  int v46; // [sp+58h] [bp-28h]@1
  int v47; // [sp+5Ch] [bp-24h]@1
  int v48; // [sp+60h] [bp-20h]@1
  int v49; // [sp+64h] [bp-1Ch]@1
  int v50; // [sp+68h] [bp-18h]@1
  int v51; // [sp+6Ch] [bp-14h]@1
  int v52; // [sp+70h] [bp-10h]@1
  int v53; // [sp+74h] [bp-Ch]@1
  int v54; // [sp+78h] [bp-8h]@1
  char v55[4]; // [sp+7Ch] [bp-4h]@1

  v2 = (int)"mom_kin_holder1_orientation";
  v31 = (int)"mom_kin_holder1_orientation";
  v32 = (int)"mom_kin_holder2_orientation";
  v33 = (int)"mom_kin_holder3_orientation";
  v34 = (int)"mom_kin_holder4_orientation";
  v35 = (int)"mom_kin_holder5_orientation";
  v36 = (int)"mom_kin_holder6_orientation";
  v37 = (int)"mom_kin_holder1_offset_x";
  v38 = (int)"mom_kin_holder1_offset_y";
  v39 = (int)"mom_kin_holder1_offset_z";
  v40 = (int)"mom_kin_holder2_offset_x";
  v41 = (int)"mom_kin_holder2_offset_y";
  v42 = (int)"mom_kin_holder2_offset_z";
  v43 = (int)"mom_kin_holder3_offset_x";
  v44 = (int)"mom_kin_holder3_offset_y";
  v45 = (int)"mom_kin_holder3_offset_z";
  v46 = (int)"mom_kin_holder4_offset_x";
  v47 = (int)"mom_kin_holder4_offset_y";
  v48 = (int)"mom_kin_holder4_offset_z";
  v49 = (int)"mom_kin_holder5_offset_x";
  v50 = (int)"mom_kin_holder5_offset_y";
  v51 = (int)"mom_kin_holder5_offset_z";
  v52 = (int)"mom_kin_holder6_offset_x";
  v53 = (int)"mom_kin_holder6_offset_y";
  v54 = (int)"mom_kin_holder6_offset_z";
  *(_DWORD *)v55 = "END";
  v29 = 0;
  if ( strcmp("mom_kin_holder1_orientation", "END") )
  {
    do
    {
      v30 = UF_MOM_ask_string(a1, v2 + 4, &Str);
      switch ( v29 )
      {
        case 0:
          v3 = Str;
          if ( !Str )
          {
            v3 = "POSZ";
            Str = "POSZ";
          }
          strcpy((char *)a2, v3);
          break;
        case 1:
          v4 = Str;
          if ( !Str )
          {
            v4 = "POSZ";
            Str = "POSZ";
          }
          strcpy((char *)(a2 + 133), v4);
          break;
        case 2:
          v5 = Str;
          if ( !Str )
          {
            v5 = "POSZ";
            Str = "POSZ";
          }
          strcpy((char *)(a2 + 266), v5);
          break;
        case 3:
          v6 = Str;
          if ( !Str )
          {
            v6 = "POSZ";
            Str = "POSZ";
          }
          strcpy((char *)(a2 + 399), v6);
          break;
        case 4:
          v7 = Str;
          if ( !Str )
          {
            v7 = "POSZ";
            Str = "POSZ";
          }
          strcpy((char *)(a2 + 532), v7);
          break;
        case 5:
          v8 = Str;
          if ( !Str )
          {
            v8 = "POSZ";
            Str = "POSZ";
          }
          strcpy((char *)(a2 + 665), v8);
          break;
        case 6:
          v9 = Str;
          if ( !Str )
          {
            v9 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 800) = strtod(v9, 0);
          break;
        case 7:
          v10 = Str;
          if ( !Str )
          {
            v10 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 808) = strtod(v10, 0);
          break;
        case 8:
          v11 = Str;
          if ( !Str )
          {
            v11 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 816) = strtod(v11, 0);
          break;
        case 9:
          v12 = Str;
          if ( !Str )
          {
            v12 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 824) = strtod(v12, 0);
          break;
        case 10:
          v13 = Str;
          if ( !Str )
          {
            v13 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 832) = strtod(v13, 0);
          break;
        case 11:
          v14 = Str;
          if ( !Str )
          {
            v14 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 840) = strtod(v14, 0);
          break;
        case 12:
          v15 = Str;
          if ( !Str )
          {
            v15 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 848) = strtod(v15, 0);
          break;
        case 13:
          v16 = Str;
          if ( !Str )
          {
            v16 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 856) = strtod(v16, 0);
          break;
        case 14:
          v17 = Str;
          if ( !Str )
          {
            v17 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 864) = strtod(v17, 0);
          break;
        case 15:
          v18 = Str;
          if ( !Str )
          {
            v18 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 872) = strtod(v18, 0);
          break;
        case 16:
          v19 = Str;
          if ( !Str )
          {
            v19 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 880) = strtod(v19, 0);
          break;
        case 17:
          v20 = Str;
          if ( !Str )
          {
            v20 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 888) = strtod(v20, 0);
          break;
        case 18:
          v21 = Str;
          if ( !Str )
          {
            v21 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 896) = strtod(v21, 0);
          break;
        case 19:
          v22 = Str;
          if ( !Str )
          {
            v22 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 904) = strtod(v22, 0);
          break;
        case 20:
          v23 = Str;
          if ( !Str )
          {
            v23 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 912) = strtod(v23, 0);
          break;
        case 21:
          v24 = Str;
          if ( !Str )
          {
            v24 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 920) = strtod(v24, 0);
          break;
        case 22:
          v25 = Str;
          if ( !Str )
          {
            v25 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 928) = strtod(v25, 0);
          break;
        case 23:
          v26 = Str;
          if ( !Str )
          {
            v26 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 936) = strtod(v26, 0);
          break;
        default:
          break;
      }
      ++v29;
      v2 = *(&v31 + v29);
    }
    while ( strcmp((const char *)*(&v31 + v29), "END") );
  }
  return v30;
}
// 10009068: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (100063B0) --------------------------------------------------------
int __cdecl sub_100063B0(int a1, int a2)
{
  int v2; // edi@1
  char *v3; // eax@3
  char *v4; // eax@6
  char *v5; // eax@9
  char *v6; // eax@12
  char *v7; // eax@15
  char *v8; // eax@18
  char *v9; // eax@21
  char *v10; // eax@24
  char *v11; // eax@27
  char *v12; // eax@30
  char *v13; // eax@33
  char *v14; // eax@36
  char *Str; // [sp+10h] [bp-40h]@2
  int v17; // [sp+14h] [bp-3Ch]@1
  int v18; // [sp+18h] [bp-38h]@2
  int v19; // [sp+1Ch] [bp-34h]@1
  int v20; // [sp+20h] [bp-30h]@1
  int v21; // [sp+24h] [bp-2Ch]@1
  int v22; // [sp+28h] [bp-28h]@1
  int v23; // [sp+2Ch] [bp-24h]@1
  int v24; // [sp+30h] [bp-20h]@1
  int v25; // [sp+34h] [bp-1Ch]@1
  int v26; // [sp+38h] [bp-18h]@1
  int v27; // [sp+3Ch] [bp-14h]@1
  int v28; // [sp+40h] [bp-10h]@1
  int v29; // [sp+44h] [bp-Ch]@1
  int v30; // [sp+48h] [bp-8h]@1
  char v31[4]; // [sp+4Ch] [bp-4h]@1

  v2 = (int)"mom_msys_origin_x";
  v19 = (int)"mom_msys_origin_x";
  v20 = (int)"mom_msys_origin_y";
  v21 = (int)"mom_msys_origin_z";
  v22 = (int)"mom_msys_x_axis_i";
  v23 = (int)"mom_msys_x_axis_j";
  v24 = (int)"mom_msys_x_axis_k";
  v25 = (int)"mom_msys_y_axis_i";
  v26 = (int)"mom_msys_y_axis_j";
  v27 = (int)"mom_msys_y_axis_k";
  v28 = (int)"mom_msys_z_axis_i";
  v29 = (int)"mom_msys_z_axis_j";
  v30 = (int)"mom_msys_z_axis_k";
  *(_DWORD *)v31 = "END";
  v17 = 0;
  if ( strcmp("mom_msys_origin_x", "END") )
  {
    do
    {
      v18 = UF_MOM_ask_string(a1, v2 + 4, &Str);
      switch ( v17 )
      {
        case 0:
          v3 = Str;
          if ( !Str )
          {
            v3 = "0.0";
            Str = "0.0";
          }
          *(double *)a2 = strtod(v3, 0);
          break;
        case 1:
          v4 = Str;
          if ( !Str )
          {
            v4 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 8) = strtod(v4, 0);
          break;
        case 2:
          v5 = Str;
          if ( !Str )
          {
            v5 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 16) = strtod(v5, 0);
          break;
        case 3:
          v6 = Str;
          if ( !Str )
          {
            v6 = "1.0";
            Str = "1.0";
          }
          *(double *)(a2 + 24) = strtod(v6, 0);
          break;
        case 4:
          v7 = Str;
          if ( !Str )
          {
            v7 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 32) = strtod(v7, 0);
          break;
        case 5:
          v8 = Str;
          if ( !Str )
          {
            v8 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 40) = strtod(v8, 0);
          break;
        case 6:
          v9 = Str;
          if ( !Str )
          {
            v9 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 48) = strtod(v9, 0);
          break;
        case 7:
          v10 = Str;
          if ( !Str )
          {
            v10 = "1.0";
            Str = "1.0";
          }
          *(double *)(a2 + 56) = strtod(v10, 0);
          break;
        case 8:
          v11 = Str;
          if ( !Str )
          {
            v11 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 64) = strtod(v11, 0);
          break;
        case 9:
          v12 = Str;
          if ( !Str )
          {
            v12 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 72) = strtod(v12, 0);
          break;
        case 10:
          v13 = Str;
          if ( !Str )
          {
            v13 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 80) = strtod(v13, 0);
          break;
        case 11:
          v14 = Str;
          if ( !Str )
          {
            v14 = "1.0";
            Str = "1.0";
          }
          *(double *)(a2 + 88) = strtod(v14, 0);
          break;
        default:
          break;
      }
      ++v17;
      v2 = *(&v19 + v17);
    }
    while ( strcmp((const char *)*(&v19 + v17), "END") );
  }
  return v18;
}
// 10009068: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (100066D0) --------------------------------------------------------
int __cdecl sub_100066D0(int a1, int a2)
{
  int v2; // edi@1
  char *v3; // eax@3
  char *v4; // eax@6
  char *v5; // eax@9
  char *v6; // eax@12
  char *v7; // eax@15
  char *v8; // eax@18
  char *v9; // eax@21
  char *v10; // eax@24
  char *v11; // eax@27
  char *v12; // eax@30
  char *v13; // eax@33
  char *v14; // eax@36
  char *Str; // [sp+10h] [bp-40h]@2
  int v17; // [sp+14h] [bp-3Ch]@1
  int v18; // [sp+18h] [bp-38h]@2
  int v19; // [sp+1Ch] [bp-34h]@1
  int v20; // [sp+20h] [bp-30h]@1
  int v21; // [sp+24h] [bp-2Ch]@1
  int v22; // [sp+28h] [bp-28h]@1
  int v23; // [sp+2Ch] [bp-24h]@1
  int v24; // [sp+30h] [bp-20h]@1
  int v25; // [sp+34h] [bp-1Ch]@1
  int v26; // [sp+38h] [bp-18h]@1
  int v27; // [sp+3Ch] [bp-14h]@1
  int v28; // [sp+40h] [bp-10h]@1
  int v29; // [sp+44h] [bp-Ch]@1
  int v30; // [sp+48h] [bp-8h]@1
  char v31[4]; // [sp+4Ch] [bp-4h]@1

  v2 = (int)"mom_mtsys_origin_x";
  v19 = (int)"mom_mtsys_origin_x";
  v20 = (int)"mom_mtsys_origin_y";
  v21 = (int)"mom_mtsys_origin_z";
  v22 = (int)"mom_mtsys_x_axis_i";
  v23 = (int)"mom_mtsys_x_axis_j";
  v24 = (int)"mom_mtsys_x_axis_k";
  v25 = (int)"mom_mtsys_y_axis_i";
  v26 = (int)"mom_mtsys_y_axis_j";
  v27 = (int)"mom_mtsys_y_axis_k";
  v28 = (int)"mom_mtsys_z_axis_i";
  v29 = (int)"mom_mtsys_z_axis_j";
  v30 = (int)"mom_mtsys_z_axis_k";
  *(_DWORD *)v31 = "END";
  v17 = 0;
  if ( strcmp("mom_mtsys_origin_x", "END") )
  {
    do
    {
      v18 = UF_MOM_ask_string(a1, v2 + 4, &Str);
      switch ( v17 )
      {
        case 0:
          v3 = Str;
          if ( !Str )
          {
            v3 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 96) = strtod(v3, 0);
          break;
        case 1:
          v4 = Str;
          if ( !Str )
          {
            v4 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 104) = strtod(v4, 0);
          break;
        case 2:
          v5 = Str;
          if ( !Str )
          {
            v5 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 112) = strtod(v5, 0);
          break;
        case 3:
          v6 = Str;
          if ( !Str )
          {
            v6 = "1.0";
            Str = "1.0";
          }
          *(double *)(a2 + 120) = strtod(v6, 0);
          break;
        case 4:
          v7 = Str;
          if ( !Str )
          {
            v7 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 128) = strtod(v7, 0);
          break;
        case 5:
          v8 = Str;
          if ( !Str )
          {
            v8 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 136) = strtod(v8, 0);
          break;
        case 6:
          v9 = Str;
          if ( !Str )
          {
            v9 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 144) = strtod(v9, 0);
          break;
        case 7:
          v10 = Str;
          if ( !Str )
          {
            v10 = "1.0";
            Str = "1.0";
          }
          *(double *)(a2 + 152) = strtod(v10, 0);
          break;
        case 8:
          v11 = Str;
          if ( !Str )
          {
            v11 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 160) = strtod(v11, 0);
          break;
        case 9:
          v12 = Str;
          if ( !Str )
          {
            v12 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 168) = strtod(v12, 0);
          break;
        case 10:
          v13 = Str;
          if ( !Str )
          {
            v13 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 176) = strtod(v13, 0);
          break;
        case 11:
          v14 = Str;
          if ( !Str )
          {
            v14 = "1.0";
            Str = "1.0";
          }
          *(double *)(a2 + 184) = strtod(v14, 0);
          break;
        default:
          break;
      }
      ++v17;
      v2 = *(&v19 + v17);
    }
    while ( strcmp((const char *)*(&v19 + v17), "END") );
  }
  return v18;
}
// 10009068: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10006A00) --------------------------------------------------------
int __cdecl sub_10006A00(int a1, char *Str)
{
  int v2; // ebx@1
  const char *v3; // edi@1
  char *v4; // ebp@2
  const char *v5; // eax@4
  const char *v6; // eax@7
  const char *v7; // eax@10
  const char *v8; // eax@13
  const char *v9; // eax@16
  const char *v10; // eax@19
  const char *v11; // edi@22
  const char *v12; // eax@25
  const char *v13; // eax@28
  int result; // eax@31
  int v15; // [sp+10h] [bp-24h]@1
  int v16; // [sp+14h] [bp-20h]@1
  int v17; // [sp+18h] [bp-1Ch]@1
  int v18; // [sp+1Ch] [bp-18h]@1
  int v19; // [sp+20h] [bp-14h]@1
  int v20; // [sp+24h] [bp-10h]@1
  int v21; // [sp+28h] [bp-Ch]@1
  int v22; // [sp+2Ch] [bp-8h]@1
  char v23[4]; // [sp+30h] [bp-4h]@1

  v3 = "mom_origin_x";
  v15 = (int)"mom_origin_y";
  v16 = (int)"mom_origin_z";
  v17 = (int)"mom_translate_x";
  v18 = (int)"mom_translate_y";
  v19 = (int)"mom_translate_z";
  v20 = (int)"mom_tool_type";
  v21 = (int)"mom_tool_z_offset";
  v22 = (int)"mom_tool_corner1_radius";
  *(_DWORD *)v23 = "END";
  v2 = 0;
  if ( strcmp("mom_origin_x", "END") )
  {
    v4 = Str;
    do
    {
      UF_MOM_ask_string(a1, v3 + 4, &Str);
      switch ( v2 )
      {
        case 0:
          v5 = Str;
          if ( !Str )
          {
            v5 = "0.0";
            Str = "0.0";
          }
          *((double *)v4 + 27) = strtod(v5, 0);
          break;
        case 1:
          v6 = Str;
          if ( !Str )
          {
            v6 = "0.0";
            Str = "0.0";
          }
          *((double *)v4 + 28) = strtod(v6, 0);
          break;
        case 2:
          v7 = Str;
          if ( !Str )
          {
            v7 = "0.0";
            Str = "0.0";
          }
          *((double *)v4 + 29) = strtod(v7, 0);
          break;
        case 3:
          v8 = Str;
          if ( !Str )
          {
            v8 = "0.0";
            Str = "0.0";
          }
          *((double *)v4 + 24) = strtod(v8, 0);
          break;
        case 4:
          v9 = Str;
          if ( !Str )
          {
            v9 = "0.0";
            Str = "0.0";
          }
          *((double *)v4 + 25) = strtod(v9, 0);
          break;
        case 5:
          v10 = Str;
          if ( !Str )
          {
            v10 = "0.0";
            Str = "0.0";
          }
          *((double *)v4 + 26) = strtod(v10, 0);
          break;
        case 6:
          v11 = Str;
          if ( !Str )
          {
            v11 = "MILL";
            Str = "MILL";
          }
          strcpy(v4 + 240, v11);
          break;
        case 7:
          v12 = Str;
          if ( !Str )
          {
            v12 = "0.0";
            Str = "0.0";
          }
          *((double *)v4 + 47) = strtod(v12, 0);
          break;
        case 8:
          v13 = Str;
          if ( !Str )
          {
            v13 = "0.0";
            Str = "0.0";
          }
          *((double *)v4 + 48) = strtod(v13, 0);
          break;
        default:
          break;
      }
      v3 = (const char *)*(&v15 + v2++);
      result = strcmp(v3, "END");
    }
    while ( result );
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10009068: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10006CA0) --------------------------------------------------------
int __cdecl sub_10006CA0(int a1, char *Str)
{
  int v2; // ebx@1
  const char *v3; // edi@1
  char *v4; // ebp@2
  const char *v5; // eax@4
  const char *v6; // eax@7
  const char *v7; // eax@10
  const char *v8; // eax@13
  const char *v9; // eax@16
  const char *v10; // eax@19
  int result; // eax@23
  int v12; // ST1C_4@24
  int v13; // [sp+Ch] [bp-20h]@3
  int v14; // [sp+14h] [bp-18h]@1
  int v15; // [sp+18h] [bp-14h]@1
  int v16; // [sp+1Ch] [bp-10h]@1
  int v17; // [sp+20h] [bp-Ch]@1
  int v18; // [sp+24h] [bp-8h]@1
  char v19[4]; // [sp+28h] [bp-4h]@1

  v3 = "mom_mcs_goto_x";
  v14 = (int)"mom_mcs_goto_y";
  v15 = (int)"mom_mcs_goto_z";
  v16 = (int)"mom_tool_axis_i";
  v17 = (int)"mom_tool_axis_j";
  v18 = (int)"mom_tool_axis_k";
  *(_DWORD *)v19 = "END";
  v2 = 0;
  if ( strcmp("mom_mcs_goto_x", "END") )
  {
    v4 = Str;
    do
    {
      v13 = UF_MOM_ask_string(a1, v3 + 4, &Str);
      switch ( v2 )
      {
        case 0:
          v5 = Str;
          if ( !Str )
          {
            v5 = "0.0";
            Str = "0.0";
          }
          *(double *)v4 = strtod(v5, 0);
          break;
        case 1:
          v6 = Str;
          if ( !Str )
          {
            v6 = "0.0";
            Str = "0.0";
          }
          *((double *)v4 + 1) = strtod(v6, 0);
          break;
        case 2:
          v7 = Str;
          if ( !Str )
          {
            v7 = "0.0";
            Str = "0.0";
          }
          *((double *)v4 + 2) = strtod(v7, 0);
          break;
        case 3:
          v8 = Str;
          if ( !Str )
          {
            v8 = "0.0";
            Str = "0.0";
          }
          *((double *)v4 + 3) = strtod(v8, 0);
          break;
        case 4:
          v9 = Str;
          if ( !Str )
          {
            v9 = "0.0";
            Str = "0.0";
          }
          *((double *)v4 + 4) = strtod(v9, 0);
          break;
        case 5:
          v10 = Str;
          if ( !Str )
          {
            v10 = "0.0";
            Str = "0.0";
          }
          *((double *)v4 + 5) = strtod(v10, 0);
          break;
        default:
          break;
      }
      v3 = (const char *)*(&v14 + v2++);
    }
    while ( strcmp(v3, "END") );
    result = v13;
  }
  else
  {
    result = v12;
  }
  return result;
}
// 10009068: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10006E90) --------------------------------------------------------
int __cdecl sub_10006E90(int a1, int a2)
{
  int v2; // edi@1
  const char *v3; // esi@2
  char *v4; // eax@5
  char *v5; // eax@8
  char *v6; // eax@11
  char *v7; // eax@14
  char *v8; // eax@17
  char *v9; // eax@20
  char *v10; // eax@23
  char *v11; // eax@26
  char *v12; // eax@29
  int result; // eax@33
  char *Str; // [sp+Ch] [bp-34h]@4
  int v15; // [sp+10h] [bp-30h]@3
  int v16; // [sp+14h] [bp-2Ch]@4
  int v17; // [sp+18h] [bp-28h]@1
  int v18; // [sp+1Ch] [bp-24h]@1
  int v19; // [sp+20h] [bp-20h]@1
  int v20; // [sp+24h] [bp-1Ch]@1
  int v21; // [sp+28h] [bp-18h]@1
  int v22; // [sp+2Ch] [bp-14h]@1
  int v23; // [sp+30h] [bp-10h]@1
  int v24; // [sp+34h] [bp-Ch]@1
  int v25; // [sp+38h] [bp-8h]@1
  char v26[4]; // [sp+3Ch] [bp-4h]@1

  v17 = (int)"mom_origin_x";
  v18 = (int)"mom_origin_y";
  v19 = (int)"mom_origin_z";
  v20 = (int)"mom_translate_x";
  v21 = (int)"mom_translate_y";
  v22 = (int)"mom_translate_z";
  v23 = (int)"mom_tool_z_offset";
  v24 = (int)"mom_kin_track_center_of_ball";
  v25 = (int)"mom_tool_corner1_radius";
  *(_DWORD *)v26 = "END";
  v2 = 0;
  if ( strcmp("mom_origin_x", "END") )
  {
    v3 = "mom_origin_x";
    while ( 1 )
    {
      v16 = UF_MOM_ask_string(a1, v3 + 4, &Str);
      switch ( v2 )
      {
        case 0:
          v4 = Str;
          if ( !Str )
          {
            v4 = "0.0";
            Str = "0.0";
          }
          *(double *)a2 = strtod(v4, 0);
          break;
        case 1:
          v5 = Str;
          if ( !Str )
          {
            v5 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 8) = strtod(v5, 0);
          break;
        case 2:
          v6 = Str;
          if ( !Str )
          {
            v6 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 16) = strtod(v6, 0);
          break;
        case 3:
          v7 = Str;
          if ( !Str )
          {
            v7 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 96) = strtod(v7, 0);
          break;
        case 4:
          v8 = Str;
          if ( !Str )
          {
            v8 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 104) = strtod(v8, 0);
          break;
        case 5:
          v9 = Str;
          if ( !Str )
          {
            v9 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 112) = strtod(v9, 0);
          break;
        case 6:
          v10 = Str;
          if ( !Str )
          {
            v10 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 120) = strtod(v10, 0);
          break;
        case 7:
          v11 = Str;
          if ( !Str )
          {
            v11 = "0.0";
            Str = "0.0";
          }
          *(_DWORD *)(a2 + 128) = (signed __int64)strtod(v11, 0);
          break;
        case 8:
          v12 = Str;
          if ( !Str )
          {
            v12 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 136) = strtod(v12, 0);
          break;
        default:
          break;
      }
      v3 = (const char *)*(&v18 + v2);
      v15 = v2 + 1;
      if ( !strcmp(v3, "END") )
        break;
      v2 = v15;
    }
  }
  result = v16;
  memcpy(&unk_1000BF48, (const void *)a2, 0x90u);
  return result;
}
// 10009068: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10007130) --------------------------------------------------------
int __cdecl sub_10007130(int a1, int a2)
{
  signed int v2; // eax@1
  int v3; // edx@2
  int v4; // ecx@2
  int v5; // edx@2
  int v6; // ecx@2
  int v7; // edx@2
  int v9; // [sp+Ch] [bp-7Ch]@4
  char v10; // [sp+10h] [bp-78h]@7
  char v11; // [sp+28h] [bp-60h]@7
  int v12; // [sp+40h] [bp-48h]@2
  int v13; // [sp+44h] [bp-44h]@2
  int v14; // [sp+58h] [bp-30h]@2
  int v15; // [sp+5Ch] [bp-2Ch]@2
  int v16; // [sp+70h] [bp-18h]@2
  int v17; // [sp+74h] [bp-14h]@2

  v2 = 0;
  do
  {
    v3 = *(int *)((char *)&dword_1000BF64 + v2);
    *(int *)((char *)&v12 + v2) = *(int *)((char *)&dword_1000BF60 + v2);
    v4 = *(int *)((char *)&dword_1000BF78 + v2);
    *(int *)((char *)&v13 + v2) = v3;
    v5 = *(int *)((char *)&dword_1000BF7C + v2);
    *(int *)((char *)&v14 + v2) = v4;
    v6 = *(int *)((char *)&dword_1000BF90 + v2);
    *(int *)((char *)&v15 + v2) = v5;
    v7 = *(int *)((char *)&dword_1000BF94 + v2);
    *(int *)((char *)&v16 + v2) = v6;
    *(int *)((char *)&v17 + v2) = v7;
    v2 += 8;
  }
  while ( v2 < 24 );
  if ( !dword_1000BFDC )
  {
    UF_VEC3_is_equal(a1 + 24, &dword_1000BF90, -500134854, 1044740494, &v9);
    if ( !v9 )
    {
      printf("WARNING  The tool axis is not matching with the                 rotated MCS-Z axis. The output may be INCORRECT\n");
      uc1601(
        "WARNING  The tool axis is not matching with the *                     rotated MCS-Z axis. The output may be INCORRECT\n",
        1);
    }
    dword_1000BFDC = 1;
  }
  UF_VEC3_copy(a1, &v10);
  UF_VEC3_copy(a1 + 24, &v11);
  UF_MTX3_vec_multiply(a1, &v12, a2);
  UF_MTX3_vec_multiply(a1 + 24, &v12, a2 + 24);
  return 0;
}
// 100090CC: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);
// 100090E8: using guessed type int __cdecl UF_VEC3_is_equal(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090F4: using guessed type int __cdecl UF_MTX3_vec_multiply(_DWORD, _DWORD, _DWORD);
// 10009108: using guessed type int __cdecl uc1601(_DWORD, _DWORD);
// 1000BF60: using guessed type int dword_1000BF60;
// 1000BF64: using guessed type int dword_1000BF64;
// 1000BF78: using guessed type int dword_1000BF78;
// 1000BF7C: using guessed type int dword_1000BF7C;
// 1000BF90: using guessed type int dword_1000BF90;
// 1000BF94: using guessed type int dword_1000BF94;
// 1000BFDC: using guessed type int dword_1000BFDC;

//----- (10007220) --------------------------------------------------------
int __cdecl sub_10007220(int a1, int a2)
{
  char v3; // [sp+10h] [bp-18h]@1

  UF_VEC3_add(a1, &unk_1000BFA8, a2);
  UF_VEC3_sub(a1, &unk_1000BF48, a2);
  UF_VEC3_copy(a1 + 24, a2 + 24);
  UF_VEC3_scale(dword_1000BFC0, dword_1000BFC4, a2 + 24, &v3);
  UF_VEC3_add(a2, &v3, a2);
  if ( dword_1000BFC8 == 1 )
  {
    UF_VEC3_scale(dword_1000BFD0, dword_1000BFD4, a2 + 24, &v3);
    UF_VEC3_add(a2, &v3, a2);
  }
  return 0;
}
// 100090A4: using guessed type int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD);
// 100090B8: using guessed type int __cdecl UF_VEC3_add(_DWORD, _DWORD, _DWORD);
// 100090BC: using guessed type int __cdecl UF_VEC3_scale(_DWORD, _DWORD, _DWORD, _DWORD);
// 100090CC: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);
// 1000BFC0: using guessed type int dword_1000BFC0;
// 1000BFC4: using guessed type int dword_1000BFC4;
// 1000BFC8: using guessed type int dword_1000BFC8;
// 1000BFD0: using guessed type int dword_1000BFD0;
// 1000BFD4: using guessed type int dword_1000BFD4;

//----- (100072C0) --------------------------------------------------------
int __cdecl sub_100072C0(int a1, int a2, int a3)
{
  char *v3; // edi@1
  int v4; // esi@1
  double v5; // ST28_8@5
  double v6; // ST28_8@6
  double v7; // ST28_8@7
  int v9; // edi@10
  char *v10; // esi@11
  int v11; // eax@13
  char *v12; // edx@13
  int *v13; // ecx@13
  signed int v14; // esi@13
  int v15; // edi@14
  char *v17; // [sp-18h] [bp-178h]@5
  double v18; // [sp-14h] [bp-174h]@5
  char *v19; // [sp-Ch] [bp-16Ch]@5
  int v20; // [sp+18h] [bp-148h]@1
  signed int v21; // [sp+1Ch] [bp-144h]@1
  double v22; // [sp+20h] [bp-140h]@1
  int v23; // [sp+28h] [bp-138h]@1
  int v24; // [sp+2Ch] [bp-134h]@1
  int v25; // [sp+30h] [bp-130h]@1
  int v26; // [sp+34h] [bp-12Ch]@1
  int v27; // [sp+38h] [bp-128h]@1
  int v28; // [sp+3Ch] [bp-124h]@1
  int v29; // [sp+40h] [bp-120h]@1
  int v30; // [sp+44h] [bp-11Ch]@1
  int v31; // [sp+48h] [bp-118h]@1
  int v32; // [sp+4Ch] [bp-114h]@1
  int v33; // [sp+50h] [bp-110h]@1
  int v34; // [sp+54h] [bp-10Ch]@1
  int v35; // [sp+58h] [bp-108h]@1
  int v36; // [sp+5Ch] [bp-104h]@1
  int v37; // [sp+60h] [bp-100h]@1
  int v38; // [sp+64h] [bp-FCh]@1
  int v39; // [sp+68h] [bp-F8h]@1
  int v40; // [sp+6Ch] [bp-F4h]@1
  char v41; // [sp+70h] [bp-F0h]@5
  char v42; // [sp+88h] [bp-D8h]@1

  v23 = 0;
  v24 = 1072693248;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v32 = 1072693248;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  v40 = 1072693248;
  v20 = 0;
  v3 = &v42;
  v4 = a3 + 8;
  v21 = 3;
  v22 = asin(1.0) * 0.01111111111111111;
  do
  {
    if ( (unsigned int)(signed __int64)*(double *)(v4 - 8) == 1 )
    {
      v7 = v22 * *(double *)v4 * -1.0;
      UF_MTX3_x_vec(&v23, &v41);
      v19 = v3;
      v18 = v7;
      v17 = &v41;
    }
    else
    {
      if ( (unsigned int)(signed __int64)*(double *)(v4 - 8) == 2 )
      {
        v6 = v22 * *(double *)v4 * -1.0;
        UF_MTX3_y_vec(&v23, &v41);
        v19 = v3;
        v18 = v6;
        v17 = &v41;
      }
      else
      {
        if ( (unsigned int)(signed __int64)*(double *)(v4 - 8) != 3 )
          goto LABEL_9;
        v5 = v22 * *(double *)v4 * -1.0;
        UF_MTX3_z_vec(&v23, &v41);
        v19 = v3;
        v18 = v5;
        v17 = &v41;
      }
    }
    UF_MTX3_rotate_about_axis(v17, LODWORD(v18), HIDWORD(v18), v19);
    v3 += 72;
    ++v20;
LABEL_9:
    v4 += 16;
  }
  while ( v21-- != 1 );
  v9 = v20;
  if ( v20 > 0 )
  {
    v10 = &v42;
    do
    {
      UF_MTX3_multiply(&v23, v10, &v23);
      v10 += 72;
      --v9;
    }
    while ( v9 );
  }
  v12 = (char *)&v23 - a2;
  v13 = &v29;
  v11 = a2 + 48;
  v14 = 3;
  do
  {
    v15 = *(v13 - 6);
    v13 += 2;
    *(_DWORD *)(v11 - 24) = v15;
    *(_DWORD *)(v11 - 20) = *(v13 - 7);
    *(_DWORD *)v11 = *(v13 - 2);
    *(_DWORD *)(v11 + 4) = *(v13 - 1);
    *(_DWORD *)(v11 + 24) = *(_DWORD *)&v12[v11];
    *(_DWORD *)(v11 + 28) = *(_DWORD *)&v12[v11 + 4];
    v11 += 8;
    --v14;
  }
  while ( v14 );
  dword_1000BFDC = 0;
  return 0;
}
// 1000906C: using guessed type int __cdecl UF_MTX3_multiply(_DWORD, _DWORD, _DWORD);
// 10009070: using guessed type int __cdecl UF_MTX3_rotate_about_axis(_DWORD, _DWORD, _DWORD, _DWORD);
// 100090DC: using guessed type int __cdecl UF_MTX3_x_vec(_DWORD, _DWORD);
// 100090E0: using guessed type int __cdecl UF_MTX3_y_vec(_DWORD, _DWORD);
// 100090E4: using guessed type int __cdecl UF_MTX3_z_vec(_DWORD, _DWORD);
// 1000BFDC: using guessed type int dword_1000BFDC;

//----- (100074F0) --------------------------------------------------------
int __cdecl ufusr(int a1, int a2)
{
  int result; // eax@2
  int v3; // eax@3
  int v4; // eax@3
  int v5; // eax@3
  int v6; // eax@3
  int v7; // eax@3
  int v8; // eax@3
  int v9; // [sp+0h] [bp-8Ch]@3
  int v10; // [sp+4h] [bp-88h]@1
  char Dest; // [sp+8h] [bp-84h]@1

  v10 = 0;
  if ( sub_100076F0(&Dest) )
  {
    printf("ERROR : Ugpost Advanced Kinematics license not found \n");
    uc1601(&Dest, 1);
    result = UF_terminate();
  }
  else
  {
    UF_MOM_ask_interp_from_param(a1, &v10);
    UF_MOM_ask_mom(a1, &v9);
    v3 = UF_MOM_extend_xlator(v9, "MOM_load_kinematics", sub_10007C40);
    sub_10007670(
      (int)"Z:\\v18projs\\batch\\project\\phase14\\ugp_adv_kins\\uf_mom_add_ufun_tclexts.c",
      112,
      (int)"UF_MOM_extend_xlator ( mom, \"MOM_load_kinematics\", mom_load_kinematics )",
      v3);
    v4 = UF_MOM_extend_xlator(v9, "MOM_convert_point", sub_100081E0);
    sub_10007670(
      (int)"Z:\\v18projs\\batch\\project\\phase14\\ugp_adv_kins\\uf_mom_add_ufun_tclexts.c",
      122,
      (int)"UF_MOM_extend_xlator ( mom, \"MOM_convert_point\", mom_convert_point )",
      v4);
    v5 = UF_MOM_extend_xlator(v9, "MOM_get_tool_attribute", sub_10008300);
    sub_10007670(
      (int)"Z:\\v18projs\\batch\\project\\phase14\\ugp_adv_kins\\uf_mom_add_ufun_tclexts.c",
      132,
      (int)"UF_MOM_extend_xlator ( mom , \"MOM_get_tool_attribute\", mom_get_tool_attribute )",
      v5);
    v6 = UF_MOM_extend_xlator(v9, "MOM_rotate_mach_csys", sub_100078F0);
    sub_10007670(
      (int)"Z:\\v18projs\\batch\\project\\phase14\\ugp_adv_kins\\uf_mom_add_ufun_tclexts.c",
      142,
      (int)"UF_MOM_extend_xlator ( mom, \"MOM_rotate_mach_csys\", mom_rotate_mach_csys )",
      v6);
    v7 = UF_MOM_extend_xlator(v9, "MOM_map_to_rotated_csys", sub_10007B50);
    sub_10007670(
      (int)"Z:\\v18projs\\batch\\project\\phase14\\ugp_adv_kins\\uf_mom_add_ufun_tclexts.c",
      152,
      (int)"UF_MOM_extend_xlator ( mom, \"MOM_map_to_rotated_csys\", mom_map_to_rotated_csys )",
      v7);
    v8 = UF_MOM_extend_xlator(v9, "MOM_exit_kinematics_module", UF_terminate);
    result = sub_10007670(
               (int)"Z:\\v18projs\\batch\\project\\phase14\\ugp_adv_kins\\uf_mom_add_ufun_tclexts.c",
               162,
               (int)"UF_MOM_extend_xlator ( mom, \"MOM_exit_kinematics_module\", mom_exit_kinematics_module )",
               v8);
    dword_1000BFE0 = v9;
    *(_DWORD *)a2 = 0;
  }
  return result;
}
// 100078E0: using guessed type int UF_terminate();
// 10009074: using guessed type int __cdecl UF_MOM_extend_xlator(_DWORD, _DWORD, _DWORD);
// 100090F8: using guessed type int __cdecl UF_MOM_ask_mom(_DWORD, _DWORD);
// 100090FC: using guessed type int __cdecl UF_MOM_ask_interp_from_param(_DWORD, _DWORD);
// 10009100: using guessed type int UF_terminate(void);
// 10009108: using guessed type int __cdecl uc1601(_DWORD, _DWORD);
// 1000BFE0: using guessed type int dword_1000BFE0;

//----- (10007670) --------------------------------------------------------
int __cdecl sub_10007670(int a1, int a2, int a3, int a4)
{
  char v5; // [sp+8h] [bp-88h]@2

  if ( a4 )
  {
    printf("%s, line %d:  %s\n", a1, a2, a3);
    if ( UF_get_fail_message(a4, &v5) )
    {
      printf("    returned a %d\n", a4);
      return a4;
    }
    printf("    returned error %d:  %s\n", a4, &v5);
  }
  return a4;
}
// 10009084: using guessed type int __cdecl UF_get_fail_message(_DWORD, _DWORD);

//----- (100076F0) --------------------------------------------------------
signed int __cdecl sub_100076F0(char *Dest)
{
  signed int result; // eax@2
  int v2; // eax@3
  int v3; // [sp+4h] [bp-Ch]@3
  double v4; // [sp+8h] [bp-8h]@3

  UF_MISC_set_program_name("<!<UGPKIN>!>");
  if ( UF_initialize() )
  {
    sprintf(Dest, "ERROR!: Advanced Kinematics Module Unavailable");
    result = 1;
  }
  else
  {
    UF_MISC_set_program_name("Kinematics");
    v2 = UF_get_release(&v3);
    sub_10007670(
      (int)"Z:\\v18projs\\batch\\project\\phase14\\ugp_adv_kins\\uf_mom_add_ufun_tclexts.c",
      196,
      (int)"UF_get_release ( &ug_release )",
      v2);
    v4 = strtod((const char *)(v3 + 1), 0);
    UF_free(v3);
    if ( v4 < 17.0 && sub_100077B0() )
    {
      sprintf(Dest, "ERROR : Kinematics Module License has expired");
      result = 6;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}
// 10009058: using guessed type int __cdecl UF_free(_DWORD);
// 10009088: using guessed type int __cdecl UF_get_release(_DWORD);
// 1000908C: using guessed type int UF_initialize(void);
// 10009090: using guessed type int __cdecl UF_MISC_set_program_name(_DWORD);

//----- (100077B0) --------------------------------------------------------
signed int __cdecl sub_100077B0()
{
  int v0; // esi@1
  signed int result; // eax@2
  time_t Time; // [sp+10h] [bp-70h]@1
  char Dest; // [sp+18h] [bp-68h]@1
  struct tm Tm; // [sp+38h] [bp-48h]@1
  char v5; // [sp+5Ch] [bp-24h]@1
  int v6; // [sp+70h] [bp-10h]@1
  int v7; // [sp+78h] [bp-8h]@1

  Tm.tm_min = 59;
  Tm.tm_sec = 59;
  Tm.tm_isdst = -1;
  Tm.tm_year = 101;
  Tm.tm_mon = 9;
  Tm.tm_mday = 30;
  Tm.tm_hour = 23;
  sprintf(&Dest, "%02d/%02d/%04d", 9, 30, 2001);
  LODWORD(Time) = mktime(&Tm);
  memcpy(&Tm, localtime(&Time), sizeof(Tm));
  Tm.tm_year += 1900;
  time((time_t *)((char *)&Time + 4));
  memcpy(&v5, localtime((time_t *)((char *)&Time + 4)), 0x24u);
  v0 = 365 * (Tm.tm_year - (v6 + 1900)) - v7 + Tm.tm_yday - 30;
  printf("EXPIRATION Date: %s.", &Dest);
  if ( v0 > 0 )
  {
    printf("  Remaining days: %d\n", v0);
    result = 0;
  }
  else
  {
    printf("%s\n", "\nYour license has expired. \nPlease contact customer support for renewal information.");
    result = 1;
  }
  return result;
}

//----- (100078F0) --------------------------------------------------------
signed int __cdecl sub_100078F0(int a1, int a2, signed int a3, int a4)
{
  signed int result; // eax@4
  int v5; // ebx@6
  int *v6; // ebp@6
  int v8; // esi@14
  int v9; // esi@16
  void *v10; // [sp+Ch] [bp-34h]@1
  int v11; // [sp+10h] [bp-30h]@1
  int v12; // [sp+14h] [bp-2Ch]@1
  int v13; // [sp+18h] [bp-28h]@1
  int v14; // [sp+1Ch] [bp-24h]@1
  int v15; // [sp+20h] [bp-20h]@1
  int v16; // [sp+24h] [bp-1Ch]@1
  int v17; // [sp+28h] [bp-18h]@1
  int v18; // [sp+2Ch] [bp-14h]@1
  int v19; // [sp+30h] [bp-10h]@1
  int v20; // [sp+34h] [bp-Ch]@1
  int v21; // [sp+38h] [bp-8h]@1
  int v22; // [sp+3Ch] [bp-4h]@1
  unsigned int v23; // [sp+4Ch] [bp+Ch]@6

  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v10 = malloc(0x90u);
  if ( a3 > 7 || a3 == 1 )
  {
    ((void (__thiscall *)(signed int))printf)(a3);
    printf(" Number of arguments should be between 1 and 6\n ", " Incorrect number of arguments\n");
    result = 999;
  }
  else
  {
    if ( a3 % 2 )
    {
      if ( a3 > 1 )
      {
        v5 = a4 + 4;
        v6 = &v11;
        v23 = (unsigned int)a3 >> 1;
        do
        {
          if ( strcmp(*(const char **)v5, "AAXIS") )
          {
            if ( strcmp(*(const char **)v5, "BAXIS") )
            {
              if ( !strcmp(*(const char **)v5, "CAXIS") )
              {
                *v6 = 0;
                v6[1] = 1074266112;
              }
            }
            else
            {
              *v6 = 0;
              v6[1] = 1073741824;
            }
          }
          else
          {
            *v6 = 0;
            v6[1] = 1072693248;
          }
          *((double *)v6 + 1) = strtod((const char *)*(_DWORD *)(v5 + 4), 0);
          v5 += 8;
          v6 += 4;
        }
        while ( v23-- != 1 );
      }
      v8 = sub_100072C0(a1, (int)v10, (int)&v11);
      if ( v8 )
      {
        printf(" SET_rotd_mcs_matrix failed in mom_rotate_mach_csys \n ");
        result = v8;
      }
      else
      {
        v9 = sub_10006E90(a1, (int)v10);
        if ( v9 )
        {
          printf(" SET_rotd_operation_data failed in mom_rotate_mach_csys \n ");
          result = v9;
        }
        else
        {
          if ( v10 )
            free(v10);
          result = 0;
        }
      }
    }
    else
    {
      printf(" Insufficient number of arguments, There should be               atleast 2 arguments\n ");
      result = 999;
    }
  }
  return result;
}

//----- (10007B50) --------------------------------------------------------
int __cdecl sub_10007B50(int a1)
{
  int v1; // edi@1
  int result; // eax@2
  int v3; // edi@3
  int v4; // edi@5
  int v5; // [sp+8h] [bp-90h]@5
  int v6; // [sp+Ch] [bp-8Ch]@7
  int v7; // [sp+10h] [bp-88h]@7
  int v8; // [sp+14h] [bp-84h]@7
  int v9; // [sp+18h] [bp-80h]@7
  int v10; // [sp+1Ch] [bp-7Ch]@7
  char Str; // [sp+38h] [bp-60h]@1
  char v12; // [sp+68h] [bp-30h]@3

  v1 = sub_10006CA0(a1, &Str);
  if ( v1 )
  {
    printf(" SET_input_point failed in mom_map_to_rotated_csys\n ");
    result = v1;
  }
  else
  {
    v3 = sub_10007220((int)&Str, (int)&v12);
    if ( v3 )
    {
      printf(" mom_process_input_gotos failed in mom_map_to_rotated_csys\n ");
      result = v3;
    }
    else
    {
      v4 = sub_10007130((int)&v12, (int)&v5);
      if ( v4 )
      {
        printf(" mom_transfer_gotos_rotd_mcsys failed in mom_map_to_rotated_csys\n ");
        result = v4;
      }
      else
      {
        UF_MOM_set_double(a1, "pos_x", v5, v6);
        UF_MOM_set_double(a1, "pos_y", v7, v8);
        UF_MOM_set_double(a1, "pos_z", v9, v10);
        result = 0;
      }
    }
  }
  return result;
}
// 10009094: using guessed type int __cdecl UF_MOM_set_double(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10007C40) --------------------------------------------------------
signed int __cdecl sub_10007C40(int a1)
{
  void *v1; // ebx@1
  int v2; // edi@1
  signed int v4; // eax@3
  int v5; // ecx@3
  int v6; // esi@3
  double v7; // st7@4
  char *(__cdecl *v8)(const char *, const char *); // edi@5
  signed int v9; // ecx@6
  const void *v10; // esi@6
  signed int v11; // eax@11
  signed int v12; // eax@15
  signed int v13; // eax@19
  int v14; // eax@30
  char v15; // zf@30
  int v16; // eax@30
  int v17; // edx@30
  int v18; // ecx@30
  int v19; // edx@30
  int v20; // eax@30
  int v21; // edx@30
  int v22; // edx@30
  int v23; // eax@32
  int v24; // [sp+Ch] [bp-364h]@1
  int v25; // [sp+10h] [bp-360h]@1
  void *v26; // [sp+14h] [bp-35Ch]@1
  void *v27; // [sp+18h] [bp-358h]@1
  void *v28; // [sp+1Ch] [bp-354h]@1
  void *v29; // [sp+20h] [bp-350h]@1
  void *v30; // [sp+24h] [bp-34Ch]@1
  void *v31; // [sp+28h] [bp-348h]@1
  void *v32; // [sp+2Ch] [bp-344h]@1
  double v33; // [sp+30h] [bp-340h]@12
  int v34; // [sp+48h] [bp-328h]@25
  int v35; // [sp+50h] [bp-320h]@30
  int v36; // [sp+54h] [bp-31Ch]@30
  char v37; // [sp+58h] [bp-318h]@30
  char v38; // [sp+70h] [bp-300h]@30
  char v39; // [sp+88h] [bp-2E8h]@30
  char v40; // [sp+A0h] [bp-2D0h]@30
  int v41; // [sp+A8h] [bp-2C8h]@30
  int v42; // [sp+ACh] [bp-2C4h]@30
  int v43; // [sp+B0h] [bp-2C0h]@30
  int v44; // [sp+B4h] [bp-2BCh]@30
  int v45; // [sp+B8h] [bp-2B8h]@30
  int v46; // [sp+BCh] [bp-2B4h]@30
  int v47; // [sp+C0h] [bp-2B0h]@30
  int v48; // [sp+C4h] [bp-2ACh]@30
  int v49; // [sp+C8h] [bp-2A8h]@30
  int v50; // [sp+CCh] [bp-2A4h]@30
  int v51; // [sp+D0h] [bp-2A0h]@30
  int v52; // [sp+D4h] [bp-29Ch]@30
  double v53; // [sp+D8h] [bp-298h]@4
  char v54; // [sp+E0h] [bp-290h]@33
  double v55; // [sp+F0h] [bp-280h]@4
  char v56; // [sp+F8h] [bp-278h]@33
  double v57; // [sp+108h] [bp-268h]@4
  char v58; // [sp+110h] [bp-260h]@33
  char v59[24]; // [sp+128h] [bp-248h]@3
  double v60; // [sp+140h] [bp-230h]@5
  double v61; // [sp+158h] [bp-218h]@5
  double v62; // [sp+170h] [bp-200h]@5
  char v63; // [sp+188h] [bp-1E8h]@5
  char v64; // [sp+1A0h] [bp-1D0h]@5
  char v65; // [sp+1B8h] [bp-1B8h]@5
  char v66; // [sp+1D0h] [bp-1A0h]@5
  char v67; // [sp+1E8h] [bp-188h]@30
  char v68; // [sp+200h] [bp-170h]@30
  int v69; // [sp+2A0h] [bp-D0h]@30
  int v70; // [sp+2A4h] [bp-CCh]@30
  int v71; // [sp+2A8h] [bp-C8h]@30
  int v72; // [sp+2ACh] [bp-C4h]@30
  char v73; // [sp+2B0h] [bp-C0h]@5
  char v74; // [sp+2C8h] [bp-A8h]@5
  char v75; // [sp+2E0h] [bp-90h]@5
  char v76; // [sp+2F8h] [bp-78h]@5
  char v77; // [sp+310h] [bp-60h]@5
  char v78; // [sp+328h] [bp-48h]@5
  char v79; // [sp+340h] [bp-30h]@5
  char v80; // [sp+358h] [bp-18h]@5

  v25 = (int)malloc(856u);
  sub_10004810(a1, v25);
  v26 = malloc(0x228u);
  sub_10004CB0(a1, (char *)v26);
  v30 = malloc(0x120u);
  sub_10004EF0(a1, (char *)v30);
  v32 = malloc(0x40u);
  sub_100050A0(a1, (char *)v32);
  v24 = (int)malloc(0x1F0u);
  sub_100052F0(a1, v24);
  v2 = (int)malloc(0x1F0u);
  v31 = (void *)v2;
  sub_10005700(a1, v2);
  v29 = malloc(0x98u);
  sub_10005B10(a1, (char *)v29);
  v27 = malloc(0x3B0u);
  sub_10005DA0(a1, (int)v27);
  v28 = malloc(0x18u);
  sub_10005C60(a1, (char *)v28);
  v1 = malloc(0x24u);
  if ( !v1 )
    return 1;
  *((_DWORD *)v1 + 2) = v30;
  *(_DWORD *)v1 = v25;
  *((_DWORD *)v1 + 1) = v26;
  *((_DWORD *)v1 + 6) = v29;
  *((_DWORD *)v1 + 3) = v32;
  *((_DWORD *)v1 + 4) = v24;
  *((_DWORD *)v1 + 5) = v2;
  *((_DWORD *)v1 + 7) = v27;
  *((_DWORD *)v1 + 8) = v28;
  sub_100063B0(a1, (int)v59);
  sub_100066D0(a1, (int)v59);
  sub_10006A00(a1, v59);
  v5 = v2 + 432;
  v6 = v25 + 832;
  v4 = 0;
  do
  {
    v7 = *(double *)&v59[v4] + *(double *)(v24 - v2 + v5);
    v4 += 8;
    v5 += 8;
    v6 += 8;
    *(_QWORD *)((char *)&v55 + v4) = *(_QWORD *)&v7;
    *(double *)((char *)&v57 + v4) = v7 + *(double *)(v5 - 8);
    *(double *)((char *)&v53 + v4) = v7 + *(double *)(v6 - 8);
  }
  while ( v4 < 24 );
  memcpy(&v77, v59, 0x18u);
  memcpy(&v78, &v60, 0x18u);
  memcpy(&v79, &v61, 0x18u);
  memcpy(&v80, &v62, 0x18u);
  memcpy(&v73, &v63, 0x18u);
  memcpy(&v74, &v64, 0x18u);
  memcpy(&v75, &v65, 0x18u);
  memcpy(&v76, &v66, 0x18u);
  v8 = strstr;
  if ( strstr((const char *)v27, "POSX") )
  {
    v9 = 6;
    v10 = &v60;
  }
  else
  {
    if ( strstr((const char *)v27, "POSY") )
    {
      v9 = 6;
      v10 = &v61;
    }
    else
    {
      if ( !strstr((const char *)v27, "POSZ") )
      {
        if ( strstr((const char *)v27, "NEGX") )
        {
          v11 = 0;
          do
          {
            *(double *)((char *)&v33 + v11) = -*(double *)((char *)&v60 + v11);
            v11 += 8;
          }
          while ( v11 < 24 );
          goto LABEL_24;
        }
        if ( strstr((const char *)v27, "NEGY") )
        {
          v12 = 0;
          do
          {
            *(double *)((char *)&v33 + v12) = -*(double *)((char *)&v61 + v12);
            v12 += 8;
          }
          while ( v12 < 24 );
          goto LABEL_24;
        }
        if ( strstr((const char *)v27, "NEGZ") )
        {
          v13 = 0;
          do
          {
            *(double *)((char *)&v33 + v13) = -*(double *)((char *)&v62 + v13);
            v13 += 8;
          }
          while ( v13 < 24 );
          goto LABEL_24;
        }
      }
      v9 = 6;
      v10 = &v62;
    }
  }
  memcpy(&v33, v10, 4 * v9);
  v8 = strstr;
LABEL_24:
  if ( v8((const char *)v25, "5_axis_dual_table") )
  {
    v34 = 2;
  }
  else
  {
    if ( v8((const char *)v25, "5_axis_dual_head") )
    {
      v34 = 1;
    }
    else
    {
      if ( v8((const char *)v25, "5_axis_head_table") )
        v34 = 3;
    }
  }
  v14 = *(_DWORD *)(v25 + 800);
  v36 = *(_DWORD *)(v25 + 804);
  v35 = v14;
  memcpy(&v37, &v67, 0x18u);
  memcpy(&v38, &v68, 0x18u);
  memcpy(&v39, (const void *)(v24 + 432), 0x18u);
  v15 = atoi((const char *)(v25 + 133)) == 1;
  v41 = v71;
  v42 = v72;
  v16 = *((_DWORD *)v1 + 4);
  v40 = v15;
  v17 = *(_DWORD *)(v16 + 412);
  v43 = *(_DWORD *)(v16 + 408);
  v44 = v17;
  v18 = *(_DWORD *)(v16 + 416);
  v19 = *(_DWORD *)(v16 + 420);
  v20 = *((_DWORD *)v1 + 5);
  v45 = v18;
  v46 = v19;
  v21 = *(_DWORD *)(v20 + 412);
  v47 = *(_DWORD *)(v20 + 408);
  v48 = v21;
  v22 = *(_DWORD *)(v20 + 420);
  v49 = *(_DWORD *)(v20 + 416);
  v50 = v22;
  v51 = v69;
  v52 = v70;
  if ( strstr((const char *)v25, "5_axis_dual_table") )
  {
    *(_QWORD *)&v53 = 0i64;
  }
  else
  {
    v23 = *((_DWORD *)v26 + 135);
    LODWORD(v53) = *((_DWORD *)v26 + 134);
    HIDWORD(v53) = v23;
  }
  sub_10001000(&v73, &v77, (int)&v56, v24 + 456, (int)&v58, (int)((char *)v31 + 456), &v54, &v33, &v34);
  free(v1);
  if ( v25 )
    free((void *)v25);
  if ( v26 )
    free(v26);
  if ( v30 )
    free(v30);
  if ( v32 )
    free(v32);
  if ( v24 )
    free((void *)v24);
  if ( v31 )
    free(v31);
  if ( v29 )
    free(v29);
  if ( v27 )
    free(v27);
  if ( v28 )
    free(v28);
  return 0;
}

//----- (100081E0) --------------------------------------------------------
int __cdecl sub_100081E0(int a1)
{
  int v2; // [sp+8h] [bp-208h]@1
  int v3; // [sp+Ch] [bp-204h]@1
  int v4; // [sp+10h] [bp-200h]@1
  int v5; // [sp+14h] [bp-1FCh]@1
  int v6; // [sp+18h] [bp-1F8h]@1
  int v7; // [sp+1Ch] [bp-1F4h]@1
  int v8; // [sp+20h] [bp-1F0h]@1
  int v9; // [sp+24h] [bp-1ECh]@1
  int v10; // [sp+28h] [bp-1E8h]@1
  int v11; // [sp+2Ch] [bp-1E4h]@1
  int v12; // [sp+30h] [bp-1E0h]@1
  int v13; // [sp+34h] [bp-1DCh]@1
  int v14; // [sp+38h] [bp-1D8h]@1
  int v15; // [sp+3Ch] [bp-1D4h]@1
  int v16; // [sp+40h] [bp-1D0h]@1
  int v17; // [sp+44h] [bp-1CCh]@1
  int v18; // [sp+48h] [bp-1C8h]@1
  int v19; // [sp+4Ch] [bp-1C4h]@1
  int v20; // [sp+50h] [bp-1C0h]@1
  int v21; // [sp+54h] [bp-1BCh]@1
  char v22; // [sp+58h] [bp-1B8h]@1
  char Str; // [sp+88h] [bp-188h]@1

  sub_10006A00(a1, &Str);
  sub_10002530((int)&Str);
  sub_10006CA0(a1, &v22);
  sub_10002170((int)&v22, (int)&v12, (int)&v2);
  UF_MOM_set_double(a1, "pos_x", v12, v13);
  UF_MOM_set_double(a1, "pos_y", v14, v15);
  UF_MOM_set_double(a1, "pos_z", v16, v17);
  UF_MOM_set_double(a1, "pos_a1", v18, v19);
  UF_MOM_set_double(a1, "pos_a2", v20, v21);
  UF_MOM_set_double(a1, "alt_pos_x", v2, v3);
  UF_MOM_set_double(a1, "alt_pos_y", v4, v5);
  UF_MOM_set_double(a1, "alt_pos_z", v6, v7);
  UF_MOM_set_double(a1, "alt_pos_a1", v8, v9);
  UF_MOM_set_double(a1, "alt_pos_a2", v10, v11);
  return 0;
}
// 10009094: using guessed type int __cdecl UF_MOM_set_double(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10008300) --------------------------------------------------------
signed int __cdecl sub_10008300(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+Ch] [bp-48Ch]@1
  const char *v6; // [sp+10h] [bp-488h]@3
  int v7; // [sp+14h] [bp-484h]@9
  char *v8; // [sp+1Ch] [bp-47Ch]@9
  char v9; // [sp+24h] [bp-474h]@6
  char v10; // [sp+44h] [bp-454h]@6
  int v11; // [sp+78h] [bp-420h]@1
  int v12; // [sp+7Ch] [bp-41Ch]@1
  __int16 v13; // [sp+80h] [bp-418h]@1
  char v14; // [sp+100h] [bp-398h]@9
  int v15; // [sp+188h] [bp-310h]@1
  char v16; // [sp+210h] [bp-288h]@1
  char v17; // [sp+298h] [bp-200h]@2
  __int16 v18; // [sp+2B8h] [bp-1E0h]@4

  v15 = dword_1000BB90;
  memcpy(&v16, "tool_attribute_text", 0x14u);
  v13 = word_1000BB8C;
  v5 = 0;
  v11 = dword_1000BB84;
  v12 = dword_1000BB88;
  if ( a3 != 2 )
  {
    memcpy(&v17, "Invalid number of arguments", 0x1Cu);
LABEL_5:
    printf(" ERROR : %s \n ", &v17);
    return 1;
  }
  if ( UF_MOM_ask_string(a1, &v11, &v6) )
  {
    memcpy(&v17, "No Tool Name obtained from UGPost", 0x20u);
    v18 = *(_WORD *)&aNoToolNameObta[32];
    goto LABEL_5;
  }
  strcpy(&v9, v6);
  strcpy(&v10, *(const char **)(a4 + 4));
  if ( UF_OBJ_cycle_by_name(&v9, &v5) )
  {
    printf(" UF_OBJ_cycle_by_name could not get the tool_object_tag \n");
    return 1;
  }
  if ( !v5 )
    goto LABEL_16;
  v8 = &v14;
  if ( UF_ATTR_read_value(v5, &v10, 5, &v7) )
  {
    printf(" UF_ATTR_read_value could not return tool string \n");
    return 1;
  }
  if ( v7 != 5 )
LABEL_16:
    strcpy(&v14, (const char *)&v15);
  UF_MOM_set_string(a1, &v16, &v14);
  return 0;
}
// 10009068: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);
// 10009098: using guessed type int __cdecl UF_MOM_set_string(_DWORD, _DWORD, _DWORD);
// 1000909C: using guessed type int __cdecl UF_ATTR_read_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 100090A0: using guessed type int __cdecl UF_OBJ_cycle_by_name(_DWORD, _DWORD);
// 1000BB84: using guessed type int dword_1000BB84;
// 1000BB88: using guessed type int dword_1000BB88;
// 1000BB8C: using guessed type __int16 word_1000BB8C;
// 1000BB90: using guessed type int dword_1000BB90;

//----- (10008660) --------------------------------------------------------
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
  if ( fdwReason == 1 )
  {
    if ( !dword_1000BFF4 )
      DisableThreadLibraryCalls(hinstDLL);
  }
  return 1;
}
// 1000BFF4: using guessed type int dword_1000BFF4;

// ALL OK, 52 function(s) have been successfully decompiled
