/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2011 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Data declarations

extern char aReturnedErrorD[]; // idb
extern char aReturnedAD[]; // idb
extern char Format[]; // idb
extern char aKinematics[11]; // weak
extern char aErrorAdvancedK[]; // idb
extern char aUgpkin[13]; // weak
extern char aNumberOfArgume[]; // idb
extern char aIncorrectNumbe[]; // idb
extern char aSet_rotd_opera[]; // idb
extern char aSet_rotd_mcs_m[]; // idb
extern char aCaxis[6]; // weak
extern char aBaxis[6]; // weak
extern char aAaxis[6]; // weak
extern char aInsufficientNu[]; // idb
extern char aPos_z[6]; // weak
extern char aPos_y[6]; // weak
extern char aPos_x[6]; // weak
extern char aMom_transfer_g[]; // idb
extern char aMom_process_in[]; // idb
extern char aSet_input_poin[]; // idb
extern char a5_axis_head_ta[]; // idb
extern char a5_axis_dual_he[]; // idb
extern char a5_axis_dual_ta[]; // idb
extern char aNegz[]; // idb
extern char aNegy[]; // idb
extern char aNegx[]; // idb
extern char aPosz[]; // idb
extern char aPosy[]; // idb
extern char SubStr[]; // idb
extern char aAlt_pos_a2[11]; // weak
extern char aAlt_pos_a1[11]; // weak
extern char aAlt_pos_z[10]; // weak
extern char aAlt_pos_y[10]; // weak
extern char aAlt_pos_x[10]; // weak
extern char aPos_a2[7]; // weak
extern char aPos_a1[7]; // weak
extern char aUf_attr_read_v[]; // idb
extern char aUf_obj_cycle_b[]; // idb
extern char aErrorS[]; // idb
extern char aNoToolNameObta[34]; // weak
extern char aInvalidNumberO[28]; // weak
extern int dword_10009564; // weak
extern int dword_10009568; // weak
extern __int16 word_1000956C; // weak
extern int dword_10009570; // weak
extern int dword_10009574; // weak
extern int dword_10009578; // weak
extern int dword_1000957C; // weak
extern int dword_10009580; // weak
extern char aUf_mom_exten_4[87]; // weak
extern char aMom_exit_kinem[27]; // weak
extern char aUf_mom_exten_3[81]; // weak
extern char aMom_map_to_rot[24]; // weak
extern char aUf_mom_exten_2[75]; // weak
extern char aMom_rotate_mac[21]; // weak
extern char aUf_mom_exten_1[80]; // weak
extern char aMom_get_tool_a[23]; // weak
extern char aUf_mom_exten_0[69]; // weak
extern char aMom_convert_po[18]; // weak
extern char aOUgnx40Ip21Src[63]; // weak
extern char aUf_mom_extend_[73]; // weak
extern char aMom_load_kinem[20]; // weak
extern char aErrorUgpostAdv[]; // idb
extern _UNKNOWN unk_10009878; // weak
extern _UNKNOWN unk_100098C0; // weak
extern _UNKNOWN unk_10009908; // weak
extern char aWarningSameVal[]; // idb
extern char aComputingT11FT[]; // idb
extern char aComputingT10FT[]; // idb
extern char aAboutAdjusting[]; // idb
extern char aWarningDegener[]; // idb
extern char aInputPoint_4f_[]; // idb
extern char aStartingOld_pc[]; // idb
extern char asc_10009B3C[]; // idb
extern char aInit_t11Init_t[]; // idb
extern char aInit_t10Init_t[]; // idb
extern char aA1FD1FAlpha1FA[]; // idb
extern char aWarningToolAxi[]; // idb
extern char aLocalSecondary[]; // idb
extern char aLocalPrimaryax[]; // idb
extern char aSulzerCase[]; // idb
extern char aMcsysFFFFFFFFF[]; // idb
extern char aTool_vectorFFF[]; // idb
extern char aTool_machine_c[]; // idb
extern char aSecondary_mach[]; // idb
extern char aSecondaryFFF[]; // idb
extern char aPrimary_machin[]; // idb
extern char aPrimaryFFF[]; // idb
extern char aIs_5_axis_head[]; // idb
extern char aIs_5_axis_du_0[21]; // weak
extern char aIs_5_axis_dual[22]; // weak
extern char aIs_orthogonal_[]; // idb
extern char asc_10009DF0[]; // idb
extern char aFinalUfuncAlt_[]; // idb
extern char aFinalUfuncMcoo[]; // idb
extern char a400_00[7]; // weak
extern char a0_0[4]; // weak
extern char asc_10009EC4[2]; // weak
extern char aIn[3]; // weak
extern char aNone[5]; // weak
extern char aMom_kin_rapid_[24]; // weak
extern char aMom_kin_pivot_[27]; // weak
extern char aMom_kin_read_a[31]; // weak
extern char aMom_kin_polar_[26]; // weak
extern char aMom_kin_output[20]; // weak
extern char aEnd[4]; // weak
extern char aMom_kin_nurbs_[26]; // weak
extern char a9999_9999[10]; // weak
extern char a0_0001[7]; // weak
extern char aXy[3]; // weak
extern char aFull_circle[12]; // weak
extern char aMom_kin_max_ar[23]; // weak
extern char aMom_kin_min_ar[23]; // weak
extern char aMom_kin_arc_va[24]; // weak
extern char aMom_kin_arc_ou[24]; // weak
extern char a99999_999[10]; // weak
extern char a99_999[7]; // weak
extern char a0_001[6]; // weak
extern char a999_999[8]; // weak
extern char aMom_kin_min_dp[16]; // weak
extern char aMom_kin_max_dp[16]; // weak
extern char aMom_kin_min_fr[16]; // weak
extern char aMom_kin_max_fr[16]; // weak
extern char aMom_kin_min__0[16]; // weak
extern char aMom_kin_max__0[16]; // weak
extern char aMom_kin_min_fp[16]; // weak
extern char aMom_kin_max_fp[16]; // weak
extern char a360_0[6]; // weak
extern char aStandard[9]; // weak
extern char aMagnitude_dete[31]; // weak
extern char aYz[3]; // weak
extern char aMom_kin_4th_13[27]; // weak
extern char aMom_kin_4th_12[27]; // weak
extern char aMom_kin_4th_11[26]; // weak
extern char aMom_kin_4th_10[26]; // weak
extern char aMom_kin_4th__9[26]; // weak
extern char aMom_kin_4th__8[33]; // weak
extern char aMom_kin_4th__7[33]; // weak
extern char aMom_kin_4th__6[33]; // weak
extern char aMom_kin_4th__5[22]; // weak
extern char aMom_kin_4th__4[27]; // weak
extern char aMom_kin_4th__3[27]; // weak
extern char aMom_kin_4th__2[26]; // weak
extern char aMom_kin_4th__1[26]; // weak
extern char aMom_kin_4th__0[27]; // weak
extern char aMom_kin_4th_ax[23]; // weak
extern char aMom_kin_5th_13[27]; // weak
extern char aMom_kin_5th_12[27]; // weak
extern char aMom_kin_5th_11[26]; // weak
extern char aMom_kin_5th_10[26]; // weak
extern char aMom_kin_5th__9[26]; // weak
extern char aMom_kin_5th__8[33]; // weak
extern char aMom_kin_5th__7[33]; // weak
extern char aMom_kin_5th__6[33]; // weak
extern char aMom_kin_5th__5[22]; // weak
extern char aMom_kin_5th__4[27]; // weak
extern char aMom_kin_5th__3[27]; // weak
extern char aMom_kin_5th__2[26]; // weak
extern char aMom_kin_5th__1[26]; // weak
extern char aMom_kin_5th__0[27]; // weak
extern char aMom_kin_5th_ax[23]; // weak
extern char aFront[6]; // weak
extern char aMom_kin_ind__0[32]; // weak
extern char aMom_kin_ind_to[32]; // weak
extern char aMom_kin_indepe[25]; // weak
extern char a3_0[4]; // weak
extern char a0_5[4]; // weak
extern char aMom_kin_flush_[19]; // weak
extern char aMom_kin_clamp_[19]; // weak
extern char aMom_kin_tool_c[25]; // weak
extern char aMom_kin_hol_22[25]; // weak
extern char aMom_kin_hol_21[25]; // weak
extern char aMom_kin_hol_20[25]; // weak
extern char aMom_kin_hol_19[25]; // weak
extern char aMom_kin_hol_18[25]; // weak
extern char aMom_kin_hol_17[25]; // weak
extern char aMom_kin_hol_16[25]; // weak
extern char aMom_kin_hol_15[25]; // weak
extern char aMom_kin_hol_14[25]; // weak
extern char aMom_kin_hol_13[25]; // weak
extern char aMom_kin_hol_12[25]; // weak
extern char aMom_kin_hol_11[25]; // weak
extern char aMom_kin_hol_10[25]; // weak
extern char aMom_kin_hold_9[25]; // weak
extern char aMom_kin_hold_8[25]; // weak
extern char aMom_kin_hold_7[25]; // weak
extern char aMom_kin_hold_6[25]; // weak
extern char aMom_kin_hold_5[25]; // weak
extern char aMom_kin_hold_4[28]; // weak
extern char aMom_kin_hold_3[28]; // weak
extern char aMom_kin_hold_2[28]; // weak
extern char aMom_kin_hold_1[28]; // weak
extern char aMom_kin_hold_0[28]; // weak
extern char aMom_kin_holder[28]; // weak
extern char aKin_4th_to_t_1[28]; // weak
extern char aKin_4th_to_t_0[28]; // weak
extern char aKin_4th_to_tra[28]; // weak
extern char a90_0[5]; // weak
extern char aCartesian[10]; // weak
extern char aT[2]; // weak
extern char a3_axis_mill[12]; // weak
extern char aMom_kin_gaug_0[25]; // weak
extern char aMom_kin_line_0[26]; // weak
extern char aMom_kin_5th_14[36]; // weak
extern char aMom_kin_tool_t[29]; // weak
extern char aMom_kin_mach_0[27]; // weak
extern char aMom_kin_linear[27]; // weak
extern char aMom_kin_coordi[24]; // weak
extern char aMom_kin_clsf_g[24]; // weak
extern char aMom_kin_wire_t[30]; // weak
extern char aMom_kin_track_[29]; // weak
extern char aMom_kin_machin[21]; // weak
extern char aMom_kin_gauge_[25]; // weak
extern char a1_0[4]; // weak
extern char aMom_msys_z_a_1[18]; // weak
extern char aMom_msys_z_a_0[18]; // weak
extern char aMom_msys_z_axi[18]; // weak
extern char aMom_msys_y_a_1[18]; // weak
extern char aMom_msys_y_a_0[18]; // weak
extern char aMom_msys_y_axi[18]; // weak
extern char aMom_msys_x_a_1[18]; // weak
extern char aMom_msys_x_a_0[18]; // weak
extern char aMom_msys_x_axi[18]; // weak
extern char aMom_msys_ori_1[18]; // weak
extern char aMom_msys_ori_0[18]; // weak
extern char aMom_msys_origi[18]; // weak
extern char aMom_mtsys_z__1[19]; // weak
extern char aMom_mtsys_z__0[19]; // weak
extern char aMom_mtsys_z_ax[19]; // weak
extern char aMom_mtsys_y__1[19]; // weak
extern char aMom_mtsys_y__0[19]; // weak
extern char aMom_mtsys_y_ax[19]; // weak
extern char aMom_mtsys_x__1[19]; // weak
extern char aMom_mtsys_x__0[19]; // weak
extern char aMom_mtsys_x_ax[19]; // weak
extern char aMom_mtsys_or_1[19]; // weak
extern char aMom_mtsys_or_0[19]; // weak
extern char aMom_mtsys_orig[19]; // weak
extern char aMill[5]; // weak
extern char aMom_tool_corne[24]; // weak
extern char aMom_tool_z_off[18]; // weak
extern char aMom_tool_type[14]; // weak
extern char aMom_translat_1[16]; // weak
extern char aMom_translat_0[16]; // weak
extern char aMom_translate_[16]; // weak
extern char aMom_origin_z[13]; // weak
extern char aMom_origin_y[13]; // weak
extern char aMom_origin_x[13]; // weak
extern char aMom_tool_axi_1[16]; // weak
extern char aMom_tool_axi_0[16]; // weak
extern char aMom_tool_axis_[16]; // weak
extern char aMom_mcs_goto_z[15]; // weak
extern char aMom_mcs_goto_y[15]; // weak
extern char aMom_mcs_goto_x[15]; // weak
extern char aWarningTheTo_0[119]; // weak
extern char aWarningTheTool[]; // idb
extern _UNKNOWN unk_1000AE18; // weak
extern _UNKNOWN unk_1000AE20; // weak
extern double dbl_1000C010; // weak
extern char byte_1000C018; // weak
extern char byte_1000C019; // weak
extern char byte_1000C01A; // weak
extern int dword_1000C028; // weak
extern double dbl_1000C030; // weak
extern double dbl_1000C038; // weak
extern double dbl_1000C040; // weak
extern double dbl_1000C048; // weak
extern double dbl_1000C050; // weak
extern double dbl_1000C058; // weak
extern double dbl_1000C060; // weak
extern double dbl_1000C068; // weak
extern double dbl_1000C070; // weak
extern double dbl_1000C078; // weak
extern double dbl_1000C080; // weak
extern double dbl_1000C088; // weak
extern int dword_1000C0B0; // weak
extern int dword_1000C0B4; // weak
extern int dword_1000C0B8; // weak
extern int dword_1000C0BC; // weak
extern int dword_1000C0C0; // weak
extern int dword_1000C0C4; // weak
extern double dbl_1000C0C8; // weak
extern double dbl_1000C0D0; // weak
extern double dbl_1000C0D8; // weak
extern double dbl_1000C0E0; // weak
extern double dbl_1000C0E8; // weak
extern double dbl_1000C0F0; // weak
extern double dbl_1000C0F8; // weak
extern double dbl_1000C100[]; // weak
extern double dbl_1000C108; // weak
extern double dbl_1000C110; // weak
extern double dbl_1000C118; // weak
extern double dbl_1000C120; // weak
extern _UNKNOWN unk_1000C128; // weak
extern double dbl_1000C130; // weak
extern int dword_1000C1C0; // weak
extern _UNKNOWN unk_1000C1C8; // weak
extern double dbl_1000C248; // weak
extern double dbl_1000C250; // weak
extern double dbl_1000C258; // weak
extern double dbl_1000C260; // weak
extern double dbl_1000C268; // weak
extern double dbl_1000C270; // weak
extern double dbl_1000C278; // weak
extern double dbl_1000C280; // weak
extern double dbl_1000C288; // weak
extern double dbl_1000C290; // weak
extern double dbl_1000C298; // weak
extern double dbl_1000C2A0; // weak
extern double dbl_1000C2A8; // weak
extern double dbl_1000C2B0; // weak
extern double dbl_1000C2B8; // weak
extern double dbl_1000C2C0; // weak
extern int dword_1000C2C8; // weak
extern int dword_1000C2CC; // weak
extern int dword_1000C2D0; // weak
extern int dword_1000C2D4; // weak
extern int dword_1000C2D8; // weak
extern int dword_1000C2DC; // weak
extern int dword_1000C2E0; // weak
extern int dword_1000C2E4; // weak
extern int dword_1000C2E8; // weak
extern int dword_1000C2EC; // weak
extern int dword_1000C2F0; // weak
extern int dword_1000C2F4; // weak
extern int dword_1000C2F8; // weak
extern int dword_1000C2FC; // weak
extern int dword_1000C300; // weak
extern int dword_1000C304; // weak
extern int dword_1000C308; // weak
extern int dword_1000C30C; // weak
extern int dword_1000C310; // weak
extern int dword_1000C314; // weak
extern int dword_1000C318; // weak
extern double dbl_1000C320; // weak
extern double dbl_1000C328; // weak
extern int dword_1000C330; // weak
extern int dword_1000C334; // weak
extern int dword_1000C338; // weak
extern int dword_1000C33C; // weak
extern int dword_1000C340; // weak
extern int dword_1000C344; // weak
extern double dbl_1000C348; // weak
extern double dbl_1000C350; // weak
extern double dbl_1000C358; // weak
extern double dbl_1000C360; // weak
extern double dbl_1000C368; // weak
extern double dbl_1000C370; // weak
extern char byte_1000C378; // weak
extern _UNKNOWN unk_1000C380; // weak
extern _UNKNOWN unk_1000C3A8; // weak
extern _UNKNOWN unk_1000C3D0; // weak
extern double dbl_1000C3E8; // weak
extern double dbl_1000C3F0; // weak
extern double dbl_1000C3F8; // weak
extern double dbl_1000C400; // weak
extern double dbl_1000C408; // weak
extern double dbl_1000C410; // weak
extern double dbl_1000C418; // weak
extern double dbl_1000C420; // weak
extern double dbl_1000C428; // weak
extern _UNKNOWN unk_1000C430; // weak
extern double dbl_1000C448; // weak
extern int dword_1000C450; // weak
extern double dbl_1000C458; // weak
extern int dword_1000C460; // weak
extern int dword_1000C474; // weak

//-------------------------------------------------------------------------
// Function declarations

// int __usercall sub_10001000<eax>(int a1<eax>, int a2<edx>, int a3<ecx>, int a4<esi>);
// int UF_terminate(); weak
signed int __cdecl sub_100010C0(int a1, int a2, signed int a3, int a4);
int __cdecl sub_10001270(int a1);
signed int __cdecl sub_10001350(int Str);
int __cdecl sub_10001B10(int a1);
signed int __cdecl sub_10001C10(int a1, int a2, char *a3, int a4);
int __cdecl ufusr(int a1, int a2);
// int __cdecl sub_10001FE0(double); idb
// int __usercall sub_10002030<eax>(int result<eax>, int a2<ecx>, long double a3);
// int __usercall sub_10002150<eax>(int a1<eax>, int a2<ecx>, int a3);
// int __usercall sub_10002220<eax>(int a1<eax>, int a2<esi>, double a3, double a4, signed int a5);
int __cdecl sub_100023B0(int, double, int); // idb
signed int __cdecl PtFuncCompare(int a1, int a2);
void __fastcall sub_10002510(int a1, int a2);
// void __usercall sub_100026F0(int a1<edx>, int a2<ecx>, int a3<ebx>);
int __cdecl sub_10002860(int a1);
int __cdecl sub_100028E0(int a1, int a2, int a3, int a4);
// signed int __usercall sub_100029A0<eax>(int a1<esi>, signed int a2, int a3, int a4);
int __fastcall sub_10002E60(int a1, int a2, int a3, int a4, int a5);
// signed int __usercall sub_10003080<eax>(int a1<eax>, int a2);
// int __usercall sub_100031B0<eax>(int a1<ecx>, unsigned int a2<ebx>, unsigned int a3<esi>, int a4, int a5);
signed int __cdecl sub_10003400(const void *a1, int a2, unsigned int a3);
int __cdecl sub_100041E0(int a1, int a2, int a3, int a4, int a5, int a6);
signed int __cdecl sub_10004420(int a1, const void *a2, int a3, int a4, int a5, int a6, int a7, int a8, const void *a9);
signed int __cdecl sub_10005470(const void *a1, int a2, int a3);
double __cdecl sub_10005760(int a1, long double *a2);
// signed int __usercall sub_10005800<eax>(int a1<eax>);
signed int __cdecl sub_10005BC0(int a1);
int __cdecl sub_10005C20(int a1, int a2);
int __cdecl sub_10005DD0(int a1, int a2);
int __cdecl sub_10005F10(int a1, int a2);
int __cdecl sub_100060E0(int a1, int a2);
int __cdecl sub_10006420(int a1, int a2);
int __cdecl sub_10006760(int a1, int a2);
int __cdecl sub_10006870(int a1, int a2);
int __cdecl sub_10006960(int a1, int a2);
int __cdecl sub_10006E70(int a1, int a2);
int __cdecl sub_10007240(int a1, int a2);
int __cdecl sub_100074C0(int a1, int a2);
int __cdecl sub_10007760(int a1, int a2);
int __cdecl sub_10007980(int a1, int a2);
int __cdecl sub_10007B00(int a1, int a2);
int __cdecl sub_10007D30(int a1, int a2);
int __cdecl sub_10007E30(int a1, int a2);
int __cdecl sub_10007ED0(int a1, int a2, int a3);
void __cdecl sub_100083B8();
void __cdecl sub_100083FC(); // idb
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
// BOOL __stdcall DisableThreadLibraryCalls(HMODULE hLibModule);
// double __cdecl ceil(double);
// double __cdecl floor(double);
// void __cdecl qsort(void *Base, size_t NumOfElements, size_t SizeOfElements, int (__cdecl *PtFuncCompare)(const void *, const void *));
// char *__cdecl strstr(const char *Str, const char *SubStr);
// int __cdecl atoi(const char *Str);
// void *__cdecl malloc(size_t Size);
// double __cdecl strtod(const char *Str, char **EndPtr);
// void __cdecl free(void *Memory);
// int sprintf(char *Dest, const char *Format, ...);
// int printf(const char *Format, ...);
// int __cdecl UF_MTX3_vec_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_ask_rotation(_DWORD, _DWORD); weak
// int __cdecl UF_MTX4_rotation(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_add(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_vec3_multiply_t(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_angle_between(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_copy(_DWORD, _DWORD); weak
// int __cdecl UF_VEC3_dot(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_free(_DWORD); weak
// int __cdecl UF_allocate_memory(_DWORD, _DWORD); weak
// int __cdecl UF_MTX4_vec3_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_affine_comb(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_is_zero(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_vec_multiply_t(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_distance(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_z_vec(_DWORD, _DWORD); weak
// int __cdecl UF_VEC3_is_parallel(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_scale(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_edit_rotation(_DWORD, _DWORD); weak
// int __cdecl UF_MTX3_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_rotate_about_axis(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_vec_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_copy(_DWORD, _DWORD); weak
// int __cdecl UF_MTX3_x_vec(_DWORD, _DWORD); weak
// int __cdecl UF_MTX3_y_vec(_DWORD, _DWORD); weak
// int __cdecl UF_MTX4_csys_to_csys(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_cross(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MOM_ask_interp_from_param(_DWORD, _DWORD); weak
// int __cdecl UF_MOM_ask_mom(_DWORD, _DWORD); weak
// int __cdecl UF_MOM_extend_xlator(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_OBJ_cycle_by_name(_DWORD, _DWORD); weak
// int __cdecl UF_ATTR_read_value(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MOM_set_string(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MOM_set_double(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int UF_terminate(void); weak
// int __cdecl UF_MISC_set_program_name(_DWORD); weak
// int UF_initialize(void); weak
// int __cdecl UF_VEC3_is_equal(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_get_fail_message(_DWORD, _DWORD); weak
// int __cdecl uc1601(_DWORD, _DWORD); weak


//----- (10001000) --------------------------------------------------------
int __usercall sub_10001000<eax>(int a1<eax>, int a2<edx>, int a3<ecx>, int a4<esi>)
{
  char v5; // [sp+0h] [bp-88h]@2

  if ( a4 )
  {
    printf("%s, line %d:  %s\n", a2, a3, a1);
    if ( UF_get_fail_message(a4, &v5) )
    {
      printf("    returned a %d\n", a4);
      return a4;
    }
    printf("    returned error %d:  %s\n", a4, &v5);
  }
  return a4;
}
// 100090FC: using guessed type int __cdecl UF_get_fail_message(_DWORD, _DWORD);

//----- (100010C0) --------------------------------------------------------
signed int __cdecl sub_100010C0(int a1, int a2, signed int a3, int a4)
{
  int v4; // esi@1
  signed int result; // eax@4
  signed int v6; // ebx@5
  int v7; // edi@7
  int v8; // esi@7
  signed int v9; // ecx@7
  bool v10; // zf@7
  double v11; // st7@11
  int v12; // edi@12
  int v13; // esi@12
  signed int v14; // ecx@12
  bool v15; // zf@12
  int v16; // edi@17
  int v17; // esi@17
  signed int v18; // ecx@17
  bool v19; // zf@17
  double v20; // st7@23
  int v21; // eax@23
  int v22; // edi@25
  int v23; // edi@27
  double v24; // [sp+4h] [bp-38h]@1
  double v25; // [sp+Ch] [bp-30h]@1
  double v26; // [sp+14h] [bp-28h]@1
  double v27; // [sp+1Ch] [bp-20h]@1
  double v28; // [sp+24h] [bp-18h]@1
  double v29; // [sp+2Ch] [bp-10h]@1
  int v30; // [sp+34h] [bp-8h]@1
  int v31; // [sp+38h] [bp-4h]@6

  v24 = 0.0;
  v25 = 0.0;
  v26 = 0.0;
  v27 = 0.0;
  v28 = 0.0;
  v29 = 0.0;
  v4 = (int)malloc(0x90u);
  v30 = v4;
  if ( a3 > 7 || a3 == 1 )
  {
    printf(" Incorrect number of arguments\n");
    printf(" Number of arguments should be between 1 and 6\n ");
    result = 999;
  }
  else
  {
    if ( !(a3 % 2) )
    {
      printf(" Insufficient number of arguments, There should be               atleast 2 arguments\n ");
      return 999;
    }
    v6 = 1;
    if ( a3 > 1 )
    {
      v31 = (int)&v24;
      while ( 1 )
      {
        v7 = (int)"AAXIS";
        v8 = *(_DWORD *)(a4 + 4 * v6);
        v9 = 6;
        v10 = 1;
        do
        {
          if ( !v9 )
            break;
          v10 = *(_BYTE *)v8++ == *(_BYTE *)v7++;
          --v9;
        }
        while ( v10 );
        if ( v10 )
        {
          v11 = 1.0;
        }
        else
        {
          v12 = (int)"BAXIS";
          v13 = *(_DWORD *)(a4 + 4 * v6);
          v14 = 6;
          v15 = 1;
          do
          {
            if ( !v14 )
              break;
            v15 = *(_BYTE *)v13++ == *(_BYTE *)v12++;
            --v14;
          }
          while ( v15 );
          if ( v15 )
          {
            v11 = 2.0;
          }
          else
          {
            v16 = (int)"CAXIS";
            v17 = *(_DWORD *)(a4 + 4 * v6);
            v18 = 6;
            v19 = 1;
            do
            {
              if ( !v18 )
                break;
              v19 = *(_BYTE *)v17++ == *(_BYTE *)v16++;
              --v18;
            }
            while ( v19 );
            if ( !v19 )
              goto LABEL_23;
            v11 = 3.0;
          }
        }
        *(_QWORD *)v31 = *(_QWORD *)&v11;
LABEL_23:
        v20 = strtod((const char *)*(_DWORD *)(a4 + 4 * v6 + 4), 0);
        v21 = v31;
        *(_QWORD *)(v31 + 8) = *(_QWORD *)&v20;
        v6 += 2;
        v31 = v21 + 16;
        if ( v6 >= a3 )
        {
          v4 = v30;
          break;
        }
      }
    }
    v22 = sub_10007ED0(a1, v4, (int)&v24);
    if ( v22 )
    {
      printf(" SET_rotd_mcs_matrix failed in mom_rotate_mach_csys \n ");
      result = v22;
    }
    else
    {
      v23 = sub_10007B00(a1, v4);
      if ( v23 )
      {
        printf(" SET_rotd_operation_data failed in mom_rotate_mach_csys \n ");
        result = v23;
      }
      else
      {
        if ( v4 )
          free((void *)v4);
        result = 0;
      }
    }
  }
  return result;
}

//----- (10001270) --------------------------------------------------------
int __cdecl sub_10001270(int a1)
{
  int v1; // edi@1
  int result; // eax@2
  int v3; // edi@3
  int v4; // edi@5
  char v5; // [sp+10h] [bp-90h]@3
  char v6; // [sp+40h] [bp-60h]@1
  double v7; // [sp+70h] [bp-30h]@5
  double v8; // [sp+78h] [bp-28h]@7
  _DWORD v9[8]; // [sp+80h] [bp-20h]@7

  v1 = sub_10007980(a1, (int)&v6);
  if ( v1 )
  {
    printf(" SET_input_point failed in mom_map_to_rotated_csys\n ");
    result = v1;
  }
  else
  {
    v3 = sub_10007E30((int)&v6, (int)&v5);
    if ( v3 )
    {
      printf(" mom_process_input_gotos failed in mom_map_to_rotated_csys\n ");
      result = v3;
    }
    else
    {
      v4 = sub_10007D30((int)&v5, (int)&v7);
      if ( v4 )
      {
        printf(" mom_transfer_gotos_rotd_mcsys failed in mom_map_to_rotated_csys\n ");
        result = v4;
      }
      else
      {
        UF_MOM_set_double(a1, "pos_x", LODWORD(v7), HIDWORD(v7));
        UF_MOM_set_double(a1, "pos_y", LODWORD(v8), HIDWORD(v8));
        UF_MOM_set_double(a1, "pos_z", v9[0], v9[1]);
        result = 0;
      }
    }
  }
  return result;
}
// 100090E8: using guessed type int __cdecl UF_MOM_set_double(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10001350) --------------------------------------------------------
signed int __cdecl sub_10001350(int Str)
{
  int v1; // esi@1
  int v2; // ebx@1
  void *v3; // edi@1
  void *v5; // eax@3
  void *v6; // ecx@3
  void *v7; // edx@3
  int v8; // eax@3
  int v9; // ecx@3
  void *v10; // ecx@3
  double v11; // st7@3
  double v12; // st6@3
  double v13; // st7@3
  double v14; // st6@3
  double v15; // st7@3
  int v16; // edx@21
  int v17; // ecx@21
  int v18; // edx@21
  int v19; // ecx@21
  int v20; // edx@21
  int v21; // eax@21
  int v22; // eax@21
  bool v23; // zf@21
  int v24; // eax@21
  double v25; // st7@21
  int v26; // eax@21
  char *v27; // eax@21
  void *v28; // esi@21
  double v29; // st7@22
  double v30; // [sp+Ch] [bp-35Ch]@3
  double v31; // [sp+14h] [bp-354h]@3
  double v32; // [sp+1Ch] [bp-34Ch]@3
  double v33; // [sp+24h] [bp-344h]@3
  double v34; // [sp+2Ch] [bp-33Ch]@3
  double v35; // [sp+34h] [bp-334h]@3
  double v36; // [sp+3Ch] [bp-32Ch]@3
  double v37; // [sp+44h] [bp-324h]@3
  double v38; // [sp+4Ch] [bp-31Ch]@3
  int v39; // [sp+54h] [bp-314h]@16
  double v40; // [sp+5Ch] [bp-30Ch]@21
  int v41; // [sp+64h] [bp-304h]@21
  int v42; // [sp+68h] [bp-300h]@21
  int v43; // [sp+6Ch] [bp-2FCh]@21
  int v44; // [sp+70h] [bp-2F8h]@21
  int v45; // [sp+74h] [bp-2F4h]@21
  int v46; // [sp+78h] [bp-2F0h]@21
  int v47; // [sp+7Ch] [bp-2ECh]@21
  int v48; // [sp+80h] [bp-2E8h]@21
  int v49; // [sp+84h] [bp-2E4h]@21
  int v50; // [sp+88h] [bp-2E0h]@21
  int v51; // [sp+8Ch] [bp-2DCh]@21
  int v52; // [sp+90h] [bp-2D8h]@21
  int v53; // [sp+94h] [bp-2D4h]@21
  int v54; // [sp+98h] [bp-2D0h]@21
  int v55; // [sp+9Ch] [bp-2CCh]@21
  int v56; // [sp+A0h] [bp-2C8h]@21
  int v57; // [sp+A4h] [bp-2C4h]@21
  int v58; // [sp+A8h] [bp-2C0h]@21
  bool v59; // [sp+ACh] [bp-2BCh]@21
  double v60; // [sp+B4h] [bp-2B4h]@21
  double v61; // [sp+BCh] [bp-2ACh]@21
  double v62; // [sp+C4h] [bp-2A4h]@21
  double v63; // [sp+CCh] [bp-29Ch]@21
  double v64; // [sp+D4h] [bp-294h]@21
  double v65; // [sp+DCh] [bp-28Ch]@21
  double v66; // [sp+E4h] [bp-284h]@24
  __int64 v67; // [sp+ECh] [bp-27Ch]@3
  double v68; // [sp+F4h] [bp-274h]@3
  __int64 v69; // [sp+FCh] [bp-26Ch]@3
  __int64 v70; // [sp+104h] [bp-264h]@3
  __int64 v71; // [sp+10Ch] [bp-25Ch]@3
  __int64 v72; // [sp+114h] [bp-254h]@3
  __int64 v73; // [sp+11Ch] [bp-24Ch]@3
  __int64 v74; // [sp+124h] [bp-244h]@3
  __int64 v75; // [sp+12Ch] [bp-23Ch]@3
  __int64 v76; // [sp+134h] [bp-234h]@3
  __int64 v77; // [sp+13Ch] [bp-22Ch]@3
  __int64 v78; // [sp+144h] [bp-224h]@3
  int v79; // [sp+14Ch] [bp-21Ch]@3
  int v80; // [sp+150h] [bp-218h]@3
  int v81; // [sp+154h] [bp-214h]@3
  int v82; // [sp+158h] [bp-210h]@3
  int v83; // [sp+15Ch] [bp-20Ch]@3
  int v84; // [sp+160h] [bp-208h]@3
  int v85; // [sp+164h] [bp-204h]@3
  int v86; // [sp+168h] [bp-200h]@3
  int v87; // [sp+16Ch] [bp-1FCh]@3
  int v88; // [sp+170h] [bp-1F8h]@3
  int v89; // [sp+174h] [bp-1F4h]@3
  int v90; // [sp+178h] [bp-1F0h]@3
  int v91; // [sp+17Ch] [bp-1ECh]@3
  int v92; // [sp+180h] [bp-1E8h]@3
  int v93; // [sp+184h] [bp-1E4h]@3
  int v94; // [sp+188h] [bp-1E0h]@3
  int v95; // [sp+18Ch] [bp-1DCh]@3
  int v96; // [sp+190h] [bp-1D8h]@3
  int v97; // [sp+194h] [bp-1D4h]@3
  int v98; // [sp+198h] [bp-1D0h]@3
  int v99; // [sp+19Ch] [bp-1CCh]@3
  int v100; // [sp+1A0h] [bp-1C8h]@3
  int v101; // [sp+1A4h] [bp-1C4h]@3
  int v102; // [sp+1A8h] [bp-1C0h]@3
  int v103; // [sp+1ACh] [bp-1BCh]@21
  int v104; // [sp+1B0h] [bp-1B8h]@21
  int v105; // [sp+1B4h] [bp-1B4h]@21
  int v106; // [sp+1B8h] [bp-1B0h]@21
  int v107; // [sp+1BCh] [bp-1ACh]@21
  int v108; // [sp+1C0h] [bp-1A8h]@21
  int v109; // [sp+1C4h] [bp-1A4h]@21
  int v110; // [sp+1C8h] [bp-1A0h]@21
  int v111; // [sp+1CCh] [bp-19Ch]@21
  int v112; // [sp+1D0h] [bp-198h]@21
  int v113; // [sp+1D4h] [bp-194h]@21
  int v114; // [sp+1D8h] [bp-190h]@21
  double v115; // [sp+264h] [bp-104h]@21
  double v116; // [sp+26Ch] [bp-FCh]@21
  int v117; // [sp+274h] [bp-F4h]@3
  int v118; // [sp+278h] [bp-F0h]@3
  int v119; // [sp+27Ch] [bp-ECh]@3
  int v120; // [sp+280h] [bp-E8h]@3
  int v121; // [sp+284h] [bp-E4h]@3
  int v122; // [sp+288h] [bp-E0h]@3
  int v123; // [sp+28Ch] [bp-DCh]@3
  int v124; // [sp+290h] [bp-D8h]@3
  int v125; // [sp+294h] [bp-D4h]@3
  int v126; // [sp+298h] [bp-D0h]@3
  int v127; // [sp+29Ch] [bp-CCh]@3
  int v128; // [sp+2A0h] [bp-C8h]@3
  int v129; // [sp+2A4h] [bp-C4h]@3
  int v130; // [sp+2A8h] [bp-C0h]@3
  int v131; // [sp+2ACh] [bp-BCh]@3
  int v132; // [sp+2B0h] [bp-B8h]@3
  int v133; // [sp+2B4h] [bp-B4h]@3
  int v134; // [sp+2B8h] [bp-B0h]@3
  int v135; // [sp+2BCh] [bp-ACh]@3
  int v136; // [sp+2C0h] [bp-A8h]@3
  int v137; // [sp+2C4h] [bp-A4h]@3
  int v138; // [sp+2C8h] [bp-A0h]@3
  int v139; // [sp+2CCh] [bp-9Ch]@3
  int v140; // [sp+2D0h] [bp-98h]@3
  __int64 v141; // [sp+2D4h] [bp-94h]@3
  double v142; // [sp+2DCh] [bp-8Ch]@3
  __int64 v143; // [sp+2E4h] [bp-84h]@3
  __int64 v144; // [sp+2ECh] [bp-7Ch]@3
  __int64 v145; // [sp+2F4h] [bp-74h]@3
  __int64 v146; // [sp+2FCh] [bp-6Ch]@3
  __int64 v147; // [sp+304h] [bp-64h]@3
  __int64 v148; // [sp+30Ch] [bp-5Ch]@3
  __int64 v149; // [sp+314h] [bp-54h]@3
  __int64 v150; // [sp+31Ch] [bp-4Ch]@3
  __int64 v151; // [sp+324h] [bp-44h]@3
  __int64 v152; // [sp+32Ch] [bp-3Ch]@3
  void *v153; // [sp+334h] [bp-34h]@1
  void *v154; // [sp+338h] [bp-30h]@1
  void *v155; // [sp+33Ch] [bp-2Ch]@1
  void *v156; // [sp+340h] [bp-28h]@1
  void *Memory; // [sp+344h] [bp-24h]@1
  int v158; // [sp+348h] [bp-20h]@1
  __int64 v159; // [sp+34Ch] [bp-1Ch]@4
  __int64 v160; // [sp+354h] [bp-14h]@4
  __int64 v161; // [sp+35Ch] [bp-Ch]@4
  int v162; // [sp+364h] [bp-4h]@1
  void *Stra; // [sp+370h] [bp+8h]@1

  v1 = Str;
  v2 = (int)malloc(0x358u);
  sub_10006E70(Str, v2);
  Memory = malloc(0x228u);
  sub_10005C20(Str, (int)Memory);
  v153 = malloc(0x120u);
  sub_10005DD0(Str, (int)v153);
  v155 = malloc(0x40u);
  sub_10005F10(Str, (int)v155);
  v162 = (int)malloc(0x1F0u);
  sub_100060E0(Str, v162);
  v158 = (int)malloc(0x1F0u);
  sub_10006420(Str, v158);
  v154 = malloc(0x98u);
  sub_10006760(Str, (int)v154);
  Stra = malloc(0x3B0u);
  sub_10006960(v1, (int)Stra);
  v156 = malloc(0x18u);
  sub_10006870(v1, (int)v156);
  v3 = malloc(0x24u);
  if ( !v3 )
    return 1;
  v5 = Memory;
  v6 = v153;
  *((_DWORD *)v3 + 3) = v155;
  v7 = v154;
  *((_DWORD *)v3 + 1) = v5;
  v8 = v162;
  *((_DWORD *)v3 + 2) = v6;
  v9 = v158;
  *((_DWORD *)v3 + 6) = v7;
  *((_DWORD *)v3 + 4) = v8;
  *((_DWORD *)v3 + 5) = v9;
  v10 = v156;
  *(_DWORD *)v3 = v2;
  *((_DWORD *)v3 + 7) = Stra;
  *((_DWORD *)v3 + 8) = v10;
  sub_10007240(v1, (int)&v67);
  sub_100074C0(v1, (int)&v67);
  sub_10007760(v1, (int)&v67);
  v11 = *(double *)&v67 + *(double *)(v162 + 432);
  v141 = v67;
  v30 = v11;
  v12 = v11 + *(double *)(v158 + 432);
  v144 = v70;
  v33 = v12;
  v13 = v11 + *(double *)(v2 + 832);
  v147 = v73;
  v36 = v13;
  v31 = v68 + *(double *)(v162 + 440);
  v34 = v31 + *(double *)(v158 + 440);
  v37 = v31 + *(double *)(v2 + 840);
  v32 = *(double *)&v69 + *(double *)(v162 + 448);
  v143 = v69;
  v14 = v32 + *(double *)(v158 + 448);
  v142 = v68;
  v35 = v14;
  v15 = v32 + *(double *)(v2 + 848);
  v145 = v71;
  v38 = v15;
  v146 = v72;
  v148 = v74;
  v150 = v76;
  v149 = v75;
  v151 = v77;
  v117 = v79;
  v152 = v78;
  v120 = v82;
  v118 = v80;
  v119 = v81;
  v123 = v85;
  v121 = v83;
  v122 = v84;
  v126 = v88;
  v124 = v86;
  v125 = v87;
  v129 = v91;
  v127 = v89;
  v128 = v90;
  v132 = v94;
  v130 = v92;
  v131 = v93;
  v135 = v97;
  v133 = v95;
  v134 = v96;
  v138 = v100;
  v136 = v98;
  v137 = v99;
  v139 = v101;
  v140 = v102;
  if ( strstr((const char *)Stra, "POSX") )
  {
    v159 = v70;
    v160 = v71;
    v161 = v72;
  }
  else
  {
    if ( !strstr((const char *)Stra, "POSY") )
    {
      if ( !strstr((const char *)Stra, "POSZ") )
      {
        if ( strstr((const char *)Stra, "NEGX") )
        {
          *(double *)&v159 = -*(double *)&v70;
          *(double *)&v160 = -*(double *)&v71;
          *(double *)&v161 = -*(double *)&v72;
          goto LABEL_15;
        }
        if ( strstr((const char *)Stra, "NEGY") )
        {
          *(double *)&v159 = -*(double *)&v73;
          *(double *)&v160 = -*(double *)&v74;
          *(double *)&v161 = -*(double *)&v75;
          goto LABEL_15;
        }
        if ( strstr((const char *)Stra, "NEGZ") )
        {
          *(double *)&v159 = -*(double *)&v76;
          *(double *)&v160 = -*(double *)&v77;
          *(double *)&v161 = -*(double *)&v78;
          goto LABEL_15;
        }
      }
      v159 = v76;
      v160 = v77;
      v161 = v78;
      goto LABEL_15;
    }
    v159 = v73;
    v160 = v74;
    v161 = v75;
  }
LABEL_15:
  if ( strstr((const char *)v2, "5_axis_dual_table") )
  {
    v39 = 2;
  }
  else
  {
    if ( strstr((const char *)v2, "5_axis_dual_head") )
    {
      v39 = 1;
    }
    else
    {
      if ( strstr((const char *)v2, "5_axis_head_table") )
        v39 = 3;
    }
  }
  v40 = *(double *)(v2 + 800);
  v42 = v104;
  v41 = v103;
  v43 = v105;
  v45 = v107;
  v44 = v106;
  v46 = v108;
  v48 = v110;
  v47 = v109;
  v49 = v111;
  v51 = v113;
  v50 = v112;
  v16 = *(_DWORD *)(v162 + 432);
  v52 = v114;
  v17 = *(_DWORD *)(v162 + 436);
  v53 = v16;
  v18 = *(_DWORD *)(v162 + 440);
  v54 = v17;
  v19 = *(_DWORD *)(v162 + 444);
  v55 = v18;
  v20 = *(_DWORD *)(v162 + 448);
  v21 = *(_DWORD *)(v162 + 452);
  v56 = v19;
  v57 = v20;
  v58 = v21;
  v22 = atoi((const char *)(v2 + 133));
  v60 = v116;
  v23 = v22 == 1;
  v24 = *((_DWORD *)v3 + 4);
  v59 = v23;
  v61 = *(double *)(v24 + 408);
  v25 = *(double *)(v24 + 416);
  v26 = *((_DWORD *)v3 + 5);
  v62 = v25;
  v63 = *(double *)(v26 + 408);
  v64 = *(double *)(v26 + 416);
  v65 = v115;
  v27 = strstr((const char *)v2, "5_axis_dual_table");
  v28 = Memory;
  if ( v27 )
    v29 = 0.0;
  else
    v29 = *((double *)Memory + 67);
  v66 = v29;
  sub_10004420((int)&v117, &v141, (int)&v30, v162 + 456, (int)&v33, v158 + 456, (int)&v36, (int)&v159, &v39);
  free(v3);
  free((void *)v2);
  if ( v28 )
    free(v28);
  if ( v153 )
    free(v153);
  if ( v155 )
    free(v155);
  free((void *)v162);
  free((void *)v158);
  if ( v154 )
    free(v154);
  if ( Stra )
    free(Stra);
  if ( v156 )
    free(v156);
  return 0;
}

//----- (10001B10) --------------------------------------------------------
int __cdecl sub_10001B10(int a1)
{
  char v2; // [sp+10h] [bp-208h]@1
  char v3; // [sp+198h] [bp-80h]@1
  double v4; // [sp+1C8h] [bp-50h]@1
  double v5; // [sp+1D0h] [bp-48h]@1
  double v6; // [sp+1D8h] [bp-40h]@1
  double v7; // [sp+1E0h] [bp-38h]@1
  double v8; // [sp+1E8h] [bp-30h]@1
  double v9; // [sp+1F0h] [bp-28h]@1
  double v10; // [sp+1F8h] [bp-20h]@1
  double v11; // [sp+200h] [bp-18h]@1
  double v12; // [sp+208h] [bp-10h]@1
  double v13; // [sp+210h] [bp-8h]@1

  sub_10007760(a1, (int)&v2);
  sub_10002860((int)&v2);
  sub_10007980(a1, (int)&v3);
  sub_10005470(&v3, (int)&v4, (int)&v9);
  UF_MOM_set_double(a1, "pos_x", LODWORD(v4), HIDWORD(v4));
  UF_MOM_set_double(a1, "pos_y", LODWORD(v5), HIDWORD(v5));
  UF_MOM_set_double(a1, "pos_z", LODWORD(v6), HIDWORD(v6));
  UF_MOM_set_double(a1, "pos_a1", LODWORD(v7), HIDWORD(v7));
  UF_MOM_set_double(a1, "pos_a2", LODWORD(v8), HIDWORD(v8));
  UF_MOM_set_double(a1, "alt_pos_x", LODWORD(v9), HIDWORD(v9));
  UF_MOM_set_double(a1, "alt_pos_y", LODWORD(v10), HIDWORD(v10));
  UF_MOM_set_double(a1, "alt_pos_z", LODWORD(v11), HIDWORD(v11));
  UF_MOM_set_double(a1, "alt_pos_a1", LODWORD(v12), HIDWORD(v12));
  UF_MOM_set_double(a1, "alt_pos_a2", LODWORD(v13), HIDWORD(v13));
  return 0;
}
// 100090E8: using guessed type int __cdecl UF_MOM_set_double(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10001C10) --------------------------------------------------------
signed int __cdecl sub_10001C10(int a1, int a2, char *a3, int a4)
{
  char *v5; // eax@6
  char *v6; // edx@6
  char v7; // cl@7
  char *v8; // eax@8
  char *v9; // edx@8
  char v10; // cl@9
  int v11; // eax@16
  char v12; // cl@17
  int v13; // eax@19
  char v14; // cl@20
  char v15; // [sp+8h] [bp-488h]@2
  __int16 v16; // [sp+28h] [bp-468h]@4
  int v17; // [sp+208h] [bp-288h]@1
  int v18; // [sp+290h] [bp-200h]@1
  int v19; // [sp+294h] [bp-1FCh]@1
  __int16 v20; // [sp+298h] [bp-1F8h]@1
  char v21[136]; // [sp+318h] [bp-178h]@13
  char v22[52]; // [sp+3A0h] [bp-F0h]@8
  int v23; // [sp+3D4h] [bp-BCh]@1
  int v24; // [sp+3D8h] [bp-B8h]@1
  int v25; // [sp+3DCh] [bp-B4h]@1
  int v26; // [sp+3E0h] [bp-B0h]@1
  int v27; // [sp+3E4h] [bp-ACh]@1
  char v28[32]; // [sp+45Ch] [bp-34h]@6
  int v29; // [sp+47Ch] [bp-14h]@13
  int v30; // [sp+484h] [bp-Ch]@13
  int v31; // [sp+48Ch] [bp-4h]@1

  v23 = dword_10009570;
  v24 = dword_10009574;
  v25 = dword_10009578;
  v26 = dword_1000957C;
  v27 = dword_10009580;
  v31 = 0;
  v17 = 2105376;
  v18 = dword_10009564;
  v19 = dword_10009568;
  v20 = word_1000956C;
  if ( a3 != (char *)2 )
  {
    memcpy(&v15, "Invalid number of arguments", 0x1Cu);
LABEL_5:
    printf(" ERROR : %s \n ", &v15);
    return 1;
  }
  if ( UF_MOM_ask_string(a1, &v18, &a3) )
  {
    memcpy(&v15, "No Tool Name obtained from UGPost", 0x20u);
    v16 = *(_WORD *)"t";
    goto LABEL_5;
  }
  v5 = a3;
  v6 = (char *)(v28 - a3);
  do
  {
    v7 = *v5;
    v5[(_DWORD)v6] = *v5;
    ++v5;
  }
  while ( v7 );
  v8 = *(char **)(a4 + 4);
  v9 = (char *)(v22 - v8);
  do
  {
    v10 = *v8;
    v8[(_DWORD)v9] = *v8;
    ++v8;
  }
  while ( v10 );
  if ( UF_OBJ_cycle_by_name(v28, &v31) )
  {
    printf(" UF_OBJ_cycle_by_name could not get the tool_object_tag \n");
    return 1;
  }
  if ( v31 )
  {
    v30 = (int)v21;
    if ( UF_ATTR_read_value(v31, v22, 5, &v29) )
    {
      printf(" UF_ATTR_read_value could not return tool string \n");
      return 1;
    }
    if ( v29 != 5 )
    {
      v11 = 0;
      do
      {
        v12 = *((_BYTE *)&v17 + v11);
        v21[v11++] = v12;
      }
      while ( v12 );
    }
  }
  else
  {
    v13 = 0;
    do
    {
      v14 = *((_BYTE *)&v17 + v13);
      v21[v13++] = v14;
    }
    while ( v14 );
  }
  UF_MOM_set_string(a1, &v23, v21);
  return 0;
}
// 100090D8: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);
// 100090DC: using guessed type int __cdecl UF_OBJ_cycle_by_name(_DWORD, _DWORD);
// 100090E0: using guessed type int __cdecl UF_ATTR_read_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 100090E4: using guessed type int __cdecl UF_MOM_set_string(_DWORD, _DWORD, _DWORD);
// 10009564: using guessed type int dword_10009564;
// 10009568: using guessed type int dword_10009568;
// 1000956C: using guessed type __int16 word_1000956C;
// 10009570: using guessed type int dword_10009570;
// 10009574: using guessed type int dword_10009574;
// 10009578: using guessed type int dword_10009578;
// 1000957C: using guessed type int dword_1000957C;
// 10009580: using guessed type int dword_10009580;
// 10001C10: using guessed type char var_34[32];
// 10001C10: using guessed type char var_F0[52];
// 10001C10: using guessed type char var_178[136];

//----- (10001E10) --------------------------------------------------------
int __cdecl ufusr(int a1, int a2)
{
  int result; // eax@2
  int v3; // eax@3
  int v4; // eax@3
  int v5; // eax@3
  int v6; // eax@3
  int v7; // esi@3
  int v8; // eax@3
  char Dest; // [sp+4h] [bp-8Ch]@2
  int v10; // [sp+88h] [bp-8h]@1
  int v11; // [sp+8Ch] [bp-4h]@3

  v10 = 0;
  UF_MISC_set_program_name("<!<UGPKIN>!>");
  if ( UF_initialize() )
  {
    sprintf(&Dest, "ERROR!: Advanced Kinematics Module Unavailable");
    printf("ERROR : Ugpost Advanced Kinematics license not found \n");
    uc1601(&Dest, 1);
    result = UF_terminate();
  }
  else
  {
    UF_MISC_set_program_name("Kinematics");
    UF_MOM_ask_interp_from_param(a1, &v10);
    UF_MOM_ask_mom(a1, &v11);
    v3 = UF_MOM_extend_xlator(v11, "MOM_load_kinematics", sub_10001350);
    sub_10001000(
      (int)"UF_MOM_extend_xlator ( mom, \"MOM_load_kinematics\", mom_load_kinematics )",
      (int)"O:\\ugnx40\\ip21\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      113,
      v3);
    v4 = UF_MOM_extend_xlator(v11, "MOM_convert_point", sub_10001B10);
    sub_10001000(
      (int)"UF_MOM_extend_xlator ( mom, \"MOM_convert_point\", mom_convert_point )",
      (int)"O:\\ugnx40\\ip21\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      123,
      v4);
    v5 = UF_MOM_extend_xlator(v11, "MOM_get_tool_attribute", sub_10001C10);
    sub_10001000(
      (int)"UF_MOM_extend_xlator ( mom , \"MOM_get_tool_attribute\", mom_get_tool_attribute )",
      (int)"O:\\ugnx40\\ip21\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      133,
      v5);
    v6 = UF_MOM_extend_xlator(v11, "MOM_rotate_mach_csys", sub_100010C0);
    sub_10001000(
      (int)"UF_MOM_extend_xlator ( mom, \"MOM_rotate_mach_csys\", mom_rotate_mach_csys )",
      (int)"O:\\ugnx40\\ip21\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      143,
      v6);
    v7 = UF_MOM_extend_xlator(v11, "MOM_map_to_rotated_csys", sub_10001270);
    sub_10001000(
      (int)"UF_MOM_extend_xlator ( mom, \"MOM_map_to_rotated_csys\", mom_map_to_rotated_csys )",
      (int)"O:\\ugnx40\\ip21\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      153,
      v7);
    v8 = UF_MOM_extend_xlator(v11, "MOM_exit_kinematics_module", UF_terminate);
    result = sub_10001000(
               (int)"UF_MOM_extend_xlator ( mom, \"MOM_exit_kinematics_module\", mom_exit_kinematics_module )",
               (int)"O:\\ugnx40\\ip21\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
               163,
               v8);
    dword_1000C028 = v11;
    *(_DWORD *)a2 = 0;
  }
  return result;
}
// 100010B0: using guessed type int UF_terminate();
// 100090CC: using guessed type int __cdecl UF_MOM_ask_interp_from_param(_DWORD, _DWORD);
// 100090D0: using guessed type int __cdecl UF_MOM_ask_mom(_DWORD, _DWORD);
// 100090D4: using guessed type int __cdecl UF_MOM_extend_xlator(_DWORD, _DWORD, _DWORD);
// 100090EC: using guessed type int UF_terminate(void);
// 100090F0: using guessed type int __cdecl UF_MISC_set_program_name(_DWORD);
// 100090F4: using guessed type int UF_initialize(void);
// 10009104: using guessed type int __cdecl uc1601(_DWORD, _DWORD);
// 1000C028: using guessed type int dword_1000C028;

//----- (10002030) --------------------------------------------------------
int __usercall sub_10002030<eax>(int result<eax>, int a2<ecx>, long double a3)
{
  long double v3; // st7@1
  long double v4; // st6@1
  double v5; // ST08_8@1
  double v6; // ST00_8@1

  v3 = cos(a3);
  v4 = sin(a3);
  v5 = *(double *)(result + 8) * *(double *)(result + 8);
  v6 = *(double *)(result + 16) * *(double *)(result + 16);
  *(long double *)a2 = (1.0 - *(double *)result * *(double *)result) * v3 + *(double *)result * *(double *)result;
  *(long double *)(a2 + 8) = *(double *)(result + 8) * *(double *)result * (1.0 - v3) + v4 * *(double *)(result + 16);
  *(long double *)(a2 + 16) = *(double *)(result + 16) * *(double *)result * (1.0 - v3) - v4 * *(double *)(result + 8);
  *(double *)(a2 + 24) = 0.0;
  *(long double *)(a2 + 32) = *(double *)(result + 8) * *(double *)result * (1.0 - v3) - v4 * *(double *)(result + 16);
  *(long double *)(a2 + 40) = (1.0 - v5) * v3 + v5;
  *(long double *)(a2 + 48) = *(double *)(result + 16) * *(double *)(result + 8) * (1.0 - v3) + v4 * *(double *)result;
  *(double *)(a2 + 56) = 0.0;
  *(long double *)(a2 + 64) = *(double *)(result + 16) * *(double *)result * (1.0 - v3) + v4 * *(double *)(result + 8);
  *(long double *)(a2 + 72) = *(double *)(result + 16) * *(double *)(result + 8) * (1.0 - v3) - v4 * *(double *)result;
  *(long double *)(a2 + 80) = (1.0 - v6) * v3 + v6;
  *(double *)(a2 + 88) = 0.0;
  *(double *)(a2 + 96) = 0.0;
  *(double *)(a2 + 104) = 0.0;
  *(double *)(a2 + 112) = 0.0;
  *(double *)(a2 + 120) = 1.0;
  return result;
}

//----- (10002150) --------------------------------------------------------
int __usercall sub_10002150<eax>(int a1<eax>, int a2<ecx>, int a3)
{
  int v3; // esi@1
  int v4; // edi@1
  char v6; // [sp+Ch] [bp-120h]@1
  char v7; // [sp+54h] [bp-D8h]@1
  char v8; // [sp+9Ch] [bp-90h]@1
  char v9; // [sp+B4h] [bp-78h]@1
  char v10; // [sp+CCh] [bp-60h]@1
  char v11; // [sp+E4h] [bp-48h]@1
  double v12; // [sp+FCh] [bp-30h]@1
  double v13; // [sp+104h] [bp-28h]@1
  double v14; // [sp+10Ch] [bp-20h]@1
  double v15; // [sp+114h] [bp-18h]@1
  double v16; // [sp+11Ch] [bp-10h]@1
  double v17; // [sp+124h] [bp-8h]@1

  v3 = a1;
  v4 = a2;
  UF_MTX3_copy(a1 + 24, &v7);
  UF_MTX3_copy(v4 + 24, &v6);
  v12 = *(double *)v3;
  v15 = *(double *)v4;
  v13 = *(double *)(v3 + 8);
  v16 = *(double *)(v4 + 8);
  v14 = *(double *)(v3 + 16);
  v17 = *(double *)(v4 + 16);
  UF_MTX3_x_vec(&v7, &v10);
  UF_MTX3_y_vec(&v7, &v8);
  UF_MTX3_x_vec(&v6, &v11);
  UF_MTX3_y_vec(&v6, &v9);
  return UF_MTX4_csys_to_csys(&v12, &v10, &v8, &v15, &v11, &v9, a3);
}
// 100090B4: using guessed type int __cdecl UF_MTX3_copy(_DWORD, _DWORD);
// 100090B8: using guessed type int __cdecl UF_MTX3_x_vec(_DWORD, _DWORD);
// 100090BC: using guessed type int __cdecl UF_MTX3_y_vec(_DWORD, _DWORD);
// 100090C0: using guessed type int __cdecl UF_MTX4_csys_to_csys(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10002220) --------------------------------------------------------
int __usercall sub_10002220<eax>(int a1<eax>, int a2<esi>, double a3, double a4, signed int a5)
{
  int v5; // edx@1
  int v6; // ecx@1
  int v7; // edx@1
  int v8; // ecx@1
  int v9; // edx@1
  int v10; // ecx@1
  int v11; // edx@1
  int result; // eax@1
  int v13; // ecx@1
  int v14; // edx@1
  char v15; // [sp+14h] [bp-258h]@1
  char v16; // [sp+94h] [bp-1D8h]@1
  char v17; // [sp+114h] [bp-158h]@1
  char v18; // [sp+15Ch] [bp-110h]@1
  char v19; // [sp+1DCh] [bp-90h]@1
  double v20; // [sp+1F4h] [bp-78h]@1
  double v21; // [sp+1FCh] [bp-70h]@1
  double v22; // [sp+204h] [bp-68h]@1
  char v23; // [sp+20Ch] [bp-60h]@1
  int v24; // [sp+224h] [bp-48h]@1
  int v25; // [sp+228h] [bp-44h]@1
  int v26; // [sp+22Ch] [bp-40h]@1
  int v27; // [sp+230h] [bp-3Ch]@1
  int v28; // [sp+234h] [bp-38h]@1
  int v29; // [sp+238h] [bp-34h]@1
  double v30; // [sp+244h] [bp-28h]@1
  int v31; // [sp+24Ch] [bp-20h]@1
  int v32; // [sp+250h] [bp-1Ch]@1
  int v33; // [sp+254h] [bp-18h]@1
  int v34; // [sp+258h] [bp-14h]@1
  int v35; // [sp+25Ch] [bp-10h]@1
  int v36; // [sp+260h] [bp-Ch]@1
  double v37; // [sp+264h] [bp-8h]@1

  v5 = *(_DWORD *)(a1 + 4);
  v31 = *(_DWORD *)a1;
  v6 = *(_DWORD *)(a1 + 8);
  v37 = (double)a5;
  v32 = v5;
  v7 = *(_DWORD *)(a1 + 12);
  v33 = v6;
  v8 = *(_DWORD *)(a1 + 16);
  v34 = v7;
  v9 = *(_DWORD *)(a1 + 20);
  v30 = *(double *)(dword_1000C1C0 + 8);
  v35 = v8;
  v20 = 0.0;
  v21 = 0.0;
  v36 = v9;
  v22 = 0.0;
  UF_MTX4_rotation(
    &dword_1000C0B0,
    &dbl_1000C110,
    COERCE_UNSIGNED_INT64(a4 * -57.29577951308235),
    COERCE_UNSIGNED_INT64(a4 * -57.29577951308235) >> 32,
    &v18);
  sub_10005BC0((int)&v18);
  UF_MTX4_ask_rotation(&v18, &v17);
  UF_MTX3_vec_multiply(&dbl_1000C0D8, &v17, &v23);
  UF_VEC3_unitize(&v23, LODWORD(v30), HIDWORD(v30), &a4, &v23);
  UF_MTX4_vec3_multiply(&v20, &v18, &v19);
  UF_MTX4_rotation(
    &v19,
    &v23,
    COERCE_UNSIGNED_INT64(a3 * -57.29577951308235),
    COERCE_UNSIGNED_INT64(a3 * -57.29577951308235) >> 32,
    &v16);
  sub_10005BC0((int)&v16);
  UF_MTX4_multiply(&v18, &v16, &v15);
  sub_10005BC0((int)&v15);
  UF_MTX4_vec_multiply(&v31, &v15, &v24);
  v10 = v25;
  v11 = v26;
  *(_DWORD *)a2 = v24;
  result = v27;
  *(_DWORD *)(a2 + 4) = v10;
  v13 = v28;
  *(_DWORD *)(a2 + 8) = v11;
  v14 = v29;
  *(_DWORD *)(a2 + 12) = result;
  *(_DWORD *)(a2 + 16) = v13;
  *(_DWORD *)(a2 + 20) = v14;
  return result;
}
// 10009054: using guessed type int __cdecl UF_MTX3_vec_multiply(_DWORD, _DWORD, _DWORD);
// 10009058: using guessed type int __cdecl UF_MTX4_ask_rotation(_DWORD, _DWORD);
// 1000905C: using guessed type int __cdecl UF_MTX4_rotation(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10009080: using guessed type int __cdecl UF_MTX4_vec3_multiply(_DWORD, _DWORD, _DWORD);
// 100090AC: using guessed type int __cdecl UF_MTX4_multiply(_DWORD, _DWORD, _DWORD);
// 100090B0: using guessed type int __cdecl UF_MTX4_vec_multiply(_DWORD, _DWORD, _DWORD);
// 100090C8: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1000C0B0: using guessed type int dword_1000C0B0;
// 1000C0D8: using guessed type double dbl_1000C0D8;
// 1000C110: using guessed type double dbl_1000C110;
// 1000C1C0: using guessed type int dword_1000C1C0;

//----- (100023B0) --------------------------------------------------------
int __cdecl sub_100023B0(int a1, double a2, int a3)
{
  char v4; // [sp+Ch] [bp-E0h]@1
  char v5; // [sp+8Ch] [bp-60h]@1
  char v6; // [sp+D4h] [bp-18h]@1

  UF_MTX4_rotation(
    &dword_1000C330,
    &dbl_1000C0D8,
    COERCE_UNSIGNED_INT64(a2 * 57.29577951308235),
    COERCE_UNSIGNED_INT64(a2 * 57.29577951308235) >> 32,
    &v4);
  sub_10005BC0((int)&v4);
  UF_MTX4_ask_rotation(&v4, &v5);
  UF_MTX3_vec_multiply(&dword_1000C0B0, &v5, &v6);
  return UF_VEC3_add(a1, &v6, a3);
}
// 10009054: using guessed type int __cdecl UF_MTX3_vec_multiply(_DWORD, _DWORD, _DWORD);
// 10009058: using guessed type int __cdecl UF_MTX4_ask_rotation(_DWORD, _DWORD);
// 1000905C: using guessed type int __cdecl UF_MTX4_rotation(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10009060: using guessed type int __cdecl UF_VEC3_add(_DWORD, _DWORD, _DWORD);
// 1000C0B0: using guessed type int dword_1000C0B0;
// 1000C0D8: using guessed type double dbl_1000C0D8;
// 1000C330: using guessed type int dword_1000C330;

//----- (100024D0) --------------------------------------------------------
signed int __cdecl PtFuncCompare(int a1, int a2)
{
  signed int result; // eax@2

  if ( fabs(*(double *)a1 - *(double *)a2) > dbl_1000C010 )
  {
    if ( dbl_1000C010 + *(double *)a2 >= *(double *)a1 )
      result = -1;
    else
      result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1000C010: using guessed type double dbl_1000C010;

//----- (10002510) --------------------------------------------------------
void __fastcall sub_10002510(int a1, int a2)
{
  double v2; // st7@5
  __int16 v3; // fps@8
  double v4; // st7@8
  unsigned __int8 v5; // c0@8
  unsigned __int8 v6; // c3@8
  double v7; // st7@11
  double v8; // [sp+0h] [bp-8h]@4

  if ( fabs(*(double *)a2 - *(double *)(a2 + 8)) <= dbl_1000C010
    && fabs(*(double *)a1 - *(double *)(a1 + 8)) <= dbl_1000C010
    && fabs(*(double *)a2 - *(double *)a1) > dbl_1000C010 )
  {
    v8 = -dbl_1000C010;
    if ( *(double *)a2 >= v8 )
    {
      if ( *(double *)a1 >= v8 )
      {
        if ( *(double *)(a1 + 8) > dbl_1000C010 )
          *(double *)(a1 + 8) = *(double *)(a1 + 8) - 6.283185307179586;
      }
      else
      {
        v7 = *(double *)a1 + 6.283185307179586;
        if ( fabs(v7 - *(double *)a2) <= dbl_1000C010 )
        {
          if ( *(double *)(a1 + 8) < v8 )
            *(double *)(a1 + 8) = *(double *)(a1 + 8) + 6.283185307179586;
        }
        else
        {
          *(_QWORD *)a1 = *(_QWORD *)&v7;
          if ( fabs(v7 - *(double *)(a1 + 8)) <= dbl_1000C010 )
            *(double *)(a1 + 8) = 6.283185307179586 - v7;
        }
      }
    }
    else
    {
      v2 = *(double *)a2 + 6.283185307179586;
      *(_QWORD *)a2 = *(_QWORD *)&v2;
      *(double *)(a2 + 8) = 6.283185307179586 - v2;
    }
  }
  if ( fabs(*(double *)a2 - *(double *)a1) <= dbl_1000C010
    && fabs(*(double *)(a2 + 8) - *(double *)(a1 + 8)) <= dbl_1000C010 )
  {
    v4 = *(double *)(a1 + 8);
    UNDEF(v3);
    if ( v5 | v6 )
    {
      if ( v4 <= dbl_1000C010 )
      {
        if ( fabs(*(double *)a2) <= dbl_1000C010 )
        {
          if ( fabs(*(double *)a1) <= dbl_1000C010 )
            *(double *)(a1 + 8) = 6.283185307179586;
        }
      }
      else
      {
        *(double *)(a1 + 8) = 6.283185307179586 - *(double *)(a1 + 8);
      }
    }
    else
    {
      *(double *)(a1 + 8) = v4 + 6.283185307179586;
    }
  }
}
// 1000C010: using guessed type double dbl_1000C010;

//----- (100026F0) --------------------------------------------------------
void __usercall sub_100026F0(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  double v3; // st7@1
  double v4; // st7@7
  char v5; // [sp+0h] [bp-28h]@14

  v3 = *(double *)(a1 + 24);
  if ( v3 <= 0.0 )
  {
    if ( v3 < 0.0 )
      v3 = v3 + 360.0;
  }
  else
  {
    v3 = v3 - 360.0;
  }
  if ( fabs(*(double *)(a2 + 24) - v3) < fabs(*(double *)(a2 + 24) - *(double *)(a1 + 24)) )
    *(_QWORD *)(a1 + 24) = *(_QWORD *)&v3;
  v4 = *(double *)(a1 + 32);
  if ( v4 <= 0.0 )
  {
    if ( v4 < 0.0 )
      v4 = v4 + 360.0;
  }
  else
  {
    v4 = v4 - 360.0;
  }
  if ( fabs(*(double *)(a2 + 32) - v4) < fabs(*(double *)(a2 + 32) - *(double *)(a1 + 32)) )
    *(_QWORD *)(a1 + 32) = *(_QWORD *)&v4;
  if ( fabs(*(double *)(a2 + 24) - *(double *)(a3 + 24)) < fabs(*(double *)(a2 + 24) - *(double *)(a1 + 24)) )
  {
    memcpy(&v5, (const void *)a1, 0x28u);
    memcpy((void *)a1, (const void *)a3, 0x28u);
    memcpy((void *)a3, &v5, 0x28u);
  }
  if ( *(double *)(dword_1000C1C0 + 104) - dbl_1000C010 >= *(double *)(a1 + 24)
    || dbl_1000C010 + *(double *)(dword_1000C1C0 + 112) <= *(double *)(a1 + 24) )
  {
    if ( *(double *)(dword_1000C1C0 + 120) - dbl_1000C010 < *(double *)(a3 + 24) )
    {
      if ( dbl_1000C010 + *(double *)(dword_1000C1C0 + 128) > *(double *)(a3 + 24) )
      {
        memcpy(&v5, (const void *)a1, 0x28u);
        memcpy((void *)a1, (const void *)a3, 0x28u);
        memcpy((void *)a3, &v5, 0x28u);
      }
    }
  }
}
// 1000C010: using guessed type double dbl_1000C010;
// 1000C1C0: using guessed type int dword_1000C1C0;

//----- (10002860) --------------------------------------------------------
int __cdecl sub_10002860(int a1)
{
  int v1; // ecx@1
  int v2; // esi@1

  v1 = dword_1000C1C0;
  v2 = dword_1000C1C0 + 16;
  *(_DWORD *)(dword_1000C1C0 + 16) = *(_DWORD *)(a1 + 192);
  *(_DWORD *)(v2 + 4) = *(_DWORD *)(a1 + 196);
  *(_DWORD *)(v2 + 8) = *(_DWORD *)(a1 + 200);
  *(_DWORD *)(v2 + 12) = *(_DWORD *)(a1 + 204);
  *(_DWORD *)(v2 + 16) = *(_DWORD *)(a1 + 208);
  *(_DWORD *)(v2 + 20) = *(_DWORD *)(a1 + 212);
  *(_DWORD *)(v1 + 40) = *(_DWORD *)(a1 + 216);
  *(_DWORD *)(v1 + 44) = *(_DWORD *)(a1 + 220);
  *(_DWORD *)(v1 + 48) = *(_DWORD *)(a1 + 224);
  *(_DWORD *)(v1 + 52) = *(_DWORD *)(a1 + 228);
  *(_DWORD *)(v1 + 56) = *(_DWORD *)(a1 + 232);
  *(_DWORD *)(v1 + 60) = *(_DWORD *)(a1 + 236);
  *(double *)(v1 + 136) = *(double *)(a1 + 376);
  return 0;
}
// 1000C1C0: using guessed type int dword_1000C1C0;

//----- (100028E0) --------------------------------------------------------
int __cdecl sub_100028E0(int a1, int a2, int a3, int a4)
{
  double v4; // st7@2
  int result; // eax@2
  char v6; // [sp+8h] [bp-40h]@1
  double v7; // [sp+20h] [bp-28h]@1
  double v8; // [sp+28h] [bp-20h]@1
  double v9; // [sp+30h] [bp-18h]@1
  double v10; // [sp+38h] [bp-10h]@1
  double v11; // [sp+40h] [bp-8h]@2

  UF_VEC3_sub(a2 + 24, a2, &v7);
  UF_VEC3_sub(a1, a2, &v6);
  v10 = v9 * v9 + v8 * v8 + v7 * v7;
  if ( v10 <= 0.0 )
  {
    *(double *)a4 = 0.0;
    UF_VEC3_copy(a2, a3);
    result = 0;
  }
  else
  {
    UF_VEC3_dot(&v7, &v6, &v11);
    v4 = v11 / v10;
    *(double *)a4 = v11 / v10;
    *(double *)a3 = v4 * v7 + *(double *)a2;
    *(double *)(a3 + 8) = v8 * *(double *)a4 + *(double *)(a2 + 8);
    result = 0;
    *(double *)(a3 + 16) = v9 * *(double *)a4 + *(double *)(a2 + 16);
  }
  return result;
}
// 1000906C: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);
// 10009070: using guessed type int __cdecl UF_VEC3_dot(_DWORD, _DWORD, _DWORD);
// 10009074: using guessed type int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD);

//----- (100029A0) --------------------------------------------------------
signed int __usercall sub_100029A0<eax>(int a1<esi>, signed int a2, int a3, int a4)
{
  signed int v4; // edi@1
  int v5; // eax@1
  double v6; // st7@2
  int v7; // ebx@2
  int v8; // edx@3
  unsigned int v9; // ecx@3
  long double *v10; // edx@14
  int v11; // ecx@14
  bool v12; // sf@19
  unsigned __int8 v13; // of@19
  signed int v14; // ecx@20
  int v15; // edx@21
  signed int v16; // ebx@22
  int v17; // eax@23
  double v18; // st7@23
  int v19; // edi@23
  int v20; // eax@24
  int v21; // edx@24
  int v22; // ebx@25
  double v23; // st6@25
  bool v24; // zf@25
  double v25; // st6@29
  int v26; // eax@30
  int v27; // eax@32
  int v28; // ebx@32
  int v29; // eax@33
  long double v30; // st7@33
  int v31; // edi@33
  int v32; // eax@34
  int v33; // edx@34
  int v34; // ebx@35
  double v35; // st6@35
  int v36; // eax@38
  int v37; // ebx@39
  double v38; // st6@39
  long double v39; // st7@41
  signed int result; // eax@43
  int v41; // ebx@46
  int v42; // eax@47
  int v43; // edi@48
  double v44; // st7@48
  int v45; // edi@48
  double v46; // st7@48
  int v47; // edi@48
  double v48; // st7@48
  int v49; // edi@48
  double v50; // st7@48
  int v51; // edi@51
  double v52; // st7@51
  double v53; // st7@56
  int v54; // ebx@56
  unsigned int v55; // edi@57
  int v56; // eax@57
  int v57; // ebx@58
  int v58; // eax@61
  double v59; // [sp+8h] [bp-30h]@32
  char v60; // [sp+10h] [bp-28h]@1
  long double v61; // [sp+14h] [bp-24h]@4
  int v62; // [sp+1Ch] [bp-1Ch]@42
  int v63; // [sp+20h] [bp-18h]@24
  int v64; // [sp+24h] [bp-14h]@21
  int v65; // [sp+28h] [bp-10h]@21
  int v66; // [sp+2Ch] [bp-Ch]@1
  int v67; // [sp+30h] [bp-8h]@20
  unsigned int v68; // [sp+34h] [bp-4h]@1

  v4 = a2;
  v5 = UF_allocate_memory(8 * a2, &v60);
  *(double *)a4 = 1.0;
  v66 = v5;
  v68 = 0;
  if ( a2 <= 0 )
  {
LABEL_20:
    v14 = 0;
    v67 = 0;
    if ( a2 > 0 )
    {
      v65 = a2 - 1;
      v15 = a1;
      v64 = a1;
      HIDWORD(v61) = a3 - a1;
      do
      {
        v16 = 0;
        v68 = 0;
        if ( v14 > 0 )
        {
          do
          {
            v17 = *(_DWORD *)(a1 + 4 * v16);
            v18 = *(double *)(v14 + v17);
            v19 = 0;
            if ( v16 >= 4 )
            {
              v63 = ((unsigned int)(v16 - 4) >> 2) + 1;
              v20 = v17 + 16;
              v21 = a1 + 8;
              v19 = 4 * v63;
              do
              {
                v22 = *(_DWORD *)(v21 - 4);
                v23 = *(double *)(*(_DWORD *)(v21 - 8) + v14) * *(double *)(v20 - 16);
                v20 += 32;
                v21 += 16;
                v24 = v63-- == 1;
                v18 = v18
                    - v23
                    - *(double *)(v22 + v14) * *(double *)(v20 - 40)
                    - *(double *)(*(_DWORD *)(v21 - 16) + v14) * *(double *)(v20 - 32)
                    - *(double *)(*(_DWORD *)(v21 - 12) + v14) * *(double *)(v20 - 24);
              }
              while ( !v24 );
              v15 = v64;
              v16 = v68;
            }
            if ( v19 < v16 )
            {
              v63 = *(_DWORD *)(a1 + 4 * v16) + 8 * v19;
              do
              {
                v25 = *(double *)(*(_DWORD *)(a1 + 4 * v19++) + v14) * *(double *)v63;
                v18 = v18 - v25;
                v63 += 8;
              }
              while ( v19 < v16 );
            }
            v26 = *(_DWORD *)(a1 + 4 * v16++);
            *(_QWORD *)(v14 + v26) = *(_QWORD *)&v18;
            v68 = v16;
          }
          while ( v16 < v67 );
          v4 = a2;
        }
        v27 = v67;
        v59 = 0.0;
        v28 = v67;
        v68 = v67;
        if ( v67 < v4 )
        {
          do
          {
            v29 = *(_DWORD *)(a1 + 4 * v28);
            v30 = *(double *)(v14 + v29);
            v31 = 0;
            if ( v14 >= 32 )
            {
              v63 = ((unsigned int)(v67 - 4) >> 2) + 1;
              v32 = v29 + 16;
              v33 = a1 + 8;
              v31 = 4 * v63;
              do
              {
                v34 = *(_DWORD *)(v33 - 4);
                v35 = *(double *)(*(_DWORD *)(v33 - 8) + v14) * *(double *)(v32 - 16);
                v32 += 32;
                v33 += 16;
                v24 = v63-- == 1;
                v30 = v30
                    - v35
                    - *(double *)(v34 + v14) * *(double *)(v32 - 40)
                    - *(double *)(*(_DWORD *)(v33 - 16) + v14) * *(double *)(v32 - 32)
                    - *(double *)(*(_DWORD *)(v33 - 12) + v14) * *(double *)(v32 - 24);
              }
              while ( !v24 );
              v15 = v64;
              v28 = v68;
            }
            if ( v31 < v67 )
            {
              v36 = *(_DWORD *)(a1 + 4 * v28) + 8 * v31;
              do
              {
                v37 = *(_DWORD *)(a1 + 4 * v31++);
                v38 = *(double *)(v37 + v14) * *(double *)v36;
                v36 += 8;
                v30 = v30 - v38;
              }
              while ( v31 < v67 );
              v28 = v68;
            }
            *(_QWORD *)(v14 + *(_DWORD *)(a1 + 4 * v28)) = *(_QWORD *)&v30;
            v39 = fabs(v30) * *(double *)(v66 + 8 * v28);
            if ( v39 >= v59 )
            {
              v59 = v39;
              v62 = v28;
            }
            ++v28;
            v68 = v28;
          }
          while ( v28 < a2 );
          v4 = a2;
          v27 = v67;
        }
        v41 = v62;
        if ( v27 != v62 )
        {
          v42 = 0;
          if ( v4 >= 4 )
          {
            do
            {
              v43 = *(_DWORD *)(a1 + 4 * v41);
              v44 = *(double *)(v43 + 8 * v42);
              v63 = v43 + 8 * v42;
              *(double *)(v43 + 8 * v42) = *(double *)(*(_DWORD *)v15 + 8 * v42);
              *(_QWORD *)(*(_DWORD *)v15 + 8 * v42) = *(_QWORD *)&v44;
              v45 = *(_DWORD *)(a1 + 4 * v41);
              v46 = *(double *)(v45 + 8 * v42 + 8);
              v63 = v45 + 8 * v42 + 8;
              *(double *)(v45 + 8 * v42 + 8) = *(double *)(*(_DWORD *)v15 + 8 * v42 + 8);
              *(_QWORD *)(*(_DWORD *)v15 + 8 * v42 + 8) = *(_QWORD *)&v46;
              v47 = *(_DWORD *)(a1 + 4 * v41);
              v48 = *(double *)(v47 + 8 * v42 + 16);
              v63 = v47 + 8 * v42 + 16;
              *(double *)(v47 + 8 * v42 + 16) = *(double *)(*(_DWORD *)v15 + 8 * v42 + 16);
              *(_QWORD *)(*(_DWORD *)v15 + 8 * v42 + 16) = *(_QWORD *)&v48;
              v49 = *(_DWORD *)(a1 + 4 * v41);
              v50 = *(double *)(v49 + 8 * v42 + 24);
              v63 = v49 + 8 * v42 + 24;
              *(double *)(v49 + 8 * v42 + 24) = *(double *)(*(_DWORD *)v15 + 8 * v42 + 24);
              v42 += 4;
              *(_QWORD *)(*(_DWORD *)v15 + 8 * v42 - 8) = *(_QWORD *)&v50;
            }
            while ( v42 < a2 - 3 );
            v4 = a2;
          }
          if ( v42 < v4 )
          {
            do
            {
              v51 = *(_DWORD *)(a1 + 4 * v41);
              v52 = *(double *)(v51 + 8 * v42);
              v63 = v51 + 8 * v42;
              *(double *)(v51 + 8 * v42) = *(double *)(*(_DWORD *)v15 + 8 * v42);
              ++v42;
              *(_QWORD *)(*(_DWORD *)v15 + 8 * v42 - 8) = *(_QWORD *)&v52;
              v4 = a2;
            }
            while ( v42 < a2 );
          }
          *(double *)a4 = -*(double *)a4;
          *(double *)(v66 + 8 * v41) = *(double *)(v14 + v66);
        }
        *(_DWORD *)(HIDWORD(v61) + v15) = v41;
        if ( *(double *)(*(_DWORD *)v15 + v14) == 0.0 )
          *(double *)(*(_DWORD *)v15 + v14) = 9.999999999999999e-21;
        if ( v67 != v4 - 1 )
        {
          v53 = 1.0 / *(double *)(*(_DWORD *)v15 + v14);
          v54 = v67 + 1;
          if ( v65 >= 4 )
          {
            v55 = ((unsigned int)(v4 - v54 - 4) >> 2) + 1;
            v56 = v15 + 12;
            v68 = v54 + 4 * v55;
            do
            {
              v57 = *(_DWORD *)(v56 - 8);
              v56 += 16;
              *(double *)(v14 + v57) = v53 * *(double *)(v57 + v14);
              *(double *)(v14 + *(_DWORD *)(v56 - 20)) = v53 * *(double *)(v14 + *(_DWORD *)(v56 - 20));
              *(double *)(v14 + *(_DWORD *)(v56 - 16)) = v53 * *(double *)(v14 + *(_DWORD *)(v56 - 16));
              --v55;
              *(double *)(v14 + *(_DWORD *)(v56 - 12)) = v53 * *(double *)(v14 + *(_DWORD *)(v56 - 12));
            }
            while ( v55 );
            v4 = a2;
            v54 = v68;
          }
          for ( ; v54 < v4; *(double *)(v14 + v58) = v53 * *(double *)(v58 + v14) )
            v58 = *(_DWORD *)(a1 + 4 * v54++);
        }
        --v65;
        v15 += 4;
        v14 += 8;
        v13 = __OFSUB__(v67 + 1, v4);
        v12 = v67++ + 1 - v4 < 0;
        v64 = v15;
      }
      while ( v12 ^ v13 );
    }
    UF_free(v66);
    result = 0;
  }
  else
  {
    while ( 1 )
    {
      v6 = 0.0;
      v7 = 0;
      if ( a2 >= 4 )
      {
        v8 = *(_DWORD *)(a1 + 4 * v68) + 16;
        v9 = ((unsigned int)(a2 - 4) >> 2) + 1;
        v7 = 4 * v9;
        do
        {
          v61 = fabs(*(double *)(v8 - 16));
          if ( v61 > v6 )
            v6 = v61;
          v61 = fabs(*(double *)(v8 - 8));
          if ( v61 > v6 )
            v6 = v61;
          v61 = fabs(*(double *)v8);
          if ( v61 > v6 )
            v6 = v61;
          v61 = fabs(*(double *)(v8 + 8));
          if ( v61 > v6 )
            v6 = v61;
          v8 += 32;
          --v9;
        }
        while ( v9 );
      }
      if ( v7 < a2 )
      {
        v10 = (long double *)(*(_DWORD *)(a1 + 4 * v68) + 8 * v7);
        v11 = a2 - v7;
        do
        {
          v61 = fabs(*v10);
          if ( v61 > v6 )
            v6 = v61;
          ++v10;
          --v11;
        }
        while ( v11 );
      }
      if ( v6 == 0.0 )
        break;
      v13 = __OFSUB__(v68 + 1, a2);
      v12 = ((v68++ + 1 - a2) & 0x80000000u) != 0;
      *(double *)(v66 + 8 * v68 - 8) = 1.0 / v6;
      if ( !(v12 ^ v13) )
        goto LABEL_20;
    }
    UF_free(v66);
    result = 1;
  }
  return result;
}
// 10009078: using guessed type int __cdecl UF_free(_DWORD);
// 1000907C: using guessed type int __cdecl UF_allocate_memory(_DWORD, _DWORD);

//----- (10002E60) --------------------------------------------------------
int __fastcall sub_10002E60(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax@1
  int v6; // ecx@1
  int v7; // edi@1
  int v8; // ebx@2
  int v9; // eax@2
  int v10; // eax@4
  double v11; // st7@4
  int v12; // eax@5
  int v13; // esi@6
  int v14; // ecx@6
  unsigned int v15; // eax@6
  double v16; // st6@7
  double v17; // st6@7
  int v18; // esi@10
  int v19; // ecx@10
  int v20; // eax@10
  double v21; // st6@11
  int v22; // edi@16
  int v23; // ebx@17
  int v24; // ecx@17
  int v25; // esi@17
  double v26; // st7@19
  int v27; // eax@20
  int v28; // ecx@20
  int v29; // esi@20
  unsigned int v30; // eax@20
  int v31; // ecx@20
  double v32; // st6@21
  double v33; // st6@21
  int v34; // eax@24
  int v35; // ecx@24
  double v36; // st6@25
  double v37; // st7@27
  int v38; // [sp+10h] [bp-14h]@0
  int v39; // [sp+10h] [bp-14h]@17
  signed int v40; // [sp+14h] [bp-10h]@1
  int v41; // [sp+14h] [bp-10h]@17
  int v42; // [sp+18h] [bp-Ch]@2
  int v43; // [sp+18h] [bp-Ch]@17
  int v44; // [sp+1Ch] [bp-8h]@6
  int v45; // [sp+1Ch] [bp-8h]@20
  int v46; // [sp+20h] [bp-4h]@5
  int v47; // [sp+20h] [bp-4h]@19

  result = a4;
  v6 = a3;
  v7 = 0;
  v40 = 0;
  if ( a4 > 0 )
  {
    v8 = v38;
    v9 = a5 - a3;
    v42 = a3;
    while ( 1 )
    {
      v10 = *(_DWORD *)(v6 + v9);
      v11 = *(double *)(a2 + 8 * v10);
      *(double *)(a2 + 8 * v10) = *(double *)(a2 + 8 * v7);
      if ( v40 )
      {
        v12 = v8;
        v46 = v8;
        if ( v7 - v8 >= 4 )
        {
          v13 = *(_DWORD *)v6 + 8 * v8 + 24;
          v44 = *(_DWORD *)v6 - a2;
          v14 = a2 + 8 * v8 + 8;
          v15 = ((unsigned int)(v7 - v8 - 4) >> 2) + 1;
          v46 = v8 + 4 * v15;
          do
          {
            v16 = *(double *)(v14 - 8);
            v14 += 32;
            v17 = v16 * *(double *)(v13 - 24);
            v13 += 32;
            --v15;
            v11 = v11
                - v17
                - *(double *)(v44 + v14 - 32) * *(double *)(v14 - 32)
                - *(double *)(v14 - 24) * *(double *)(v13 - 40)
                - *(double *)(v14 - 16) * *(double *)(v13 - 32);
          }
          while ( v15 );
          v6 = v42;
          v8 = v38;
          v12 = v46;
        }
        if ( v12 < v7 )
        {
          v18 = *(_DWORD *)v6 - a2;
          v19 = v7 - v46;
          v20 = a2 + 8 * v12;
          do
          {
            v21 = *(double *)(v20 + v18);
            v20 += 8;
            --v19;
            v11 = v11 - v21 * *(double *)(v20 - 8);
          }
          while ( v19 );
          v6 = v42;
        }
      }
      else
      {
        if ( v11 != 0.0 )
        {
          v8 = v7;
          v40 = 1;
          v38 = v7;
        }
      }
      result = a4;
      *(_QWORD *)(a2 + 8 * v7++) = *(_QWORD *)&v11;
      v6 += 4;
      v42 = v6;
      if ( v7 >= a4 )
        break;
      v9 = a5 - a3;
    }
  }
  v22 = result - 1;
  if ( result - 1 >= 0 )
  {
    result = result - v22 - 1;
    v23 = v22 + 1;
    v24 = a2 + 8 * v22;
    v25 = 32 - a2;
    v39 = v22 + 1;
    v41 = a2 + 8 * v22;
    v43 = result;
    while ( 1 )
    {
      v26 = *(double *)v24;
      v47 = v23;
      if ( result >= 4 )
      {
        v27 = *(_DWORD *)(a3 + 4 * v22);
        v28 = v25 + v24;
        v29 = v28 + v27;
        v45 = v27 - a2;
        v30 = ((unsigned int)(a4 - v23 - 4) >> 2) + 1;
        v47 = v23 + 4 * v30;
        v31 = v28 + a2 - 16;
        do
        {
          v32 = *(double *)(v31 - 8);
          v31 += 32;
          v33 = v32 * *(double *)(v29 - 24);
          v29 += 32;
          --v30;
          v26 = v26
              - v33
              - *(double *)(v45 + v31 - 32) * *(double *)(v31 - 32)
              - *(double *)(v31 - 24) * *(double *)(v29 - 40)
              - *(double *)(v31 - 16) * *(double *)(v29 - 32);
        }
        while ( v30 );
        v23 = v39;
        v24 = v41;
        result = v43;
      }
      if ( v47 < a4 )
      {
        v34 = a2 + 8 * v47;
        v35 = a4 - v47;
        do
        {
          v36 = *(double *)(*(_DWORD *)(a3 + 4 * v22) - a2 + v34);
          v34 += 8;
          --v35;
          v26 = v26 - v36 * *(double *)(v34 - 8);
        }
        while ( v35 );
        v24 = v41;
        result = v43;
      }
      v37 = v26 / *(double *)(*(_DWORD *)(a3 + 4 * v22) + 8 * v22);
      --v22;
      ++result;
      --v23;
      v24 -= 8;
      v43 = result;
      v39 = v23;
      v41 = v24;
      *(_QWORD *)(v24 + 8) = *(_QWORD *)&v37;
      if ( v22 < 0 )
        break;
      v25 = 32 - a2;
    }
  }
  return result;
}

//----- (10003080) --------------------------------------------------------
signed int __usercall sub_10003080<eax>(int a1<eax>, int a2)
{
  double v2; // st7@1
  double v3; // st7@1
  signed int result; // eax@1
  signed int v5; // edi@2
  int v6; // esi@2
  char v7; // [sp+0h] [bp-C8h]@1
  char v8; // [sp+10h] [bp-B8h]@1
  double v9; // [sp+18h] [bp-B0h]@1
  double v10; // [sp+20h] [bp-A8h]@1
  double v11; // [sp+28h] [bp-A0h]@1
  double v12; // [sp+30h] [bp-98h]@1
  double v13; // [sp+38h] [bp-90h]@1
  double v14; // [sp+40h] [bp-88h]@1
  double v15; // [sp+48h] [bp-80h]@1
  double v16; // [sp+50h] [bp-78h]@1
  double v17; // [sp+58h] [bp-70h]@1
  double v18; // [sp+60h] [bp-68h]@1
  double v19; // [sp+68h] [bp-60h]@1
  double v20; // [sp+70h] [bp-58h]@1
  double v21; // [sp+78h] [bp-50h]@1
  double v22; // [sp+80h] [bp-48h]@1
  double v23; // [sp+88h] [bp-40h]@1
  double v24; // [sp+90h] [bp-38h]@1
  double *v25; // [sp+98h] [bp-30h]@1
  double *v26; // [sp+9Ch] [bp-2Ch]@1
  double *v27; // [sp+A0h] [bp-28h]@1
  double *v28; // [sp+A4h] [bp-24h]@1
  double v29; // [sp+A8h] [bp-20h]@3
  double v30; // [sp+B0h] [bp-18h]@3
  double v31; // [sp+B8h] [bp-10h]@3
  double v32; // [sp+C0h] [bp-8h]@3

  v21 = *(double *)a1;
  v2 = *(double *)(a1 + 32);
  v26 = &v17;
  v17 = v2;
  v9 = *(double *)(a1 + 64);
  v27 = &v9;
  v13 = *(double *)(a1 + 96);
  v22 = *(double *)(a1 + 8);
  v18 = *(double *)(a1 + 40);
  v10 = *(double *)(a1 + 72);
  v14 = *(double *)(a1 + 104);
  v23 = *(double *)(a1 + 16);
  v19 = *(double *)(a1 + 48);
  v11 = *(double *)(a1 + 80);
  v15 = *(double *)(a1 + 112);
  v24 = *(double *)(a1 + 24);
  v20 = *(double *)(a1 + 56);
  v12 = *(double *)(a1 + 88);
  v3 = *(double *)(a1 + 120);
  v25 = &v21;
  v16 = v3;
  v28 = &v13;
  result = sub_100029A0((int)&v25, 4, (int)&v7, (int)&v8);
  if ( !result )
  {
    v5 = 0;
    v6 = a2 + 64;
    do
    {
      v29 = 0.0;
      v30 = 0.0;
      v31 = 0.0;
      v32 = 0.0;
      *(&v29 + v5) = 1.0;
      result = sub_10002E60((int)&v7, (int)&v29, (int)&v25, 4, (int)&v7);
      *(_QWORD *)(v6 - 64) = *(_QWORD *)&v29;
      ++v5;
      *(_QWORD *)(v6 - 32) = *(_QWORD *)&v30;
      v6 += 8;
      *(_QWORD *)(v6 - 8) = *(_QWORD *)&v31;
      *(_QWORD *)(v6 + 24) = *(_QWORD *)&v32;
    }
    while ( v5 < 4 );
  }
  return result;
}

//----- (100031B0) --------------------------------------------------------
int __usercall sub_100031B0<eax>(int a1<ecx>, unsigned int a2<ebx>, unsigned int a3<esi>, int a4, int a5)
{
  double v5; // st7@1
  double v6; // st6@1
  int v7; // ebx@3
  signed int v8; // edi@3
  int v9; // ST0C_4@4
  int v10; // ebx@7
  signed int v11; // edi@7
  int v12; // ST0C_4@8
  int result; // eax@11
  unsigned __int64 v14; // [sp+18h] [bp-E8h]@3
  double Base; // [sp+20h] [bp-E0h]@7
  double v16; // [sp+50h] [bp-B0h]@1
  double v17; // [sp+58h] [bp-A8h]@1
  double v18; // [sp+60h] [bp-A0h]@1
  double v19; // [sp+68h] [bp-98h]@1
  double v20; // [sp+70h] [bp-90h]@1
  double v21; // [sp+78h] [bp-88h]@1
  double v22; // [sp+80h] [bp-80h]@1
  double v23; // [sp+88h] [bp-78h]@1
  double v24; // [sp+90h] [bp-70h]@1
  double v25; // [sp+98h] [bp-68h]@1
  double v26; // [sp+A0h] [bp-60h]@1
  double v27; // [sp+A8h] [bp-58h]@1
  double v28; // [sp+B0h] [bp-50h]@1
  double v29; // [sp+B8h] [bp-48h]@1
  double v30; // [sp+C0h] [bp-40h]@1
  char v31; // [sp+C8h] [bp-38h]@4
  char v32; // [sp+D0h] [bp-30h]@4
  double v33; // [sp+E8h] [bp-18h]@1
  double v34; // [sp+F0h] [bp-10h]@1
  double v35; // [sp+F8h] [bp-8h]@1

  v28 = 0.0;
  v29 = 0.0;
  v30 = 1.0;
  v5 = *(double *)a5;
  v6 = *(double *)(a5 + 8);
  v33 = *(double *)a1;
  v34 = *(double *)(a1 + 8);
  v22 = v5;
  v23 = v5 * -1.0;
  v24 = v5 + 3.141592653589793;
  v25 = 3.141592653589793 - v5;
  v26 = 3.141592653589793 - v5 * -1.0;
  v27 = v5 * -1.0 + 3.141592653589793;
  v16 = v6;
  v35 = -1.0 * v6;
  v17 = -1.0 * v6;
  v18 = v6 + 3.141592653589793;
  v19 = 3.141592653589793 - v6;
  v20 = 3.141592653589793 - v35;
  v21 = v35 + 3.141592653589793;
  if ( fabs(v33 - v34) <= dbl_1000C010 )
    *(double *)(a1 + 8) = v34 * -1.0;
  v14 = __PAIR__(a2, a3);
  v7 = 0;
  v8 = 0;
  do
  {
    sub_10002220(a4, (int)&v32, *(&v22 + v8), v33, 0);
    UF_VEC3_unitize(&v32, LODWORD(dbl_1000C010), HIDWORD(dbl_1000C010), &v31, &v32);
    UF_VEC3_is_equal(&v28, &v32, LODWORD(dbl_1000C010), v9, (char *)&v35 + 4);
    if ( HIDWORD(v35) )
    {
      ++v7;
      *((double *)&v14 + v7) = *(&v22 + v8);
    }
    ++v8;
  }
  while ( v8 < 6 );
  qsort(&Base, v7 - 1, 8u, (int (__cdecl *)(const void *, const void *))PtFuncCompare);
  *(_QWORD *)a5 = *(_QWORD *)&Base;
  v10 = 0;
  v11 = 0;
  do
  {
    sub_10002220(a4, (int)&v32, *(&v16 + v11), v34, 0);
    UF_VEC3_unitize(&v32, LODWORD(dbl_1000C010), HIDWORD(dbl_1000C010), &v31, &v32);
    UF_VEC3_is_equal(&v28, &v32, LODWORD(dbl_1000C010), v12, (char *)&v35 + 4);
    if ( HIDWORD(v35) )
    {
      ++v10;
      *((double *)&v14 + v10) = *(&v16 + v11);
    }
    ++v11;
  }
  while ( v11 < 6 );
  qsort(&Base, v10 - 1, 8u, (int (__cdecl *)(const void *, const void *))PtFuncCompare);
  result = a5;
  *(_QWORD *)(a5 + 8) = *(_QWORD *)&Base;
  return result;
}
// 100031B0: could not find valid save-restore pair for ebx
// 100031B0: could not find valid save-restore pair for esi
// 100090C8: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090F8: using guessed type int __cdecl UF_VEC3_is_equal(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1000C010: using guessed type double dbl_1000C010;

//----- (10003400) --------------------------------------------------------
signed int __cdecl sub_10003400(const void *a1, int a2, unsigned int a3)
{
  bool v3; // zf@1
  unsigned int v4; // ebx@1
  int (*v5)(const char *, ...); // esi@1
  int v6; // edi@1
  signed int result; // eax@7
  int v8; // ecx@8
  long double v9; // st7@10
  long double v10; // st7@11
  long double v11; // st7@20
  long double v12; // st7@21
  signed int v13; // ecx@22
  long double v14; // st7@23
  long double v15; // st6@23
  long double v16; // st7@23
  long double v17; // st7@23
  long double v18; // st7@25
  long double v19; // st7@30
  long double v20; // st6@30
  long double v21; // st5@31
  double v22; // st5@33
  long double v23; // st7@40
  long double v24; // st6@43
  long double v25; // st5@47
  long double v26; // st5@50
  signed int v27; // ecx@53
  long double v28; // st7@53
  long double v29; // st6@54
  long double v30; // st5@54
  long double v31; // st6@55
  long double v32; // st6@59
  int v33; // eax@70
  int v34; // eax@71
  int v35; // ecx@71
  int v36; // edx@71
  int v37; // edx@71
  int v38; // eax@71
  int v39; // ecx@71
  int v40; // eax@71
  int v41; // ecx@78
  int v42; // ecx@78
  signed int v43; // esi@79
  unsigned int v44; // eax@80
  int v45; // ecx@83
  int v46; // eax@83
  int v47; // ecx@86
  void (__cdecl *v48)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // esi@86
  unsigned __int64 v49; // st7@86
  double v50; // st7@93
  __int16 v51; // fps@93
  unsigned __int8 v52; // c0@93
  unsigned __int8 v53; // c2@93
  double v54; // st7@95
  __int16 v55; // fps@95
  unsigned __int8 v56; // c0@95
  unsigned __int8 v57; // c2@95
  char *v58[5]; // [sp+28h] [bp-1DCh]@86
  unsigned int v59; // [sp+2Ch] [bp-1D8h]@86
  char v60; // [sp+3Ch] [bp-1C8h]@86
  char v61; // [sp+BCh] [bp-148h]@78
  long double v62; // [sp+13Ch] [bp-C8h]@8
  int v63; // [sp+144h] [bp-C0h]@4
  int v64; // [sp+148h] [bp-BCh]@71
  int v65; // [sp+14Ch] [bp-B8h]@71
  int v66; // [sp+150h] [bp-B4h]@71
  int v67; // [sp+154h] [bp-B0h]@71
  int v68; // [sp+158h] [bp-ACh]@71
  char v69; // [sp+15Ch] [bp-A8h]@4
  char v70; // [sp+174h] [bp-90h]@8
  char v71; // [sp+17Ch] [bp-88h]@88
  double v72; // [sp+184h] [bp-80h]@77
  double v73; // [sp+18Ch] [bp-78h]@8
  long double v74; // [sp+194h] [bp-70h]@38
  char v75; // [sp+19Ch] [bp-68h]@86
  double v76; // [sp+1A4h] [bp-60h]@77
  double v77; // [sp+1ACh] [bp-58h]@8
  int v78; // [sp+1B4h] [bp-50h]@1
  long double v79; // [sp+1B8h] [bp-4Ch]@23
  long double v80; // [sp+1C0h] [bp-44h]@8
  double v81; // [sp+1C8h] [bp-3Ch]@8
  long double v82; // [sp+1D0h] [bp-34h]@8
  double v83; // [sp+1D8h] [bp-2Ch]@14
  double v84; // [sp+1E0h] [bp-24h]@14
  long double v85; // [sp+1E8h] [bp-1Ch]@10
  double v86; // [sp+1F0h] [bp-14h]@10
  double v87; // [sp+1F8h] [bp-Ch]@10
  char v88; // [sp+203h] [bp-1h]@1

  v3 = byte_1000C378 == 0;
  v4 = a3;
  *(double *)a3 = 0.0;
  v5 = (int (*)(const char *, ...))a1;
  v6 = a2;
  *(double *)a2 = 0.0;
  v88 = 0;
  v78 = 0;
  *(double *)(v4 + 8) = 0.0;
  *(double *)(a2 + 8) = 0.0;
  *(double *)(v4 + 16) = 0.0;
  *(double *)(a2 + 16) = 0.0;
  *(double *)(v4 + 24) = 0.0;
  *(double *)(a2 + 24) = 0.0;
  *(double *)(v4 + 32) = 0.0;
  *(double *)(a2 + 32) = 0.0;
  if ( !v3 )
  {
    printf("\n------------------------------------------------------\n");
    printf(
      "Starting old_pcoord_t[] = (%f,%f,%f,%f,%f,%f)\n",
      *(double *)a1,
      *((double *)a1 + 1),
      *((double *)a1 + 2),
      *((double *)a1 + 3),
      *((double *)a1 + 4),
      *((double *)a1 + 5));
  }
  if ( dword_1000C318 == 3 )
  {
    UF_MTX3_vec_multiply_t(a1, &unk_10009908, &v63);
    UF_MTX3_vec_multiply_t((char *)a1 + 24, &unk_10009908, &v69);
  }
  else
  {
    memcpy(&v63, a1, 0x30u);
    v6 = a2;
    v5 = (int (*)(const char *, ...))a1;
  }
  UF_VEC3_is_zero(&v69, LODWORD(dbl_1000C010), HIDWORD(dbl_1000C010), &a3);
  if ( a3 )
    return 4;
  UF_VEC3_unitize(&v69, LODWORD(dbl_1000C010), HIDWORD(dbl_1000C010), &v70, &v80);
  v77 = v80;
  v8 = *(_DWORD *)dword_1000C1C0;
  v73 = v81;
  v62 = v82;
  if ( v8 != 3 )
  {
    v79 = (dbl_1000C080 * v82
         + dbl_1000C060 * v81
         + dbl_1000C040 * v80
         - (dbl_1000C088 * v82 + dbl_1000C068 * v81 + dbl_1000C048 * v80) * dbl_1000C350)
        * dbl_1000C2C0;
    v19 = dbl_1000C070 * v82 + dbl_1000C050 * v81 + dbl_1000C030 * v80;
    v20 = dbl_1000C078 * v82 + dbl_1000C058 * v81 + dbl_1000C038 * v80;
    if ( fabs(dbl_1000C0F8) > dbl_1000C010 )
    {
      if ( v8 == 1 )
      {
        v22 = dbl_1000C0F0;
      }
      else
      {
        if ( v8 == 2 )
          v22 = dbl_1000C0F0;
        else
          v22 = v77;
      }
      v21 = (v22 - v79) / dbl_1000C0F8;
    }
    else
    {
      v21 = 0.0;
      v88 = 1;
    }
    v85 = v21;
    v74 = sqrt(v20 * v20 + v19 * v19);
    if ( fabs(v19) > dbl_1000C010 || fabs(v20) > dbl_1000C010 )
      v23 = atan2(v19, v20);
    else
      v23 = 0.0;
    if ( fabs(v74) > dbl_1000C010 )
      v24 = v85 / v74;
    else
      v24 = 0.0;
    v85 = v24;
    if ( dbl_1000C010 + 1.0 >= fabs(v24) )
    {
      v25 = 1.0 - v24 * v24;
      if ( fabs(v25) <= dbl_1000C010 )
        v25 = 0.0;
      if ( fabs(v24 - 1.0) > dbl_1000C010 )
        v26 = sqrt(v25);
      else
        v26 = 0.0;
      v86 = atan2(v26, v24) + v23;
      v87 = atan2(-v26, v24) + v23;
    }
    else
    {
      printf(
        "INPUT Point =%-.4f,%-.4f,%-.4f,%-.8f,%-.8f,%-.8f\n",
        *(double *)v5,
        *((double *)v5 + 1),
        *((double *)v5 + 2),
        *((double *)v5 + 3),
        *((double *)v5 + 4),
        *((double *)v5 + 5));
      printf("WARNING: Degenerated G_lambda(%f) out of range (-1, 1)\n", *(_QWORD *)&v85);
      v87 = 0.0;
      v88 = 1;
      v86 = 0.0;
    }
    v27 = 0;
    v28 = fabs(dbl_1000C2B8);
    do
    {
      v29 = sin(*(double *)((char *)&v86 + v27));
      v30 = cos(*(double *)((char *)&v86 + v27));
      if ( v28 > dbl_1000C010 )
      {
        v74 = -(v29 * dbl_1000C2C0);
        v79 = dbl_1000C2C0 * v30;
        v85 = -(dbl_1000C0F8 * dbl_1000C350);
        v31 = ((v29 * dbl_1000C078 + v30 * dbl_1000C070 - dbl_1000C348 * dbl_1000C088) * v62
             + (v29 * dbl_1000C058 + v30 * dbl_1000C050 - dbl_1000C348 * dbl_1000C068) * v73
             + (v29 * dbl_1000C038 + v30 * dbl_1000C030 - dbl_1000C348 * dbl_1000C048) * v77)
            / dbl_1000C2B8;
        v85 = ((dbl_1000C0F8 * dbl_1000C080 + v79 * dbl_1000C078 + v74 * dbl_1000C070 + v85 * dbl_1000C088) * v62
             + (dbl_1000C0F8 * dbl_1000C060 + v79 * dbl_1000C058 + v74 * dbl_1000C050 + v85 * dbl_1000C068) * v73
             + (dbl_1000C0F8 * dbl_1000C040 + v79 * dbl_1000C038 + v74 * dbl_1000C030 + v85 * dbl_1000C048) * v77)
            * -1.0
            / dbl_1000C2B8;
      }
      else
      {
        v85 = 0.0;
        v31 = 0.0;
      }
      if ( fabs(v31) > dbl_1000C010 || fabs(v85) > dbl_1000C010 )
      {
        v32 = atan2(v85, v31);
      }
      else
      {
        v88 = 1;
        v32 = 0.0;
      }
      *(_QWORD *)((char *)&v83 + v27) = *(_QWORD *)&v32;
      v27 += 8;
    }
    while ( v27 < 16 );
    goto LABEL_62;
  }
  if ( dword_1000C318 )
  {
    if ( dword_1000C318 != 1 && dword_1000C318 != 3 )
      return 2;
    if ( fabs(dbl_1000C0E8 - 1.0) > dbl_1000C010
      && (v11 = (v82 - dbl_1000C0E8 * dbl_1000C0E8) / (1.0 - dbl_1000C0E8 * dbl_1000C0E8),
          dbl_1000C010 + 1.0 >= fabs(v11)) )
    {
      sub_10001FE0(v11);
      v86 = v11;
      v12 = -v11;
    }
    else
    {
      v88 = 1;
      v86 = dbl_1000C248;
      v12 = dbl_1000C250;
    }
    v87 = v12;
    v13 = 0;
    do
    {
      v14 = sin(*(double *)((char *)&v86 + v13 * 8));
      v15 = (1.0 - cos(*(double *)((char *)&v86 + v13 * 8))) * dbl_1000C0E8;
      v85 = dbl_1000C0D8 * v15 + dbl_1000C0E0 * v14;
      v16 = v15 * dbl_1000C0E0 - dbl_1000C0D8 * v14;
      v79 = v81 * v16 + v85 * v80;
      v17 = v85 * v81 - v16 * v80;
      if ( fabs(v17) > dbl_1000C010 || fabs(v79) > dbl_1000C010 )
      {
        v18 = atan2(v79, v17);
      }
      else
      {
        v88 = 1;
        v18 = dbl_1000C100[v13];
      }
      *(_QWORD *)((char *)&v83 + v13 * 8) = *(_QWORD *)&v18;
      ++v13;
    }
    while ( v13 < 2 );
LABEL_62:
    if ( !v88 )
      goto LABEL_66;
    goto LABEL_63;
  }
  v86 = asin(-v81);
  v9 = sqrt(v82 * v82 + v80 * v80);
  v85 = v9;
  sub_10001FE0(v9);
  v87 = v9;
  if ( fabs(v86 - v9) <= dbl_1000C010 )
  {
    v10 = -v85;
    sub_10001FE0(-v85);
    v87 = v10;
  }
  if ( fabs(v80) > dbl_1000C010 || fabs(v82) > dbl_1000C010 )
  {
    v83 = atan2(v82, v80);
    v84 = atan2(-v82, -v80);
    goto LABEL_66;
  }
  v88 = 1;
  v83 = dbl_1000C100[0];
  v84 = dbl_1000C108;
LABEL_63:
  if ( *(_DWORD *)dword_1000C1C0 != 3 )
  {
    v86 = dbl_1000C248;
    v87 = dbl_1000C250;
    v83 = dbl_1000C100[0];
    v84 = dbl_1000C108;
  }
  v78 = 1;
LABEL_66:
  if ( byte_1000C019 && (*(_DWORD *)dword_1000C1C0 == 2 || *(_DWORD *)dword_1000C1C0 == 3) )
  {
    sub_10002510((int)&v83, (int)&v86);
    result = v78;
    dbl_1000C320 = v86;
    dbl_1000C328 = v87;
    dbl_1000C0C8 = v83;
    dbl_1000C0D0 = v84;
    return result;
  }
  v33 = *(_DWORD *)dword_1000C1C0;
  if ( *(_DWORD *)dword_1000C1C0 == 1 )
  {
    v34 = v63;
    v35 = v64;
    v36 = v65;
    *(_DWORD *)v6 = v63;
    *(_DWORD *)(v6 + 4) = v35;
    *(_DWORD *)(v6 + 8) = v36;
    *(_DWORD *)(v6 + 12) = v66;
    *(_DWORD *)(v6 + 16) = v67;
    v37 = v68;
    *(_DWORD *)(v6 + 20) = v68;
    *(_DWORD *)v4 = v34;
    v38 = v65;
    *(_DWORD *)(v4 + 4) = v35;
    v39 = v66;
    *(_DWORD *)(v4 + 8) = v38;
    v40 = v67;
    *(_DWORD *)(v4 + 12) = v39;
    *(_DWORD *)(v4 + 16) = v40;
    *(_DWORD *)(v4 + 20) = v37;
  }
  else
  {
    if ( v33 == 2 || v33 == 3 )
    {
      if ( byte_1000C378 )
      {
        v5 = printf;
        printf("About adjusting theta with initial angle...\n");
        printf(
          "computing t1[0]=%f, t2[0]=%f, (Init_T1[0]*2-t1[0])=%f,(Init_T2[0]*2-t2[0])=%f\n",
          v86 * 57.29577951308235,
          v83 * 57.29577951308235,
          (dbl_1000C320 + dbl_1000C320 - v86) * 57.29577951308235,
          (dbl_1000C0C8 + dbl_1000C0C8 - v83) * 57.29577951308235);
        printf(
          "computing t1[1]=%f, t2[1]=%f, (Init_T1[1]*2-t1[1])=%f,(Init_T2[1]*2-t2[1])=%f\n",
          v87 * 57.29577951308235,
          v84 * 57.29577951308235,
          (dbl_1000C328 + dbl_1000C328 - v87) * 57.29577951308235,
          (dbl_1000C0D0 + dbl_1000C0D0 - v84) * 57.29577951308235);
      }
      sub_10002510((int)&v83, (int)&v86);
      if ( *(_DWORD *)dword_1000C1C0 == 2 )
      {
        v72 = v86;
        v73 = v87;
        v76 = v83;
        v77 = v84;
        sub_100031B0((int)&v76, v4, (unsigned int)v5, (int)&v80, (int)&v72);
        v86 = v72;
        v87 = v73;
        v83 = v76;
        v84 = v77;
        sub_10002220((int)&v63, v6, v72, v76, 1);
        sub_10002220((int)&v63, v4, v73, v77, 1);
      }
      else
      {
        sub_10002030((int)&dbl_1000C110, (int)&v61, -v83);
        sub_10005BC0(v41);
        UF_MTX4_vec3_multiply_t(&v63, &v61, v6);
        sub_10002030((int)&dbl_1000C110, (int)&v61, -v84);
        sub_10005BC0(v42);
        UF_MTX4_vec3_multiply_t(&v63, &v61, v4);
        if ( dword_1000C318 == 3 )
        {
          v43 = 0;
          do
          {
            v44 = v6;
            if ( v43 )
              v44 = v4;
            UF_MTX3_vec_multiply_t(v44, &unk_100098C0, v44);
            ++v43;
          }
          while ( v43 < 2 );
        }
      }
    }
  }
  v45 = dword_1000C1C0;
  v46 = *(_DWORD *)dword_1000C1C0;
  if ( *(_DWORD *)dword_1000C1C0 == 1 )
  {
    v77 = *(double *)(dword_1000C1C0 + 144) + *(double *)(dword_1000C1C0 + 136);
    UF_VEC3_affine_comb(v6, LODWORD(v77), HIDWORD(v77), &v80, v6);
    UF_VEC3_affine_comb(v4, LODWORD(v77), HIDWORD(v77), &v80, v4);
    sub_100023B0(v6, v86, v6);
    sub_100023B0(v4, v87, v4);
  }
  else
  {
    if ( v46 == 3 )
    {
      sub_10002030((int)&dbl_1000C110, (int)&v60, -v83);
      sub_10005BC0(v47);
      UF_MTX4_vec3_multiply_t(&v80, &v60, &v75);
      UF_VEC3_unitize(&v75, LODWORD(dbl_1000C010), HIDWORD(dbl_1000C010), &v70, &v75);
      v48 = UF_VEC3_affine_comb;
      UF_VEC3_affine_comb(
        v6,
        COERCE_UNSIGNED_INT64(*(double *)(dword_1000C1C0 + 136)),
        COERCE_UNSIGNED_INT64(*(double *)(dword_1000C1C0 + 136)) >> 32,
        &v75,
        v6);
      *(double *)&v49 = *(double *)(dword_1000C1C0 + 136);
      v59 = v4;
      v58[0] = &v75;
    }
    else
    {
      if ( v46 != 2 )
        goto LABEL_91;
      sub_10002220((int)&v80, (int)&v75, v86, v83, 0);
      sub_10002220((int)&v80, (int)&v71, v87, v84, 0);
      UF_VEC3_unitize(&v75, LODWORD(dbl_1000C010), HIDWORD(dbl_1000C010), &v70, &v75);
      UF_VEC3_unitize(&v71, LODWORD(dbl_1000C010), HIDWORD(dbl_1000C010), &v70, &v71);
      v48 = UF_VEC3_affine_comb;
      UF_VEC3_affine_comb(
        v6,
        COERCE_UNSIGNED_INT64(*(double *)(dword_1000C1C0 + 136)),
        COERCE_UNSIGNED_INT64(*(double *)(dword_1000C1C0 + 136)) >> 32,
        &v75,
        v6);
      *(double *)&v49 = *(double *)(dword_1000C1C0 + 136);
      v59 = v4;
      v58[0] = &v71;
    }
    v48(v4, v49, v49 >> 32, v58[0], v59);
  }
  v45 = dword_1000C1C0;
LABEL_91:
  v3 = byte_1000C018 == 0;
  *(double *)(v6 + 24) = v86 * 57.29577951308235;
  *(double *)(v4 + 24) = v87 * 57.29577951308235;
  *(double *)(v6 + 32) = v83 * 57.29577951308235;
  *(double *)(v4 + 32) = v84 * 57.29577951308235;
  if ( !v3 && *(_DWORD *)v45 != 3 )
  {
    v50 = *(double *)(v6 + 32) - 90.0;
    UNDEF(v51);
    *(_QWORD *)(v6 + 32) = *(_QWORD *)&v50;
    if ( v52 | v53 )
      *(double *)(v6 + 32) = v50 + 360.0;
    v54 = *(double *)(v4 + 32) - 90.0;
    UNDEF(v55);
    *(_QWORD *)(v4 + 32) = *(_QWORD *)&v54;
    if ( v56 | v57 )
      *(double *)(v4 + 32) = v54 + 360.0;
  }
  if ( v88 && *(_DWORD *)v45 != 3 )
  {
    *(_DWORD *)(v6 + 24) = dword_1000C2E0;
    *(_DWORD *)(v6 + 28) = dword_1000C2E4;
    *(_DWORD *)(v6 + 32) = dword_1000C2E8;
    *(_DWORD *)(v6 + 36) = dword_1000C2EC;
    *(_DWORD *)(v4 + 24) = dword_1000C308;
    *(_DWORD *)(v4 + 28) = dword_1000C30C;
    *(_DWORD *)(v4 + 32) = dword_1000C310;
    *(_DWORD *)(v4 + 36) = dword_1000C314;
  }
  if ( byte_1000C378 && fabs(v86 - v87) <= dbl_1000C010 )
  {
    if ( fabs(v83 - v84) <= dbl_1000C010 )
      printf("WARNING: same value of rotary produced:\n");
  }
  result = v78;
  memcpy(&dword_1000C2C8, (const void *)a2, 0x28u);
  memcpy(&dword_1000C2F0, (const void *)v4, 0x28u);
  dbl_1000C248 = v86;
  dbl_1000C250 = v87;
  dbl_1000C100[0] = v83;
  dbl_1000C108 = v84;
  return result;
}
// 10009064: using guessed type int __cdecl UF_MTX4_vec3_multiply_t(_DWORD, _DWORD, _DWORD);
// 10009084: using guessed type int __cdecl UF_VEC3_affine_comb(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10009088: using guessed type int __cdecl UF_VEC3_is_zero(_DWORD, _DWORD, _DWORD, _DWORD);
// 1000908C: using guessed type int __cdecl UF_MTX3_vec_multiply_t(_DWORD, _DWORD, _DWORD);
// 100090C8: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1000C010: using guessed type double dbl_1000C010;
// 1000C018: using guessed type char byte_1000C018;
// 1000C019: using guessed type char byte_1000C019;
// 1000C030: using guessed type double dbl_1000C030;
// 1000C038: using guessed type double dbl_1000C038;
// 1000C040: using guessed type double dbl_1000C040;
// 1000C048: using guessed type double dbl_1000C048;
// 1000C050: using guessed type double dbl_1000C050;
// 1000C058: using guessed type double dbl_1000C058;
// 1000C060: using guessed type double dbl_1000C060;
// 1000C068: using guessed type double dbl_1000C068;
// 1000C070: using guessed type double dbl_1000C070;
// 1000C078: using guessed type double dbl_1000C078;
// 1000C080: using guessed type double dbl_1000C080;
// 1000C088: using guessed type double dbl_1000C088;
// 1000C0C8: using guessed type double dbl_1000C0C8;
// 1000C0D0: using guessed type double dbl_1000C0D0;
// 1000C0D8: using guessed type double dbl_1000C0D8;
// 1000C0E0: using guessed type double dbl_1000C0E0;
// 1000C0E8: using guessed type double dbl_1000C0E8;
// 1000C0F0: using guessed type double dbl_1000C0F0;
// 1000C0F8: using guessed type double dbl_1000C0F8;
// 1000C100: using guessed type double dbl_1000C100[];
// 1000C108: using guessed type double dbl_1000C108;
// 1000C110: using guessed type double dbl_1000C110;
// 1000C1C0: using guessed type int dword_1000C1C0;
// 1000C248: using guessed type double dbl_1000C248;
// 1000C250: using guessed type double dbl_1000C250;
// 1000C2B8: using guessed type double dbl_1000C2B8;
// 1000C2C0: using guessed type double dbl_1000C2C0;
// 1000C2C8: using guessed type int dword_1000C2C8;
// 1000C2E0: using guessed type int dword_1000C2E0;
// 1000C2E4: using guessed type int dword_1000C2E4;
// 1000C2E8: using guessed type int dword_1000C2E8;
// 1000C2EC: using guessed type int dword_1000C2EC;
// 1000C2F0: using guessed type int dword_1000C2F0;
// 1000C308: using guessed type int dword_1000C308;
// 1000C30C: using guessed type int dword_1000C30C;
// 1000C310: using guessed type int dword_1000C310;
// 1000C314: using guessed type int dword_1000C314;
// 1000C318: using guessed type int dword_1000C318;
// 1000C320: using guessed type double dbl_1000C320;
// 1000C328: using guessed type double dbl_1000C328;
// 1000C348: using guessed type double dbl_1000C348;
// 1000C350: using guessed type double dbl_1000C350;
// 1000C378: using guessed type char byte_1000C378;

//----- (100041E0) --------------------------------------------------------
int __cdecl sub_100041E0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax@3
  double v7; // st7@9
  double v8; // st7@12
  char v9; // [sp+Ch] [bp-78h]@1
  double v10; // [sp+24h] [bp-60h]@1
  double v11; // [sp+2Ch] [bp-58h]@12
  double v12; // [sp+34h] [bp-50h]@12
  double v13; // [sp+3Ch] [bp-48h]@1
  double v14; // [sp+44h] [bp-40h]@12
  double v15; // [sp+4Ch] [bp-38h]@12
  double v16; // [sp+54h] [bp-30h]@1
  double v17; // [sp+5Ch] [bp-28h]@1
  double v18; // [sp+64h] [bp-20h]@8
  double v19; // [sp+6Ch] [bp-18h]@1
  double v20; // [sp+74h] [bp-10h]@1
  double v21; // [sp+7Ch] [bp-8h]@1

  UF_VEC3_sub(a1 + 24, a1, &v13);
  UF_VEC3_sub(a1, a2, &v9);
  UF_VEC3_sub(a2 + 24, a2, &v10);
  UF_VEC3_dot(&v13, &v9, &v16);
  UF_VEC3_dot(&v10, &v13, &v21);
  UF_VEC3_dot(&v10, &v9, &v17);
  UF_VEC3_dot(&v10, &v10, &v20);
  UF_VEC3_dot(&v13, &v13, &v19);
  if ( v20 == 0.0 )
  {
    UF_VEC3_copy(a2, a4);
    *(double *)a6 = 0.0;
    if ( v19 == 0.0 )
    {
      UF_VEC3_copy(a1, a3);
      *(double *)a5 = 0.0;
      return 0;
    }
    result = sub_100028E0(a4, a1, a3, a5);
    if ( result )
      return result;
    return 0;
  }
  if ( v19 == 0.0 )
  {
    UF_VEC3_copy(a1, a3);
    *(double *)a5 = 0.0;
    return 0;
  }
  v18 = v21 * v21 - v19 * v20;
  if ( v18 != 0.0 )
  {
    v7 = v21 * v21 / (v19 * v20);
    if ( v7 < 0.0 )
      v7 = -v7;
    if ( v7 < 1.0 - (dbl_1000C010 + dbl_1000C010) )
    {
      v8 = (v20 * v16 - v17 * v21) / v18;
      *(_QWORD *)a5 = *(_QWORD *)&v8;
      *(double *)a6 = (v8 * v21 + v17) / v20;
      *(double *)a3 = v13 * *(double *)a5 + *(double *)a1;
      *(double *)a4 = v10 * *(double *)a6 + *(double *)a2;
      *(double *)(a3 + 8) = v14 * *(double *)a5 + *(double *)(a1 + 8);
      *(double *)(a4 + 8) = v11 * *(double *)a6 + *(double *)(a2 + 8);
      result = 0;
      *(double *)(a3 + 16) = v15 * *(double *)a5 + *(double *)(a1 + 16);
      *(double *)(a4 + 16) = v12 * *(double *)a6 + *(double *)(a2 + 16);
      return result;
    }
  }
  UF_VEC3_copy(a1, a3);
  *(double *)a5 = 0.0;
  result = sub_100028E0(a3, a2, a4, a6);
  if ( !result )
    return 0;
  return result;
}
// 1000906C: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);
// 10009070: using guessed type int __cdecl UF_VEC3_dot(_DWORD, _DWORD, _DWORD);
// 10009074: using guessed type int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD);
// 1000C010: using guessed type double dbl_1000C010;

//----- (10004420) --------------------------------------------------------
signed int __cdecl sub_10004420(int a1, const void *a2, int a3, int a4, int a5, int a6, int a7, int a8, const void *a9)
{
  int v9; // edx@1
  int v10; // ebx@1
  int v11; // esi@1
  int v12; // eax@1
  bool v13; // zf@1
  int v14; // esi@12
  long double v15; // st7@23
  signed int result; // eax@24
  long double v17; // st7@33
  int v18; // ebx@41
  double v19; // st6@41
  double v20; // st6@41
  double v21; // st6@41
  double v22; // st7@44
  double v23; // st7@49
  double v24; // st6@52
  double v25; // st5@52
  int v26; // ebx@52
  double v27; // st6@52
  double v28; // st6@52
  double v29; // st7@56
  double v30; // st7@61
  int v31; // eax@64
  int v32; // ecx@64
  int v33; // edx@64
  int v34; // eax@64
  int v35; // ecx@64
  int v36; // edx@64
  int v37; // eax@67
  int v38; // edx@67
  int v39; // ecx@67
  int v40; // edx@67
  int v41; // eax@67
  int v42; // edx@67
  int v43; // ecx@67
  int v44; // edx@67
  int v45; // ecx@67
  int v46; // edx@67
  const char *v47; // [sp+5Ch] [bp-230h]@8
  int v48; // [sp+6Ch] [bp-220h]@64
  int v49; // [sp+70h] [bp-21Ch]@64
  int v50; // [sp+74h] [bp-218h]@64
  int v51; // [sp+78h] [bp-214h]@64
  int v52; // [sp+7Ch] [bp-210h]@64
  int v53; // [sp+80h] [bp-20Ch]@64
  char v54; // [sp+84h] [bp-208h]@64
  char v55; // [sp+9Ch] [bp-1F0h]@64
  __int64 v56; // [sp+B4h] [bp-1D8h]@64
  __int64 v57; // [sp+BCh] [bp-1D0h]@64
  __int64 v58; // [sp+C4h] [bp-1C8h]@64
  char v59; // [sp+CCh] [bp-1C0h]@41
  double v60; // [sp+E4h] [bp-1A8h]@41
  double v61; // [sp+ECh] [bp-1A0h]@41
  double v62; // [sp+F4h] [bp-198h]@41
  double v63; // [sp+FCh] [bp-190h]@41
  double v64; // [sp+104h] [bp-188h]@41
  double v65; // [sp+10Ch] [bp-180h]@41
  double v66; // [sp+114h] [bp-178h]@41
  double v67; // [sp+11Ch] [bp-170h]@41
  double v68; // [sp+124h] [bp-168h]@41
  double v69; // [sp+12Ch] [bp-160h]@41
  double v70; // [sp+134h] [bp-158h]@41
  double v71; // [sp+13Ch] [bp-150h]@41
  char v72; // [sp+14Ch] [bp-140h]@67
  double v73; // [sp+15Ch] [bp-130h]@15
  double v74; // [sp+164h] [bp-128h]@41
  double v75; // [sp+16Ch] [bp-120h]@41
  char v76; // [sp+174h] [bp-118h]@6
  char v77; // [sp+18Ch] [bp-100h]@41
  int v78; // [sp+1A4h] [bp-E8h]@67
  int v79; // [sp+1A8h] [bp-E4h]@67
  int v80; // [sp+1ACh] [bp-E0h]@67
  int v81; // [sp+1B0h] [bp-DCh]@67
  int v82; // [sp+1B4h] [bp-D8h]@67
  int v83; // [sp+1B8h] [bp-D4h]@67
  int v84; // [sp+1BCh] [bp-D0h]@15
  int v85; // [sp+1C0h] [bp-CCh]@67
  int v86; // [sp+1C4h] [bp-C8h]@67
  int v87; // [sp+1C8h] [bp-C4h]@67
  int v88; // [sp+1CCh] [bp-C0h]@67
  int v89; // [sp+1D0h] [bp-BCh]@67
  double v90; // [sp+1D4h] [bp-B8h]@1
  double v91; // [sp+1DCh] [bp-B0h]@52
  double v92; // [sp+1E4h] [bp-A8h]@52
  char v93; // [sp+1ECh] [bp-A0h]@5
  double v94; // [sp+204h] [bp-88h]@41
  double v95; // [sp+20Ch] [bp-80h]@41
  double v96; // [sp+214h] [bp-78h]@41
  double v97; // [sp+21Ch] [bp-70h]@15
  double v98; // [sp+224h] [bp-68h]@41
  double v99; // [sp+22Ch] [bp-60h]@41
  double v100; // [sp+234h] [bp-58h]@1
  double v101; // [sp+23Ch] [bp-50h]@41
  double v102; // [sp+244h] [bp-48h]@41
  __int64 v103; // [sp+24Ch] [bp-40h]@1
  __int64 v104; // [sp+254h] [bp-38h]@41
  __int64 v105; // [sp+25Ch] [bp-30h]@41
  char v106; // [sp+264h] [bp-28h]@41
  int v107; // [sp+268h] [bp-24h]@1
  long double v108; // [sp+26Ch] [bp-20h]@1
  long double v109; // [sp+274h] [bp-18h]@41
  int v110; // [sp+27Ch] [bp-10h]@4
  bool v111; // [sp+283h] [bp-9h]@4
  long double v112; // [sp+284h] [bp-8h]@5

  dword_1000C330 = *(_DWORD *)a3;
  dword_1000C334 = *(_DWORD *)(a3 + 4);
  dword_1000C338 = *(_DWORD *)(a3 + 8);
  dword_1000C33C = *(_DWORD *)(a3 + 12);
  dword_1000C340 = *(_DWORD *)(a3 + 16);
  dword_1000C344 = *(_DWORD *)(a3 + 20);
  dword_1000C0B0 = *(_DWORD *)a5;
  dword_1000C0B4 = *(_DWORD *)(a5 + 4);
  dword_1000C0B8 = *(_DWORD *)(a5 + 8);
  dword_1000C0BC = *(_DWORD *)(a5 + 12);
  dword_1000C0C0 = *(_DWORD *)(a5 + 16);
  v9 = *(_DWORD *)(a5 + 20);
  v107 = 0;
  dword_1000C0C4 = v9;
  UF_VEC3_copy(a4, &v103);
  v10 = a6;
  UF_VEC3_copy(a6, &v100);
  UF_VEC3_copy(a8, &v90);
  dbl_1000C348 = 0.0;
  dbl_1000C350 = 0.0;
  dbl_1000C358 = 0.0;
  byte_1000C378 = 0;
  dword_1000C1C0 = (int)&unk_1000C128;
  dbl_1000C360 = 0.0;
  memcpy(&unk_1000C128, a9, 0x98u);
  dbl_1000C368 = 0.0;
  dbl_1000C370 = 0.0;
  dbl_1000C010 = dbl_1000C130;
  memcpy(&dbl_1000C258, a2, 0x60u);
  dbl_1000C328 = 0.0;
  dbl_1000C320 = 0.0;
  dbl_1000C0D0 = 0.0;
  dbl_1000C0C8 = 0.0;
  dbl_1000C250 = 0.0;
  v11 = a4;
  dbl_1000C248 = 0.0;
  dbl_1000C108 = 0.0;
  dbl_1000C100[0] = 0.0;
  UF_VEC3_unitize(a4, LODWORD(dbl_1000C130), HIDWORD(dbl_1000C130), &v108, &dbl_1000C0D8);
  UF_VEC3_unitize(v10, LODWORD(dbl_1000C010), HIDWORD(dbl_1000C010), &v108, &dbl_1000C110);
  dword_1000C2C8 = 0;
  dword_1000C2F0 = 0;
  dword_1000C2CC = 0;
  dword_1000C2F4 = 0;
  dword_1000C2D0 = 0;
  dword_1000C2F8 = 0;
  dword_1000C2D4 = 0;
  dword_1000C2FC = 0;
  dword_1000C2D8 = 0;
  dword_1000C300 = 0;
  dword_1000C2DC = 0;
  dword_1000C304 = 0;
  dword_1000C2E0 = 0;
  dword_1000C308 = 0;
  dword_1000C2E4 = 0;
  dword_1000C30C = 0;
  dword_1000C2E8 = 0;
  dword_1000C310 = 0;
  dword_1000C2EC = 0;
  dword_1000C314 = 0;
  v12 = *(_DWORD *)dword_1000C1C0;
  v13 = *(_DWORD *)dword_1000C1C0 == 1;
  byte_1000C019 = 1;
  byte_1000C01A = 1;
  if ( !v13 && v12 != 2 && v12 != 3 )
    return 2;
  UF_VEC3_is_parallel(&v103, &v100, LODWORD(dbl_1000C010), HIDWORD(dbl_1000C010), &v110);
  v111 = v110 != 0;
  UF_VEC3_is_parallel(&v103, &v90, LODWORD(dbl_1000C010), HIDWORD(dbl_1000C010), &v110);
  BYTE3(a2) = v110 != 0;
  UF_VEC3_is_parallel(&v100, &v90, LODWORD(dbl_1000C010), HIDWORD(dbl_1000C010), &v110);
  BYTE3(a9) = v110 != 0;
  if ( !BYTE3(a2) )
  {
    v112 = v108;
    UF_VEC3_cross(&v103, &v90, &v93);
    UF_VEC3_unitize(&v93, COERCE_UNSIGNED_INT64(1.0e-10), COERCE_UNSIGNED_INT64(1.0e-10) >> 32, &v112, &v93);
  }
  UF_VEC3_cross(&v103, &v100, &v76);
  UF_VEC3_is_parallel(&v76, &v90, LODWORD(dbl_1000C010), HIDWORD(dbl_1000C010), &v110);
  byte_1000C018 = v110 != 0;
  if ( byte_1000C378 )
  {
    printf("\n\n======================================================================\n");
    printf("Is_orthogonal_case = %d, ", (unsigned __int8)byte_1000C018);
    if ( *(_DWORD *)dword_1000C1C0 == 2 )
    {
      v47 = "is_5_axis_dual_table\n";
    }
    else
    {
      if ( *(_DWORD *)dword_1000C1C0 == 1 )
        v47 = "is_5_axis_dual_head\n";
      else
        v47 = "is_5_axis_head_table\n";
    }
    printf(v47);
    printf("primary=(%f,%f,%f)\n", *(double *)v11, *(double *)(v11 + 8), *(double *)(v11 + 16));
    v14 = a3;
    printf("primary_machine_center=(%f,%f,%f)\n", *(double *)a3, *(double *)(a3 + 8), *(double *)(a3 + 16));
    printf("secondary=(%f,%f,%f)\n", *(double *)v10, *(double *)(v10 + 8), *(double *)(v10 + 16));
    printf("secondary_machine_center=(%f,%f,%f)\n", *(double *)a5, *(double *)(a5 + 8), *(double *)(a5 + 16));
    printf("tool_machine_center=(%f,%f,%f)\n", *(double *)a7, *(double *)(a7 + 8), *(double *)(a7 + 16));
    printf("tool_vector=(%f,%f,%f)\n", *(double *)a8, *(double *)(a8 + 8), *(double *)(a8 + 16));
    printf(
      "Mcsys= (%f,%f,%f) (%f,%f,%f) (%f,%f,%f)  (%f,%f,%f)\n",
      *(_QWORD *)&dbl_1000C258,
      *(_QWORD *)&dbl_1000C260,
      *(_QWORD *)&dbl_1000C268,
      *(_QWORD *)&dbl_1000C270,
      *(_QWORD *)&dbl_1000C278,
      *(_QWORD *)&dbl_1000C280,
      *(_QWORD *)&dbl_1000C288,
      *(_QWORD *)&dbl_1000C290,
      *(_QWORD *)&dbl_1000C298,
      *(_QWORD *)&dbl_1000C2A0,
      *(_QWORD *)&dbl_1000C2A8,
      *(_QWORD *)&dbl_1000C2B0);
  }
  else
  {
    v14 = a3;
  }
  v13 = *(_DWORD *)dword_1000C1C0 == 3;
  dword_1000C318 = -1;
  if ( v13 )
  {
    UF_MTX3_x_vec(&unk_10009878, &v97);
    UF_MTX3_y_vec(&unk_10009878, &v73);
    UF_MTX3_z_vec(&unk_10009878, &v84);
    UF_VEC3_is_equal(a8, &v84, LODWORD(dbl_1000C010), HIDWORD(dbl_1000C010), &a3);
    if ( a3 )
    {
      UF_VEC3_is_equal(a4, &v97, LODWORD(dbl_1000C010), HIDWORD(dbl_1000C010), &a5);
      UF_VEC3_is_equal(v10, &v73, LODWORD(dbl_1000C010), HIDWORD(dbl_1000C010), &a9);
      UF_VEC3_is_equal(v10, &v84, LODWORD(dbl_1000C010), HIDWORD(dbl_1000C010), &a2);
      if ( a5 && a9 )
      {
        result = v107;
        dword_1000C318 = 0;
        byte_1000C019 = 0;
      }
      else
      {
        if ( a2 )
        {
          result = v107;
          dword_1000C318 = 1;
          byte_1000C019 = 0;
        }
        else
        {
          v107 = 2;
          result = 2;
          byte_1000C019 = 0;
        }
      }
      return result;
    }
    UF_VEC3_is_equal(a8, &v73, LODWORD(dbl_1000C010), HIDWORD(dbl_1000C010), &a2);
    UF_VEC3_is_equal(&v103, &v84, LODWORD(dbl_1000C010), HIDWORD(dbl_1000C010), &v107);
    if ( !byte_1000C018 && BYTE3(a9) && a2 && v107 )
    {
      dword_1000C318 = 3;
      UF_MTX3_vec_multiply_t(&dbl_1000C0D8, &unk_10009908, &dbl_1000C0D8);
      UF_MTX3_vec_multiply_t(&dbl_1000C110, &unk_10009908, &dbl_1000C110);
      if ( byte_1000C378 )
      {
        printf("Sulzer case:\n");
        printf(
          "local PrimaryAxis=(%f,%f,%f)\n",
          *(_QWORD *)&dbl_1000C0D8,
          *(_QWORD *)&dbl_1000C0E0,
          *(_QWORD *)&dbl_1000C0E8);
        printf(
          "local SecondaryAxis=(%f,%f,%f)\n",
          *(_QWORD *)&dbl_1000C110,
          *(_QWORD *)&dbl_1000C118,
          *(_QWORD *)&dbl_1000C120);
      }
      goto LABEL_22;
    }
    return 2;
  }
LABEL_22:
  if ( v111 )
  {
    v15 = 0.0;
  }
  else
  {
    v112 = v108;
    UF_VEC3_cross(&v103, &v100, &v93);
    UF_VEC3_unitize(&v93, COERCE_UNSIGNED_INT64(1.0e-10), COERCE_UNSIGNED_INT64(1.0e-10) >> 32, &v112, &v93);
    UF_VEC3_angle_between(&v103, &v100, &v93, &v112);
    v15 = v112;
  }
  dbl_1000C368 = v15;
  if ( BYTE3(a9) )
  {
    printf("WARNING: Tool axis is parallelled with secondary axis that may cause unresolved rotaries");
    v17 = 0.0;
  }
  else
  {
    if ( fabs(dbl_1000C368) <= dbl_1000C010 )
    {
      v112 = v108;
      UF_VEC3_cross(&v100, &v90, &v93);
      UF_VEC3_unitize(&v93, COERCE_UNSIGNED_INT64(1.0e-10), COERCE_UNSIGNED_INT64(1.0e-10) >> 32, &v112, &v93);
      if ( fabs(v108) <= dbl_1000C010 )
        return 3;
    }
    if ( byte_1000C018 )
    {
      v112 = v108;
      UF_VEC3_cross(&v100, &v90, &v84);
      UF_VEC3_unitize(&v84, COERCE_UNSIGNED_INT64(1.0e-10), COERCE_UNSIGNED_INT64(1.0e-10) >> 32, &v112, &v84);
      UF_VEC3_angle_between(&v100, &v90, &v84, &v112);
    }
    else
    {
      UF_VEC3_angle_between(&v100, &v90, &v93, &v112);
    }
    v17 = v112;
  }
  dbl_1000C370 = v17;
  v18 = a5;
  v19 = *(double *)&v103 * 1000000.0 + *(double *)v14;
  v73 = *(double *)v14 - *(double *)&v103 * 1000000.0;
  v94 = v100 * 1000000.0 + *(double *)a5;
  v97 = *(double *)a5 - v100 * 1000000.0;
  v60 = v19;
  v66 = v94;
  v63 = v73;
  v69 = v97;
  v20 = *(double *)&v104 * 1000000.0 + *(double *)(v14 + 8);
  v74 = *(double *)(v14 + 8) - *(double *)&v104 * 1000000.0;
  v95 = v101 * 1000000.0 + *(double *)(a5 + 8);
  v98 = *(double *)(a5 + 8) - v101 * 1000000.0;
  v61 = v20;
  v67 = v95;
  v64 = v74;
  v70 = v98;
  v21 = *(double *)&v105 * 1000000.0 + *(double *)(v14 + 16);
  v75 = *(double *)(v14 + 16) - *(double *)&v105 * 1000000.0;
  v96 = v102 * 1000000.0 + *(double *)(a5 + 16);
  v99 = *(double *)(a5 + 16) - v102 * 1000000.0;
  v62 = v21;
  v68 = v96;
  v65 = v75;
  v71 = v99;
  if ( sub_100041E0((int)&v60, (int)&v66, (int)&v59, (int)&v77, (int)&v109, (int)&v106) )
    return 5;
  UF_VEC3_distance(&v59, &v77, &dbl_1000C348);
  if ( dbl_1000C348 <= dbl_1000C010 )
  {
    v22 = 0.0;
  }
  else
  {
    UF_VEC3_sub(&v77, &v59, &v76);
    UF_VEC3_dot(&v76, &v93, &v112);
    if ( v112 >= 0.0 )
      goto LABEL_47;
    v22 = -dbl_1000C348;
  }
  dbl_1000C348 = v22;
LABEL_47:
  UF_VEC3_distance(&v77, v14, &dbl_1000C350);
  if ( dbl_1000C350 <= dbl_1000C010 )
  {
    v23 = 0.0;
  }
  else
  {
    UF_VEC3_sub(&v77, v14, &v76);
    UF_VEC3_dot(&v76, &v103, &v112);
    if ( v112 >= 0.0 )
      goto LABEL_52;
    v23 = -dbl_1000C350;
  }
  dbl_1000C350 = v23;
LABEL_52:
  v24 = v100 * 1000000.0 + *(double *)v18;
  v25 = *(double *)v18;
  v26 = a7;
  v73 = v25 - v100 * 1000000.0;
  v94 = v90 * 1000000.0 + *(double *)a7;
  v97 = *(double *)a7 - v90 * 1000000.0;
  v60 = v24;
  v66 = v94;
  v63 = v73;
  v69 = v97;
  v27 = v101 * 1000000.0 + *(double *)(a5 + 8);
  v74 = *(double *)(a5 + 8) - v101 * 1000000.0;
  v95 = v91 * 1000000.0 + *(double *)(a7 + 8);
  v98 = *(double *)(a7 + 8) - v91 * 1000000.0;
  v61 = v27;
  v67 = v95;
  v64 = v74;
  v70 = v98;
  v28 = v102 * 1000000.0 + *(double *)(a5 + 16);
  v75 = *(double *)(a5 + 16) - v102 * 1000000.0;
  v96 = v92 * 1000000.0 + *(double *)(a7 + 16);
  v99 = *(double *)(a7 + 16) - v92 * 1000000.0;
  v62 = v28;
  v68 = v96;
  v65 = v75;
  v71 = v99;
  if ( sub_100041E0((int)&v60, (int)&v66, (int)&v59, (int)&v77, (int)&v109, (int)&v106) )
    return 5;
  UF_VEC3_distance(&v59, &v77, &dbl_1000C358);
  if ( dbl_1000C358 <= dbl_1000C010 )
  {
    v29 = 0.0;
  }
  else
  {
    UF_VEC3_sub(&v77, &v59, &v76);
    UF_VEC3_dot(&v76, &v93, &v109);
    if ( v109 >= 0.0 )
      goto LABEL_59;
    v29 = -dbl_1000C358;
  }
  dbl_1000C358 = v29;
LABEL_59:
  UF_VEC3_distance(&v77, v26, &dbl_1000C360);
  if ( dbl_1000C360 <= dbl_1000C010 )
  {
    v30 = 0.0;
    goto LABEL_63;
  }
  UF_VEC3_sub(&v77, v26, &v76);
  UF_VEC3_dot(&v76, &v100, &v109);
  if ( v109 < 0.0 )
  {
    v30 = -dbl_1000C360;
LABEL_63:
    dbl_1000C360 = v30;
  }
  v31 = *(_DWORD *)v14;
  v32 = *(_DWORD *)(v14 + 4);
  v109 = v108;
  v33 = *(_DWORD *)(v14 + 8);
  v48 = v31;
  v34 = *(_DWORD *)(v14 + 12);
  v49 = v32;
  v35 = *(_DWORD *)(v14 + 16);
  v50 = v33;
  v36 = *(_DWORD *)(v14 + 20);
  v51 = v34;
  v52 = v35;
  v53 = v36;
  UF_VEC3_cross(&v103, &v100, &v54);
  UF_VEC3_unitize(&v54, COERCE_UNSIGNED_INT64(1.0e-10), COERCE_UNSIGNED_INT64(1.0e-10) >> 32, &v109, &v54);
  v109 = v108;
  v56 = v103;
  v57 = v104;
  v58 = v105;
  UF_VEC3_cross(&v103, &v54, &v55);
  UF_VEC3_unitize(&v55, COERCE_UNSIGNED_INT64(1.0e-10), COERCE_UNSIGNED_INT64(1.0e-10) >> 32, &v109, &v55);
  sub_10002150((int)&v48, a1, (int)&unk_1000C1C8);
  sub_10003080((int)&unk_1000C1C8, (int)&dbl_1000C030);
  dbl_1000C0F8 = sin(dbl_1000C368);
  dbl_1000C2B8 = sin(dbl_1000C370);
  dbl_1000C2C0 = cos(dbl_1000C368);
  dbl_1000C0F0 = cos(dbl_1000C370);
  if ( byte_1000C378 )
    printf(
      "A1=%f,D1=%f,Alpha1=%f,A2=%f,D2=%f,Alpha2=%f\n",
      *(_QWORD *)&dbl_1000C348,
      *(_QWORD *)&dbl_1000C350,
      dbl_1000C368 * 57.29577951308235,
      *(_QWORD *)&dbl_1000C358,
      *(_QWORD *)&dbl_1000C360,
      dbl_1000C370 * 57.29577951308235);
  if ( *(_DWORD *)dword_1000C1C0 == 2 )
  {
    v37 = *(_DWORD *)(v26 + 8);
    v38 = *(_DWORD *)(v26 + 4);
    v78 = *(_DWORD *)v26;
    v39 = *(_DWORD *)(v26 + 12);
    v79 = v38;
    v40 = *(_DWORD *)(v26 + 16);
    v80 = v37;
    v41 = *(_DWORD *)(v26 + 20);
    v81 = v39;
    v82 = v40;
    v83 = v41;
    v42 = *(_DWORD *)(a8 + 4);
    v84 = *(_DWORD *)a8;
    v43 = *(_DWORD *)(a8 + 8);
    v85 = v42;
    v44 = *(_DWORD *)(a8 + 12);
    v86 = v43;
    v45 = *(_DWORD *)(a8 + 16);
    v87 = v44;
    v46 = *(_DWORD *)(a8 + 20);
    v88 = v45;
    v89 = v46;
    sub_10003400(&v78, (int)&v72, (unsigned int)&v95);
    if ( byte_1000C378 )
    {
      printf("Init_T1[0], Init_T2[0] = (%f,%f)\n", dbl_1000C320 * 57.29577951308235, dbl_1000C0C8 * 57.29577951308235);
      printf("Init_T1[1], Init_T2[1] = (%f,%f)\n", dbl_1000C328 * 57.29577951308235, dbl_1000C0D0 * 57.29577951308235);
    }
  }
  result = 0;
  byte_1000C019 = 0;
  return result;
}
// 10009068: using guessed type int __cdecl UF_VEC3_angle_between(_DWORD, _DWORD, _DWORD, _DWORD);
// 1000906C: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);
// 10009070: using guessed type int __cdecl UF_VEC3_dot(_DWORD, _DWORD, _DWORD);
// 10009074: using guessed type int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD);
// 1000908C: using guessed type int __cdecl UF_MTX3_vec_multiply_t(_DWORD, _DWORD, _DWORD);
// 10009090: using guessed type int __cdecl UF_VEC3_distance(_DWORD, _DWORD, _DWORD);
// 10009094: using guessed type int __cdecl UF_MTX3_z_vec(_DWORD, _DWORD);
// 10009098: using guessed type int __cdecl UF_VEC3_is_parallel(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090B8: using guessed type int __cdecl UF_MTX3_x_vec(_DWORD, _DWORD);
// 100090BC: using guessed type int __cdecl UF_MTX3_y_vec(_DWORD, _DWORD);
// 100090C4: using guessed type int __cdecl UF_VEC3_cross(_DWORD, _DWORD, _DWORD);
// 100090C8: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090F8: using guessed type int __cdecl UF_VEC3_is_equal(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1000C010: using guessed type double dbl_1000C010;
// 1000C018: using guessed type char byte_1000C018;
// 1000C019: using guessed type char byte_1000C019;
// 1000C01A: using guessed type char byte_1000C01A;
// 1000C030: using guessed type double dbl_1000C030;
// 1000C0B0: using guessed type int dword_1000C0B0;
// 1000C0B4: using guessed type int dword_1000C0B4;
// 1000C0B8: using guessed type int dword_1000C0B8;
// 1000C0BC: using guessed type int dword_1000C0BC;
// 1000C0C0: using guessed type int dword_1000C0C0;
// 1000C0C4: using guessed type int dword_1000C0C4;
// 1000C0C8: using guessed type double dbl_1000C0C8;
// 1000C0D0: using guessed type double dbl_1000C0D0;
// 1000C0D8: using guessed type double dbl_1000C0D8;
// 1000C0E0: using guessed type double dbl_1000C0E0;
// 1000C0E8: using guessed type double dbl_1000C0E8;
// 1000C0F0: using guessed type double dbl_1000C0F0;
// 1000C0F8: using guessed type double dbl_1000C0F8;
// 1000C100: using guessed type double dbl_1000C100[];
// 1000C108: using guessed type double dbl_1000C108;
// 1000C110: using guessed type double dbl_1000C110;
// 1000C118: using guessed type double dbl_1000C118;
// 1000C120: using guessed type double dbl_1000C120;
// 1000C130: using guessed type double dbl_1000C130;
// 1000C1C0: using guessed type int dword_1000C1C0;
// 1000C248: using guessed type double dbl_1000C248;
// 1000C250: using guessed type double dbl_1000C250;
// 1000C258: using guessed type double dbl_1000C258;
// 1000C260: using guessed type double dbl_1000C260;
// 1000C268: using guessed type double dbl_1000C268;
// 1000C270: using guessed type double dbl_1000C270;
// 1000C278: using guessed type double dbl_1000C278;
// 1000C280: using guessed type double dbl_1000C280;
// 1000C288: using guessed type double dbl_1000C288;
// 1000C290: using guessed type double dbl_1000C290;
// 1000C298: using guessed type double dbl_1000C298;
// 1000C2A0: using guessed type double dbl_1000C2A0;
// 1000C2A8: using guessed type double dbl_1000C2A8;
// 1000C2B0: using guessed type double dbl_1000C2B0;
// 1000C2B8: using guessed type double dbl_1000C2B8;
// 1000C2C0: using guessed type double dbl_1000C2C0;
// 1000C2C8: using guessed type int dword_1000C2C8;
// 1000C2CC: using guessed type int dword_1000C2CC;
// 1000C2D0: using guessed type int dword_1000C2D0;
// 1000C2D4: using guessed type int dword_1000C2D4;
// 1000C2D8: using guessed type int dword_1000C2D8;
// 1000C2DC: using guessed type int dword_1000C2DC;
// 1000C2E0: using guessed type int dword_1000C2E0;
// 1000C2E4: using guessed type int dword_1000C2E4;
// 1000C2E8: using guessed type int dword_1000C2E8;
// 1000C2EC: using guessed type int dword_1000C2EC;
// 1000C2F0: using guessed type int dword_1000C2F0;
// 1000C2F4: using guessed type int dword_1000C2F4;
// 1000C2F8: using guessed type int dword_1000C2F8;
// 1000C2FC: using guessed type int dword_1000C2FC;
// 1000C300: using guessed type int dword_1000C300;
// 1000C304: using guessed type int dword_1000C304;
// 1000C308: using guessed type int dword_1000C308;
// 1000C30C: using guessed type int dword_1000C30C;
// 1000C310: using guessed type int dword_1000C310;
// 1000C314: using guessed type int dword_1000C314;
// 1000C318: using guessed type int dword_1000C318;
// 1000C320: using guessed type double dbl_1000C320;
// 1000C328: using guessed type double dbl_1000C328;
// 1000C330: using guessed type int dword_1000C330;
// 1000C334: using guessed type int dword_1000C334;
// 1000C338: using guessed type int dword_1000C338;
// 1000C33C: using guessed type int dword_1000C33C;
// 1000C340: using guessed type int dword_1000C340;
// 1000C344: using guessed type int dword_1000C344;
// 1000C348: using guessed type double dbl_1000C348;
// 1000C350: using guessed type double dbl_1000C350;
// 1000C358: using guessed type double dbl_1000C358;
// 1000C360: using guessed type double dbl_1000C360;
// 1000C368: using guessed type double dbl_1000C368;
// 1000C370: using guessed type double dbl_1000C370;
// 1000C378: using guessed type char byte_1000C378;

//----- (10005470) --------------------------------------------------------
signed int __cdecl sub_10005470(const void *a1, int a2, int a3)
{
  const void *v3; // ebx@1
  signed int v4; // esi@3
  bool v5; // zf@8
  char v7; // [sp+34h] [bp-98h]@1
  char v8[40]; // [sp+64h] [bp-68h]@1
  char v9[40]; // [sp+8Ch] [bp-40h]@1
  double v10; // [sp+B4h] [bp-18h]@2
  double v11; // [sp+BCh] [bp-10h]@2
  double v12; // [sp+C4h] [bp-8h]@2
  signed int v13; // [sp+D4h] [bp+8h]@1

  v3 = a1;
  memcpy(&v7, a1, 0x30u);
  UF_VEC3_add(&v7, dword_1000C1C0 + 16, &v7);
  UF_VEC3_sub(&v7, dword_1000C1C0 + 40, &v7);
  v13 = sub_10003400(&v7, (int)v9, (unsigned int)v8);
  UF_VEC3_add(v9, dword_1000C1C0 + 64, v9);
  UF_VEC3_add(v8, dword_1000C1C0 + 64, v8);
  if ( *(_BYTE *)(dword_1000C1C0 + 88) )
  {
    v10 = *((double *)v3 + 3);
    v11 = *((double *)v3 + 4);
    v12 = *((double *)v3 + 5);
    UF_VEC3_scale(
      COERCE_UNSIGNED_INT64(*(double *)(dword_1000C1C0 + 96)),
      COERCE_UNSIGNED_INT64(*(double *)(dword_1000C1C0 + 96)) >> 32,
      &v10,
      &v10);
    UF_VEC3_add(v9, &v10, v9);
    UF_VEC3_add(v8, &v10, v8);
  }
  v4 = 0;
  do
  {
    *(double *)&v9[v4] = sub_10005760((int)&v9[v4], (long double *)(dword_1000C1C0 + 8));
    *(double *)&v8[v4] = sub_10005760((int)&v8[v4], (long double *)(dword_1000C1C0 + 8));
    v4 += 8;
  }
  while ( v4 <= 16 );
  if ( byte_1000C01A )
    byte_1000C01A = 0;
  else
    sub_100026F0((int)v9, (int)&unk_1000C3A8, (int)v8);
  v5 = byte_1000C378 == 0;
  memcpy((void *)a2, v9, 0x28u);
  memcpy((void *)a3, v8, 0x28u);
  memcpy(&unk_1000C3A8, (const void *)a2, 0x28u);
  memcpy(&unk_1000C380, (const void *)a3, 0x28u);
  if ( !v5 )
  {
    printf(
      "final ufunc mcoord[] = (%f,%f,%f), (%f,%f)\n",
      *(double *)a2,
      *(double *)(a2 + 8),
      *(double *)(a2 + 16),
      *(double *)(a2 + 24),
      *(double *)(a2 + 32));
    printf(
      "final ufunc alt_mcoord[] = (%f,%f,%f), (%f,%f)\n",
      *(double *)a3,
      *(double *)(a3 + 8),
      *(double *)(a3 + 16),
      *(double *)(a3 + 24),
      *(double *)(a3 + 32));
  }
  return v13;
}
// 10009060: using guessed type int __cdecl UF_VEC3_add(_DWORD, _DWORD, _DWORD);
// 10009074: using guessed type int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD);
// 1000909C: using guessed type int __cdecl UF_VEC3_scale(_DWORD, _DWORD, _DWORD, _DWORD);
// 1000C01A: using guessed type char byte_1000C01A;
// 1000C1C0: using guessed type int dword_1000C1C0;
// 1000C378: using guessed type char byte_1000C378;
// 10005470: using guessed type char var_68[40];
// 10005470: using guessed type char var_40[40];

//----- (10005760) --------------------------------------------------------
double __cdecl sub_10005760(int a1, long double *a2)
{
  double result; // st7@2
  double v3; // st7@3
  double v4; // st7@3
  double v5; // [sp+8h] [bp-8h]@3

  if ( fabs(fabs(*a2)) > 1.0e-10 )
  {
    v3 = 1.0 / *a2;
    v5 = v3;
    v4 = v3 * *(double *)a1;
    if ( v4 >= 0.000001 )
    {
      result = floor(v4 + 0.5) / v5;
    }
    else
    {
      if ( v4 <= -0.000001 )
        result = ceil(v4 - 0.5) / v5;
      else
        result = 0.0 / v5;
    }
  }
  else
  {
    result = 0.0;
  }
  return result;
}

//----- (10005800) --------------------------------------------------------
signed int __usercall sub_10005800<eax>(int a1<eax>)
{
  int v1; // esi@1
  long double *v2; // ebx@1
  long double v3; // st7@1
  double v4; // st7@2
  long double v5; // st7@8
  double v6; // st7@9
  long double v7; // st7@15
  double v8; // st7@16
  long double v9; // st7@22
  double v10; // st7@23
  long double v11; // st7@29
  double v12; // st7@30
  long double v13; // st7@36
  double v14; // st7@37
  long double v15; // st7@43
  double v16; // st7@44
  long double v17; // st7@50
  double v18; // st7@51
  long double v19; // st7@57
  double v20; // st7@58
  signed int result; // eax@66
  char v22; // [sp+1Ch] [bp-98h]@1
  char v23; // [sp+64h] [bp-50h]@1
  char v24; // [sp+7Ch] [bp-38h]@1
  char v25; // [sp+94h] [bp-20h]@1
  char v26; // [sp+ACh] [bp-8h]@64

  v1 = a1;
  UF_VEC3_copy(a1, &v25);
  v2 = (long double *)(v1 + 24);
  UF_VEC3_copy(v1 + 24, &v24);
  UF_VEC3_copy(v1 + 48, &v23);
  UF_MTX3_copy(v1, &v22);
  v3 = fabs(*(double *)v1);
  if ( v3 > 1.0e-10 )
  {
    if ( fabs(v3 - 1.0) > 1.0e-10 )
      goto LABEL_8;
    if ( *(double *)v1 <= 0.0 )
      v4 = -1.0;
    else
      v4 = 1.0;
  }
  else
  {
    v4 = 0.0;
  }
  *(_QWORD *)v1 = *(_QWORD *)&v4;
LABEL_8:
  v5 = fabs(*(double *)(v1 + 8));
  if ( v5 > 1.0e-10 )
  {
    if ( fabs(v5 - 1.0) > 1.0e-10 )
      goto LABEL_15;
    if ( *(double *)(v1 + 8) <= 0.0 )
      v6 = -1.0;
    else
      v6 = 1.0;
  }
  else
  {
    v6 = 0.0;
  }
  *(_QWORD *)(v1 + 8) = *(_QWORD *)&v6;
LABEL_15:
  v7 = fabs(*(double *)(v1 + 16));
  if ( v7 > 1.0e-10 )
  {
    if ( fabs(v7 - 1.0) > 1.0e-10 )
      goto LABEL_22;
    if ( *(double *)(v1 + 16) <= 0.0 )
      v8 = -1.0;
    else
      v8 = 1.0;
  }
  else
  {
    v8 = 0.0;
  }
  *(_QWORD *)(v1 + 16) = *(_QWORD *)&v8;
LABEL_22:
  v9 = fabs(*v2);
  if ( v9 > 1.0e-10 )
  {
    if ( fabs(v9 - 1.0) > 1.0e-10 )
      goto LABEL_29;
    if ( *v2 <= 0.0 )
      v10 = -1.0;
    else
      v10 = 1.0;
  }
  else
  {
    v10 = 0.0;
  }
  *(_QWORD *)v2 = *(_QWORD *)&v10;
LABEL_29:
  v11 = fabs(*(double *)(v1 + 32));
  if ( v11 > 1.0e-10 )
  {
    if ( fabs(v11 - 1.0) > 1.0e-10 )
      goto LABEL_36;
    if ( *(double *)(v1 + 32) <= 0.0 )
      v12 = -1.0;
    else
      v12 = 1.0;
  }
  else
  {
    v12 = 0.0;
  }
  *(_QWORD *)(v1 + 32) = *(_QWORD *)&v12;
LABEL_36:
  v13 = fabs(*(double *)(v1 + 40));
  if ( v13 > 1.0e-10 )
  {
    if ( fabs(v13 - 1.0) > 1.0e-10 )
      goto LABEL_43;
    if ( *(double *)(v1 + 40) <= 0.0 )
      v14 = -1.0;
    else
      v14 = 1.0;
  }
  else
  {
    v14 = 0.0;
  }
  *(_QWORD *)(v1 + 40) = *(_QWORD *)&v14;
LABEL_43:
  v15 = fabs(*(double *)(v1 + 48));
  if ( v15 > 1.0e-10 )
  {
    if ( fabs(v15 - 1.0) > 1.0e-10 )
      goto LABEL_50;
    if ( *(double *)(v1 + 48) <= 0.0 )
      v16 = -1.0;
    else
      v16 = 1.0;
  }
  else
  {
    v16 = 0.0;
  }
  *(_QWORD *)(v1 + 48) = *(_QWORD *)&v16;
LABEL_50:
  v17 = fabs(*(double *)(v1 + 56));
  if ( v17 > 1.0e-10 )
  {
    if ( fabs(v17 - 1.0) > 1.0e-10 )
      goto LABEL_57;
    if ( *(double *)(v1 + 56) <= 0.0 )
      v18 = -1.0;
    else
      v18 = 1.0;
  }
  else
  {
    v18 = 0.0;
  }
  *(_QWORD *)(v1 + 56) = *(_QWORD *)&v18;
LABEL_57:
  v19 = fabs(*(double *)(v1 + 64));
  if ( v19 <= 1.0e-10 )
  {
    v20 = 0.0;
LABEL_63:
    *(_QWORD *)(v1 + 64) = *(_QWORD *)&v20;
    goto LABEL_64;
  }
  if ( fabs(v19 - 1.0) <= 1.0e-10 )
  {
    if ( *(double *)(v1 + 64) <= 0.0 )
      v20 = -1.0;
    else
      v20 = 1.0;
    goto LABEL_63;
  }
LABEL_64:
  if ( UF_VEC3_unitize(&v25, COERCE_UNSIGNED_INT64(1.0e-10), COERCE_UNSIGNED_INT64(1.0e-10) >> 32, &v26, &v25)
    && UF_VEC3_unitize(&v24, COERCE_UNSIGNED_INT64(1.0e-10), COERCE_UNSIGNED_INT64(1.0e-10) >> 32, &v26, &v24) )
  {
    UF_VEC3_cross(&v25, &v24, &v23);
    UF_VEC3_cross(&v23, &v25, &v24);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1000906C: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);
// 100090B4: using guessed type int __cdecl UF_MTX3_copy(_DWORD, _DWORD);
// 100090C4: using guessed type int __cdecl UF_VEC3_cross(_DWORD, _DWORD, _DWORD);
// 100090C8: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10005BC0) --------------------------------------------------------
signed int __cdecl sub_10005BC0(int a1)
{
  signed int v1; // edi@1
  char v3; // [sp+8h] [bp-48h]@1

  UF_MTX4_ask_rotation(a1, &v3);
  v1 = sub_10005800((int)&v3);
  UF_MTX4_edit_rotation(a1, &v3);
  return v1;
}
// 10009058: using guessed type int __cdecl UF_MTX4_ask_rotation(_DWORD, _DWORD);
// 100090A0: using guessed type int __cdecl UF_MTX4_edit_rotation(_DWORD, _DWORD);

//----- (10005C20) --------------------------------------------------------
int __cdecl sub_10005C20(int a1, int a2)
{
  int v2; // eax@1
  char v3[4]; // edi@1
  int v4; // esi@1
  signed int v5; // ecx@1
  bool v6; // zf@1
  int v7; // eax@5
  int v8; // esi@5
  char *v9; // eax@6
  int v10; // edx@8
  char v11; // cl@9
  char *v12; // eax@11
  int v13; // edx@13
  char v14; // cl@14
  char *v15; // eax@16
  int v16; // edx@18
  char v17; // cl@19
  char *v18; // eax@21
  int v19; // edx@23
  char v20; // cl@24
  char *v21; // eax@26
  char *v22; // eax@29
  char v23[4]; // edi@32
  int v24; // esi@32
  signed int v25; // ecx@32
  bool v26; // zf@32
  int v28; // [sp+Ch] [bp-24h]@4
  int v29; // [sp+10h] [bp-20h]@4
  int v30; // [sp+14h] [bp-1Ch]@4
  int v31; // [sp+18h] [bp-18h]@4
  int v32; // [sp+1Ch] [bp-14h]@4
  char v33[4]; // [sp+20h] [bp-10h]@1
  int v34; // [sp+24h] [bp-Ch]@5
  int v35; // [sp+28h] [bp-8h]@4
  char *Str; // [sp+2Ch] [bp-4h]@5

  v2 = (int)"mom_kin_nurbs_output_type";
  *(_DWORD *)v3 = "END";
  v4 = (int)"mom_kin_nurbs_output_type";
  v5 = 26;
  v6 = 1;
  *(_DWORD *)v33 = "END";
  do
  {
    if ( !v5 )
      break;
    v6 = *(_BYTE *)v4++ == **(_BYTE **)v3;
    ++*(_DWORD *)v3;
    --v5;
  }
  while ( v6 );
  v28 = (int)"mom_kin_output_unit";
  v29 = (int)"mom_kin_polar_radius_side";
  v30 = (int)"mom_kin_read_ahead_next_motion";
  v31 = (int)"mom_kin_pivot_gauge_offset";
  v32 = (int)"mom_kin_rapid_feed_rate";
  v35 = 0;
  if ( !v6 )
  {
    do
    {
      v7 = UF_MOM_ask_string(a1, v2 + 4, &Str);
      v8 = v35;
      v34 = v7;
      switch ( v35 )
      {
        case 0:
          v9 = Str;
          if ( !Str )
          {
            v9 = "NONE";
            Str = "NONE";
          }
          v10 = a2 - (_DWORD)v9;
          do
          {
            v11 = *v9;
            v9[v10] = *v9;
            ++v9;
          }
          while ( v11 );
          break;
        case 1:
          v12 = Str;
          if ( !Str )
          {
            v12 = "IN";
            Str = "IN";
          }
          v13 = a2 - (_DWORD)v12 + 133;
          do
          {
            v14 = *v12;
            v12[v13] = *v12;
            ++v12;
          }
          while ( v14 );
          break;
        case 2:
          v15 = Str;
          if ( !Str )
          {
            v15 = "NONE";
            Str = "NONE";
          }
          v16 = a2 - (_DWORD)v15 + 266;
          do
          {
            v17 = *v15;
            v15[v16] = *v15;
            ++v15;
          }
          while ( v17 );
          break;
        case 3:
          v18 = Str;
          if ( !Str )
          {
            v18 = "F";
            Str = "F";
          }
          v19 = a2 - (_DWORD)v18 + 399;
          do
          {
            v20 = *v18;
            v18[v19] = *v18;
            ++v18;
          }
          while ( v20 );
          break;
        case 4:
          v21 = Str;
          if ( !Str )
          {
            v21 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 536) = strtod(v21, 0);
          break;
        case 5:
          v22 = Str;
          if ( !Str )
          {
            v22 = "400.00";
            Str = "400.00";
          }
          *(double *)(a2 + 544) = strtod(v22, 0);
          break;
        default:
          break;
      }
      v2 = *(&v28 + v8);
      v35 = v8 + 1;
      *(_DWORD *)v23 = "END";
      v24 = v2;
      v25 = 4;
      v26 = 1;
      do
      {
        if ( !v25 )
          break;
        v26 = *(_BYTE *)v24++ == **(_BYTE **)v23;
        ++*(_DWORD *)v23;
        --v25;
      }
      while ( v26 );
    }
    while ( !v26 );
  }
  return v34;
}
// 100090D8: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10005DD0) --------------------------------------------------------
int __cdecl sub_10005DD0(int a1, int a2)
{
  int v2; // eax@1
  char v3[4]; // edi@1
  int v4; // ebx@1
  int v5; // esi@1
  signed int v6; // ecx@1
  bool v7; // zf@1
  char *v8; // eax@6
  int v9; // edx@8
  char v10; // cl@9
  char *v11; // eax@11
  int v12; // edx@13
  char v13; // cl@14
  char *v14; // eax@16
  char *v15; // eax@19
  char v16[4]; // edi@22
  int v17; // esi@22
  signed int v18; // ecx@22
  bool v19; // zf@22
  int v21; // [sp+10h] [bp-18h]@4
  int v22; // [sp+14h] [bp-14h]@4
  int v23; // [sp+18h] [bp-10h]@4
  char v24[4]; // [sp+1Ch] [bp-Ch]@1
  int v25; // [sp+20h] [bp-8h]@5
  char *Str; // [sp+24h] [bp-4h]@5

  v2 = (int)"mom_kin_arc_output_mode";
  *(_DWORD *)v3 = "END";
  v4 = 0;
  v5 = (int)"mom_kin_arc_output_mode";
  v6 = 24;
  v7 = 1;
  *(_DWORD *)v24 = "END";
  do
  {
    if ( !v6 )
      break;
    v7 = *(_BYTE *)v5++ == **(_BYTE **)v3;
    ++*(_DWORD *)v3;
    --v6;
  }
  while ( v7 );
  v21 = (int)"mom_kin_arc_valid_plane";
  v22 = (int)"mom_kin_min_arc_radius";
  v23 = (int)"mom_kin_max_arc_radius";
  if ( !v7 )
  {
    do
    {
      v25 = UF_MOM_ask_string(a1, v2 + 4, &Str);
      switch ( v4 )
      {
        case 0:
          v8 = Str;
          if ( !Str )
          {
            v8 = "FULL_CIRCLE";
            Str = "FULL_CIRCLE";
          }
          v9 = a2 - (_DWORD)v8;
          do
          {
            v10 = *v8;
            v8[v9] = *v8;
            ++v8;
          }
          while ( v10 );
          break;
        case 1:
          v11 = Str;
          if ( !Str )
          {
            v11 = "XY";
            Str = "XY";
          }
          v12 = a2 - (_DWORD)v11 + 133;
          do
          {
            v13 = *v11;
            v11[v12] = *v11;
            ++v11;
          }
          while ( v13 );
          break;
        case 2:
          v14 = Str;
          if ( !Str )
          {
            v14 = "0.0001";
            Str = "0.0001";
          }
          *(double *)(a2 + 272) = strtod(v14, 0);
          break;
        case 3:
          v15 = Str;
          if ( !Str )
          {
            v15 = "9999.9999";
            Str = "9999.9999";
          }
          *(double *)(a2 + 280) = strtod(v15, 0);
          break;
        default:
          break;
      }
      v2 = *(&v21 + v4++);
      *(_DWORD *)v16 = "END";
      v17 = v2;
      v18 = 4;
      v19 = 1;
      do
      {
        if ( !v18 )
          break;
        v19 = *(_BYTE *)v17++ == **(_BYTE **)v16;
        ++*(_DWORD *)v16;
        --v18;
      }
      while ( v19 );
    }
    while ( !v19 );
  }
  return v25;
}
// 100090D8: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10005F10) --------------------------------------------------------
int __cdecl sub_10005F10(int a1, int a2)
{
  int v2; // eax@1
  char v3[4]; // edi@1
  int v4; // esi@1
  signed int v5; // ecx@1
  bool v6; // zf@1
  int v7; // eax@5
  int v8; // esi@5
  char *v9; // eax@6
  char *v10; // eax@9
  char *v11; // eax@12
  char *v12; // eax@15
  char *v13; // eax@18
  char *v14; // eax@21
  char *v15; // eax@24
  char *v16; // eax@27
  char v17[4]; // edi@30
  int v18; // esi@30
  signed int v19; // ecx@30
  bool v20; // zf@30
  int v22; // [sp+Ch] [bp-2Ch]@4
  int v23; // [sp+10h] [bp-28h]@4
  int v24; // [sp+14h] [bp-24h]@4
  int v25; // [sp+18h] [bp-20h]@4
  int v26; // [sp+1Ch] [bp-1Ch]@4
  int v27; // [sp+20h] [bp-18h]@4
  int v28; // [sp+24h] [bp-14h]@4
  char v29[4]; // [sp+28h] [bp-10h]@1
  int v30; // [sp+2Ch] [bp-Ch]@5
  int v31; // [sp+30h] [bp-8h]@4
  char *Str; // [sp+34h] [bp-4h]@5

  v2 = (int)"mom_kin_max_fpm";
  *(_DWORD *)v3 = "END";
  v4 = (int)"mom_kin_max_fpm";
  v5 = 16;
  v6 = 1;
  *(_DWORD *)v29 = "END";
  do
  {
    if ( !v5 )
      break;
    v6 = *(_BYTE *)v4++ == **(_BYTE **)v3;
    ++*(_DWORD *)v3;
    --v5;
  }
  while ( v6 );
  v22 = (int)"mom_kin_min_fpm";
  v23 = (int)"mom_kin_max_fpr";
  v24 = (int)"mom_kin_min_fpr";
  v25 = (int)"mom_kin_max_frn";
  v26 = (int)"mom_kin_min_frn";
  v27 = (int)"mom_kin_max_dpm";
  v28 = (int)"mom_kin_min_dpm";
  v31 = 0;
  if ( !v6 )
  {
    do
    {
      v7 = UF_MOM_ask_string(a1, v2 + 4, &Str);
      v8 = v31;
      v30 = v7;
      switch ( v31 )
      {
        case 0:
          v9 = Str;
          if ( !Str )
          {
            v9 = "999.999";
            Str = "999.999";
          }
          *(double *)a2 = strtod(v9, 0);
          break;
        case 1:
          v10 = Str;
          if ( !Str )
          {
            v10 = "0.001";
            Str = "0.001";
          }
          *(double *)(a2 + 32) = strtod(v10, 0);
          break;
        case 2:
          v11 = Str;
          if ( !Str )
          {
            v11 = "99.999";
            Str = "99.999";
          }
          *(double *)(a2 + 8) = strtod(v11, 0);
          break;
        case 3:
          v12 = Str;
          if ( !Str )
          {
            v12 = "0.001";
            Str = "0.001";
          }
          *(double *)(a2 + 40) = strtod(v12, 0);
          break;
        case 4:
          v13 = Str;
          if ( !Str )
          {
            v13 = "99999.999";
            Str = "99999.999";
          }
          *(double *)(a2 + 16) = strtod(v13, 0);
          break;
        case 5:
          v14 = Str;
          if ( !Str )
          {
            v14 = "0.001";
            Str = "0.001";
          }
          *(double *)(a2 + 48) = strtod(v14, 0);
          break;
        case 6:
          v15 = Str;
          if ( !Str )
          {
            v15 = "99.999";
            Str = "99.999";
          }
          *(double *)(a2 + 24) = strtod(v15, 0);
          break;
        case 7:
          v16 = Str;
          if ( !Str )
          {
            v16 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 56) = strtod(v16, 0);
          break;
        default:
          break;
      }
      v2 = *(&v22 + v8);
      v31 = v8 + 1;
      *(_DWORD *)v17 = "END";
      v18 = v2;
      v19 = 4;
      v20 = 1;
      do
      {
        if ( !v19 )
          break;
        v20 = *(_BYTE *)v18++ == **(_BYTE **)v17;
        ++*(_DWORD *)v17;
        --v19;
      }
      while ( v20 );
    }
    while ( !v20 );
  }
  return v30;
}
// 100090D8: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (100060E0) --------------------------------------------------------
int __cdecl sub_100060E0(int a1, int a2)
{
  int v2; // eax@1
  char v3[4]; // edi@1
  int v4; // esi@1
  signed int v5; // ecx@1
  bool v6; // zf@1
  int v7; // eax@5
  int v8; // esi@5
  char *v9; // eax@6
  int v10; // edx@8
  char v11; // cl@9
  char *v12; // eax@11
  int v13; // edx@13
  char v14; // cl@14
  char *v15; // eax@16
  int v16; // edx@18
  char v17; // cl@19
  char *v18; // eax@21
  char *v19; // eax@24
  char *v20; // eax@27
  char *v21; // eax@30
  char *v22; // eax@33
  char *v23; // eax@36
  char *v24; // eax@39
  char *v25; // eax@42
  char *v26; // eax@45
  char *v27; // eax@48
  char *v28; // eax@51
  char *v29; // eax@54
  char v30[4]; // edi@57
  int v31; // esi@57
  signed int v32; // ecx@57
  bool v33; // zf@57
  int v35; // [sp+Ch] [bp-48h]@4
  int v36; // [sp+10h] [bp-44h]@4
  int v37; // [sp+14h] [bp-40h]@4
  int v38; // [sp+18h] [bp-3Ch]@4
  int v39; // [sp+1Ch] [bp-38h]@4
  int v40; // [sp+20h] [bp-34h]@4
  int v41; // [sp+24h] [bp-30h]@4
  int v42; // [sp+28h] [bp-2Ch]@4
  int v43; // [sp+2Ch] [bp-28h]@4
  int v44; // [sp+30h] [bp-24h]@4
  int v45; // [sp+34h] [bp-20h]@4
  int v46; // [sp+38h] [bp-1Ch]@4
  int v47; // [sp+3Ch] [bp-18h]@4
  int v48; // [sp+40h] [bp-14h]@4
  char v49[4]; // [sp+44h] [bp-10h]@1
  int v50; // [sp+48h] [bp-Ch]@5
  int v51; // [sp+4Ch] [bp-8h]@4
  char *Str; // [sp+50h] [bp-4h]@5

  v2 = (int)"mom_kin_4th_axis_plane";
  *(_DWORD *)v3 = "END";
  v4 = (int)"mom_kin_4th_axis_plane";
  v5 = 23;
  v6 = 1;
  *(_DWORD *)v49 = "END";
  do
  {
    if ( !v5 )
      break;
    v6 = *(_BYTE *)v4++ == **(_BYTE **)v3;
    ++*(_DWORD *)v3;
    --v5;
  }
  while ( v6 );
  v35 = (int)"mom_kin_4th_axis_direction";
  v36 = (int)"mom_kin_4th_axis_rotation";
  v37 = (int)"mom_kin_4th_axis_min_incr";
  v38 = (int)"mom_kin_4th_axis_min_limit";
  v39 = (int)"mom_kin_4th_axis_max_limit";
  v40 = (int)"mom_kin_4th_axis_zero";
  v41 = (int)"mom_kin_4th_axis_center_offset_x";
  v42 = (int)"mom_kin_4th_axis_center_offset_y";
  v43 = (int)"mom_kin_4th_axis_center_offset_z";
  v44 = (int)"mom_kin_4th_axis_vector_i";
  v45 = (int)"mom_kin_4th_axis_vector_j";
  v46 = (int)"mom_kin_4th_axis_vector_k";
  v47 = (int)"mom_kin_4th_axis_angles_a1";
  v48 = (int)"mom_kin_4th_axis_angles_a2";
  v51 = 0;
  if ( !v6 )
  {
    do
    {
      v7 = UF_MOM_ask_string(a1, v2 + 4, &Str);
      v8 = v51;
      v50 = v7;
      switch ( v51 )
      {
        case 0:
          v9 = Str;
          if ( !Str )
          {
            v9 = "YZ";
            Str = "YZ";
          }
          v10 = a2 - (_DWORD)v9;
          do
          {
            v11 = *v9;
            v9[v10] = *v9;
            ++v9;
          }
          while ( v11 );
          break;
        case 1:
          v12 = Str;
          if ( !Str )
          {
            v12 = "MAGNITUDE_DETERMINES_DIRECTION";
            Str = "MAGNITUDE_DETERMINES_DIRECTION";
          }
          v13 = a2 - (_DWORD)v12 + 133;
          do
          {
            v14 = *v12;
            v12[v13] = *v12;
            ++v12;
          }
          while ( v14 );
          break;
        case 2:
          v15 = Str;
          if ( !Str )
          {
            v15 = "STANDARD";
            Str = "STANDARD";
          }
          v16 = a2 - (_DWORD)v15 + 266;
          do
          {
            v17 = *v15;
            v15[v16] = *v15;
            ++v15;
          }
          while ( v17 );
          break;
        case 3:
          v18 = Str;
          if ( !Str )
          {
            v18 = "0.001";
            Str = "0.001";
          }
          *(double *)(a2 + 400) = strtod(v18, 0);
          break;
        case 4:
          v19 = Str;
          if ( !Str )
          {
            v19 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 408) = strtod(v19, 0);
          break;
        case 5:
          v20 = Str;
          if ( !Str )
          {
            v20 = "360.0";
            Str = "360.0";
          }
          *(double *)(a2 + 416) = strtod(v20, 0);
          break;
        case 6:
          v21 = Str;
          if ( !Str )
          {
            v21 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 424) = strtod(v21, 0);
          break;
        case 7:
          v22 = Str;
          if ( !Str )
          {
            v22 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 432) = strtod(v22, 0);
          break;
        case 8:
          v23 = Str;
          if ( !Str )
          {
            v23 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 440) = strtod(v23, 0);
          break;
        case 9:
          v24 = Str;
          if ( !Str )
          {
            v24 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 448) = strtod(v24, 0);
          break;
        case 10:
          v25 = Str;
          if ( !Str )
          {
            v25 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 456) = strtod(v25, 0);
          break;
        case 11:
          v26 = Str;
          if ( !Str )
          {
            v26 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 464) = strtod(v26, 0);
          break;
        case 12:
          v27 = Str;
          if ( !Str )
          {
            v27 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 472) = strtod(v27, 0);
          break;
        case 13:
          v28 = Str;
          if ( !Str )
          {
            v28 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 480) = strtod(v28, 0);
          break;
        case 14:
          v29 = Str;
          if ( !Str )
          {
            v29 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 488) = strtod(v29, 0);
          break;
        default:
          break;
      }
      v2 = *(&v35 + v8);
      v51 = v8 + 1;
      *(_DWORD *)v30 = "END";
      v31 = v2;
      v32 = 4;
      v33 = 1;
      do
      {
        if ( !v32 )
          break;
        v33 = *(_BYTE *)v31++ == **(_BYTE **)v30;
        ++*(_DWORD *)v30;
        --v32;
      }
      while ( v33 );
    }
    while ( !v33 );
  }
  return v50;
}
// 100090D8: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10006420) --------------------------------------------------------
int __cdecl sub_10006420(int a1, int a2)
{
  int v2; // eax@1
  char v3[4]; // edi@1
  int v4; // esi@1
  signed int v5; // ecx@1
  bool v6; // zf@1
  int v7; // eax@5
  int v8; // esi@5
  char *v9; // eax@6
  int v10; // edx@8
  char v11; // cl@9
  char *v12; // eax@11
  int v13; // edx@13
  char v14; // cl@14
  char *v15; // eax@16
  int v16; // edx@18
  char v17; // cl@19
  char *v18; // eax@21
  char *v19; // eax@24
  char *v20; // eax@27
  char *v21; // eax@30
  char *v22; // eax@33
  char *v23; // eax@36
  char *v24; // eax@39
  char *v25; // eax@42
  char *v26; // eax@45
  char *v27; // eax@48
  char *v28; // eax@51
  char *v29; // eax@54
  char v30[4]; // edi@57
  int v31; // esi@57
  signed int v32; // ecx@57
  bool v33; // zf@57
  int v35; // [sp+Ch] [bp-48h]@4
  int v36; // [sp+10h] [bp-44h]@4
  int v37; // [sp+14h] [bp-40h]@4
  int v38; // [sp+18h] [bp-3Ch]@4
  int v39; // [sp+1Ch] [bp-38h]@4
  int v40; // [sp+20h] [bp-34h]@4
  int v41; // [sp+24h] [bp-30h]@4
  int v42; // [sp+28h] [bp-2Ch]@4
  int v43; // [sp+2Ch] [bp-28h]@4
  int v44; // [sp+30h] [bp-24h]@4
  int v45; // [sp+34h] [bp-20h]@4
  int v46; // [sp+38h] [bp-1Ch]@4
  int v47; // [sp+3Ch] [bp-18h]@4
  int v48; // [sp+40h] [bp-14h]@4
  char v49[4]; // [sp+44h] [bp-10h]@1
  int v50; // [sp+48h] [bp-Ch]@5
  int v51; // [sp+4Ch] [bp-8h]@4
  char *Str; // [sp+50h] [bp-4h]@5

  v2 = (int)"mom_kin_5th_axis_plane";
  *(_DWORD *)v3 = "END";
  v4 = (int)"mom_kin_5th_axis_plane";
  v5 = 23;
  v6 = 1;
  *(_DWORD *)v49 = "END";
  do
  {
    if ( !v5 )
      break;
    v6 = *(_BYTE *)v4++ == **(_BYTE **)v3;
    ++*(_DWORD *)v3;
    --v5;
  }
  while ( v6 );
  v35 = (int)"mom_kin_5th_axis_direction";
  v36 = (int)"mom_kin_5th_axis_rotation";
  v37 = (int)"mom_kin_5th_axis_min_incr";
  v38 = (int)"mom_kin_5th_axis_min_limit";
  v39 = (int)"mom_kin_5th_axis_max_limit";
  v40 = (int)"mom_kin_5th_axis_zero";
  v41 = (int)"mom_kin_5th_axis_center_offset_x";
  v42 = (int)"mom_kin_5th_axis_center_offset_y";
  v43 = (int)"mom_kin_5th_axis_center_offset_z";
  v44 = (int)"mom_kin_5th_axis_vector_i";
  v45 = (int)"mom_kin_5th_axis_vector_j";
  v46 = (int)"mom_kin_5th_axis_vector_k";
  v47 = (int)"mom_kin_5th_axis_angles_a1";
  v48 = (int)"mom_kin_5th_axis_angles_a2";
  v51 = 0;
  if ( !v6 )
  {
    do
    {
      v7 = UF_MOM_ask_string(a1, v2 + 4, &Str);
      v8 = v51;
      v50 = v7;
      switch ( v51 )
      {
        case 0:
          v9 = Str;
          if ( !Str )
          {
            v9 = "YZ";
            Str = "YZ";
          }
          v10 = a2 - (_DWORD)v9;
          do
          {
            v11 = *v9;
            v9[v10] = *v9;
            ++v9;
          }
          while ( v11 );
          break;
        case 1:
          v12 = Str;
          if ( !Str )
          {
            v12 = "MAGNITUDE_DETERMINES_DIRECTION";
            Str = "MAGNITUDE_DETERMINES_DIRECTION";
          }
          v13 = a2 - (_DWORD)v12 + 133;
          do
          {
            v14 = *v12;
            v12[v13] = *v12;
            ++v12;
          }
          while ( v14 );
          break;
        case 2:
          v15 = Str;
          if ( !Str )
          {
            v15 = "STANDARD";
            Str = "STANDARD";
          }
          v16 = a2 - (_DWORD)v15 + 266;
          do
          {
            v17 = *v15;
            v15[v16] = *v15;
            ++v15;
          }
          while ( v17 );
          break;
        case 3:
          v18 = Str;
          if ( !Str )
          {
            v18 = "0.001";
            Str = "0.001";
          }
          *(double *)(a2 + 400) = strtod(v18, 0);
          break;
        case 4:
          v19 = Str;
          if ( !Str )
          {
            v19 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 408) = strtod(v19, 0);
          break;
        case 5:
          v20 = Str;
          if ( !Str )
          {
            v20 = "360.0";
            Str = "360.0";
          }
          *(double *)(a2 + 416) = strtod(v20, 0);
          break;
        case 6:
          v21 = Str;
          if ( !Str )
          {
            v21 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 424) = strtod(v21, 0);
          break;
        case 7:
          v22 = Str;
          if ( !Str )
          {
            v22 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 432) = strtod(v22, 0);
          break;
        case 8:
          v23 = Str;
          if ( !Str )
          {
            v23 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 440) = strtod(v23, 0);
          break;
        case 9:
          v24 = Str;
          if ( !Str )
          {
            v24 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 448) = strtod(v24, 0);
          break;
        case 10:
          v25 = Str;
          if ( !Str )
          {
            v25 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 456) = strtod(v25, 0);
          break;
        case 11:
          v26 = Str;
          if ( !Str )
          {
            v26 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 464) = strtod(v26, 0);
          break;
        case 12:
          v27 = Str;
          if ( !Str )
          {
            v27 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 472) = strtod(v27, 0);
          break;
        case 13:
          v28 = Str;
          if ( !Str )
          {
            v28 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 480) = strtod(v28, 0);
          break;
        case 14:
          v29 = Str;
          if ( !Str )
          {
            v29 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 488) = strtod(v29, 0);
          break;
        default:
          break;
      }
      v2 = *(&v35 + v8);
      v51 = v8 + 1;
      *(_DWORD *)v30 = "END";
      v31 = v2;
      v32 = 4;
      v33 = 1;
      do
      {
        if ( !v32 )
          break;
        v33 = *(_BYTE *)v31++ == **(_BYTE **)v30;
        ++*(_DWORD *)v30;
        --v32;
      }
      while ( v33 );
    }
    while ( !v33 );
  }
  return v50;
}
// 100090D8: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10006760) --------------------------------------------------------
int __cdecl sub_10006760(int a1, int a2)
{
  int v2; // eax@1
  char v3[4]; // edi@1
  int v4; // ebx@1
  int v5; // esi@1
  signed int v6; // ecx@1
  bool v7; // zf@1
  char *v8; // eax@8
  char *v9; // eax@11
  char *v10; // eax@14
  int v11; // edx@16
  char v12; // cl@17
  char v13[4]; // edi@18
  int v14; // esi@18
  signed int v15; // ecx@18
  bool v16; // zf@18
  int v18; // [sp+10h] [bp-14h]@4
  int v19; // [sp+14h] [bp-10h]@4
  char v20[4]; // [sp+18h] [bp-Ch]@1
  int v21; // [sp+1Ch] [bp-8h]@5
  char *Str; // [sp+20h] [bp-4h]@5

  v2 = (int)"mom_kin_independent_head";
  *(_DWORD *)v3 = "END";
  v4 = 0;
  v5 = (int)"mom_kin_independent_head";
  v6 = 25;
  v7 = 1;
  *(_DWORD *)v20 = "END";
  do
  {
    if ( !v6 )
      break;
    v7 = *(_BYTE *)v5++ == **(_BYTE **)v3;
    ++*(_DWORD *)v3;
    --v6;
  }
  while ( v7 );
  v18 = (int)"mom_kin_ind_to_dependent_head_x";
  v19 = (int)"mom_kin_ind_to_dependent_head_z";
  if ( !v7 )
  {
    do
    {
      v21 = UF_MOM_ask_string(a1, v2 + 4, &Str);
      if ( v4 )
      {
        if ( v4 == 1 )
        {
          v9 = Str;
          if ( !Str )
          {
            v9 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 136) = strtod(v9, 0);
        }
        else
        {
          if ( v4 == 2 )
          {
            v8 = Str;
            if ( !Str )
            {
              v8 = "0.0";
              Str = "0.0";
            }
            *(double *)(a2 + 144) = strtod(v8, 0);
          }
        }
      }
      else
      {
        v10 = Str;
        if ( !Str )
        {
          v10 = "FRONT";
          Str = "FRONT";
        }
        v11 = a2 - (_DWORD)v10;
        do
        {
          v12 = *v10;
          v10[v11] = *v10;
          ++v10;
        }
        while ( v12 );
      }
      v2 = *(&v18 + v4++);
      *(_DWORD *)v13 = "END";
      v14 = v2;
      v15 = 4;
      v16 = 1;
      do
      {
        if ( !v15 )
          break;
        v16 = *(_BYTE *)v14++ == **(_BYTE **)v13;
        ++*(_DWORD *)v13;
        --v15;
      }
      while ( v16 );
    }
    while ( !v16 );
  }
  return v21;
}
// 100090D8: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10006870) --------------------------------------------------------
int __cdecl sub_10006870(int a1, int a2)
{
  int v2; // eax@1
  char v3[4]; // edi@1
  int v4; // ebx@1
  int v5; // esi@1
  signed int v6; // ecx@1
  bool v7; // zf@1
  char *v8; // eax@8
  char *v9; // eax@11
  char *v10; // eax@14
  char v11[4]; // edi@17
  int v12; // esi@17
  signed int v13; // ecx@17
  bool v14; // zf@17
  int v16; // [sp+10h] [bp-14h]@4
  int v17; // [sp+14h] [bp-10h]@4
  char v18[4]; // [sp+18h] [bp-Ch]@1
  int v19; // [sp+1Ch] [bp-8h]@5
  char *Str; // [sp+20h] [bp-4h]@5

  v2 = (int)"mom_kin_tool_change_time";
  *(_DWORD *)v3 = "END";
  v4 = 0;
  v5 = (int)"mom_kin_tool_change_time";
  v6 = 25;
  v7 = 1;
  *(_DWORD *)v18 = "END";
  do
  {
    if ( !v6 )
      break;
    v7 = *(_BYTE *)v5++ == **(_BYTE **)v3;
    ++*(_DWORD *)v3;
    --v6;
  }
  while ( v7 );
  v16 = (int)"mom_kin_clamp_time";
  v17 = (int)"mom_kin_flush_time";
  if ( !v7 )
  {
    do
    {
      v19 = UF_MOM_ask_string(a1, v2 + 4, &Str);
      if ( v4 )
      {
        if ( v4 == 1 )
        {
          v9 = Str;
          if ( !Str )
          {
            v9 = "0.5";
            Str = "0.5";
          }
          *(double *)(a2 + 8) = strtod(v9, 0);
        }
        else
        {
          if ( v4 == 2 )
          {
            v8 = Str;
            if ( !Str )
            {
              v8 = "0.5";
              Str = "0.5";
            }
            *(double *)(a2 + 16) = strtod(v8, 0);
          }
        }
      }
      else
      {
        v10 = Str;
        if ( !Str )
        {
          v10 = "3.0";
          Str = "3.0";
        }
        *(double *)a2 = strtod(v10, 0);
      }
      v2 = *(&v16 + v4++);
      *(_DWORD *)v11 = "END";
      v12 = v2;
      v13 = 4;
      v14 = 1;
      do
      {
        if ( !v13 )
          break;
        v14 = *(_BYTE *)v12++ == **(_BYTE **)v11;
        ++*(_DWORD *)v11;
        --v13;
      }
      while ( v14 );
    }
    while ( !v14 );
  }
  return v19;
}
// 100090D8: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10006960) --------------------------------------------------------
int __cdecl sub_10006960(int a1, int a2)
{
  int v2; // eax@1
  char v3[4]; // edi@1
  int v4; // esi@1
  signed int v5; // ecx@1
  bool v6; // zf@1
  char *v7; // eax@6
  int v8; // edx@8
  char v9; // cl@9
  char *v10; // eax@11
  int v11; // edx@13
  char v12; // cl@14
  char *v13; // eax@16
  int v14; // edx@18
  char v15; // cl@19
  char *v16; // eax@21
  int v17; // edx@23
  char v18; // cl@24
  char *v19; // eax@26
  int v20; // edx@28
  char v21; // cl@29
  char *v22; // eax@31
  int v23; // edx@33
  char v24; // cl@34
  char *v25; // eax@36
  char *v26; // eax@39
  char *v27; // eax@42
  char *v28; // eax@45
  char *v29; // eax@48
  char *v30; // eax@51
  char *v31; // eax@54
  char *v32; // eax@57
  char *v33; // eax@60
  char *v34; // eax@63
  char *v35; // eax@66
  char *v36; // eax@69
  char *v37; // eax@72
  char *v38; // eax@75
  char *v39; // eax@78
  char *v40; // eax@81
  char *v41; // eax@84
  char *v42; // eax@87
  int v43; // eax@90
  char v44[4]; // edi@90
  int v45; // esi@90
  signed int v46; // ecx@90
  bool v47; // zf@90
  int v49; // [sp+8h] [bp-70h]@4
  int v50; // [sp+Ch] [bp-6Ch]@4
  int v51; // [sp+10h] [bp-68h]@4
  int v52; // [sp+14h] [bp-64h]@4
  int v53; // [sp+18h] [bp-60h]@4
  int v54; // [sp+1Ch] [bp-5Ch]@4
  int v55; // [sp+20h] [bp-58h]@4
  int v56; // [sp+24h] [bp-54h]@4
  int v57; // [sp+28h] [bp-50h]@4
  int v58; // [sp+2Ch] [bp-4Ch]@4
  int v59; // [sp+30h] [bp-48h]@4
  int v60; // [sp+34h] [bp-44h]@4
  int v61; // [sp+38h] [bp-40h]@4
  int v62; // [sp+3Ch] [bp-3Ch]@4
  int v63; // [sp+40h] [bp-38h]@4
  int v64; // [sp+44h] [bp-34h]@4
  int v65; // [sp+48h] [bp-30h]@4
  int v66; // [sp+4Ch] [bp-2Ch]@4
  int v67; // [sp+50h] [bp-28h]@4
  int v68; // [sp+54h] [bp-24h]@4
  int v69; // [sp+58h] [bp-20h]@4
  int v70; // [sp+5Ch] [bp-1Ch]@4
  int v71; // [sp+60h] [bp-18h]@4
  int v72; // [sp+64h] [bp-14h]@4
  char v73[4]; // [sp+68h] [bp-10h]@1
  int v74; // [sp+6Ch] [bp-Ch]@5
  int v75; // [sp+70h] [bp-8h]@4
  char *Str; // [sp+74h] [bp-4h]@5

  v2 = (int)"mom_kin_holder1_orientation";
  *(_DWORD *)v3 = "END";
  v4 = (int)"mom_kin_holder1_orientation";
  v5 = 28;
  v6 = 1;
  *(_DWORD *)v73 = "END";
  do
  {
    if ( !v5 )
      break;
    v6 = *(_BYTE *)v4++ == **(_BYTE **)v3;
    ++*(_DWORD *)v3;
    --v5;
  }
  while ( v6 );
  v49 = (int)"mom_kin_holder1_orientation";
  v50 = (int)"mom_kin_holder2_orientation";
  v51 = (int)"mom_kin_holder3_orientation";
  v52 = (int)"mom_kin_holder4_orientation";
  v53 = (int)"mom_kin_holder5_orientation";
  v54 = (int)"mom_kin_holder6_orientation";
  v55 = (int)"mom_kin_holder1_offset_x";
  v56 = (int)"mom_kin_holder1_offset_y";
  v57 = (int)"mom_kin_holder1_offset_z";
  v58 = (int)"mom_kin_holder2_offset_x";
  v59 = (int)"mom_kin_holder2_offset_y";
  v60 = (int)"mom_kin_holder2_offset_z";
  v61 = (int)"mom_kin_holder3_offset_x";
  v62 = (int)"mom_kin_holder3_offset_y";
  v63 = (int)"mom_kin_holder3_offset_z";
  v64 = (int)"mom_kin_holder4_offset_x";
  v65 = (int)"mom_kin_holder4_offset_y";
  v66 = (int)"mom_kin_holder4_offset_z";
  v67 = (int)"mom_kin_holder5_offset_x";
  v68 = (int)"mom_kin_holder5_offset_y";
  v69 = (int)"mom_kin_holder5_offset_z";
  v70 = (int)"mom_kin_holder6_offset_x";
  v71 = (int)"mom_kin_holder6_offset_y";
  v72 = (int)"mom_kin_holder6_offset_z";
  v75 = 0;
  if ( !v6 )
  {
    do
    {
      v74 = UF_MOM_ask_string(a1, v2 + 4, &Str);
      switch ( v75 )
      {
        case 0:
          v7 = Str;
          if ( !Str )
          {
            v7 = "POSZ";
            Str = "POSZ";
          }
          v8 = a2 - (_DWORD)v7;
          do
          {
            v9 = *v7;
            v7[v8] = *v7;
            ++v7;
          }
          while ( v9 );
          break;
        case 1:
          v10 = Str;
          if ( !Str )
          {
            v10 = "POSZ";
            Str = "POSZ";
          }
          v11 = a2 - (_DWORD)v10 + 133;
          do
          {
            v12 = *v10;
            v10[v11] = *v10;
            ++v10;
          }
          while ( v12 );
          break;
        case 2:
          v13 = Str;
          if ( !Str )
          {
            v13 = "POSZ";
            Str = "POSZ";
          }
          v14 = a2 - (_DWORD)v13 + 266;
          do
          {
            v15 = *v13;
            v13[v14] = *v13;
            ++v13;
          }
          while ( v15 );
          break;
        case 3:
          v16 = Str;
          if ( !Str )
          {
            v16 = "POSZ";
            Str = "POSZ";
          }
          v17 = a2 - (_DWORD)v16 + 399;
          do
          {
            v18 = *v16;
            v16[v17] = *v16;
            ++v16;
          }
          while ( v18 );
          break;
        case 4:
          v19 = Str;
          if ( !Str )
          {
            v19 = "POSZ";
            Str = "POSZ";
          }
          v20 = a2 - (_DWORD)v19 + 532;
          do
          {
            v21 = *v19;
            v19[v20] = *v19;
            ++v19;
          }
          while ( v21 );
          break;
        case 5:
          v22 = Str;
          if ( !Str )
          {
            v22 = "POSZ";
            Str = "POSZ";
          }
          v23 = a2 - (_DWORD)v22 + 665;
          do
          {
            v24 = *v22;
            v22[v23] = *v22;
            ++v22;
          }
          while ( v24 );
          break;
        case 6:
          v25 = Str;
          if ( !Str )
          {
            v25 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 800) = strtod(v25, 0);
          break;
        case 7:
          v26 = Str;
          if ( !Str )
          {
            v26 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 808) = strtod(v26, 0);
          break;
        case 8:
          v27 = Str;
          if ( !Str )
          {
            v27 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 816) = strtod(v27, 0);
          break;
        case 9:
          v28 = Str;
          if ( !Str )
          {
            v28 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 824) = strtod(v28, 0);
          break;
        case 10:
          v29 = Str;
          if ( !Str )
          {
            v29 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 832) = strtod(v29, 0);
          break;
        case 11:
          v30 = Str;
          if ( !Str )
          {
            v30 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 840) = strtod(v30, 0);
          break;
        case 12:
          v31 = Str;
          if ( !Str )
          {
            v31 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 848) = strtod(v31, 0);
          break;
        case 13:
          v32 = Str;
          if ( !Str )
          {
            v32 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 856) = strtod(v32, 0);
          break;
        case 14:
          v33 = Str;
          if ( !Str )
          {
            v33 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 864) = strtod(v33, 0);
          break;
        case 15:
          v34 = Str;
          if ( !Str )
          {
            v34 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 872) = strtod(v34, 0);
          break;
        case 16:
          v35 = Str;
          if ( !Str )
          {
            v35 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 880) = strtod(v35, 0);
          break;
        case 17:
          v36 = Str;
          if ( !Str )
          {
            v36 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 888) = strtod(v36, 0);
          break;
        case 18:
          v37 = Str;
          if ( !Str )
          {
            v37 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 896) = strtod(v37, 0);
          break;
        case 19:
          v38 = Str;
          if ( !Str )
          {
            v38 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 904) = strtod(v38, 0);
          break;
        case 20:
          v39 = Str;
          if ( !Str )
          {
            v39 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 912) = strtod(v39, 0);
          break;
        case 21:
          v40 = Str;
          if ( !Str )
          {
            v40 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 920) = strtod(v40, 0);
          break;
        case 22:
          v41 = Str;
          if ( !Str )
          {
            v41 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 928) = strtod(v41, 0);
          break;
        case 23:
          v42 = Str;
          if ( !Str )
          {
            v42 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 936) = strtod(v42, 0);
          break;
        default:
          break;
      }
      v43 = v75 + 1;
      v75 = v43;
      v2 = *(&v49 + v43);
      *(_DWORD *)v44 = "END";
      v45 = v2;
      v46 = 4;
      v47 = 1;
      do
      {
        if ( !v46 )
          break;
        v47 = *(_BYTE *)v45++ == **(_BYTE **)v44;
        ++*(_DWORD *)v44;
        --v46;
      }
      while ( v47 );
    }
    while ( !v47 );
  }
  return v74;
}
// 100090D8: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10006E70) --------------------------------------------------------
int __cdecl sub_10006E70(int a1, int a2)
{
  char v2[4]; // edi@1
  int v3; // esi@1
  signed int v4; // ecx@1
  bool v5; // zf@1
  int v6; // eax@5
  char *v7; // eax@7
  int v8; // edx@9
  char v9; // cl@10
  char *v10; // eax@12
  int v11; // edx@14
  char v12; // cl@15
  char *v13; // eax@17
  int v14; // edx@19
  char v15; // cl@20
  char *v16; // eax@22
  int v17; // edx@24
  char v18; // cl@25
  char *v19; // eax@27
  int v20; // edx@29
  char v21; // cl@30
  char *v22; // eax@32
  int v23; // edx@34
  char v24; // cl@35
  char *v25; // eax@37
  char *v26; // eax@40
  char *v27; // eax@43
  char *v28; // eax@46
  char *v29; // ecx@49
  int v30; // eax@50
  char *v31; // ecx@54
  int v32; // eax@55
  char *v33; // ecx@59
  int v34; // eax@60
  int v35; // eax@64
  char v36[4]; // edi@64
  int v37; // esi@64
  signed int v38; // ecx@64
  bool v39; // zf@64
  char v41; // [sp+Ch] [bp-9Ch]@55
  char v42; // [sp+28h] [bp-80h]@60
  char v43; // [sp+44h] [bp-64h]@50
  int v44; // [sp+60h] [bp-48h]@4
  int v45; // [sp+64h] [bp-44h]@4
  int v46; // [sp+68h] [bp-40h]@4
  int v47; // [sp+6Ch] [bp-3Ch]@4
  int v48; // [sp+70h] [bp-38h]@4
  int v49; // [sp+74h] [bp-34h]@4
  int v50; // [sp+78h] [bp-30h]@4
  int v51; // [sp+7Ch] [bp-2Ch]@4
  int v52; // [sp+80h] [bp-28h]@4
  int v53; // [sp+84h] [bp-24h]@4
  int v54; // [sp+88h] [bp-20h]@1
  int v55; // [sp+8Ch] [bp-1Ch]@4
  int v56; // [sp+90h] [bp-18h]@1
  char v57[4]; // [sp+94h] [bp-14h]@1
  int v58; // [sp+98h] [bp-10h]@6
  int v59; // [sp+9Ch] [bp-Ch]@4
  int v60; // [sp+A0h] [bp-8h]@50
  char *Str; // [sp+A4h] [bp-4h]@6

  *(_DWORD *)v2 = "END";
  v54 = (int)"mom_kin_gauge_to_pivot_x";
  v56 = (int)"mom_kin_gauge_to_pivot_x";
  v3 = (int)"mom_kin_machine_type";
  v4 = 21;
  v5 = 1;
  *(_DWORD *)v57 = "END";
  do
  {
    if ( !v4 )
      break;
    v5 = *(_BYTE *)v3++ == **(_BYTE **)v2;
    ++*(_DWORD *)v2;
    --v4;
  }
  while ( v5 );
  v44 = (int)"mom_kin_machine_type";
  v45 = (int)"mom_kin_track_center_of_ball";
  v46 = (int)"mom_kin_wire_tilt_output_type";
  v47 = (int)"mom_kin_clsf_generation";
  v48 = (int)"mom_kin_coordinate_type";
  v49 = (int)"mom_kin_linearization_flag";
  v50 = (int)"mom_kin_machine_resolution";
  v51 = (int)"mom_kin_tool_tracking_height";
  v52 = (int)"mom_kin_5th_axis_inclination_to_4th";
  v53 = (int)"mom_kin_linearization_tol";
  v55 = (int)"mom_kin_gauge_to_pivot_y";
  v59 = 0;
  if ( !v5 )
  {
    v6 = (int)"mom_kin_machine_type";
    do
    {
      v58 = UF_MOM_ask_string(a1, v6 + 4, &Str);
      switch ( v59 )
      {
        case 0:
          v7 = Str;
          if ( !Str )
          {
            v7 = "3_axis_mill";
            Str = "3_axis_mill";
          }
          v8 = a2 - (_DWORD)v7;
          do
          {
            v9 = *v7;
            v7[v8] = *v7;
            ++v7;
          }
          while ( v9 );
          break;
        case 1:
          v10 = Str;
          if ( !Str )
          {
            v10 = "T";
            Str = "T";
          }
          v11 = a2 - (_DWORD)v10 + 133;
          do
          {
            v12 = *v10;
            v10[v11] = *v10;
            ++v10;
          }
          while ( v12 );
          break;
        case 2:
          v13 = Str;
          if ( !Str )
          {
            v13 = "NONE";
            Str = "NONE";
          }
          v14 = a2 - (_DWORD)v13 + 266;
          do
          {
            v15 = *v13;
            v13[v14] = *v13;
            ++v13;
          }
          while ( v15 );
          break;
        case 3:
          v16 = Str;
          if ( !Str )
          {
            v16 = "F";
            Str = "F";
          }
          v17 = a2 - (_DWORD)v16 + 399;
          do
          {
            v18 = *v16;
            v16[v17] = *v16;
            ++v16;
          }
          while ( v18 );
          break;
        case 4:
          v19 = Str;
          if ( !Str )
          {
            v19 = "CARTESIAN";
            Str = "CARTESIAN";
          }
          v20 = a2 - (_DWORD)v19 + 532;
          do
          {
            v21 = *v19;
            v19[v20] = *v19;
            ++v19;
          }
          while ( v21 );
          break;
        case 5:
          v22 = Str;
          if ( !Str )
          {
            v22 = "F";
            Str = "F";
          }
          v23 = a2 - (_DWORD)v22 + 665;
          do
          {
            v24 = *v22;
            v22[v23] = *v22;
            ++v22;
          }
          while ( v24 );
          break;
        case 6:
          v25 = Str;
          if ( !Str )
          {
            v25 = "0.0001";
            Str = "0.0001";
          }
          *(double *)(a2 + 800) = strtod(v25, 0);
          break;
        case 7:
          v26 = Str;
          if ( !Str )
          {
            v26 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 808) = strtod(v26, 0);
          break;
        case 8:
          v27 = Str;
          if ( !Str )
          {
            v27 = "90.0";
            Str = "90.0";
          }
          *(double *)(a2 + 816) = strtod(v27, 0);
          break;
        case 9:
          v28 = Str;
          if ( !Str )
          {
            v28 = "0.0001";
            Str = "0.0001";
          }
          *(double *)(a2 + 824) = strtod(v28, 0);
          break;
        case 10:
          v29 = Str;
          if ( !Str )
          {
            memcpy(&v43, "kin_4th_to_tracking_point_x", 0x1Cu);
            v60 = 0;
            v30 = UF_MOM_ask_string(a1, &v43, &v60);
            v29 = Str;
            if ( !Str || v30 )
            {
              v29 = "0.0";
              Str = "0.0";
            }
          }
          *(double *)(a2 + 832) = strtod(v29, 0);
          break;
        case 11:
          v31 = Str;
          if ( !Str )
          {
            memcpy(&v41, "kin_4th_to_tracking_point_y", 0x1Cu);
            v60 = 0;
            v32 = UF_MOM_ask_string(a1, &v41, &v60);
            v31 = Str;
            if ( !Str || v32 )
            {
              v31 = "0.0";
              Str = "0.0";
            }
          }
          *(double *)(a2 + 840) = strtod(v31, 0);
          break;
        case 12:
          v33 = Str;
          if ( !Str )
          {
            memcpy(&v42, "kin_4th_to_tracking_point_z", 0x1Cu);
            v60 = 0;
            v34 = UF_MOM_ask_string(a1, &v42, &v60);
            v33 = Str;
            if ( !Str || v34 )
            {
              v33 = "0.0";
              Str = "0.0";
            }
          }
          *(double *)(a2 + 848) = strtod(v33, 0);
          break;
        default:
          break;
      }
      v35 = v59 + 1;
      v59 = v35;
      v6 = *(&v44 + v35);
      *(_DWORD *)v36 = "END";
      v37 = v6;
      v38 = 4;
      v39 = 1;
      do
      {
        if ( !v38 )
          break;
        v39 = *(_BYTE *)v37++ == **(_BYTE **)v36;
        ++*(_DWORD *)v36;
        --v38;
      }
      while ( v39 );
    }
    while ( !v39 );
  }
  return v58;
}
// 100090D8: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10007240) --------------------------------------------------------
int __cdecl sub_10007240(int a1, int a2)
{
  int v2; // eax@1
  char v3[4]; // edi@1
  int v4; // esi@1
  signed int v5; // ecx@1
  bool v6; // zf@1
  int v7; // eax@5
  int v8; // esi@5
  char *v9; // eax@6
  char *v10; // eax@9
  char *v11; // eax@12
  char *v12; // eax@15
  char *v13; // eax@18
  char *v14; // eax@21
  char *v15; // eax@24
  char *v16; // eax@27
  char *v17; // eax@30
  char *v18; // eax@33
  char *v19; // eax@36
  char *v20; // eax@39
  char v21[4]; // edi@42
  int v22; // esi@42
  signed int v23; // ecx@42
  bool v24; // zf@42
  int v26; // [sp+Ch] [bp-3Ch]@4
  int v27; // [sp+10h] [bp-38h]@4
  int v28; // [sp+14h] [bp-34h]@4
  int v29; // [sp+18h] [bp-30h]@4
  int v30; // [sp+1Ch] [bp-2Ch]@4
  int v31; // [sp+20h] [bp-28h]@4
  int v32; // [sp+24h] [bp-24h]@4
  int v33; // [sp+28h] [bp-20h]@4
  int v34; // [sp+2Ch] [bp-1Ch]@4
  int v35; // [sp+30h] [bp-18h]@4
  int v36; // [sp+34h] [bp-14h]@4
  char v37[4]; // [sp+38h] [bp-10h]@1
  int v38; // [sp+3Ch] [bp-Ch]@5
  int v39; // [sp+40h] [bp-8h]@4
  char *Str; // [sp+44h] [bp-4h]@5

  v2 = (int)"mom_msys_origin_x";
  *(_DWORD *)v3 = "END";
  v4 = (int)"mom_msys_origin_x";
  v5 = 18;
  v6 = 1;
  *(_DWORD *)v37 = "END";
  do
  {
    if ( !v5 )
      break;
    v6 = *(_BYTE *)v4++ == **(_BYTE **)v3;
    ++*(_DWORD *)v3;
    --v5;
  }
  while ( v6 );
  v26 = (int)"mom_msys_origin_y";
  v27 = (int)"mom_msys_origin_z";
  v28 = (int)"mom_msys_x_axis_i";
  v29 = (int)"mom_msys_x_axis_j";
  v30 = (int)"mom_msys_x_axis_k";
  v31 = (int)"mom_msys_y_axis_i";
  v32 = (int)"mom_msys_y_axis_j";
  v33 = (int)"mom_msys_y_axis_k";
  v34 = (int)"mom_msys_z_axis_i";
  v35 = (int)"mom_msys_z_axis_j";
  v36 = (int)"mom_msys_z_axis_k";
  v39 = 0;
  if ( !v6 )
  {
    do
    {
      v7 = UF_MOM_ask_string(a1, v2 + 4, &Str);
      v8 = v39;
      v38 = v7;
      switch ( v39 )
      {
        case 0:
          v9 = Str;
          if ( !Str )
          {
            v9 = "0.0";
            Str = "0.0";
          }
          *(double *)a2 = strtod(v9, 0);
          break;
        case 1:
          v10 = Str;
          if ( !Str )
          {
            v10 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 8) = strtod(v10, 0);
          break;
        case 2:
          v11 = Str;
          if ( !Str )
          {
            v11 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 16) = strtod(v11, 0);
          break;
        case 3:
          v12 = Str;
          if ( !Str )
          {
            v12 = "1.0";
            Str = "1.0";
          }
          *(double *)(a2 + 24) = strtod(v12, 0);
          break;
        case 4:
          v13 = Str;
          if ( !Str )
          {
            v13 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 32) = strtod(v13, 0);
          break;
        case 5:
          v14 = Str;
          if ( !Str )
          {
            v14 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 40) = strtod(v14, 0);
          break;
        case 6:
          v15 = Str;
          if ( !Str )
          {
            v15 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 48) = strtod(v15, 0);
          break;
        case 7:
          v16 = Str;
          if ( !Str )
          {
            v16 = "1.0";
            Str = "1.0";
          }
          *(double *)(a2 + 56) = strtod(v16, 0);
          break;
        case 8:
          v17 = Str;
          if ( !Str )
          {
            v17 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 64) = strtod(v17, 0);
          break;
        case 9:
          v18 = Str;
          if ( !Str )
          {
            v18 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 72) = strtod(v18, 0);
          break;
        case 10:
          v19 = Str;
          if ( !Str )
          {
            v19 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 80) = strtod(v19, 0);
          break;
        case 11:
          v20 = Str;
          if ( !Str )
          {
            v20 = "1.0";
            Str = "1.0";
          }
          *(double *)(a2 + 88) = strtod(v20, 0);
          break;
        default:
          break;
      }
      v2 = *(&v26 + v8);
      v39 = v8 + 1;
      *(_DWORD *)v21 = "END";
      v22 = v2;
      v23 = 4;
      v24 = 1;
      do
      {
        if ( !v23 )
          break;
        v24 = *(_BYTE *)v22++ == **(_BYTE **)v21;
        ++*(_DWORD *)v21;
        --v23;
      }
      while ( v24 );
    }
    while ( !v24 );
  }
  return v38;
}
// 100090D8: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (100074C0) --------------------------------------------------------
int __cdecl sub_100074C0(int a1, int a2)
{
  int v2; // eax@1
  char v3[4]; // edi@1
  int v4; // esi@1
  signed int v5; // ecx@1
  bool v6; // zf@1
  int v7; // eax@5
  int v8; // esi@5
  char *v9; // eax@6
  char *v10; // eax@9
  char *v11; // eax@12
  char *v12; // eax@15
  char *v13; // eax@18
  char *v14; // eax@21
  char *v15; // eax@24
  char *v16; // eax@27
  char *v17; // eax@30
  char *v18; // eax@33
  char *v19; // eax@36
  char *v20; // eax@39
  char v21[4]; // edi@42
  int v22; // esi@42
  signed int v23; // ecx@42
  bool v24; // zf@42
  int v26; // [sp+Ch] [bp-3Ch]@4
  int v27; // [sp+10h] [bp-38h]@4
  int v28; // [sp+14h] [bp-34h]@4
  int v29; // [sp+18h] [bp-30h]@4
  int v30; // [sp+1Ch] [bp-2Ch]@4
  int v31; // [sp+20h] [bp-28h]@4
  int v32; // [sp+24h] [bp-24h]@4
  int v33; // [sp+28h] [bp-20h]@4
  int v34; // [sp+2Ch] [bp-1Ch]@4
  int v35; // [sp+30h] [bp-18h]@4
  int v36; // [sp+34h] [bp-14h]@4
  char v37[4]; // [sp+38h] [bp-10h]@1
  int v38; // [sp+3Ch] [bp-Ch]@5
  int v39; // [sp+40h] [bp-8h]@4
  char *Str; // [sp+44h] [bp-4h]@5

  v2 = (int)"mom_mtsys_origin_x";
  *(_DWORD *)v3 = "END";
  v4 = (int)"mom_mtsys_origin_x";
  v5 = 19;
  v6 = 1;
  *(_DWORD *)v37 = "END";
  do
  {
    if ( !v5 )
      break;
    v6 = *(_BYTE *)v4++ == **(_BYTE **)v3;
    ++*(_DWORD *)v3;
    --v5;
  }
  while ( v6 );
  v26 = (int)"mom_mtsys_origin_y";
  v27 = (int)"mom_mtsys_origin_z";
  v28 = (int)"mom_mtsys_x_axis_i";
  v29 = (int)"mom_mtsys_x_axis_j";
  v30 = (int)"mom_mtsys_x_axis_k";
  v31 = (int)"mom_mtsys_y_axis_i";
  v32 = (int)"mom_mtsys_y_axis_j";
  v33 = (int)"mom_mtsys_y_axis_k";
  v34 = (int)"mom_mtsys_z_axis_i";
  v35 = (int)"mom_mtsys_z_axis_j";
  v36 = (int)"mom_mtsys_z_axis_k";
  v39 = 0;
  if ( !v6 )
  {
    do
    {
      v7 = UF_MOM_ask_string(a1, v2 + 4, &Str);
      v8 = v39;
      v38 = v7;
      switch ( v39 )
      {
        case 0:
          v9 = Str;
          if ( !Str )
          {
            v9 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 96) = strtod(v9, 0);
          break;
        case 1:
          v10 = Str;
          if ( !Str )
          {
            v10 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 104) = strtod(v10, 0);
          break;
        case 2:
          v11 = Str;
          if ( !Str )
          {
            v11 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 112) = strtod(v11, 0);
          break;
        case 3:
          v12 = Str;
          if ( !Str )
          {
            v12 = "1.0";
            Str = "1.0";
          }
          *(double *)(a2 + 120) = strtod(v12, 0);
          break;
        case 4:
          v13 = Str;
          if ( !Str )
          {
            v13 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 128) = strtod(v13, 0);
          break;
        case 5:
          v14 = Str;
          if ( !Str )
          {
            v14 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 136) = strtod(v14, 0);
          break;
        case 6:
          v15 = Str;
          if ( !Str )
          {
            v15 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 144) = strtod(v15, 0);
          break;
        case 7:
          v16 = Str;
          if ( !Str )
          {
            v16 = "1.0";
            Str = "1.0";
          }
          *(double *)(a2 + 152) = strtod(v16, 0);
          break;
        case 8:
          v17 = Str;
          if ( !Str )
          {
            v17 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 160) = strtod(v17, 0);
          break;
        case 9:
          v18 = Str;
          if ( !Str )
          {
            v18 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 168) = strtod(v18, 0);
          break;
        case 10:
          v19 = Str;
          if ( !Str )
          {
            v19 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 176) = strtod(v19, 0);
          break;
        case 11:
          v20 = Str;
          if ( !Str )
          {
            v20 = "1.0";
            Str = "1.0";
          }
          *(double *)(a2 + 184) = strtod(v20, 0);
          break;
        default:
          break;
      }
      v2 = *(&v26 + v8);
      v39 = v8 + 1;
      *(_DWORD *)v21 = "END";
      v22 = v2;
      v23 = 4;
      v24 = 1;
      do
      {
        if ( !v23 )
          break;
        v24 = *(_BYTE *)v22++ == **(_BYTE **)v21;
        ++*(_DWORD *)v21;
        --v23;
      }
      while ( v24 );
    }
    while ( !v24 );
  }
  return v38;
}
// 100090D8: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10007760) --------------------------------------------------------
int __cdecl sub_10007760(int a1, int a2)
{
  int v2; // eax@1
  char v3[4]; // edi@1
  int v4; // esi@1
  signed int v5; // ecx@1
  bool v6; // zf@1
  int v7; // esi@5
  char *v8; // eax@6
  char *v9; // eax@9
  char *v10; // eax@12
  char *v11; // eax@15
  char *v12; // eax@18
  char *v13; // eax@21
  char *v14; // eax@24
  int v15; // edx@26
  char v16; // cl@27
  char *v17; // eax@29
  char *v18; // eax@32
  char v19[4]; // edi@35
  int v20; // esi@35
  signed int v21; // ecx@35
  bool v22; // zf@35
  int v24; // [sp+Ch] [bp-2Ch]@4
  int v25; // [sp+10h] [bp-28h]@4
  int v26; // [sp+14h] [bp-24h]@4
  int v27; // [sp+18h] [bp-20h]@4
  int v28; // [sp+1Ch] [bp-1Ch]@4
  int v29; // [sp+20h] [bp-18h]@4
  int v30; // [sp+24h] [bp-14h]@4
  int v31; // [sp+28h] [bp-10h]@4
  char v32[4]; // [sp+2Ch] [bp-Ch]@1
  int v33; // [sp+30h] [bp-8h]@4
  char *Str; // [sp+34h] [bp-4h]@5

  v2 = (int)"mom_origin_x";
  *(_DWORD *)v3 = "END";
  v4 = (int)"mom_origin_x";
  v5 = 13;
  v6 = 1;
  *(_DWORD *)v32 = "END";
  do
  {
    if ( !v5 )
      break;
    v6 = *(_BYTE *)v4++ == **(_BYTE **)v3;
    ++*(_DWORD *)v3;
    --v5;
  }
  while ( v6 );
  v24 = (int)"mom_origin_y";
  v25 = (int)"mom_origin_z";
  v26 = (int)"mom_translate_x";
  v27 = (int)"mom_translate_y";
  v28 = (int)"mom_translate_z";
  v29 = (int)"mom_tool_type";
  v30 = (int)"mom_tool_z_offset";
  v31 = (int)"mom_tool_corner1_radius";
  v33 = 0;
  if ( !v6 )
  {
    do
    {
      UF_MOM_ask_string(a1, v2 + 4, &Str);
      v7 = v33;
      switch ( v33 )
      {
        case 0:
          v8 = Str;
          if ( !Str )
          {
            v8 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 216) = strtod(v8, 0);
          break;
        case 1:
          v9 = Str;
          if ( !Str )
          {
            v9 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 224) = strtod(v9, 0);
          break;
        case 2:
          v10 = Str;
          if ( !Str )
          {
            v10 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 232) = strtod(v10, 0);
          break;
        case 3:
          v11 = Str;
          if ( !Str )
          {
            v11 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 192) = strtod(v11, 0);
          break;
        case 4:
          v12 = Str;
          if ( !Str )
          {
            v12 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 200) = strtod(v12, 0);
          break;
        case 5:
          v13 = Str;
          if ( !Str )
          {
            v13 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 208) = strtod(v13, 0);
          break;
        case 6:
          v14 = Str;
          if ( !Str )
          {
            v14 = "MILL";
            Str = "MILL";
          }
          v15 = a2 - (_DWORD)v14 + 240;
          do
          {
            v16 = *v14;
            v14[v15] = *v14;
            ++v14;
          }
          while ( v16 );
          break;
        case 7:
          v17 = Str;
          if ( !Str )
          {
            v17 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 376) = strtod(v17, 0);
          break;
        case 8:
          v18 = Str;
          if ( !Str )
          {
            v18 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 384) = strtod(v18, 0);
          break;
        default:
          break;
      }
      v2 = *(&v24 + v7);
      v33 = v7 + 1;
      *(_DWORD *)v19 = "END";
      v20 = v2;
      v21 = 4;
      v22 = 1;
      do
      {
        if ( !v21 )
          break;
        v22 = *(_BYTE *)v20++ == **(_BYTE **)v19;
        ++*(_DWORD *)v19;
        --v21;
      }
      while ( v22 );
    }
    while ( !v22 );
  }
  return 0;
}
// 100090D8: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10007980) --------------------------------------------------------
int __cdecl sub_10007980(int a1, int a2)
{
  int v2; // eax@1
  char v3[4]; // edi@1
  int v4; // esi@1
  signed int v5; // ecx@1
  bool v6; // zf@1
  int v7; // eax@5
  int v8; // esi@5
  char *v9; // eax@6
  char *v10; // eax@9
  char *v11; // eax@12
  char *v12; // eax@15
  char *v13; // eax@18
  char *v14; // eax@21
  char v15[4]; // edi@24
  int v16; // esi@24
  signed int v17; // ecx@24
  bool v18; // zf@24
  int v20; // [sp+Ch] [bp-24h]@4
  int v21; // [sp+10h] [bp-20h]@4
  int v22; // [sp+14h] [bp-1Ch]@4
  int v23; // [sp+18h] [bp-18h]@4
  int v24; // [sp+1Ch] [bp-14h]@4
  char v25[4]; // [sp+20h] [bp-10h]@1
  int v26; // [sp+24h] [bp-Ch]@5
  int v27; // [sp+28h] [bp-8h]@4
  char *Str; // [sp+2Ch] [bp-4h]@5

  v2 = (int)"mom_mcs_goto_x";
  *(_DWORD *)v3 = "END";
  v4 = (int)"mom_mcs_goto_x";
  v5 = 15;
  v6 = 1;
  *(_DWORD *)v25 = "END";
  do
  {
    if ( !v5 )
      break;
    v6 = *(_BYTE *)v4++ == **(_BYTE **)v3;
    ++*(_DWORD *)v3;
    --v5;
  }
  while ( v6 );
  v20 = (int)"mom_mcs_goto_y";
  v21 = (int)"mom_mcs_goto_z";
  v22 = (int)"mom_tool_axis_i";
  v23 = (int)"mom_tool_axis_j";
  v24 = (int)"mom_tool_axis_k";
  v27 = 0;
  if ( !v6 )
  {
    do
    {
      v7 = UF_MOM_ask_string(a1, v2 + 4, &Str);
      v8 = v27;
      v26 = v7;
      switch ( v27 )
      {
        case 0:
          v9 = Str;
          if ( !Str )
          {
            v9 = "0.0";
            Str = "0.0";
          }
          *(double *)a2 = strtod(v9, 0);
          break;
        case 1:
          v10 = Str;
          if ( !Str )
          {
            v10 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 8) = strtod(v10, 0);
          break;
        case 2:
          v11 = Str;
          if ( !Str )
          {
            v11 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 16) = strtod(v11, 0);
          break;
        case 3:
          v12 = Str;
          if ( !Str )
          {
            v12 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 24) = strtod(v12, 0);
          break;
        case 4:
          v13 = Str;
          if ( !Str )
          {
            v13 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 32) = strtod(v13, 0);
          break;
        case 5:
          v14 = Str;
          if ( !Str )
          {
            v14 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 40) = strtod(v14, 0);
          break;
        default:
          break;
      }
      v2 = *(&v20 + v8);
      v27 = v8 + 1;
      *(_DWORD *)v15 = "END";
      v16 = v2;
      v17 = 4;
      v18 = 1;
      do
      {
        if ( !v17 )
          break;
        v18 = *(_BYTE *)v16++ == **(_BYTE **)v15;
        ++*(_DWORD *)v15;
        --v17;
      }
      while ( v18 );
    }
    while ( !v18 );
  }
  return v26;
}
// 100090D8: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10007B00) --------------------------------------------------------
int __cdecl sub_10007B00(int a1, int a2)
{
  int v2; // eax@1
  char v3[4]; // edi@1
  int v4; // esi@1
  signed int v5; // ecx@1
  bool v6; // zf@1
  int v7; // eax@5
  int v8; // esi@5
  char *v9; // eax@6
  char *v10; // eax@9
  char *v11; // eax@12
  char *v12; // eax@15
  char *v13; // eax@18
  char *v14; // eax@21
  char *v15; // eax@24
  char *v16; // eax@27
  double v17; // st7@29
  int v18; // eax@29
  char *v19; // eax@30
  char v20[4]; // edi@33
  int v21; // esi@33
  signed int v22; // ecx@33
  bool v23; // zf@33
  int result; // eax@37
  int v25; // [sp+10h] [bp-30h]@4
  int v26; // [sp+14h] [bp-2Ch]@4
  int v27; // [sp+18h] [bp-28h]@4
  int v28; // [sp+1Ch] [bp-24h]@4
  int v29; // [sp+20h] [bp-20h]@4
  int v30; // [sp+24h] [bp-1Ch]@4
  int v31; // [sp+28h] [bp-18h]@4
  int v32; // [sp+2Ch] [bp-14h]@4
  char v33[4]; // [sp+30h] [bp-10h]@1
  int v34; // [sp+34h] [bp-Ch]@5
  int v35; // [sp+38h] [bp-8h]@4
  char *Str; // [sp+3Ch] [bp-4h]@5

  v2 = (int)"mom_origin_x";
  *(_DWORD *)v3 = "END";
  v4 = (int)"mom_origin_x";
  v5 = 13;
  v6 = 1;
  *(_DWORD *)v33 = "END";
  do
  {
    if ( !v5 )
      break;
    v6 = *(_BYTE *)v4++ == **(_BYTE **)v3;
    ++*(_DWORD *)v3;
    --v5;
  }
  while ( v6 );
  v25 = (int)"mom_origin_y";
  v26 = (int)"mom_origin_z";
  v27 = (int)"mom_translate_x";
  v28 = (int)"mom_translate_y";
  v29 = (int)"mom_translate_z";
  v30 = (int)"mom_tool_z_offset";
  v31 = (int)"mom_kin_track_center_of_ball";
  v32 = (int)"mom_tool_corner1_radius";
  v35 = 0;
  if ( !v6 )
  {
    do
    {
      v7 = UF_MOM_ask_string(a1, v2 + 4, &Str);
      v8 = v35;
      v34 = v7;
      switch ( v35 )
      {
        case 0:
          v9 = Str;
          if ( !Str )
          {
            v9 = "0.0";
            Str = "0.0";
          }
          *(double *)a2 = strtod(v9, 0);
          break;
        case 1:
          v10 = Str;
          if ( !Str )
          {
            v10 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 8) = strtod(v10, 0);
          break;
        case 2:
          v11 = Str;
          if ( !Str )
          {
            v11 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 16) = strtod(v11, 0);
          break;
        case 3:
          v12 = Str;
          if ( !Str )
          {
            v12 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 96) = strtod(v12, 0);
          break;
        case 4:
          v13 = Str;
          if ( !Str )
          {
            v13 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 104) = strtod(v13, 0);
          break;
        case 5:
          v14 = Str;
          if ( !Str )
          {
            v14 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 112) = strtod(v14, 0);
          break;
        case 6:
          v15 = Str;
          if ( !Str )
          {
            v15 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 120) = strtod(v15, 0);
          break;
        case 7:
          v16 = Str;
          if ( !Str )
          {
            v16 = "0.0";
            Str = "0.0";
          }
          v17 = strtod(v16, 0);
          v18 = HIWORD(a2);
          *(_WORD *)((char *)&v18 + 1) = BYTE1(v18) | 0xC;
          v35 = v18;
          *(_DWORD *)(a2 + 128) = (signed int)v17;
          break;
        case 8:
          v19 = Str;
          if ( !Str )
          {
            v19 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 136) = strtod(v19, 0);
          break;
        default:
          break;
      }
      v2 = *(&v25 + v8);
      v35 = v8 + 1;
      *(_DWORD *)v20 = "END";
      v21 = v2;
      v22 = 4;
      v23 = 1;
      do
      {
        if ( !v22 )
          break;
        v23 = *(_BYTE *)v21++ == **(_BYTE **)v20;
        ++*(_DWORD *)v20;
        --v22;
      }
      while ( v23 );
    }
    while ( !v23 );
  }
  result = v34;
  memcpy(&unk_1000C3D0, (const void *)a2, 0x90u);
  return result;
}
// 100090D8: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10007D30) --------------------------------------------------------
int __cdecl sub_10007D30(int a1, int a2)
{
  int v2; // esi@1
  int v3; // ebx@5
  double v5; // [sp+18h] [bp-78h]@1
  double v6; // [sp+20h] [bp-70h]@1
  double v7; // [sp+28h] [bp-68h]@1
  double v8; // [sp+30h] [bp-60h]@1
  double v9; // [sp+38h] [bp-58h]@1
  double v10; // [sp+40h] [bp-50h]@1
  double v11; // [sp+48h] [bp-48h]@1
  double v12; // [sp+50h] [bp-40h]@1
  double v13; // [sp+58h] [bp-38h]@1
  char v14; // [sp+60h] [bp-30h]@5
  char v15; // [sp+78h] [bp-18h]@5

  v5 = dbl_1000C3E8;
  v8 = dbl_1000C400;
  v2 = a1;
  v11 = dbl_1000C418;
  v6 = dbl_1000C3F0;
  v9 = dbl_1000C408;
  v12 = dbl_1000C420;
  v7 = dbl_1000C3F8;
  v10 = dbl_1000C410;
  v13 = dbl_1000C428;
  if ( !dword_1000C460 )
  {
    UF_VEC3_is_equal(
      a1 + 24,
      &dbl_1000C418,
      COERCE_UNSIGNED_INT64(0.00000001),
      COERCE_UNSIGNED_INT64(0.00000001) >> 32,
      &a1);
    if ( !a1 )
    {
      printf("WARNING  The tool axis is not matching with the                 rotated MCS-Z axis. The output may be INCORRECT\n");
      uc1601(
        "WARNING  The tool axis is not matching with the *                     rotated MCS-Z axis. The output may be INCORRECT\n",
        1);
    }
    dword_1000C460 = 1;
  }
  UF_VEC3_copy(v2, &v15);
  UF_VEC3_copy(v2 + 24, &v14);
  v3 = a2;
  UF_MTX3_vec_multiply(v2, &v5, a2);
  UF_MTX3_vec_multiply(v2 + 24, &v5, v3 + 24);
  return 0;
}
// 10009054: using guessed type int __cdecl UF_MTX3_vec_multiply(_DWORD, _DWORD, _DWORD);
// 1000906C: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);
// 100090F8: using guessed type int __cdecl UF_VEC3_is_equal(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10009104: using guessed type int __cdecl uc1601(_DWORD, _DWORD);
// 1000C3E8: using guessed type double dbl_1000C3E8;
// 1000C3F0: using guessed type double dbl_1000C3F0;
// 1000C3F8: using guessed type double dbl_1000C3F8;
// 1000C400: using guessed type double dbl_1000C400;
// 1000C408: using guessed type double dbl_1000C408;
// 1000C410: using guessed type double dbl_1000C410;
// 1000C418: using guessed type double dbl_1000C418;
// 1000C420: using guessed type double dbl_1000C420;
// 1000C428: using guessed type double dbl_1000C428;
// 1000C460: using guessed type int dword_1000C460;

//----- (10007E30) --------------------------------------------------------
int __cdecl sub_10007E30(int a1, int a2)
{
  char v3; // [sp+1Ch] [bp-18h]@1

  UF_VEC3_add(a1, &unk_1000C430, a2);
  UF_VEC3_sub(a1, &unk_1000C3D0, a2);
  UF_VEC3_copy(a1 + 24, a2 + 24);
  UF_VEC3_scale(LODWORD(dbl_1000C448), HIDWORD(dbl_1000C448), a2 + 24, &v3);
  UF_VEC3_add(a2, &v3, a2);
  if ( dword_1000C450 == 1 )
  {
    UF_VEC3_scale(LODWORD(dbl_1000C458), HIDWORD(dbl_1000C458), a2 + 24, &v3);
    UF_VEC3_add(a2, &v3, a2);
  }
  return 0;
}
// 10009060: using guessed type int __cdecl UF_VEC3_add(_DWORD, _DWORD, _DWORD);
// 1000906C: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);
// 10009074: using guessed type int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD);
// 1000909C: using guessed type int __cdecl UF_VEC3_scale(_DWORD, _DWORD, _DWORD, _DWORD);
// 1000C448: using guessed type double dbl_1000C448;
// 1000C450: using guessed type int dword_1000C450;
// 1000C458: using guessed type double dbl_1000C458;

//----- (10007ED0) --------------------------------------------------------
int __cdecl sub_10007ED0(int a1, int a2, int a3)
{
  char *v3; // edi@1
  int v4; // esi@1
  int v5; // edi@10
  char *v6; // esi@11
  char v8; // [sp+18h] [bp-154h]@1
  char v9; // [sp+F0h] [bp-7Ch]@5
  double v10; // [sp+108h] [bp-64h]@1
  double v11; // [sp+110h] [bp-5Ch]@1
  double v12; // [sp+118h] [bp-54h]@1
  double v13; // [sp+120h] [bp-4Ch]@1
  double v14; // [sp+128h] [bp-44h]@1
  double v15; // [sp+130h] [bp-3Ch]@1
  double v16; // [sp+138h] [bp-34h]@1
  double v17; // [sp+140h] [bp-2Ch]@1
  double v18; // [sp+148h] [bp-24h]@1
  long double v19; // [sp+150h] [bp-1Ch]@1
  int v20; // [sp+158h] [bp-14h]@1
  int v21; // [sp+15Ch] [bp-10h]@1
  long double v22; // [sp+160h] [bp-Ch]@2

  v10 = 1.0;
  v11 = 0.0;
  v12 = 0.0;
  v13 = 0.0;
  v14 = 1.0;
  v15 = 0.0;
  v16 = 0.0;
  v17 = 0.0;
  v18 = 1.0;
  v21 = 0;
  v3 = &v8;
  v19 = asin(1.0) * 0.01111111111111111;
  v4 = a3 + 8;
  v20 = 3;
  do
  {
    *(_QWORD *)&v22 = (signed __int64)*(double *)(v4 - 8);
    if ( LODWORD(v22) == 1 )
    {
      v22 = v19 * *(double *)v4 * -1.0;
      UF_MTX3_x_vec(&v10, &v9);
    }
    else
    {
      if ( LODWORD(v22) == 2 )
      {
        v22 = v19 * *(double *)v4 * -1.0;
        UF_MTX3_y_vec(&v10, &v9);
      }
      else
      {
        if ( LODWORD(v22) != 3 )
          goto LABEL_9;
        v22 = v19 * *(double *)v4 * -1.0;
        UF_MTX3_z_vec(&v10, &v9);
      }
    }
    UF_MTX3_rotate_about_axis(&v9, LODWORD(v22), HIDWORD(v22), v3);
    ++v21;
    v3 += 72;
LABEL_9:
    v4 += 16;
    --v20;
  }
  while ( v20 );
  v5 = v21;
  if ( v21 > 0 )
  {
    v6 = &v8;
    do
    {
      UF_MTX3_multiply(&v10, v6, &v10);
      v6 += 72;
      --v5;
    }
    while ( v5 );
  }
  *(_QWORD *)(a2 + 24) = *(_QWORD *)&v10;
  *(_QWORD *)(a2 + 48) = *(_QWORD *)&v13;
  dword_1000C460 = 0;
  *(_QWORD *)(a2 + 72) = *(_QWORD *)&v16;
  *(_QWORD *)(a2 + 32) = *(_QWORD *)&v11;
  *(_QWORD *)(a2 + 56) = *(_QWORD *)&v14;
  *(_QWORD *)(a2 + 80) = *(_QWORD *)&v17;
  *(_QWORD *)(a2 + 40) = *(_QWORD *)&v12;
  *(_QWORD *)(a2 + 64) = *(_QWORD *)&v15;
  *(_QWORD *)(a2 + 88) = *(_QWORD *)&v18;
  return 0;
}
// 10009094: using guessed type int __cdecl UF_MTX3_z_vec(_DWORD, _DWORD);
// 100090A4: using guessed type int __cdecl UF_MTX3_multiply(_DWORD, _DWORD, _DWORD);
// 100090A8: using guessed type int __cdecl UF_MTX3_rotate_about_axis(_DWORD, _DWORD, _DWORD, _DWORD);
// 100090B8: using guessed type int __cdecl UF_MTX3_x_vec(_DWORD, _DWORD);
// 100090BC: using guessed type int __cdecl UF_MTX3_y_vec(_DWORD, _DWORD);
// 1000C460: using guessed type int dword_1000C460;

//----- (100083B8) --------------------------------------------------------
void __cdecl sub_100083B8()
{
  unsigned int i; // [sp+Ch] [bp-1Ch]@1

  for ( i = (unsigned int)&unk_1000AE18; i < (unsigned int)&unk_1000AE18; i += 4 )
  {
    if ( *(_DWORD *)i )
      (*(void (**)(void))i)();
  }
}

//----- (100083FC) --------------------------------------------------------
void __cdecl sub_100083FC()
{
  unsigned int i; // [sp+Ch] [bp-1Ch]@1

  for ( i = (unsigned int)&unk_1000AE20; i < (unsigned int)&unk_1000AE20; i += 4 )
  {
    if ( *(_DWORD *)i )
      (*(void (**)(void))i)();
  }
}

//----- (10008446) --------------------------------------------------------
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
  if ( fdwReason == 1 && !dword_1000C474 )
    DisableThreadLibraryCalls(hinstDLL);
  return 1;
}
// 1000C474: using guessed type int dword_1000C474;

// ALL OK, 47 function(s) have been successfully decompiled
