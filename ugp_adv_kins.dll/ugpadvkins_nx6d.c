/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2009 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Data declarations

extern char aReturnedErrorD[]; // idb
extern char aReturnedAD[]; // idb
extern char aSLineDS[]; // idb
extern char aKinematics[11]; // weak
extern char aErrorAdvancedK[]; // idb
extern char aUgpkin[13]; // weak
extern char aNumberOfArgume[]; // idb
extern char aIncorrectNumbe[]; // idb
extern char aSet_rotd_opera[]; // idb
extern char aSet_rotd_mcs_m[]; // idb
extern char aCaxis[6]; // weak
extern char aBaxis[6]; // weak
extern char aAaxis[6]; // weak
extern char aInsufficientNu[]; // idb
extern char aPos_z[6]; // weak
extern char aPos_y[6]; // weak
extern char aPos_x[6]; // weak
extern char aMom_transfer_g[]; // idb
extern char aMom_process_in[]; // idb
extern char aSet_input_poin[]; // idb
extern char a5_axis_head_ta[]; // idb
extern char a5_axis_dual_he[]; // idb
extern char a5_axis_dual_ta[]; // idb
extern char aNegz[]; // idb
extern char aNegy[]; // idb
extern char aNegx[]; // idb
extern char aPosz[]; // idb
extern char aPosy[]; // idb
extern char aPosx[]; // idb
extern char aAlt_pos_a2[11]; // weak
extern char aAlt_pos_a1[11]; // weak
extern char aAlt_pos_z[10]; // weak
extern char aAlt_pos_y[10]; // weak
extern char aAlt_pos_x[10]; // weak
extern char aPos_a2[7]; // weak
extern char aPos_a1[7]; // weak
extern char aUf_attr_read_v[]; // idb
extern char aUf_obj_cycle_b[]; // idb
extern char aNoToolNameObta[34]; // weak
extern char aErrorS[]; // idb
extern char aInvalidNumberO[28]; // weak
extern int dword_100095D4; // weak
extern int dword_100095D8; // weak
extern __int16 word_100095DC; // weak
extern int dword_100095E0; // weak
extern int dword_100095E4; // weak
extern int dword_100095E8; // weak
extern int dword_100095EC; // weak
extern int dword_100095F0; // weak
extern char aUf_mom_exten_4[87]; // weak
extern char aMom_exit_kinem[27]; // weak
extern char aUf_mom_exten_3[81]; // weak
extern char aMom_map_to_rot[24]; // weak
extern char aUf_mom_exten_2[75]; // weak
extern char aMom_rotate_mac[21]; // weak
extern char aUf_mom_exten_1[80]; // weak
extern char aMom_get_tool_a[23]; // weak
extern char aUf_mom_exten_0[69]; // weak
extern char aMom_convert_po[18]; // weak
extern char aOUgnx60Ip24Src[63]; // weak
extern char aUf_mom_extend_[73]; // weak
extern char aMom_load_kinem[20]; // weak
extern char aErrorUgpostAdv[]; // idb
extern _UNKNOWN unk_100098E8; // weak
extern _UNKNOWN unk_10009930; // weak
extern _UNKNOWN unk_10009978; // weak
extern char aWarningSameVal[]; // idb
extern char aComputingT11FT[]; // idb
extern char aComputingT10FT[]; // idb
extern char aAboutAdjusting[]; // idb
extern char aWarningDegener[]; // idb
extern char aInputPoint_4f_[]; // idb
extern char aStartingOld_pc[]; // idb
extern char asc_10009BAC[]; // idb
extern char aInit_t11Init_t[]; // idb
extern char aInit_t10Init_t[]; // idb
extern char aA1FD1FAlpha1FA[]; // idb
extern char aWarningToolAxi[]; // idb
extern char aLocalSecondary[]; // idb
extern char aLocalPrimaryax[]; // idb
extern char aSulzerCase[]; // idb
extern char aMcsysFFFFFFFFF[]; // idb
extern char aTool_vectorFFF[]; // idb
extern char aTool_machine_c[]; // idb
extern char aSecondary_mach[]; // idb
extern char aSecondaryFFF[]; // idb
extern char aPrimary_machin[]; // idb
extern char aPrimaryFFF[]; // idb
extern char aIs_5_axis_head[]; // idb
extern char aIs_5_axis_du_0[21]; // weak
extern char aIs_5_axis_dual[22]; // weak
extern char aIs_orthogonal_[]; // idb
extern char asc_10009E60[]; // idb
extern char aFinalUfuncAlt_[]; // idb
extern char aFinalUfuncMcoo[]; // idb
extern char a400_00[7]; // weak
extern char a0_0[4]; // weak
extern wchar_t aF[2]; // weak
extern char aIn[3]; // weak
extern char aNone[5]; // weak
extern char aMom_kin_rapid_[24]; // weak
extern char aMom_kin_pivot_[27]; // weak
extern char aMom_kin_read_a[31]; // weak
extern char aMom_kin_polar_[26]; // weak
extern char aMom_kin_output[20]; // weak
extern char aEnd[4]; // weak
extern char aMom_kin_nurbs_[26]; // weak
extern char a9999_9999[10]; // weak
extern char a0_0001[7]; // weak
extern char aXy[3]; // weak
extern char aFull_circle[12]; // weak
extern char aMom_kin_max_ar[23]; // weak
extern char aMom_kin_min_ar[23]; // weak
extern char aMom_kin_arc_va[24]; // weak
extern char aMom_kin_arc_ou[24]; // weak
extern char a99999_999[10]; // weak
extern char a99_999[7]; // weak
extern char a0_001[6]; // weak
extern char a999_999[8]; // weak
extern char aMom_kin_min_dp[16]; // weak
extern char aMom_kin_max_dp[16]; // weak
extern char aMom_kin_min_fr[16]; // weak
extern char aMom_kin_max_fr[16]; // weak
extern char aMom_kin_min__0[16]; // weak
extern char aMom_kin_max__0[16]; // weak
extern char aMom_kin_min_fp[16]; // weak
extern char aMom_kin_max_fp[16]; // weak
extern char a360_0[6]; // weak
extern char aStandard[9]; // weak
extern char aMagnitude_dete[31]; // weak
extern char aYz[3]; // weak
extern char aMom_kin_4th_13[27]; // weak
extern char aMom_kin_4th_12[27]; // weak
extern char aMom_kin_4th_11[26]; // weak
extern char aMom_kin_4th_10[26]; // weak
extern char aMom_kin_4th__9[26]; // weak
extern char aMom_kin_4th__8[33]; // weak
extern char aMom_kin_4th__7[33]; // weak
extern char aMom_kin_4th__6[33]; // weak
extern char aMom_kin_4th__5[22]; // weak
extern char aMom_kin_4th__4[27]; // weak
extern char aMom_kin_4th__3[27]; // weak
extern char aMom_kin_4th__2[26]; // weak
extern char aMom_kin_4th__1[26]; // weak
extern char aMom_kin_4th__0[27]; // weak
extern char aMom_kin_4th_ax[23]; // weak
extern char aMom_kin_5th_13[27]; // weak
extern char aMom_kin_5th_12[27]; // weak
extern char aMom_kin_5th_11[26]; // weak
extern char aMom_kin_5th_10[26]; // weak
extern char aMom_kin_5th__9[26]; // weak
extern char aMom_kin_5th__8[33]; // weak
extern char aMom_kin_5th__7[33]; // weak
extern char aMom_kin_5th__6[33]; // weak
extern char aMom_kin_5th__5[22]; // weak
extern char aMom_kin_5th__4[27]; // weak
extern char aMom_kin_5th__3[27]; // weak
extern char aMom_kin_5th__2[26]; // weak
extern char aMom_kin_5th__1[26]; // weak
extern char aMom_kin_5th__0[27]; // weak
extern char aMom_kin_5th_ax[23]; // weak
extern char aFront[6]; // weak
extern char aMom_kin_ind__0[32]; // weak
extern char aMom_kin_ind_to[32]; // weak
extern char aMom_kin_indepe[25]; // weak
extern char a3_0[4]; // weak
extern char a0_5[4]; // weak
extern char aMom_kin_flush_[19]; // weak
extern char aMom_kin_clamp_[19]; // weak
extern char aMom_kin_tool_c[25]; // weak
extern char aMom_kin_hol_22[25]; // weak
extern char aMom_kin_hol_21[25]; // weak
extern char aMom_kin_hol_20[25]; // weak
extern char aMom_kin_hol_19[25]; // weak
extern char aMom_kin_hol_18[25]; // weak
extern char aMom_kin_hol_17[25]; // weak
extern char aMom_kin_hol_16[25]; // weak
extern char aMom_kin_hol_15[25]; // weak
extern char aMom_kin_hol_14[25]; // weak
extern char aMom_kin_hol_13[25]; // weak
extern char aMom_kin_hol_12[25]; // weak
extern char aMom_kin_hol_11[25]; // weak
extern char aMom_kin_hol_10[25]; // weak
extern char aMom_kin_hold_9[25]; // weak
extern char aMom_kin_hold_8[25]; // weak
extern char aMom_kin_hold_7[25]; // weak
extern char aMom_kin_hold_6[25]; // weak
extern char aMom_kin_hold_5[25]; // weak
extern char aMom_kin_hold_4[28]; // weak
extern char aMom_kin_hold_3[28]; // weak
extern char aMom_kin_hold_2[28]; // weak
extern char aMom_kin_hold_1[28]; // weak
extern char aMom_kin_hold_0[28]; // weak
extern char aMom_kin_holder[28]; // weak
extern char aKin_4th_to_t_1[28]; // weak
extern char aKin_4th_to_t_0[28]; // weak
extern char aKin_4th_to_tra[28]; // weak
extern char a90_0[5]; // weak
extern char aCartesian[10]; // weak
extern wchar_t aT[2]; // weak
extern char a3_axis_mill[12]; // weak
extern char aMom_kin_gaug_0[25]; // weak
extern char aMom_kin_line_0[26]; // weak
extern char aMom_kin_5th_14[36]; // weak
extern char aMom_kin_tool_t[29]; // weak
extern char aMom_kin_mach_0[27]; // weak
extern char aMom_kin_linear[27]; // weak
extern char aMom_kin_coordi[24]; // weak
extern char aMom_kin_clsf_g[24]; // weak
extern char aMom_kin_wire_t[30]; // weak
extern char aMom_kin_track_[29]; // weak
extern char aMom_kin_machin[21]; // weak
extern char aMom_kin_gauge_[25]; // weak
extern char a1_0[4]; // weak
extern char aMom_msys_z_a_1[18]; // weak
extern char aMom_msys_z_a_0[18]; // weak
extern char aMom_msys_z_axi[18]; // weak
extern char aMom_msys_y_a_1[18]; // weak
extern char aMom_msys_y_a_0[18]; // weak
extern char aMom_msys_y_axi[18]; // weak
extern char aMom_msys_x_a_1[18]; // weak
extern char aMom_msys_x_a_0[18]; // weak
extern char aMom_msys_x_axi[18]; // weak
extern char aMom_msys_ori_1[18]; // weak
extern char aMom_msys_ori_0[18]; // weak
extern char aMom_msys_origi[18]; // weak
extern char aMom_mtsys_z__1[19]; // weak
extern char aMom_mtsys_z__0[19]; // weak
extern char aMom_mtsys_z_ax[19]; // weak
extern char aMom_mtsys_y__1[19]; // weak
extern char aMom_mtsys_y__0[19]; // weak
extern char aMom_mtsys_y_ax[19]; // weak
extern char aMom_mtsys_x__1[19]; // weak
extern char aMom_mtsys_x__0[19]; // weak
extern char aMom_mtsys_x_ax[19]; // weak
extern char aMom_mtsys_or_1[19]; // weak
extern char aMom_mtsys_or_0[19]; // weak
extern char aMom_mtsys_orig[19]; // weak
extern char aMill[5]; // weak
extern char aMom_tool_corne[24]; // weak
extern char aMom_tool_z_off[18]; // weak
extern char aMom_tool_type[14]; // weak
extern char aMom_translat_1[16]; // weak
extern char aMom_translat_0[16]; // weak
extern char aMom_translate_[16]; // weak
extern char aMom_origin_z[13]; // weak
extern char aMom_origin_y[13]; // weak
extern char aMom_origin_x[13]; // weak
extern char aMom_tool_axi_1[16]; // weak
extern char aMom_tool_axi_0[16]; // weak
extern char aMom_tool_axis_[16]; // weak
extern char aMom_mcs_goto_z[15]; // weak
extern char aMom_mcs_goto_y[15]; // weak
extern char aMom_mcs_goto_x[15]; // weak
extern char aWarningTheTo_0[119]; // weak
extern char aWarningTheTool[]; // idb
extern int dword_1000ADB8; // weak
extern _UNKNOWN unk_1000AE78; // weak
extern _UNKNOWN unk_1000AE80; // weak
extern double dbl_1000C000; // weak
extern char byte_1000C008; // weak
extern char byte_1000C009; // weak
extern char byte_1000C00A; // weak
extern int dword_1000C240; // weak
extern double dbl_1000C248; // weak
extern int dword_1000C2C8; // weak
extern int dword_1000C2CC; // weak
extern int dword_1000C2D0; // weak
extern int dword_1000C2D4; // weak
extern int dword_1000C2D8; // weak
extern int dword_1000C2DC; // weak
extern double dbl_1000C2E0; // weak
extern double dbl_1000C2E8; // weak
extern double dbl_1000C2F0; // weak
extern double dbl_1000C2F8; // weak
extern double dbl_1000C300; // weak
extern double dbl_1000C308; // weak
extern double dbl_1000C310; // weak
extern double dbl_1000C318; // weak
extern double dbl_1000C320; // weak
extern double dbl_1000C328; // weak
extern double dbl_1000C330; // weak
extern double dbl_1000C338; // weak
extern _UNKNOWN unk_1000C340; // weak
extern double dbl_1000C348; // weak
extern int dword_1000C3D8; // weak
extern int dword_1000C3DC; // weak
extern _UNKNOWN unk_1000C3E0; // weak
extern double dbl_1000C460; // weak
extern double dbl_1000C468; // weak
extern double dbl_1000C470; // weak
extern double dbl_1000C478; // weak
extern double dbl_1000C480; // weak
extern double dbl_1000C488; // weak
extern double dbl_1000C490; // weak
extern double dbl_1000C498; // weak
extern double dbl_1000C4A0; // weak
extern double dbl_1000C4A8; // weak
extern double dbl_1000C4B0; // weak
extern double dbl_1000C4B8; // weak
extern double dbl_1000C4C0; // weak
extern double dbl_1000C4C8; // weak
extern double dbl_1000C4D0; // weak
extern double dbl_1000C4D8; // weak
extern int dword_1000C4E0; // weak
extern int dword_1000C4E4; // weak
extern int dword_1000C4E8; // weak
extern int dword_1000C4EC; // weak
extern int dword_1000C4F0; // weak
extern int dword_1000C4F4; // weak
extern int dword_1000C4F8; // weak
extern int dword_1000C4FC; // weak
extern int dword_1000C500; // weak
extern int dword_1000C504; // weak
extern int dword_1000C508; // weak
extern int dword_1000C50C; // weak
extern int dword_1000C510; // weak
extern int dword_1000C514; // weak
extern int dword_1000C518; // weak
extern int dword_1000C51C; // weak
extern int dword_1000C520; // weak
extern int dword_1000C524; // weak
extern int dword_1000C528; // weak
extern int dword_1000C52C; // weak
extern double dbl_1000C530; // weak
extern double dbl_1000C538; // weak
extern int dword_1000C540; // weak
extern int dword_1000C544; // weak
extern int dword_1000C548; // weak
extern int dword_1000C54C; // weak
extern int dword_1000C550; // weak
extern int dword_1000C554; // weak
extern double dbl_1000C558; // weak
extern double dbl_1000C560; // weak
extern double dbl_1000C568; // weak
extern double dbl_1000C570; // weak
extern double dbl_1000C578; // weak
extern double dbl_1000C580; // weak
extern char byte_1000C588; // weak
extern _UNKNOWN unk_1000C590; // weak
extern _UNKNOWN unk_1000C5B8; // weak
extern _UNKNOWN unk_1000C5E0; // weak
extern double dbl_1000C5F8; // weak
extern double dbl_1000C600; // weak
extern double dbl_1000C608; // weak
extern double dbl_1000C610; // weak
extern double dbl_1000C618; // weak
extern double dbl_1000C620; // weak
extern double dbl_1000C628; // weak
extern double dbl_1000C630; // weak
extern double dbl_1000C638; // weak
extern _UNKNOWN unk_1000C640; // weak
extern double dbl_1000C658; // weak
extern int dword_1000C660; // weak
extern double dbl_1000C668; // weak
extern int dword_1000C670; // weak
extern _UNKNOWN unk_1000C67C; // weak
extern int dword_1000C9AC; // weak

//-------------------------------------------------------------------------
// Function declarations

// int __usercall sub_10001010<eax>(int a1<eax>, int a2<edx>, int a3<ecx>, int a4<esi>);
int __cdecl sub_10001070(char *); // idb
// int UF_terminate(); weak
signed int __cdecl sub_100010D0(int a1, int a2, signed int a3, int a4);
int __cdecl sub_10001260(int a1);
signed int __cdecl sub_10001340(int a1);
int __cdecl sub_10001AB0(int a1);
signed int __cdecl sub_10001BB0(int a1, int a2, int a3, int a4);
int __cdecl ufusr(int a1, int a2);
// int __usercall sub_10001F20<eax>(int a1<eax>, int a2<ecx>, int a3<esi>, char a4);
// int __cdecl sub_10001F50(double); idb
// int __usercall sub_10001FA0<eax>(int result<eax>, int _ECX<ecx>, double a3);
// int __usercall sub_10002080<eax>(int a1<eax>, int a2<ecx>, int a3);
// int __usercall sub_10002150<eax>(int a1<eax>, int a2<esi>, double a3, double a4, signed int a5);
int __cdecl sub_100022D0(int, double, int); // idb
int __cdecl sub_10002350(int, double, int); // idb
long double __fastcall sub_10002390(int a1, int a2, int a3);
// int __usercall sub_100023B0<eax>(int a1<eax>, int a2<ecx>, int a3);
signed int __cdecl sub_100023F0(int a1, int a2);
void __fastcall sub_10002430(int a1, int a2);
long double __cdecl sub_10002580(double a1);
// void __usercall sub_100025B0(int a1<edx>, int a2<ebx>);
int __cdecl sub_100026E0(int a1);
_DWORD __cdecl sub_10002770(_DWORD, _DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_10002830(int a1, signed int a2, int a3, int a4);
int __fastcall sub_10002CA0(int a1, int a2, int a3, int a4, int a5);
// signed int __usercall sub_10002EB0<eax>(int a1<eax>, int a2);
int __cdecl sub_10002FE0(int a2, int a3);
// signed int __usercall sub_10003210<eax>(int a1<ebx>, int a2<edi>, int a3<esi>, const void *a4, int a5, int a6);
int __cdecl sub_10003F80(int a1, int a2, int a3, int a4, int a5, int a6);
signed int __cdecl sub_100041A0(int a1, const void *a2, int a3, int a4, int a5, int a6, int a7, int a8, const void *a9);
signed int __cdecl sub_10004F70(int a1, int a2, int a3);
long double __cdecl sub_10005200(int a1, long double *a2);
// signed int __usercall sub_10005290<eax>(int a1<eax>);
int __cdecl sub_100053B0(int a1);
int __fastcall sub_100053F0(int a1, int a2, char a3);
int __cdecl sub_10005410(int a1, int a2);
int __cdecl sub_100055C0(int a1, int a2);
int __cdecl sub_10005700(int a1, int a2);
int __cdecl sub_100058D0(int a1, int a2);
int __cdecl sub_10005C10(int a1, int a2);
int __cdecl sub_10005F50(int a1, int a2);
int __cdecl sub_10006060(int a1, int a2);
int __cdecl sub_10006150(int a1, int a2);
int __cdecl sub_10006660(int a1, int a2);
int __cdecl sub_10006A10(int a1, int a2);
int __cdecl sub_10006C90(int a1, int a2);
int __cdecl sub_10006F30(int a1, int a2);
int __cdecl sub_10007150(int a1, int a2);
int __cdecl sub_100072D0(int, char *); // idb
int __cdecl sub_100074F0(int a1, int a2);
int __cdecl sub_100075F0(int a1, int a2);
int __cdecl sub_10007690(int a1, int a2, int a3);
// double __cdecl floor(double);
int __cdecl sub_10007D6B();
int (*__cdecl sub_10007E2E())(void);
int (*__cdecl sub_10007E52())(void);
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
// int unknown_libname_1(void); weak
int __cdecl sub_100081C4();
// int __cdecl _clean_type_info_names_internal(_DWORD); weak
// BOOL __stdcall DisableThreadLibraryCalls(HMODULE hLibModule);
// double __cdecl ceil(double);
// void __cdecl qsort(void *, size_t, size_t, int (__cdecl *)(const void *, const void *));
// int __cdecl atoi(const char *);
// void *__cdecl malloc(size_t);
// double __cdecl strtod(const char *, char **);
// void __cdecl free(void *);
// int sprintf(char *, const char *, ...);
// int printf(const char *, ...);
// char *__cdecl strstr(const char *, const char *);
// int __cdecl UF_VEC3_cross(_DWORD, _DWORD); weak
// int __cdecl UF_get_fail_message(_DWORD, _DWORD); weak
// int __cdecl UF_MTX3_rotate_about_axis(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_edit_rotation(_DWORD, _DWORD); weak
// int __cdecl UF_VEC3_scale(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_is_parallel(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_z_vec(_DWORD, _DWORD); weak
// int __cdecl UF_VEC3_distance(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_vec_multiply_t(_DWORD, _DWORD, _DWORD);
// int __stdcall UF_VEC3_is_zero(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_affine_comb(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_is_equal(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_allocate_memory(_DWORD, _DWORD); weak
// int __cdecl UF_free(_DWORD); weak
// int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_dot(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_copy(_DWORD, _DWORD); weak
// int __cdecl UF_VEC3_angle_between(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_vec3_multiply_t(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_add(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_rotation(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_ask_rotation(_DWORD, _DWORD); weak
// int __cdecl UF_MTX3_vec_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_vec3_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_vec_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_copy(_DWORD, _DWORD); weak
// int __cdecl UF_MTX3_x_vec(_DWORD, _DWORD); weak
// int __cdecl UF_MTX3_y_vec(_DWORD, _DWORD); weak
// int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MOM_ask_interp_from_param(_DWORD, _DWORD); weak
// int __cdecl UF_MOM_ask_mom(_DWORD, _DWORD); weak
// int __cdecl UF_MOM_extend_xlator(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_OBJ_cycle_by_name(_DWORD, _DWORD); weak
// int __cdecl UF_ATTR_read_value(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MOM_set_string(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MOM_set_double(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int UF_terminate(void); weak
// int __cdecl UF_MISC_set_program_name(_DWORD); weak
// int UF_initialize(void); weak
// int __cdecl UF_MTX4_csys_to_csys(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl uc1601(_DWORD, _DWORD); weak


//----- (10001010) --------------------------------------------------------
int __usercall sub_10001010<eax>(int a1<eax>, int a2<edx>, int a3<ecx>, int a4<esi>)
{
  char v5; // [sp+0h] [bp-88h]@2

  if ( a4 )
  {
    printf("%s, line %d:  %s\n", a2, a3, a1);
    if ( UF_get_fail_message(a4, &v5) )
    {
      printf("    returned a %d\n", a4);
      return a4;
    }
    printf("    returned error %d:  %s\n", a4, &v5);
  }
  return a4;
}
// 100090B4: using guessed type int __cdecl UF_get_fail_message(_DWORD, _DWORD);

//----- (10001070) --------------------------------------------------------
signed int __cdecl sub_10001070(char *a1)
{
  signed int result; // eax@2

  UF_MISC_set_program_name("<!<UGPKIN>!>");
  if ( UF_initialize() )
  {
    sprintf(a1, "ERROR!: Advanced Kinematics Module Unavailable");
    result = 1;
  }
  else
  {
    UF_MISC_set_program_name("Kinematics");
    result = 0;
  }
  return result;
}
// 10009150: using guessed type int __cdecl UF_MISC_set_program_name(_DWORD);
// 10009154: using guessed type int UF_initialize(void);

//----- (100010D0) --------------------------------------------------------
signed int __cdecl sub_100010D0(int a1, int a2, signed int a3, int a4)
{
  int v4; // esi@1
  signed int result; // eax@4
  signed int v6; // ebx@5
  char v7; // zf@7
  signed int v8; // ecx@7
  int v9; // edi@7
  int v10; // esi@7
  long double v11; // fst7@12
  char v12; // zf@13
  signed int v13; // ecx@13
  int v14; // edi@13
  int v15; // esi@13
  char v16; // zf@19
  signed int v17; // ecx@19
  int v18; // edi@19
  int v19; // esi@19
  long double v20; // fst7@26
  int v21; // eax@26
  int v22; // edi@28
  int v23; // edi@30
  double v24; // [sp+0h] [bp-38h]@1
  double v25; // [sp+8h] [bp-30h]@1
  double v26; // [sp+10h] [bp-28h]@1
  double v27; // [sp+18h] [bp-20h]@1
  double v28; // [sp+20h] [bp-18h]@1
  double v29; // [sp+28h] [bp-10h]@1
  int v30; // [sp+30h] [bp-8h]@1
  int v31; // [sp+34h] [bp-4h]@6

  v24 = 0.0;
  v25 = 0.0;
  v26 = 0.0;
  v27 = 0.0;
  v28 = 0.0;
  v29 = 0.0;
  v4 = (int)malloc(0x90u);
  v30 = v4;
  if ( a3 > 7 || a3 == 1 )
  {
    ((void (__thiscall *)(signed int))printf)(a3);
    printf(" Number of arguments should be between 1 and 6\n ", " Incorrect number of arguments\n");
    result = 999;
  }
  else
  {
    if ( !(a3 % 2) )
    {
      printf(" Insufficient number of arguments, There should be               atleast 2 arguments\n ");
      return 999;
    }
    v6 = 1;
    if ( a3 > 1 )
    {
      v31 = (int)&v24;
      while ( 1 )
      {
        v9 = (int)"AAXIS";
        v10 = *(_DWORD *)(a4 + 4 * v6);
        v8 = 6;
        v7 = 1;
        do
        {
          if ( !v8 )
            break;
          v7 = *(_BYTE *)v10++ == *(_BYTE *)v9++;
          --v8;
        }
        while ( v7 );
        if ( v7 )
        {
          v11 = 1.0;
        }
        else
        {
          v14 = (int)"BAXIS";
          v15 = *(_DWORD *)(a4 + 4 * v6);
          v13 = 6;
          v12 = 1;
          do
          {
            if ( !v13 )
              break;
            v12 = *(_BYTE *)v15++ == *(_BYTE *)v14++;
            --v13;
          }
          while ( v12 );
          if ( v12 )
          {
            v11 = 2.0;
          }
          else
          {
            v18 = (int)"CAXIS";
            v19 = *(_DWORD *)(a4 + 4 * v6);
            v17 = 6;
            v16 = 1;
            do
            {
              if ( !v17 )
                break;
              v16 = *(_BYTE *)v19++ == *(_BYTE *)v18++;
              --v17;
            }
            while ( v16 );
            if ( !v16 )
              goto LABEL_26;
            v11 = 3.0;
          }
        }
        *(double *)v31 = v11;
LABEL_26:
        v20 = strtod((const char *)*(_DWORD *)(a4 + 4 * v6 + 4), 0);
        v21 = v31;
        *(double *)(v31 + 8) = v20;
        v6 += 2;
        v31 = v21 + 16;
        if ( v6 >= a3 )
        {
          v4 = v30;
          break;
        }
      }
    }
    v22 = sub_10007690(a1, v4, (int)&v24);
    if ( v22 )
    {
      printf(" SET_rotd_mcs_matrix failed in mom_rotate_mach_csys \n ");
      result = v22;
    }
    else
    {
      v23 = sub_100072D0(a1, (char *)v4);
      if ( v23 )
      {
        printf(" SET_rotd_operation_data failed in mom_rotate_mach_csys \n ");
        result = v23;
      }
      else
      {
        if ( v4 )
          free((void *)v4);
        result = 0;
      }
    }
  }
  return result;
}

//----- (10001260) --------------------------------------------------------
int __cdecl sub_10001260(int a1)
{
  int v1; // edi@1
  int result; // eax@2
  int v3; // edi@3
  int v4; // edi@5
  char v5; // [sp+10h] [bp-90h]@3
  char v6; // [sp+40h] [bp-60h]@1
  double v7; // [sp+70h] [bp-30h]@5
  double v8; // [sp+78h] [bp-28h]@7
  _DWORD v9[8]; // [sp+80h] [bp-20h]@7

  v1 = sub_10007150(a1, (int)&v6);
  if ( v1 )
  {
    printf(" SET_input_point failed in mom_map_to_rotated_csys\n ");
    result = v1;
  }
  else
  {
    v3 = sub_100075F0((int)&v6, (int)&v5);
    if ( v3 )
    {
      printf(" mom_process_input_gotos failed in mom_map_to_rotated_csys\n ");
      result = v3;
    }
    else
    {
      v4 = sub_100074F0((int)&v5, (int)&v7);
      if ( v4 )
      {
        printf(" mom_transfer_gotos_rotd_mcsys failed in mom_map_to_rotated_csys\n ");
        result = v4;
      }
      else
      {
        UF_MOM_set_double(a1, "pos_x", LODWORD(v7), HIDWORD(v7));
        UF_MOM_set_double(a1, "pos_y", LODWORD(v8), HIDWORD(v8));
        UF_MOM_set_double(a1, "pos_z", v9[0], v9[1]);
        result = 0;
      }
    }
  }
  return result;
}
// 10009148: using guessed type int __cdecl UF_MOM_set_double(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10001340) --------------------------------------------------------
signed int __cdecl sub_10001340(int a1)
{
  int v1; // ebx@1
  void *v2; // edi@1
  int v3; // esi@1
  char *v5; // esi@3
  char *v6; // eax@3
  void *v7; // ecx@3
  void *v8; // edx@3
  void *v9; // eax@3
  void *v10; // ecx@3
  void *v11; // ecx@3
  long double v12; // fst7@3
  long double v13; // fst6@3
  long double v14; // fst7@3
  long double v15; // fst7@3
  long double v16; // fst7@3
  long double v17; // fst6@3
  long double v18; // fst7@3
  long double v19; // fst6@3
  long double v20; // fst7@3
  long double v21; // fst7@4
  int v22; // edx@21
  int v23; // edx@21
  int v24; // eax@21
  int v25; // ecx@21
  int v26; // eax@21
  int v27; // ecx@21
  long double v28; // fst7@22
  double v29; // [sp+Ch] [bp-35Ch]@3
  double v30; // [sp+14h] [bp-354h]@3
  double v31; // [sp+1Ch] [bp-34Ch]@3
  double v32; // [sp+24h] [bp-344h]@3
  double v33; // [sp+2Ch] [bp-33Ch]@3
  double v34; // [sp+34h] [bp-334h]@3
  double v35; // [sp+3Ch] [bp-32Ch]@3
  double v36; // [sp+44h] [bp-324h]@3
  double v37; // [sp+4Ch] [bp-31Ch]@3
  int v38; // [sp+54h] [bp-314h]@16
  double v39; // [sp+5Ch] [bp-30Ch]@21
  int v40; // [sp+64h] [bp-304h]@21
  int v41; // [sp+68h] [bp-300h]@21
  int v42; // [sp+6Ch] [bp-2FCh]@21
  int v43; // [sp+70h] [bp-2F8h]@21
  int v44; // [sp+74h] [bp-2F4h]@21
  int v45; // [sp+78h] [bp-2F0h]@21
  int v46; // [sp+7Ch] [bp-2ECh]@21
  int v47; // [sp+80h] [bp-2E8h]@21
  int v48; // [sp+84h] [bp-2E4h]@21
  int v49; // [sp+88h] [bp-2E0h]@21
  int v50; // [sp+8Ch] [bp-2DCh]@21
  int v51; // [sp+90h] [bp-2D8h]@21
  int v52; // [sp+94h] [bp-2D4h]@21
  int v53; // [sp+98h] [bp-2D0h]@21
  int v54; // [sp+9Ch] [bp-2CCh]@21
  int v55; // [sp+A0h] [bp-2C8h]@21
  int v56; // [sp+A4h] [bp-2C4h]@21
  int v57; // [sp+A8h] [bp-2C0h]@21
  char v58; // [sp+ACh] [bp-2BCh]@21
  double v59; // [sp+B4h] [bp-2B4h]@21
  double v60; // [sp+BCh] [bp-2ACh]@21
  double v61; // [sp+C4h] [bp-2A4h]@21
  double v62; // [sp+CCh] [bp-29Ch]@21
  double v63; // [sp+D4h] [bp-294h]@21
  double v64; // [sp+DCh] [bp-28Ch]@21
  double v65; // [sp+E4h] [bp-284h]@24
  __int64 v66; // [sp+ECh] [bp-27Ch]@3
  __int64 v67; // [sp+F4h] [bp-274h]@3
  double v68; // [sp+FCh] [bp-26Ch]@3
  int v69; // [sp+100h] [bp-268h]@3
  __int64 v70; // [sp+104h] [bp-264h]@3
  __int64 v71; // [sp+10Ch] [bp-25Ch]@3
  __int64 v72; // [sp+114h] [bp-254h]@3
  __int64 v73; // [sp+11Ch] [bp-24Ch]@3
  __int64 v74; // [sp+124h] [bp-244h]@3
  __int64 v75; // [sp+12Ch] [bp-23Ch]@3
  __int64 v76; // [sp+134h] [bp-234h]@3
  __int64 v77; // [sp+13Ch] [bp-22Ch]@3
  __int64 v78; // [sp+144h] [bp-224h]@3
  int v79; // [sp+14Ch] [bp-21Ch]@3
  int v80; // [sp+150h] [bp-218h]@3
  int v81; // [sp+154h] [bp-214h]@3
  int v82; // [sp+158h] [bp-210h]@3
  int v83; // [sp+15Ch] [bp-20Ch]@3
  int v84; // [sp+160h] [bp-208h]@3
  int v85; // [sp+164h] [bp-204h]@3
  int v86; // [sp+168h] [bp-200h]@3
  int v87; // [sp+16Ch] [bp-1FCh]@3
  int v88; // [sp+170h] [bp-1F8h]@3
  int v89; // [sp+174h] [bp-1F4h]@3
  int v90; // [sp+178h] [bp-1F0h]@3
  int v91; // [sp+17Ch] [bp-1ECh]@3
  int v92; // [sp+180h] [bp-1E8h]@3
  int v93; // [sp+184h] [bp-1E4h]@3
  int v94; // [sp+188h] [bp-1E0h]@3
  int v95; // [sp+18Ch] [bp-1DCh]@3
  int v96; // [sp+190h] [bp-1D8h]@3
  int v97; // [sp+194h] [bp-1D4h]@3
  int v98; // [sp+198h] [bp-1D0h]@3
  int v99; // [sp+19Ch] [bp-1CCh]@3
  int v100; // [sp+1A0h] [bp-1C8h]@3
  int v101; // [sp+1A4h] [bp-1C4h]@3
  int v102; // [sp+1A8h] [bp-1C0h]@3
  int v103; // [sp+1ACh] [bp-1BCh]@21
  int v104; // [sp+1B0h] [bp-1B8h]@21
  int v105; // [sp+1B4h] [bp-1B4h]@21
  int v106; // [sp+1B8h] [bp-1B0h]@21
  int v107; // [sp+1BCh] [bp-1ACh]@21
  int v108; // [sp+1C0h] [bp-1A8h]@21
  int v109; // [sp+1C4h] [bp-1A4h]@21
  int v110; // [sp+1C8h] [bp-1A0h]@21
  int v111; // [sp+1CCh] [bp-19Ch]@21
  int v112; // [sp+1D0h] [bp-198h]@21
  int v113; // [sp+1D4h] [bp-194h]@21
  int v114; // [sp+1D8h] [bp-190h]@21
  double v115; // [sp+264h] [bp-104h]@21
  double v116; // [sp+26Ch] [bp-FCh]@21
  double v117; // [sp+274h] [bp-F4h]@3
  double v118; // [sp+27Ch] [bp-ECh]@3
  int v119; // [sp+284h] [bp-E4h]@3
  int v120; // [sp+288h] [bp-E0h]@3
  double v121; // [sp+28Ch] [bp-DCh]@3
  double v122; // [sp+294h] [bp-D4h]@3
  double v123; // [sp+29Ch] [bp-CCh]@3
  double v124; // [sp+2A4h] [bp-C4h]@3
  double v125; // [sp+2ACh] [bp-BCh]@3
  double v126; // [sp+2B4h] [bp-B4h]@3
  double v127; // [sp+2BCh] [bp-ACh]@3
  double v128; // [sp+2C4h] [bp-A4h]@3
  double v129; // [sp+2CCh] [bp-9Ch]@3
  int v130; // [sp+2D4h] [bp-94h]@3
  int v131; // [sp+2D8h] [bp-90h]@3
  int v132; // [sp+2DCh] [bp-8Ch]@3
  int v133; // [sp+2E0h] [bp-88h]@3
  int v134; // [sp+2E4h] [bp-84h]@3
  int v135; // [sp+2E8h] [bp-80h]@3
  int v136; // [sp+2ECh] [bp-7Ch]@3
  int v137; // [sp+2F0h] [bp-78h]@3
  int v138; // [sp+2F4h] [bp-74h]@3
  int v139; // [sp+2F8h] [bp-70h]@3
  int v140; // [sp+2FCh] [bp-6Ch]@3
  int v141; // [sp+300h] [bp-68h]@3
  int v142; // [sp+304h] [bp-64h]@3
  int v143; // [sp+308h] [bp-60h]@3
  int v144; // [sp+30Ch] [bp-5Ch]@3
  int v145; // [sp+310h] [bp-58h]@3
  int v146; // [sp+314h] [bp-54h]@3
  int v147; // [sp+318h] [bp-50h]@3
  int v148; // [sp+31Ch] [bp-4Ch]@3
  int v149; // [sp+320h] [bp-48h]@3
  int v150; // [sp+324h] [bp-44h]@3
  int v151; // [sp+328h] [bp-40h]@3
  int v152; // [sp+32Ch] [bp-3Ch]@3
  int v153; // [sp+330h] [bp-38h]@3
  void *v154; // [sp+334h] [bp-34h]@1
  void *v155; // [sp+338h] [bp-30h]@1
  void *v156; // [sp+33Ch] [bp-2Ch]@1
  void *v157; // [sp+340h] [bp-28h]@1
  char *v158; // [sp+344h] [bp-24h]@1
  __int64 v159; // [sp+348h] [bp-20h]@4
  __int64 v160; // [sp+350h] [bp-18h]@4
  double v161; // [sp+358h] [bp-10h]@15
  void *v162; // [sp+360h] [bp-8h]@1
  void *v163; // [sp+364h] [bp-4h]@1
  void *v164; // [sp+370h] [bp+8h]@1

  v3 = a1;
  v158 = (char *)malloc(856u);
  sub_10006660(a1, (int)v158);
  v162 = malloc(0x228u);
  sub_10005410(a1, (int)v162);
  v154 = malloc(0x120u);
  sub_100055C0(a1, (int)v154);
  v156 = malloc(0x40u);
  sub_10005700(a1, (int)v156);
  v1 = (int)malloc(0x1F0u);
  sub_100058D0(a1, v1);
  v163 = malloc(0x1F0u);
  sub_10005C10(a1, (int)v163);
  v155 = malloc(0x98u);
  sub_10005F50(a1, (int)v155);
  v164 = malloc(0x3B0u);
  sub_10006150(v3, (int)v164);
  v157 = malloc(0x18u);
  sub_10006060(v3, (int)v157);
  v2 = malloc(0x24u);
  if ( !v2 )
    return 1;
  v6 = v158;
  v7 = v162;
  *((_DWORD *)v2 + 2) = v154;
  v8 = v155;
  *(_DWORD *)v2 = v6;
  v9 = v156;
  *((_DWORD *)v2 + 1) = v7;
  v10 = v163;
  *((_DWORD *)v2 + 6) = v8;
  *((_DWORD *)v2 + 3) = v9;
  *((_DWORD *)v2 + 5) = v10;
  v11 = v157;
  *((_DWORD *)v2 + 4) = v1;
  *((_DWORD *)v2 + 7) = v164;
  *((_DWORD *)v2 + 8) = v11;
  sub_10006A10(v3, (int)&v66);
  sub_10006C90(v3, (int)&v66);
  sub_10006F30(v3, (int)&v66);
  v12 = *(double *)&v66 + *(double *)(v1 + 432);
  v5 = v158;
  v29 = v12;
  v13 = *((double *)v163 + 54);
  *(_QWORD *)&v117 = v66;
  *(_QWORD *)&v118 = v67;
  v32 = v13 + v12;
  v14 = v12 + *((double *)v158 + 104);
  v120 = v69;
  *(_QWORD *)&v121 = v70;
  v35 = v14;
  v15 = *(double *)(v1 + 440);
  *(_QWORD *)&v122 = v71;
  v16 = v15 + *(double *)&v67;
  v30 = v16;
  v17 = *((double *)v163 + 55);
  *(_QWORD *)&v124 = v73;
  v33 = v17 + v16;
  v36 = v16 + *((double *)v158 + 105);
  v18 = *(double *)(v1 + 448) + v68;
  v31 = v18;
  v19 = *((double *)v163 + 56) + v18;
  v119 = LODWORD(v68);
  v34 = v19;
  v20 = v18 + *((double *)v158 + 106);
  *(_QWORD *)&v123 = v72;
  v37 = v20;
  *(_QWORD *)&v125 = v74;
  *(_QWORD *)&v127 = v76;
  *(_QWORD *)&v126 = v75;
  *(_QWORD *)&v128 = v77;
  v130 = v79;
  *(_QWORD *)&v129 = v78;
  v133 = v82;
  v131 = v80;
  v132 = v81;
  v136 = v85;
  v134 = v83;
  v135 = v84;
  v139 = v88;
  v137 = v86;
  v138 = v87;
  v142 = v91;
  v140 = v89;
  v141 = v90;
  v145 = v94;
  v143 = v92;
  v144 = v93;
  v148 = v97;
  v146 = v95;
  v147 = v96;
  v151 = v100;
  v149 = v98;
  v150 = v99;
  v152 = v101;
  v153 = v102;
  if ( strstr((const char *)v164, "POSX") )
  {
    v159 = v70;
    v160 = v71;
    v21 = *(double *)&v72;
  }
  else
  {
    if ( !strstr((const char *)v164, "POSY") )
    {
      if ( !strstr((const char *)v164, "POSZ") )
      {
        if ( strstr((const char *)v164, "NEGX") )
        {
          *(double *)&v159 = -*(double *)&v70;
          *(double *)&v160 = -*(double *)&v71;
          v21 = -*(double *)&v72;
          goto LABEL_15;
        }
        if ( strstr((const char *)v164, "NEGY") )
        {
          *(double *)&v159 = -*(double *)&v73;
          *(double *)&v160 = -*(double *)&v74;
          v21 = -*(double *)&v75;
          goto LABEL_15;
        }
        if ( strstr((const char *)v164, "NEGZ") )
        {
          *(double *)&v159 = -*(double *)&v76;
          *(double *)&v160 = -*(double *)&v77;
          v21 = -*(double *)&v78;
          goto LABEL_15;
        }
      }
      v159 = v76;
      v160 = v77;
      v21 = *(double *)&v78;
      goto LABEL_15;
    }
    v159 = v73;
    v160 = v74;
    v21 = *(double *)&v75;
  }
LABEL_15:
  v161 = v21;
  if ( strstr(v5, "5_axis_dual_table") )
  {
    v38 = 2;
  }
  else
  {
    if ( strstr(v5, "5_axis_dual_head") )
    {
      v38 = 1;
    }
    else
    {
      if ( strstr(v5, "5_axis_head_table") )
        v38 = 3;
    }
  }
  v39 = *((double *)v5 + 100);
  v40 = v103;
  v43 = v106;
  v41 = v104;
  v42 = v105;
  v46 = v109;
  v44 = v107;
  v45 = v108;
  v49 = v112;
  v22 = *(_DWORD *)(v1 + 432);
  v47 = v110;
  v48 = v111;
  v52 = v22;
  v23 = *(_DWORD *)(v1 + 444);
  v50 = v113;
  v24 = *(_DWORD *)(v1 + 436);
  v51 = v114;
  v25 = *(_DWORD *)(v1 + 440);
  v55 = v23;
  v53 = v24;
  v26 = *(_DWORD *)(v1 + 448);
  v54 = v25;
  v27 = *(_DWORD *)(v1 + 452);
  v56 = v26;
  v57 = v27;
  v59 = v116;
  v58 = atoi(v5 + 133) == 1;
  v60 = *(double *)(v1 + 408);
  v61 = *(double *)(v1 + 416);
  v62 = *((double *)v163 + 51);
  v63 = *((double *)v163 + 52);
  v64 = v115;
  if ( strstr(v5, "5_axis_dual_table") )
    v28 = 0.0;
  else
    v28 = *((double *)v162 + 67);
  v65 = v28;
  sub_100041A0(
    (int)&v130,
    &v117,
    (int)&v29,
    v1 + 456,
    (int)&v32,
    (int)((char *)v163 + 456),
    (int)&v35,
    (int)&v159,
    &v38);
  free(v2);
  free(v5);
  if ( v162 )
    free(v162);
  if ( v154 )
    free(v154);
  if ( v156 )
    free(v156);
  free((void *)v1);
  free(v163);
  if ( v155 )
    free(v155);
  if ( v164 )
    free(v164);
  if ( v157 )
    free(v157);
  return 0;
}

//----- (10001AB0) --------------------------------------------------------
int __cdecl sub_10001AB0(int a1)
{
  char v2; // [sp+10h] [bp-208h]@1
  char v3; // [sp+198h] [bp-80h]@1
  double v4; // [sp+1C8h] [bp-50h]@1
  double v5; // [sp+1D0h] [bp-48h]@1
  double v6; // [sp+1D8h] [bp-40h]@1
  double v7; // [sp+1E0h] [bp-38h]@1
  double v8; // [sp+1E8h] [bp-30h]@1
  double v9; // [sp+1F0h] [bp-28h]@1
  double v10; // [sp+1F8h] [bp-20h]@1
  double v11; // [sp+200h] [bp-18h]@1
  double v12; // [sp+208h] [bp-10h]@1
  double v13; // [sp+210h] [bp-8h]@1

  sub_10006F30(a1, (int)&v2);
  sub_100026E0((int)&v2);
  sub_10007150(a1, (int)&v3);
  sub_10004F70((int)&v3, (int)&v4, (int)&v9);
  UF_MOM_set_double(a1, "pos_x", LODWORD(v4), HIDWORD(v4));
  UF_MOM_set_double(a1, "pos_y", LODWORD(v5), HIDWORD(v5));
  UF_MOM_set_double(a1, "pos_z", LODWORD(v6), HIDWORD(v6));
  UF_MOM_set_double(a1, "pos_a1", LODWORD(v7), HIDWORD(v7));
  UF_MOM_set_double(a1, "pos_a2", LODWORD(v8), HIDWORD(v8));
  UF_MOM_set_double(a1, "alt_pos_x", LODWORD(v9), HIDWORD(v9));
  UF_MOM_set_double(a1, "alt_pos_y", LODWORD(v10), HIDWORD(v10));
  UF_MOM_set_double(a1, "alt_pos_z", LODWORD(v11), HIDWORD(v11));
  UF_MOM_set_double(a1, "alt_pos_a1", LODWORD(v12), HIDWORD(v12));
  UF_MOM_set_double(a1, "alt_pos_a2", LODWORD(v13), HIDWORD(v13));
  return 0;
}
// 10009148: using guessed type int __cdecl UF_MOM_set_double(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10001BB0) --------------------------------------------------------
signed int __cdecl sub_10001BB0(int a1, int a2, int a3, int a4)
{
  int v5; // eax@6
  _BYTE *v6; // edx@6
  char v7; // cl@7
  int v8; // eax@8
  _BYTE *v9; // edx@8
  char v10; // cl@9
  int v11; // eax@16
  char v12; // cl@17
  int v13; // eax@19
  char v14; // cl@20
  char v15; // [sp+8h] [bp-488h]@2
  __int16 v16; // [sp+28h] [bp-468h]@5
  _BYTE v17[136]; // [sp+208h] [bp-288h]@1
  int v18; // [sp+290h] [bp-200h]@1
  int v19; // [sp+294h] [bp-1FCh]@1
  __int16 v20; // [sp+298h] [bp-1F8h]@1
  _BYTE v21[136]; // [sp+318h] [bp-178h]@13
  _BYTE v22[52]; // [sp+3A0h] [bp-F0h]@8
  int v23; // [sp+3D4h] [bp-BCh]@1
  int v24; // [sp+3D8h] [bp-B8h]@1
  int v25; // [sp+3DCh] [bp-B4h]@1
  int v26; // [sp+3E0h] [bp-B0h]@1
  int v27; // [sp+3E4h] [bp-ACh]@1
  _BYTE v28[32]; // [sp+45Ch] [bp-34h]@6
  int v29; // [sp+47Ch] [bp-14h]@13
  int v30; // [sp+484h] [bp-Ch]@13
  int v31; // [sp+48Ch] [bp-4h]@1

  v23 = dword_100095E0;
  v24 = dword_100095E4;
  v25 = dword_100095E8;
  v26 = dword_100095EC;
  v27 = dword_100095F0;
  v31 = 0;
  *(_DWORD *)v17 = 2105376;
  v18 = dword_100095D4;
  v19 = dword_100095D8;
  v20 = word_100095DC;
  if ( a3 != 2 )
  {
    memcpy(&v15, "Invalid number of arguments", 0x1Cu);
LABEL_3:
    printf(" ERROR : %s \n ", &v15);
    return 1;
  }
  if ( UF_MOM_ask_string(a1, &v18, &a3) )
  {
    memcpy(&v15, "No Tool Name obtained from UGPost", 0x20u);
    v16 = *(_WORD *)&aNoToolNameObta[32];
    goto LABEL_3;
  }
  v5 = a3;
  v6 = &v28[-a3];
  do
  {
    v7 = *(_BYTE *)v5;
    v6[v5] = *(_BYTE *)v5;
    ++v5;
  }
  while ( v7 );
  v8 = *(_DWORD *)(a4 + 4);
  v9 = &v22[-v8];
  do
  {
    v10 = *(_BYTE *)v8;
    v9[v8] = *(_BYTE *)v8;
    ++v8;
  }
  while ( v10 );
  if ( UF_OBJ_cycle_by_name(v28, &v31) )
  {
    printf(" UF_OBJ_cycle_by_name could not get the tool_object_tag \n");
    return 1;
  }
  if ( v31 )
  {
    v30 = (int)v21;
    if ( UF_ATTR_read_value(v31, v22, 5, &v29) )
    {
      printf(" UF_ATTR_read_value could not return tool string \n");
      return 1;
    }
    if ( v29 != 5 )
    {
      v11 = 0;
      do
      {
        v12 = v17[v11];
        v21[v11++] = v12;
      }
      while ( v12 );
    }
  }
  else
  {
    v13 = 0;
    do
    {
      v14 = v17[v13];
      v21[v13++] = v14;
    }
    while ( v14 );
  }
  UF_MOM_set_string(a1, &v23, v21);
  return 0;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);
// 1000913C: using guessed type int __cdecl UF_OBJ_cycle_by_name(_DWORD, _DWORD);
// 10009140: using guessed type int __cdecl UF_ATTR_read_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 10009144: using guessed type int __cdecl UF_MOM_set_string(_DWORD, _DWORD, _DWORD);
// 100095D4: using guessed type int dword_100095D4;
// 100095D8: using guessed type int dword_100095D8;
// 100095DC: using guessed type __int16 word_100095DC;
// 100095E0: using guessed type int dword_100095E0;
// 100095E4: using guessed type int dword_100095E4;
// 100095E8: using guessed type int dword_100095E8;
// 100095EC: using guessed type int dword_100095EC;
// 100095F0: using guessed type int dword_100095F0;

//----- (10001DB0) --------------------------------------------------------
int __cdecl ufusr(int a1, int a2)
{
  int result; // eax@2
  int v3; // eax@3
  int v4; // eax@3
  int v5; // eax@3
  int v6; // eax@3
  int v7; // eax@3
  int v8; // eax@3
  char v9; // [sp+0h] [bp-8Ch]@1
  int v10; // [sp+84h] [bp-8h]@1
  int v11; // [sp+88h] [bp-4h]@3

  v10 = 0;
  if ( sub_10001070(&v9) )
  {
    printf("ERROR : Ugpost Advanced Kinematics license not found \n");
    uc1601(&v9, 1);
    result = UF_terminate();
  }
  else
  {
    UF_MOM_ask_interp_from_param(a1, &v10);
    UF_MOM_ask_mom(a1, &v11);
    v3 = UF_MOM_extend_xlator(v11, "MOM_load_kinematics", sub_10001340);
    sub_10001010(
      (int)"UF_MOM_extend_xlator ( mom, \"MOM_load_kinematics\", mom_load_kinematics )",
      (int)"O:\\ugnx60\\ip24\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      113,
      v3);
    v4 = UF_MOM_extend_xlator(v11, "MOM_convert_point", sub_10001AB0);
    sub_10001010(
      (int)"UF_MOM_extend_xlator ( mom, \"MOM_convert_point\", mom_convert_point )",
      (int)"O:\\ugnx60\\ip24\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      123,
      v4);
    v5 = UF_MOM_extend_xlator(v11, "MOM_get_tool_attribute", sub_10001BB0);
    sub_10001010(
      (int)"UF_MOM_extend_xlator ( mom , \"MOM_get_tool_attribute\", mom_get_tool_attribute )",
      (int)"O:\\ugnx60\\ip24\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      133,
      v5);
    v6 = UF_MOM_extend_xlator(v11, "MOM_rotate_mach_csys", sub_100010D0);
    sub_10001010(
      (int)"UF_MOM_extend_xlator ( mom, \"MOM_rotate_mach_csys\", mom_rotate_mach_csys )",
      (int)"O:\\ugnx60\\ip24\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      143,
      v6);
    v7 = UF_MOM_extend_xlator(v11, "MOM_map_to_rotated_csys", sub_10001260);
    sub_10001010(
      (int)"UF_MOM_extend_xlator ( mom, \"MOM_map_to_rotated_csys\", mom_map_to_rotated_csys )",
      (int)"O:\\ugnx60\\ip24\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      153,
      v7);
    v8 = UF_MOM_extend_xlator(v11, "MOM_exit_kinematics_module", UF_terminate);
    result = sub_10001010(
               (int)"UF_MOM_extend_xlator ( mom, \"MOM_exit_kinematics_module\", mom_exit_kinematics_module )",
               (int)"O:\\ugnx60\\ip24\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
               163,
               v8);
    dword_1000C240 = v11;
    *(_DWORD *)a2 = 0;
  }
  return result;
}
// 100010C0: using guessed type int UF_terminate();
// 1000912C: using guessed type int __cdecl UF_MOM_ask_interp_from_param(_DWORD, _DWORD);
// 10009130: using guessed type int __cdecl UF_MOM_ask_mom(_DWORD, _DWORD);
// 10009134: using guessed type int __cdecl UF_MOM_extend_xlator(_DWORD, _DWORD, _DWORD);
// 1000914C: using guessed type int UF_terminate(void);
// 10009160: using guessed type int __cdecl uc1601(_DWORD, _DWORD);
// 1000C240: using guessed type int dword_1000C240;

//----- (10001F20) --------------------------------------------------------
int __usercall sub_10001F20<eax>(int a1<eax>, int a2<ecx>, int a3<esi>, char a4)
{
  UF_VEC3_cross(a2, a1);
  return UF_VEC3_unitize(a3, COERCE_UNSIGNED_INT64(1.0e-10), COERCE_UNSIGNED_INT64(1.0e-10) >> 32, &a4, a3);
}
// 100090B0: using guessed type int __cdecl UF_VEC3_cross(_DWORD, _DWORD);
// 10009128: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10001FA0) --------------------------------------------------------
int __usercall sub_10001FA0<eax>(int result<eax>, int _ECX<ecx>, double a3)
{
  __asm
  {
    fld     [ebp+arg_0]
    fld     st
    fcos
    fxch    st(1)
    fsin
    fld     qword ptr [eax]
    fmul    st, st
    fld     qword ptr [eax+8]
    fmul    st, st
    fld     qword ptr [eax+10h]
    fmul    st, st
    fstp    [ebp+var_8]
    fld1
    fld     st
    fsub    st, st(5)
    fld     st(1)
    fsub    st, st(4)
    fmul    st, st(6)
    faddp   st(4), st
    fxch    st(3)
    fstp    qword ptr [ecx]
    fld     qword ptr [eax+8]
    fmul    qword ptr [eax]
    fmul    st, st(3)
    fld     qword ptr [eax+10h]
    fmul    st, st(5)
    faddp   st(1), st
    fstp    qword ptr [ecx+8]
    fld     qword ptr [eax+10h]
    fmul    qword ptr [eax]
    fmul    st, st(3)
    fld     qword ptr [eax+8]
    fmul    st, st(5)
    fsubp   st(1), st
    fstp    qword ptr [ecx+10h]
    fldz
    fst     qword ptr [ecx+18h]
    fld     qword ptr [eax+8]
    fmul    qword ptr [eax]
    fmul    st, st(4)
    fld     qword ptr [eax+10h]
    fmul    st, st(6)
    fsubp   st(1), st
    fstp    qword ptr [ecx+20h]
    fld     st(1)
    fsub    st, st(3)
    fmul    st, st(6)
    faddp   st(3), st
    fxch    st(2)
    fstp    qword ptr [ecx+28h]
    fld     qword ptr [eax+10h]
    fmul    qword ptr [eax+8]
    fmul    st, st(3)
    fld     qword ptr [eax]
    fmul    st, st(5)
    faddp   st(1), st
    fstp    qword ptr [ecx+30h]
    fxch    st(1)
    fst     qword ptr [ecx+38h]
    fld     qword ptr [eax+10h]
    fmul    qword ptr [eax]
    fmul    st, st(3)
    fld     qword ptr [eax+8]
    fmul    st, st(5)
    faddp   st(1), st
    fstp    qword ptr [ecx+40h]
    fld     qword ptr [eax+10h]
    fmul    qword ptr [eax+8]
    fmulp   st(3), st
    fld     qword ptr [eax]
    fmulp   st(4), st
    fxch    st(2)
    fsubrp  st(3), st
    fxch    st(2)
    fstp    qword ptr [ecx+48h]
    fld     st(1)
    fld     [ebp+var_8]
    fsub    st(1), st
    fxch    st(1)
    fmulp   st(4), st
    faddp   st(3), st
    fxch    st(2)
    fstp    qword ptr [ecx+50h]
    fxch    st(1)
    fst     qword ptr [ecx+58h]
    fst     qword ptr [ecx+60h]
    fst     qword ptr [ecx+68h]
    fstp    qword ptr [ecx+70h]
    fstp    qword ptr [ecx+78h]
  }
  return result;
}
// 10001FA6: inconsistent fpu stack

//----- (10002080) --------------------------------------------------------
int __usercall sub_10002080<eax>(int a1<eax>, int a2<ecx>, int a3)
{
  int v4; // esi@1
  int v5; // edi@1
  char v6; // [sp+Ch] [bp-120h]@1
  char v7; // [sp+54h] [bp-D8h]@1
  char v8; // [sp+9Ch] [bp-90h]@1
  char v9; // [sp+B4h] [bp-78h]@1
  char v10; // [sp+CCh] [bp-60h]@1
  char v11; // [sp+E4h] [bp-48h]@1
  double v12; // [sp+FCh] [bp-30h]@1
  double v13; // [sp+104h] [bp-28h]@1
  double v14; // [sp+10Ch] [bp-20h]@1
  double v15; // [sp+114h] [bp-18h]@1
  double v16; // [sp+11Ch] [bp-10h]@1
  double v17; // [sp+124h] [bp-8h]@1

  v4 = a1;
  v5 = a2;
  UF_MTX3_copy(a1 + 24, &v7);
  UF_MTX3_copy(v5 + 24, &v6);
  v12 = *(double *)v4;
  v15 = *(double *)v5;
  v13 = *(double *)(v4 + 8);
  v16 = *(double *)(v5 + 8);
  v14 = *(double *)(v4 + 16);
  v17 = *(double *)(v5 + 16);
  UF_MTX3_x_vec(&v7, &v10);
  UF_MTX3_y_vec(&v7, &v8);
  UF_MTX3_x_vec(&v6, &v11);
  UF_MTX3_y_vec(&v6, &v9);
  return UF_MTX4_csys_to_csys(&v12, &v10, &v8, &v15, &v11, &v9, a3);
}
// 1000911C: using guessed type int __cdecl UF_MTX3_copy(_DWORD, _DWORD);
// 10009120: using guessed type int __cdecl UF_MTX3_x_vec(_DWORD, _DWORD);
// 10009124: using guessed type int __cdecl UF_MTX3_y_vec(_DWORD, _DWORD);
// 10009158: using guessed type int __cdecl UF_MTX4_csys_to_csys(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10002150) --------------------------------------------------------
int __usercall sub_10002150<eax>(int a1<eax>, int a2<esi>, double a3, double a4, signed int a5)
{
  int result; // eax@1
  int v6; // edx@1
  int v7; // ecx@1
  int v8; // edx@1
  int v9; // ecx@1
  int v10; // edx@1
  int v11; // ecx@1
  int v12; // edx@1
  int v13; // ecx@1
  int v14; // edx@1
  char v15; // [sp+14h] [bp-258h]@1
  char v16; // [sp+94h] [bp-1D8h]@1
  char v17; // [sp+114h] [bp-158h]@1
  char v18; // [sp+15Ch] [bp-110h]@1
  char v19; // [sp+1DCh] [bp-90h]@1
  double v20; // [sp+1F4h] [bp-78h]@1
  double v21; // [sp+1FCh] [bp-70h]@1
  double v22; // [sp+204h] [bp-68h]@1
  char v23; // [sp+20Ch] [bp-60h]@1
  int v24; // [sp+224h] [bp-48h]@1
  int v25; // [sp+228h] [bp-44h]@1
  int v26; // [sp+22Ch] [bp-40h]@1
  int v27; // [sp+230h] [bp-3Ch]@1
  int v28; // [sp+234h] [bp-38h]@1
  int v29; // [sp+238h] [bp-34h]@1
  double v30; // [sp+244h] [bp-28h]@1
  int v31; // [sp+24Ch] [bp-20h]@1
  int v32; // [sp+250h] [bp-1Ch]@1
  int v33; // [sp+254h] [bp-18h]@1
  int v34; // [sp+258h] [bp-14h]@1
  int v35; // [sp+25Ch] [bp-10h]@1
  int v36; // [sp+260h] [bp-Ch]@1
  double v37; // [sp+264h] [bp-8h]@1

  v6 = *(_DWORD *)(a1 + 4);
  v31 = *(_DWORD *)a1;
  v7 = *(_DWORD *)(a1 + 8);
  v37 = (long double)a5;
  v32 = v6;
  v8 = *(_DWORD *)(a1 + 12);
  v33 = v7;
  v9 = *(_DWORD *)(a1 + 16);
  v34 = v8;
  v10 = *(_DWORD *)(a1 + 20);
  v30 = *(double *)(dword_1000C3D8 + 8);
  v35 = v9;
  v20 = 0.0;
  v21 = 0.0;
  v22 = 0.0;
  v36 = v10;
  UF_MTX4_rotation(
    &dword_1000C2C8,
    &dbl_1000C328,
    COERCE_UNSIGNED_INT64(a4 * -57.29577951308235),
    COERCE_UNSIGNED_INT64(a4 * -57.29577951308235) >> 32,
    &v18);
  sub_100053B0((int)&v18);
  UF_MTX4_ask_rotation(&v18, &v17);
  UF_MTX3_vec_multiply(&dbl_1000C2F0, &v17, &v23);
  UF_VEC3_unitize(&v23, LODWORD(v30), HIDWORD(v30), &a4, &v23);
  UF_MTX4_vec3_multiply(&v20, &v18, &v19);
  UF_MTX4_rotation(
    &v19,
    &v23,
    COERCE_UNSIGNED_INT64(a3 * -57.29577951308235),
    COERCE_UNSIGNED_INT64(a3 * -57.29577951308235) >> 32,
    &v16);
  sub_100053B0((int)&v16);
  UF_MTX4_multiply(&v18, &v16, &v15);
  sub_100053B0((int)&v15);
  UF_MTX4_vec_multiply(&v31, &v15, &v24);
  v11 = v25;
  v12 = v26;
  *(_DWORD *)a2 = v24;
  result = v27;
  *(_DWORD *)(a2 + 4) = v11;
  v13 = v28;
  *(_DWORD *)(a2 + 8) = v12;
  v14 = v29;
  *(_DWORD *)(a2 + 12) = result;
  *(_DWORD *)(a2 + 16) = v13;
  *(_DWORD *)(a2 + 20) = v14;
  return result;
}
// 10009104: using guessed type int __cdecl UF_MTX4_rotation(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10009108: using guessed type int __cdecl UF_MTX4_ask_rotation(_DWORD, _DWORD);
// 1000910C: using guessed type int __cdecl UF_MTX3_vec_multiply(_DWORD, _DWORD, _DWORD);
// 10009110: using guessed type int __cdecl UF_MTX4_vec3_multiply(_DWORD, _DWORD, _DWORD);
// 10009114: using guessed type int __cdecl UF_MTX4_multiply(_DWORD, _DWORD, _DWORD);
// 10009118: using guessed type int __cdecl UF_MTX4_vec_multiply(_DWORD, _DWORD, _DWORD);
// 10009128: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1000C2C8: using guessed type int dword_1000C2C8;
// 1000C2F0: using guessed type double dbl_1000C2F0;
// 1000C328: using guessed type double dbl_1000C328;
// 1000C3D8: using guessed type int dword_1000C3D8;

//----- (100022D0) --------------------------------------------------------
int __cdecl sub_100022D0(int a1, double a2, int a3)
{
  char v4; // [sp+Ch] [bp-E0h]@1
  char v5; // [sp+8Ch] [bp-60h]@1
  char v6; // [sp+D4h] [bp-18h]@1

  UF_MTX4_rotation(
    &dword_1000C540,
    &dbl_1000C2F0,
    COERCE_UNSIGNED_INT64(a2 * 57.29577951308235),
    COERCE_UNSIGNED_INT64(a2 * 57.29577951308235) >> 32,
    &v4);
  sub_100053B0((int)&v4);
  UF_MTX4_ask_rotation(&v4, &v5);
  UF_MTX3_vec_multiply(&dword_1000C2C8, &v5, &v6);
  return UF_VEC3_add(a1, &v6, a3);
}
// 10009100: using guessed type int __cdecl UF_VEC3_add(_DWORD, _DWORD, _DWORD);
// 10009104: using guessed type int __cdecl UF_MTX4_rotation(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10009108: using guessed type int __cdecl UF_MTX4_ask_rotation(_DWORD, _DWORD);
// 1000910C: using guessed type int __cdecl UF_MTX3_vec_multiply(_DWORD, _DWORD, _DWORD);
// 1000C2C8: using guessed type int dword_1000C2C8;
// 1000C2F0: using guessed type double dbl_1000C2F0;
// 1000C540: using guessed type int dword_1000C540;

//----- (10002350) --------------------------------------------------------
int __cdecl sub_10002350(int a1, double a2, int a3)
{
  int v4; // ecx@1
  char v5; // [sp+8h] [bp-80h]@1

  sub_10001FA0((int)&dbl_1000C328, (int)&v5, a2);
  sub_100053B0(v4);
  return UF_MTX4_vec3_multiply_t(a1, &v5, a3);
}
// 100090FC: using guessed type int __cdecl UF_MTX4_vec3_multiply_t(_DWORD, _DWORD, _DWORD);
// 1000C328: using guessed type double dbl_1000C328;

//----- (10002390) --------------------------------------------------------
long double __fastcall sub_10002390(int a1, int a2, int a3)
{
  double v4; // [sp+0h] [bp-8h]@1

  UF_VEC3_angle_between(a3, a2, a1, &v4);
  return v4;
}
// 100090F8: using guessed type int __cdecl UF_VEC3_angle_between(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100023B0) --------------------------------------------------------
int __usercall sub_100023B0<eax>(int a1<eax>, int a2<ecx>, int a3)
{
  long double v4; // fst7@1
  long double v5; // fst6@1
  double v6; // [sp+0h] [bp-18h]@1
  double v7; // [sp+8h] [bp-10h]@1
  double v8; // [sp+10h] [bp-8h]@1

  v4 = *(double *)a1;
  v5 = sin(*(double *)(a1 + 8));
  v6 = cos(v4) * v5;
  v7 = sin(v4) * v5;
  v8 = v5;
  return UF_MTX3_vec_multiply(&v6, a2 + 24, a3);
}
// 1000910C: using guessed type int __cdecl UF_MTX3_vec_multiply(_DWORD, _DWORD, _DWORD);

//----- (100023F0) --------------------------------------------------------
signed int __cdecl sub_100023F0(int a1, int a2)
{
  signed int result; // eax@2

  if ( dbl_1000C000 < fabs(*(double *)a1 - *(double *)a2) )
  {
    if ( dbl_1000C000 + *(double *)a2 >= (long double)*(double *)a1 )
      result = -1;
    else
      result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1000C000: using guessed type double dbl_1000C000;

//----- (10002430) --------------------------------------------------------
void __fastcall sub_10002430(int a1, int a2)
{
  long double v2; // fst6@1
  long double v3; // fst7@1
  long double v4; // fst5@4
  long double v5; // fst5@5
  long double v6; // fst4@7
  long double v7; // fst6@12
  long double v8; // ft1@14
  long double v9; // ft2@20
  long double v10; // fst6@20
  long double v11; // fst7@20

  v3 = dbl_1000C000;
  v2 = 6.283185307179586;
  if ( dbl_1000C000 >= fabs(*(double *)a2 - *(double *)(a2 + 8)) )
  {
    if ( fabs(*(double *)a1 - *(double *)(a1 + 8)) <= v3 )
    {
      if ( fabs(*(double *)a2 - *(double *)a1) > v3 )
      {
        v4 = -v3;
        if ( -v3 <= *(double *)a2 )
        {
          if ( v4 <= *(double *)a1 )
          {
            v7 = dbl_1000C000;
            if ( dbl_1000C000 < (long double)*(double *)(a1 + 8) )
              *(double *)(a1 + 8) = *(double *)(a1 + 8) - 6.283185307179586;
            v8 = v7;
            v2 = 6.283185307179586;
            v3 = v8;
          }
          else
          {
            v6 = *(double *)a1 + 6.283185307179586;
            if ( fabs(v6 - *(double *)a2) <= v3 )
            {
              if ( v4 > *(double *)(a1 + 8) )
                *(double *)(a1 + 8) = *(double *)(a1 + 8) + 6.283185307179586;
            }
            else
            {
              *(double *)a1 = v6;
              if ( fabs(v6 - *(double *)(a1 + 8)) <= v3 )
                *(double *)(a1 + 8) = 6.283185307179586 - v6;
            }
          }
        }
        else
        {
          v5 = *(double *)a2 + 6.283185307179586;
          *(double *)a2 = v5;
          *(double *)(a2 + 8) = 6.283185307179586 - v5;
        }
      }
    }
  }
  if ( fabs(*(double *)a2 - *(double *)a1) <= v3 )
  {
    if ( fabs(*(double *)(a2 + 8) - *(double *)(a1 + 8)) <= v3 )
    {
      if ( -v3 <= *(double *)(a1 + 8) )
      {
        v9 = v2;
        v10 = v3;
        v11 = v9;
        if ( v10 >= *(double *)(a1 + 8) )
        {
          if ( fabs(*(double *)a2) <= v10 )
          {
            if ( fabs(*(double *)a1) <= v10 )
              *(double *)(a1 + 8) = v11;
          }
        }
        else
        {
          *(double *)(a1 + 8) = v11 - *(double *)(a1 + 8);
        }
      }
      else
      {
        *(double *)(a1 + 8) = v2 + *(double *)(a1 + 8);
      }
    }
  }
}
// 1000C000: using guessed type double dbl_1000C000;

//----- (10002580) --------------------------------------------------------
long double __cdecl sub_10002580(double a1)
{
  long double v1; // fst6@1
  long double result; // fst7@2

  v1 = a1;
  if ( a1 <= 0.0 )
  {
    result = a1;
    if ( v1 < 0.0 )
      result = v1 + 360.0;
  }
  else
  {
    result = v1 - 360.0;
  }
  return result;
}

//----- (100025B0) --------------------------------------------------------
void __usercall sub_100025B0(int a1<edx>, int a2<ebx>)
{
  int v2; // edx@1
  long double v3; // fst7@1
  int v4; // ecx@1
  int v5; // edx@3
  int v6; // ecx@3
  long double v7; // fst7@3
  long double v8; // fst7@7
  char v9; // [sp+8h] [bp-28h]@6

  v3 = sub_10002580(*(double *)(a1 + 24));
  if ( fabs(*(double *)(v4 + 24) - v3) < fabs(*(double *)(v4 + 24) - *(double *)(v2 + 24)) )
    *(double *)(v2 + 24) = v3;
  v7 = sub_10002580(*(double *)(v2 + 32));
  if ( fabs(*(double *)(v6 + 32) - v7) < fabs(*(double *)(v6 + 32) - *(double *)(v5 + 32)) )
    *(double *)(v5 + 32) = v7;
  if ( fabs(*(double *)(v6 + 24) - *(double *)(a2 + 24)) < fabs(*(double *)(v6 + 24) - *(double *)(v5 + 24)) )
  {
    memcpy(&v9, (const void *)v5, 0x28u);
    memcpy((void *)v5, (const void *)a2, 0x28u);
    memcpy((void *)a2, &v9, 0x28u);
  }
  v8 = dbl_1000C000;
  if ( *(double *)(dword_1000C3D8 + 104) - dbl_1000C000 >= (long double)*(double *)(v5 + 24)
    || *(double *)(dword_1000C3D8 + 112) + v8 <= *(double *)(v5 + 24) )
  {
    if ( *(double *)(dword_1000C3D8 + 120) - v8 < *(double *)(a2 + 24) )
    {
      if ( v8 + *(double *)(dword_1000C3D8 + 128) > *(double *)(a2 + 24) )
      {
        memcpy(&v9, (const void *)v5, 0x28u);
        memcpy((void *)v5, (const void *)a2, 0x28u);
        memcpy((void *)a2, &v9, 0x28u);
      }
    }
  }
}
// 1000C000: using guessed type double dbl_1000C000;
// 1000C3D8: using guessed type int dword_1000C3D8;

//----- (100026E0) --------------------------------------------------------
int __cdecl sub_100026E0(int a1)
{
  int v2; // ecx@1

  v2 = dword_1000C3D8;
  *(_DWORD *)(dword_1000C3D8 + 16) = *(_DWORD *)(a1 + 192);
  *(_DWORD *)(v2 + 20) = *(_DWORD *)(a1 + 196);
  *(_DWORD *)(v2 + 24) = *(_DWORD *)(a1 + 200);
  *(_DWORD *)(v2 + 28) = *(_DWORD *)(a1 + 204);
  *(_DWORD *)(v2 + 32) = *(_DWORD *)(a1 + 208);
  *(_DWORD *)(v2 + 36) = *(_DWORD *)(a1 + 212);
  *(_DWORD *)(v2 + 40) = *(_DWORD *)(a1 + 216);
  *(_DWORD *)(v2 + 44) = *(_DWORD *)(a1 + 220);
  *(_DWORD *)(v2 + 48) = *(_DWORD *)(a1 + 224);
  *(_DWORD *)(v2 + 52) = *(_DWORD *)(a1 + 228);
  *(_DWORD *)(v2 + 56) = *(_DWORD *)(a1 + 232);
  *(_DWORD *)(v2 + 60) = *(_DWORD *)(a1 + 236);
  *(double *)(v2 + 136) = *(double *)(a1 + 376);
  return 0;
}
// 1000C3D8: using guessed type int dword_1000C3D8;

//----- (10002770) --------------------------------------------------------
int __cdecl sub_10002770(int a1, int a2, int a3, int a4)
{
  long double v4; // fst7@1
  int result; // eax@2
  long double v6; // fst7@2
  char v7; // [sp+8h] [bp-40h]@1
  double v8; // [sp+20h] [bp-28h]@1
  double v9; // [sp+28h] [bp-20h]@1
  double v10; // [sp+30h] [bp-18h]@1
  double v11; // [sp+38h] [bp-10h]@1
  double v12; // [sp+40h] [bp-8h]@2

  UF_VEC3_sub(a2 + 24, a2, &v8);
  UF_VEC3_sub(a1, a2, &v7);
  v4 = v10 * v10 + v9 * v9 + v8 * v8;
  v11 = v4;
  if ( v4 <= 0.0 )
  {
    *(double *)a4 = 0.0;
    UF_VEC3_copy(a2, a3);
    result = 0;
  }
  else
  {
    UF_VEC3_dot(&v8, &v7, &v12);
    v6 = v12 / v11;
    *(double *)a4 = v6;
    *(double *)a3 = v6 * v8 + *(double *)a2;
    *(double *)(a3 + 8) = *(double *)a4 * v9 + *(double *)(a2 + 8);
    result = 0;
    *(double *)(a3 + 16) = *(double *)a4 * v10 + *(double *)(a2 + 16);
  }
  return result;
}
// 10002770: using guessed type _DWORD __cdecl sub_10002770(_DWORD, _DWORD, _DWORD, _DWORD);
// 100090EC: using guessed type int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD);
// 100090F0: using guessed type int __cdecl UF_VEC3_dot(_DWORD, _DWORD, _DWORD);
// 100090F4: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);

//----- (10002830) --------------------------------------------------------
signed int __cdecl sub_10002830(int a1, signed int a2, int a3, int a4)
{
  int v4; // edi@1
  signed int v5; // esi@1
  int v6; // eax@1
  int v7; // ebx@2
  long double v8; // fst5@2
  int v9; // edx@3
  unsigned int v10; // ecx@3
  long double v11; // fst4@4
  long double v12; // fst4@6
  long double v13; // fst4@8
  long double v14; // fst4@10
  long double *v15; // edx@14
  int v16; // ecx@14
  long double v17; // fst4@15
  unsigned __int8 v18; // sf@19
  unsigned __int8 v19; // of@19
  int v20; // edx@20
  signed int v21; // ecx@21
  signed int v22; // ebx@22
  int v23; // eax@23
  int v24; // esi@23
  long double v25; // fst4@23
  int v26; // eax@24
  int v27; // edx@24
  unsigned int v28; // ebx@24
  int v29; // edi@25
  long double v30; // fst3@25
  int v31; // eax@28
  int v32; // edx@29
  long double v33; // fst3@29
  int v34; // ebx@33
  long double v35; // fst4@33
  int v36; // eax@34
  int v37; // esi@34
  long double v38; // fst3@34
  int v39; // eax@35
  int v40; // edx@35
  unsigned int v41; // edi@35
  int v42; // ebx@36
  long double v43; // fst2@36
  int v44; // ebx@39
  long double v45; // fst2@40
  long double v46; // fst3@42
  signed int result; // eax@44
  int v48; // ebx@47
  int v49; // eax@48
  int v50; // eax@49
  int v51; // edx@49
  int v52; // ebx@49
  unsigned int v53; // esi@49
  int v54; // esi@49
  int v55; // ebx@49
  long double v56; // fst4@50
  long double v57; // fst4@50
  long double v58; // fst4@50
  long double v59; // fst4@50
  int v60; // eax@53
  int v61; // edx@53
  int v62; // ebx@53
  long double v63; // fst4@54
  int v64; // eax@57
  int v65; // ebx@57
  int v66; // edx@59
  int v67; // edx@60
  long double v68; // fst4@60
  int v69; // eax@61
  unsigned int v70; // ebx@61
  int v71; // esi@62
  int v72; // eax@65
  char v73; // [sp+Ch] [bp-24h]@1
  int v74; // [sp+10h] [bp-20h]@21
  int v75; // [sp+14h] [bp-1Ch]@21
  int v76; // [sp+18h] [bp-18h]@43
  int v77; // [sp+1Ch] [bp-14h]@23
  int v78; // [sp+20h] [bp-10h]@1
  int v79; // [sp+24h] [bp-Ch]@21
  int v80; // [sp+28h] [bp-8h]@20
  int v81; // [sp+2Ch] [bp-4h]@1

  v5 = a2;
  v4 = a1;
  v6 = UF_allocate_memory(8 * a2, &v73);
  *(double *)a4 = 1.0;
  v78 = v6;
  v81 = 0;
  if ( a2 <= 0 )
  {
LABEL_20:
    v20 = 0;
    v80 = 0;
    if ( a2 > 0 )
    {
      v75 = a2 - 1;
      v21 = 0;
      v79 = a1;
      v74 = a3 - a1;
      do
      {
        v22 = 0;
        v81 = 0;
        if ( v20 > 0 )
        {
          do
          {
            v23 = *(_DWORD *)(v4 + 4 * v22);
            v25 = *(double *)(v21 + v23);
            v24 = 0;
            v77 = *(_DWORD *)(v4 + 4 * v22);
            if ( v22 >= 4 )
            {
              v26 = v23 + 16;
              v28 = ((unsigned int)(v22 - 4) >> 2) + 1;
              v27 = v4 + 8;
              v24 = 4 * v28;
              do
              {
                v29 = *(_DWORD *)(v27 - 4);
                v30 = *(double *)(*(_DWORD *)(v27 - 8) + v21) * *(double *)(v26 - 16);
                v26 += 32;
                v27 += 16;
                --v28;
                v25 = v25
                    - v30
                    - *(double *)(v29 + v21) * *(double *)(v26 - 40)
                    - *(double *)(*(_DWORD *)(v27 - 16) + v21) * *(double *)(v26 - 32)
                    - *(double *)(*(_DWORD *)(v27 - 12) + v21) * *(double *)(v26 - 24);
              }
              while ( v28 );
              v4 = a1;
              v22 = v81;
              v23 = v77;
              v20 = v80;
            }
            if ( v24 < v22 )
            {
              v31 = v23 + 8 * v24;
              do
              {
                v32 = *(_DWORD *)(v4 + 4 * v24++);
                v33 = *(double *)(v32 + v21) * *(double *)v31;
                v31 += 8;
                v25 = v25 - v33;
              }
              while ( v24 < v22 );
              v23 = v77;
              v20 = v80;
            }
            ++v22;
            *(double *)(v21 + v23) = v25;
            v81 = v22;
          }
          while ( v22 < v20 );
          v5 = a2;
        }
        v35 = 0.0;
        v34 = v20;
        v81 = v20;
        if ( v20 < v5 )
        {
          do
          {
            v36 = *(_DWORD *)(v4 + 4 * v34);
            v38 = *(double *)(v21 + v36);
            v37 = 0;
            v77 = *(_DWORD *)(v4 + 4 * v34);
            if ( v21 >= 32 )
            {
              v40 = v4 + 8;
              v39 = v36 + 16;
              v41 = ((unsigned int)(v80 - 4) >> 2) + 1;
              v37 = 4 * v41;
              do
              {
                v42 = *(_DWORD *)(v40 - 4);
                v43 = *(double *)(*(_DWORD *)(v40 - 8) + v21) * *(double *)(v39 - 16);
                v39 += 32;
                v40 += 16;
                --v41;
                v38 = v38
                    - v43
                    - *(double *)(v42 + v21) * *(double *)(v39 - 40)
                    - *(double *)(*(_DWORD *)(v40 - 16) + v21) * *(double *)(v39 - 32)
                    - *(double *)(*(_DWORD *)(v40 - 12) + v21) * *(double *)(v39 - 24);
              }
              while ( v41 );
              v34 = v81;
              v4 = a1;
              v36 = v77;
              v20 = v80;
            }
            if ( v37 < v20 )
            {
              v44 = v36 + 8 * v37;
              do
              {
                v20 = v80;
                v45 = *(double *)(*(_DWORD *)(v4 + 4 * v37++) + v21) * *(double *)v44;
                v44 += 8;
                v38 = v38 - v45;
              }
              while ( v37 < v80 );
              v34 = v81;
            }
            *(double *)(v21 + v36) = v38;
            v46 = fabs(v38) * *(double *)(v78 + 8 * v34);
            if ( v46 >= v35 )
            {
              v35 = v46;
              v76 = v34;
            }
            ++v34;
            v81 = v34;
          }
          while ( v34 < a2 );
          v5 = a2;
        }
        v48 = v76;
        if ( v20 != v76 )
        {
          v49 = 0;
          v77 = 0;
          if ( v5 >= 4 )
          {
            v54 = *(_DWORD *)(v4 + 4 * v76);
            v55 = *(_DWORD *)v79;
            v51 = v54 + 24;
            v81 = v54 - *(_DWORD *)v79;
            v50 = v55 + 8;
            v53 = ((unsigned int)(a2 - 4) >> 2) + 1;
            v77 = 4 * v53;
            v52 = v81;
            do
            {
              v56 = *(double *)(v51 - 24);
              v50 += 32;
              v51 += 32;
              --v53;
              *(double *)(v51 - 56) = *(double *)(v50 - 40);
              *(double *)(v50 - 40) = v56;
              v57 = *(double *)(v50 + v52 - 32);
              *(double *)(v50 + v52 - 32) = *(double *)(v50 - 32);
              *(double *)(v50 - 32) = v57;
              v58 = *(double *)(v51 - 40);
              *(double *)(v51 - 40) = *(double *)(v50 - 24);
              *(double *)(v50 - 24) = v58;
              v59 = *(double *)(v51 - 32);
              *(double *)(v51 - 32) = *(double *)(v50 - 16);
              *(double *)(v50 - 16) = v59;
            }
            while ( v53 );
            v5 = a2;
            v48 = v76;
            v49 = v77;
          }
          if ( v49 < v5 )
          {
            v62 = *(_DWORD *)(v4 + 4 * v48) - *(_DWORD *)v79;
            v60 = *(_DWORD *)v79 + 8 * v49;
            v61 = v5 - v77;
            v81 = v62;
            do
            {
              v63 = *(double *)(v62 + v60);
              v60 += 8;
              --v61;
              *(double *)(v62 + v60 - 8) = *(double *)(v60 - 8);
              *(double *)(v60 - 8) = v63;
            }
            while ( v61 );
            v48 = v76;
          }
          *(double *)a4 = -*(double *)a4;
          *(double *)(v78 + 8 * v48) = *(double *)(v21 + v78);
        }
        v64 = v79;
        *(_DWORD *)(v74 + v79) = v48;
        v65 = v21 + *(_DWORD *)v64;
        if ( 0.0 == *(double *)v65 )
          *(double *)v65 = 9.999999999999999e-21;
        v66 = v80;
        if ( v80 != v5 - 1 )
        {
          v67 = v80 + 1;
          v68 = 1.0 / *(double *)v65;
          if ( v75 >= 4 )
          {
            v69 = v79 + 12;
            v70 = ((unsigned int)(v5 - v67 - 4) >> 2) + 1;
            v67 += 4 * v70;
            do
            {
              v71 = *(_DWORD *)(v69 - 8);
              v69 += 16;
              *(double *)(v21 + v71) = *(double *)(v71 + v21) * v68;
              *(double *)(v21 + *(_DWORD *)(v69 - 20)) = *(double *)(*(_DWORD *)(v69 - 20) + v21) * v68;
              *(double *)(v21 + *(_DWORD *)(v69 - 16)) = *(double *)(*(_DWORD *)(v69 - 16) + v21) * v68;
              --v70;
              *(double *)(v21 + *(_DWORD *)(v69 - 12)) = *(double *)(*(_DWORD *)(v69 - 12) + v21) * v68;
            }
            while ( v70 );
            v5 = a2;
          }
          for ( ; v67 < v5; *(double *)(v21 + v72) = v68 * *(double *)(v72 + v21) )
            v72 = *(_DWORD *)(v4 + 4 * v67++);
          v66 = v80;
        }
        --v75;
        v79 += 4;
        v20 = v66 + 1;
        v21 += 8;
        v80 = v20;
      }
      while ( v20 < v5 );
    }
    UF_free(v78);
    result = 0;
  }
  else
  {
    while ( 1 )
    {
      v7 = 0;
      v8 = 0.0;
      if ( a2 >= 4 )
      {
        v9 = *(_DWORD *)(a1 + 4 * v81) + 16;
        v10 = ((unsigned int)(a2 - 4) >> 2) + 1;
        v7 = 4 * v10;
        do
        {
          v11 = fabs(*(double *)(v9 - 16));
          if ( v11 > v8 )
            v8 = v11;
          v12 = fabs(*(double *)(v9 - 8));
          if ( v12 > v8 )
            v8 = v12;
          v13 = fabs(*(double *)v9);
          if ( v13 > v8 )
            v8 = v13;
          v14 = fabs(*(double *)(v9 + 8));
          if ( v14 > v8 )
            v8 = v14;
          v9 += 32;
          --v10;
        }
        while ( v10 );
      }
      if ( v7 < a2 )
      {
        v15 = (long double *)(*(_DWORD *)(a1 + 4 * v81) + 8 * v7);
        v16 = a2 - v7;
        do
        {
          v17 = fabs(*(double *)v15);
          if ( v17 > v8 )
            v8 = v17;
          v15 = (long double *)((char *)v15 + 8);
          --v16;
        }
        while ( v16 );
      }
      if ( 0.0 == v8 )
        break;
      v19 = __SETO__(v81 + 1, a2);
      v18 = v81++ + 1 - a2 < 0;
      *(double *)(v78 + 8 * v81 - 8) = 1.0 / v8;
      if ( !(v18 ^ v19) )
        goto LABEL_20;
    }
    UF_free(v78);
    result = 1;
  }
  return result;
}
// 100090E4: using guessed type int __cdecl UF_allocate_memory(_DWORD, _DWORD);
// 100090E8: using guessed type int __cdecl UF_free(_DWORD);

//----- (10002CA0) --------------------------------------------------------
int __fastcall sub_10002CA0(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax@1
  int v6; // ecx@1
  int v7; // edi@1
  int v8; // eax@2
  int v9; // ebx@2
  int v10; // ST18_4@2
  long double v11; // fst6@4
  int v12; // eax@4
  int v13; // eax@5
  unsigned int v14; // eax@6
  int v15; // ecx@6
  int v16; // esi@6
  long double v17; // fst5@7
  long double v18; // fst5@7
  int v19; // eax@10
  int v20; // ecx@10
  int v21; // esi@10
  long double v22; // fst5@11
  int v23; // edi@16
  int v24; // ecx@17
  int v25; // ebx@17
  int v26; // esi@17
  long double v27; // fst7@19
  unsigned int v28; // eax@20
  int v29; // ecx@20
  int v30; // esi@20
  int v31; // eax@20
  int v32; // ecx@20
  long double v33; // fst6@21
  long double v34; // fst6@21
  int v35; // eax@24
  int v36; // ecx@24
  long double v37; // fst6@25
  long double v38; // fst7@27
  int v39; // [sp+Ch] [bp-18h]@6
  int v40; // [sp+10h] [bp-14h]@17
  signed int v41; // [sp+14h] [bp-10h]@1
  int v42; // [sp+14h] [bp-10h]@17
  int v43; // [sp+18h] [bp-Ch]@8
  int v44; // [sp+18h] [bp-Ch]@17
  int v45; // [sp+1Ch] [bp-8h]@2
  int v46; // [sp+1Ch] [bp-8h]@20
  int v47; // [sp+20h] [bp-4h]@5
  int v48; // [sp+20h] [bp-4h]@19

  result = a4;
  v6 = a3;
  v7 = 0;
  v41 = 0;
  if ( a4 > 0 )
  {
    v9 = v10;
    v8 = a5 - a3;
    v45 = a3;
    while ( 1 )
    {
      v12 = *(_DWORD *)(v6 + v8);
      v11 = *(double *)(a2 + 8 * v12);
      *(double *)(a2 + 8 * v12) = *(double *)(a2 + 8 * v7);
      if ( v41 )
      {
        v13 = v9;
        v47 = v9;
        if ( v7 - v9 >= 4 )
        {
          v16 = *(_DWORD *)v6 + 8 * v9 + 24;
          v39 = *(_DWORD *)v6 - a2;
          v15 = a2 + 8 * v9 + 8;
          v14 = ((unsigned int)(v7 - v9 - 4) >> 2) + 1;
          v47 = v9 + 4 * v14;
          do
          {
            v17 = *(double *)(v15 - 8);
            v15 += 32;
            v18 = v17 * *(double *)(v16 - 24);
            v16 += 32;
            --v14;
            v11 = v11
                - v18
                - *(double *)(v15 + v39 - 32) * *(double *)(v15 - 32)
                - *(double *)(v15 - 24) * *(double *)(v16 - 40)
                - *(double *)(v15 - 16) * *(double *)(v16 - 32);
          }
          while ( v14 );
          v6 = v45;
          v9 = v43;
          v13 = v47;
        }
        if ( v13 < v7 )
        {
          v21 = *(_DWORD *)v6 - a2;
          v20 = v7 - v47;
          v19 = a2 + 8 * v13;
          do
          {
            v22 = *(double *)(v19 + v21);
            v19 += 8;
            --v20;
            v11 = v11 - v22 * *(double *)(v19 - 8);
          }
          while ( v20 );
          v6 = v45;
        }
      }
      else
      {
        if ( 0.0 != v11 )
        {
          v9 = v7;
          v41 = 1;
          v43 = v7;
        }
      }
      result = a4;
      *(double *)(a2 + 8 * v7++) = v11;
      v6 += 4;
      v45 = v6;
      if ( v7 >= a4 )
        break;
      v8 = a5 - a3;
    }
  }
  v23 = result - 1;
  if ( result - 1 >= 0 )
  {
    result = result - v23 - 1;
    v25 = v23 + 1;
    v24 = a2 + 8 * v23;
    v26 = 32 - a2;
    v40 = v23 + 1;
    v42 = a2 + 8 * v23;
    v44 = result;
    while ( 1 )
    {
      v27 = *(double *)v24;
      v48 = v25;
      if ( result >= 4 )
      {
        v31 = *(_DWORD *)(a3 + 4 * v23);
        v32 = v26 + v24;
        v30 = v32 + v31;
        v46 = v31 - a2;
        v28 = ((unsigned int)(a4 - v25 - 4) >> 2) + 1;
        v48 = v25 + 4 * v28;
        v29 = v32 + a2 - 16;
        do
        {
          v33 = *(double *)(v29 - 8);
          v29 += 32;
          v34 = v33 * *(double *)(v30 - 24);
          v30 += 32;
          --v28;
          v27 = v27
              - v34
              - *(double *)(v46 + v29 - 32) * *(double *)(v29 - 32)
              - *(double *)(v29 - 24) * *(double *)(v30 - 40)
              - *(double *)(v29 - 16) * *(double *)(v30 - 32);
        }
        while ( v28 );
        v25 = v40;
        v24 = v42;
        result = v44;
      }
      if ( v48 < a4 )
      {
        v35 = a2 + 8 * v48;
        v36 = a4 - v48;
        do
        {
          v37 = *(double *)(*(_DWORD *)(a3 + 4 * v23) - a2 + v35);
          v35 += 8;
          --v36;
          v27 = v27 - v37 * *(double *)(v35 - 8);
        }
        while ( v36 );
        v24 = v42;
        result = v44;
      }
      v38 = v27 / *(double *)(*(_DWORD *)(a3 + 4 * v23) + 8 * v23);
      --v23;
      ++result;
      --v25;
      v24 -= 8;
      v44 = result;
      v40 = v25;
      v42 = v24;
      *(double *)(v24 + 8) = v38;
      if ( v23 < 0 )
        break;
      v26 = 32 - a2;
    }
  }
  return result;
}

//----- (10002EB0) --------------------------------------------------------
signed int __usercall sub_10002EB0<eax>(int a1<eax>, int a2)
{
  signed int result; // eax@1
  long double v3; // fst7@1
  signed int v4; // edi@2
  int v5; // esi@2
  char v6; // [sp+0h] [bp-C8h]@1
  char v7; // [sp+10h] [bp-B8h]@1
  double v8; // [sp+18h] [bp-B0h]@1
  double v9; // [sp+20h] [bp-A8h]@1
  double v10; // [sp+28h] [bp-A0h]@1
  double v11; // [sp+30h] [bp-98h]@1
  double v12; // [sp+38h] [bp-90h]@1
  double v13; // [sp+40h] [bp-88h]@1
  double v14; // [sp+48h] [bp-80h]@1
  double v15; // [sp+50h] [bp-78h]@1
  double v16; // [sp+58h] [bp-70h]@1
  double v17; // [sp+60h] [bp-68h]@1
  double v18; // [sp+68h] [bp-60h]@1
  double v19; // [sp+70h] [bp-58h]@1
  double v20; // [sp+78h] [bp-50h]@1
  double v21; // [sp+80h] [bp-48h]@1
  double v22; // [sp+88h] [bp-40h]@1
  double v23; // [sp+90h] [bp-38h]@1
  double *v24; // [sp+98h] [bp-30h]@1
  double *v25; // [sp+9Ch] [bp-2Ch]@1
  double *v26; // [sp+A0h] [bp-28h]@1
  double *v27; // [sp+A4h] [bp-24h]@1
  double v28; // [sp+A8h] [bp-20h]@3
  double v29; // [sp+B0h] [bp-18h]@3
  double v30; // [sp+B8h] [bp-10h]@3
  double v31; // [sp+C0h] [bp-8h]@3

  v20 = *(double *)a1;
  v25 = &v16;
  v16 = *(double *)(a1 + 32);
  v8 = *(double *)(a1 + 64);
  v26 = &v8;
  v12 = *(double *)(a1 + 96);
  v21 = *(double *)(a1 + 8);
  v17 = *(double *)(a1 + 40);
  v9 = *(double *)(a1 + 72);
  v13 = *(double *)(a1 + 104);
  v22 = *(double *)(a1 + 16);
  v18 = *(double *)(a1 + 48);
  v10 = *(double *)(a1 + 80);
  v14 = *(double *)(a1 + 112);
  v23 = *(double *)(a1 + 24);
  v19 = *(double *)(a1 + 56);
  v11 = *(double *)(a1 + 88);
  v3 = *(double *)(a1 + 120);
  v24 = &v20;
  v15 = v3;
  v27 = &v12;
  result = sub_10002830((int)&v24, 4, (int)&v6, (int)&v7);
  if ( !result )
  {
    v4 = 0;
    v5 = a2 + 64;
    do
    {
      *(_QWORD *)&v28 = 0i64;
      *(_QWORD *)&v29 = 0i64;
      *(_QWORD *)&v30 = 0i64;
      *(_QWORD *)&v31 = 0i64;
      *(&v28 + v4) = 1.0;
      result = sub_10002CA0((int)&v6, (int)&v28, (int)&v24, 4, (int)&v6);
      *(double *)(v5 - 64) = v28;
      ++v4;
      *(double *)(v5 - 32) = v29;
      v5 += 8;
      *(double *)(v5 - 8) = v30;
      *(double *)(v5 + 24) = v31;
    }
    while ( v4 < 4 );
  }
  return result;
}

//----- (10002FE0) --------------------------------------------------------
int __cdecl sub_10002FE0(int a2, int a3)
{
  int v6; // eax@5
  signed int v7; // ST10_4@5
  double v8; // ST08_8@5
  int v9; // esi@5
  double v10; // ST00_8@5
  char *v11; // ST10_4@5
  char *v12; // ST0C_4@5
  __int64 v13; // ST04_8@5
  int *v14; // ST10_4@5
  __int64 v15; // ST08_8@5
  int v19; // eax@9
  signed int v20; // ST10_4@9
  double v21; // ST08_8@9
  int v22; // esi@9
  double v23; // ST00_8@9
  char *v24; // ST10_4@9
  char *v25; // ST0C_4@9
  __int64 v26; // ST04_8@9
  int *v27; // ST10_4@9
  __int64 v28; // ST08_8@9
  int result; // eax@12
  double v31; // [sp+20h] [bp-DCh]@8
  double v44; // [sp+B0h] [bp-4Ch]@1
  char v49; // [sp+D8h] [bp-24h]@5
  char v50; // [sp+E0h] [bp-1Ch]@5
  int v51; // [sp+F8h] [bp-4h]@5

  __asm { fldz }
  _EAX = a3;
  __asm
  {
    fst     [ebp+var_4C]
    fstp    [ebp+var_44]
    fld1
    fstp    [ebp+var_3C]
    fld     qword ptr [eax]
    fld     qword ptr [eax+8]
    fld     qword ptr [ecx]
    fst     [ebp+var_34]
    fld     qword ptr [ecx+8]
    fst     [ebp+var_2C]
    fxch    st(3)
    fst     [ebp+var_AC]
    fld     st
    fld     ds:dbl_100099D0
    fmul    st(1), st
    fxch    st(1)
    fst     [ebp+var_A4]
    fld     st(2)
    fld     ds:dbl_100099C8
    fadd    st(1), st
    fxch    st(1)
    fstp    [ebp+var_9C]
    fld     st
    fsubrp  st(4), st
    fxch    st(3)
    fstp    [ebp+var_94]
    fld     st(2)
    fsub    st, st(1)
    fstp    [ebp+var_8C]
    fadd    st, st(2)
    fstp    [ebp+var_84]
    fxch    st(3)
    fst     [ebp+var_7C]
    fld     st
    fmul    st, st(4)
    fst     [ebp+var_74]
    fld     st(1)
    fadd    st, st(3)
    fstp    [ebp+var_6C]
    fld     st(2)
    fsubrp  st(2), st
    fxch    st(1)
    fstp    [ebp+var_64]
    fld     st(1)
    fsub    st, st(1)
    fstp    [ebp+var_5C]
    faddp   st(1), st
    fstp    [ebp+var_54]
    fld     st
    fsub    st, st(3)
    fabs
    fcomp   dbl_1000C000
    fnstsw  ax
  }
  if ( __SETP__(BYTE1(_EAX) & 0x41, 0) )
  {
    __asm
    {
      fstp    st(2)
      fstp    st
    }
    _EBX = 0;
    _EDI = 0;
  }
  else
  {
    __asm
    {
      fxch    st(2)
      fmulp   st(1), st
    }
    _EBX = 0;
    __asm { fstp    qword ptr [ecx+8] }
    _EDI = 0;
  }
  while ( 1 )
  {
    v6 = a2;
    v7 = 0;
    __asm { fstp    [esp+0FCh+var_F4] }
    v9 = (int)&v50;
    __asm
    {
      fld     [ebp+edi*8+var_AC]
      fstp    [esp+0FCh+var_FC]
    }
    sub_10002150(v6, v9, v10, v8, v7);
    __asm { fld     dbl_1000C000 }
    v11 = &v50;
    v12 = &v49;
    __asm { fstp    [esp+0F8h+var_FC+4] }
    UF_VEC3_unitize(&v50, v13, HIDWORD(v13), v12, v11);
    __asm { fld     dbl_1000C000 }
    v14 = &v51;
    __asm { fstp    [esp+0F4h+var_F4] }
    UF_VEC3_is_equal(&v44, &v50, v15, HIDWORD(v15), v14);
    if ( v51 )
    {
      __asm { fld     [ebp+edi*8+var_AC] }
      ++_EBX;
      __asm { fstp    [ebp+ebx*8+var_E4] }
    }
    ++_EDI;
    if ( _EDI >= 6 )
      break;
    __asm { fld     [ebp+var_34] }
  }
  qsort(&v31, _EBX - 1, 8u, (int (__cdecl *)(const void *, const void *))sub_100023F0);
  __asm { fld     [ebp+var_DC] }
  _ECX = a3;
  __asm { fstp    qword ptr [ecx] }
  _EBX = 0;
  _EDI = 0;
  do
  {
    __asm { fld     [ebp+var_2C] }
    v19 = a2;
    v20 = 0;
    __asm { fstp    [esp+0FCh+var_F4] }
    v22 = (int)&v50;
    __asm
    {
      fld     [ebp+edi*8+var_7C]
      fstp    [esp+0FCh+var_FC]
    }
    sub_10002150(v19, v22, v23, v21, v20);
    __asm { fld     dbl_1000C000 }
    v24 = &v50;
    v25 = &v49;
    __asm { fstp    [esp+0F8h+var_FC+4] }
    UF_VEC3_unitize(&v50, v26, HIDWORD(v26), v25, v24);
    __asm { fld     dbl_1000C000 }
    v27 = &v51;
    __asm { fstp    [esp+0F4h+var_F4] }
    UF_VEC3_is_equal(&v44, &v50, v28, HIDWORD(v28), v27);
    if ( v51 )
    {
      __asm { fld     [ebp+edi*8+var_7C] }
      ++_EBX;
      __asm { fstp    [ebp+ebx*8+var_E4] }
    }
    ++_EDI;
  }
  while ( _EDI < 6 );
  qsort(&v31, _EBX - 1, 8u, (int (__cdecl *)(const void *, const void *))sub_100023F0);
  __asm { fld     [ebp+var_DC] }
  result = a3;
  __asm { fstp    qword ptr [eax+8] }
  return result;
}
// 10002FE9: inconsistent fpu stack
// 100090E0: using guessed type int __cdecl UF_VEC3_is_equal(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10009128: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10003210) --------------------------------------------------------
signed int __usercall sub_10003210<eax>(int a1<ebx>, int a2<edi>, int a3<esi>, const void *a4, int a5, int a6)
{
  char v8; // zf@1
  __int64 v10; // ST2C_8@2
  __int64 v11; // ST24_8@2
  __int64 v12; // ST1C_8@2
  __int64 v13; // ST14_8@2
  __int64 v14; // ST0C_8@2
  __int64 v15; // ST04_8@2
  __int64 v16; // ST28_8@6
  signed int result; // eax@7
  int v18; // ecx@8
  int v19; // esi@8
  int *v20; // ST3C_4@8
  char *v21; // ST38_4@8
  __int64 v22; // ST30_8@8
  double v23; // ST38_8@10
  double v25; // ST38_8@11
  double v31; // ST38_8@21
  void (*v40)(const char *, ...); // esi@46
  __int64 v41; // ST38_8@46
  __int64 v42; // ST30_8@46
  __int64 v43; // ST28_8@46
  __int64 v44; // ST20_8@46
  __int64 v45; // ST18_8@46
  __int64 v46; // ST10_8@46
  __int64 v47; // ST38_8@46
  int v53; // eax@71
  int v55; // eax@72
  int v56; // ecx@72
  int v57; // edx@72
  int v58; // esi@72
  int v59; // esi@72
  int v60; // eax@72
  __int64 v61; // ST38_8@76
  __int64 v62; // ST30_8@76
  __int64 v63; // ST28_8@76
  __int64 v64; // ST20_8@76
  __int64 v65; // ST38_8@76
  __int64 v66; // ST30_8@76
  __int64 v67; // ST28_8@76
  __int64 v68; // ST20_8@76
  signed int v69; // ST3C_4@78
  int v70; // esi@78
  int v71; // eax@78
  double v72; // ST34_8@78
  double v73; // ST2C_8@78
  signed int v74; // ST3C_4@78
  double v75; // ST34_8@78
  int v76; // esi@78
  int v77; // eax@78
  double v78; // ST2C_8@78
  int v79; // ST3C_4@80
  double v80; // ST34_8@80
  int v81; // ST3C_4@80
  double v82; // ST34_8@80
  signed int v83; // esi@81
  int v84; // eax@82
  int v85; // eax@87
  void (__cdecl *v87)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // esi@88
  int v88; // ST3C_4@88
  int *v89; // ST38_4@88
  __int64 v90; // ST30_8@88
  int v91; // ST3C_4@88
  int *v92; // ST38_4@88
  __int64 v93; // ST30_8@88
  int v94; // ST3C_4@88
  double v95; // ST34_8@88
  int v96; // ST3C_4@88
  double v97; // ST34_8@88
  void (__cdecl *v98)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // esi@90
  int v99; // ST3C_4@90
  double v100; // ST34_8@90
  int *v101; // ST3C_4@90
  char *v102; // ST38_4@90
  __int64 v103; // ST30_8@90
  int v105; // ST3C_4@90
  int *v106; // ST38_4@90
  __int64 v107; // ST30_8@90
  signed int v109; // ST3C_4@92
  double v110; // ST34_8@92
  int v111; // esi@92
  int v112; // eax@92
  double v113; // ST2C_8@92
  signed int v114; // ST3C_4@92
  double v115; // ST34_8@92
  int v116; // esi@92
  int v117; // eax@92
  double v118; // ST2C_8@92
  void (__cdecl *v119)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // esi@92
  int *v120; // ST3C_4@92
  char *v121; // ST38_4@92
  __int64 v122; // ST30_8@92
  char *v123; // ST3C_4@92
  char *v124; // ST38_4@92
  __int64 v125; // ST30_8@92
  int v127; // ST3C_4@92
  int *v128; // ST38_4@92
  __int64 v129; // ST30_8@92
  __int64 v131; // ST30_8@93
  char v132; // zf@95
  int v137; // [sp+30h] [bp-D4h]@1
  int *v138; // [sp+34h] [bp-D0h]@90
  int v139; // [sp+38h] [bp-CCh]@1
  int v140; // [sp+38h] [bp-CCh]@90
  int v141; // [sp+3Ch] [bp-C8h]@4
  int v142; // [sp+40h] [bp-C4h]@72
  int v143; // [sp+44h] [bp-C0h]@72
  int v144; // [sp+48h] [bp-BCh]@72
  int v145; // [sp+4Ch] [bp-B8h]@72
  int v146; // [sp+50h] [bp-B4h]@72
  char v147; // [sp+54h] [bp-B0h]@4
  char v150; // [sp+7Ch] [bp-88h]@8
  char v151; // [sp+84h] [bp-80h]@92
  double v152; // [sp+8Ch] [bp-78h]@78
  int v154[2]; // [sp+9Ch] [bp-68h]@8
  int v158; // [sp+BCh] [bp-48h]@90
  int v161; // [sp+D4h] [bp-30h]@1
  double v163; // [sp+E0h] [bp-24h]@14
  double v165; // [sp+F0h] [bp-14h]@10
  char v167; // [sp+103h] [bp-1h]@1

  v8 = byte_1000C588 == 0;
  __asm { fldz }
  _EAX = a5;
  v139 = a1;
  _EBX = a6;
  __asm
  {
    fst     qword ptr [ebx]
    fst     qword ptr [eax]
    fst     qword ptr [ebx+8]
  }
  v137 = a2;
  _EDI = a4;
  __asm
  {
    fst     qword ptr [eax+8]
    fst     qword ptr [ebx+10h]
  }
  v167 = 0;
  __asm { fst     qword ptr [eax+10h] }
  v161 = 0;
  __asm
  {
    fst     qword ptr [ebx+18h]
    fst     qword ptr [eax+18h]
    fst     qword ptr [ebx+20h]
    fstp    qword ptr [eax+20h]
  }
  if ( !v8 )
  {
    printf("\n------------------------------------------------------\n", v137, a3, v139);
    __asm
    {
      fld     qword ptr [edi+28h]
      fstp    [esp+104h+var_DC]
      fld     qword ptr [edi+20h]
      fstp    [esp+104h+var_E4]
      fld     qword ptr [edi+18h]
      fstp    [esp+104h+var_EC]
      fld     qword ptr [edi+10h]
      fstp    [esp+104h+var_F4]
      fld     qword ptr [edi+8]
      fstp    [esp+104h+var_FC]
      fld     qword ptr [edi]
      fstp    [esp+104h+var_104]
    }
    printf("Starting old_pcoord_t[] = (%f,%f,%f,%f,%f,%f)\n", v15, v14, v13, v12, v11, v10);
  }
  if ( dword_1000C3DC == 3 )
  {
    UF_MTX3_vec_multiply_t(a4, &unk_10009978, &v141);
    UF_MTX3_vec_multiply_t((char *)a4 + 24, &unk_10009978, &v147);
  }
  else
  {
    memcpy(&v141, a4, 0x30u);
    _EDI = a4;
  }
  __asm
  {
    fld     dbl_1000C000
    fstp    [esp+0E0h+var_E4+4]
  }
  UF_VEC3_is_zero(&v147, v16, HIDWORD(v16));
  if ( a6 )
    return 4;
  __asm { fld     dbl_1000C000 }
  v20 = v154;
  v21 = &v150;
  __asm { fstp    [esp+0D8h+var_DC+4] }
  UF_VEC3_unitize(&v147, v22, HIDWORD(v22), v21, v20);
  __asm { fld     qword ptr [ebp+var_68] }
  v19 = dword_1000C3D8;
  __asm
  {
    fst     [ebp+var_70]
    fld     [ebp+var_60]
  }
  v18 = *(_DWORD *)dword_1000C3D8;
  __asm
  {
    fst     [ebp+var_90]
    fld     [ebp+var_58]
    fst     [ebp+var_98]
  }
  if ( v18 != 3 )
  {
    __asm
    {
      fld     dbl_1000C298
      fmul    st, st(1)
      fld     dbl_1000C278
      fmul    st, st(3)
      faddp   st(1), st
      fld     dbl_1000C258
      fmul    st, st(4)
      faddp   st(1), st
      fld     dbl_1000C2A0
      fmul    st, st(2)
      fld     dbl_1000C280
      fmul    st, st(4)
      faddp   st(1), st
      fld     dbl_1000C260
      fmul    st, st(5)
      faddp   st(1), st
      fmul    dbl_1000C560
      fsubp   st(1), st
      fld     dbl_1000C4D8
      fmul    st(1), st
      fxch    st(1)
      fstp    [ebp+var_2C]
      fld     dbl_1000C288
      fmul    st, st(2)
      fld     dbl_1000C268
      fmul    st, st(4)
      faddp   st(1), st
      fld     dbl_1000C248
      fmul    st, st(5)
      faddp   st(1), st
      fld     dbl_1000C290
      fmulp   st(3), st
      fld     dbl_1000C270
      fmulp   st(4), st
      fxch    st(2)
      faddp   st(3), st
      fld     dbl_1000C250
      fmulp   st(4), st
      fxch    st(2)
      faddp   st(3), st
      fld     dbl_1000C310
      fld     st
      fabs
      fld     dbl_1000C000
      fcom    st(1)
      fnstsw  ax
      fstp    st(1)
    }
    if ( HIBYTE(_AX) & 1 )
    {
      if ( v18 == 1 )
      {
        __asm { fld     dbl_1000C308 }
      }
      else
      {
        if ( v18 == 2 )
          __asm { fld     dbl_1000C308 }
        else
          __asm { fld     [ebp+var_38] }
      }
      __asm
      {
        fsub    [ebp+var_2C]
        fdiv    st, st(2)
        fstp    [ebp+var_2C]
        fldz
      }
    }
    else
    {
      __asm { fldz }
      v167 = 1;
      __asm { fst     [ebp+var_2C] }
    }
    __asm
    {
      fld     st(5)
      fmul    st, st(6)
      fld     st(4)
      fmul    st, st(5)
      faddp   st(1), st
      fsqrt
      fld     st(4)
      fabs
      fcomp   st(3)
      fnstsw  ax
    }
    if ( __SETP__(HIBYTE(_AX) & 0x41, 0) )
      goto LABEL_115;
    __asm
    {
      fld     st(6)
      fabs
      fcomp   st(3)
      fnstsw  ax
    }
    if ( __SETP__(HIBYTE(_AX) & 0x41, 0) )
    {
LABEL_115:
      __asm
      {
        fxch    st(1)
        fxch    st(6)
        fxch    st(1)
        fxch    st(4)
        fpatan
        fstp    [ebp+var_50]
        fxch    st(2)
        fxch    st(4)
      }
    }
    else
    {
      __asm
      {
        fstp    st(6)
        fstp    st(3)
        fxch    st(2)
        fst     [ebp+var_50]
      }
    }
    __asm
    {
      fld     st(4)
      fabs
      fcomp   st(3)
      fnstsw  ax
    }
    if ( __SETP__(HIBYTE(_AX) & 0x41, 0) )
    {
      __asm
      {
        fld     [ebp+var_2C]
        fdivrp  st(5), st
        fxch    st(4)
      }
    }
    else
    {
      __asm
      {
        fstp    st(4)
        fld     st(3)
      }
    }
    __asm
    {
      fst     [ebp+var_2C]
      fld     st
      fabs
      fld     st(3)
      fld1
      fadd    st(1), st
      fxch    st(2)
      fcompp
      fnstsw  ax
    }
    if ( HIBYTE(_AX) & 0x41 )
    {
      __asm
      {
        fld     st(1)
        fmul    st, st(2)
        fsubr   st, st(1)
        fld     st
        fabs
        fcomp   st(5)
        fnstsw  ax
      }
      if ( !__SETP__(HIBYTE(_AX) & 0x41, 0) )
      {
        __asm
        {
          fstp    st
          fld     st(5)
        }
      }
      __asm
      {
        fld     st(2)
        fsubrp  st(2), st
        fxch    st(1)
        fabs
        fcomp   st(4)
        fnstsw  ax
      }
      if ( __SETP__(HIBYTE(_AX) & 0x41, 0) )
      {
        __asm { fsqrt }
      }
      else
      {
        __asm
        {
          fstp    st
          fld     st(4)
        }
      }
      __asm { fld     st }
      _ECX = 0;
      __asm
      {
        fld     st(2)
        fxch    st(1)
        fpatan
        fadd    [ebp+var_50]
        fstp    [ebp+var_14]
        fchs
        fpatan
        fadd    [ebp+var_50]
        fstp    [ebp+var_C]
        fld     dbl_1000C4D0
        fabs
        fstp    [ebp+var_2C]
      }
    }
    else
    {
      __asm { fstp    st(1) }
      v40 = printf;
      __asm
      {
        fstp    st(4)
        fstp    st
        fstp    st(1)
        fstp    st
        fstp    st
        fld     qword ptr [edi+28h]
        fstp    [esp+0F8h+var_D0]
        fld     qword ptr [edi+20h]
        fstp    [esp+0F8h+var_DC+4]
        fld     qword ptr [edi+18h]
        fstp    [esp+0F8h+var_E4+4]
        fld     qword ptr [edi+10h]
        fstp    [esp+0F8h+var_EC+4]
        fld     qword ptr [edi+8]
        fstp    [esp+0F8h+var_F4+4]
        fld     qword ptr [edi]
        fstp    [esp+0F8h+var_FC+4]
      }
      v40("INPUT Point =%-.4f,%-.4f,%-.4f,%-.8f,%-.8f,%-.8f\n", v46, v45, v44, v43, v42, v41);
      __asm
      {
        fld     [ebp+var_2C]
        fstp    [esp+0D0h+var_D0]
      }
      printf("WARNING: Degenerated G_lambda(%f) out of range (-1, 1)\n", v47);
      __asm
      {
        fldz
        fst     [ebp+var_C]
        fst     [ebp+var_14]
      }
      v167 = 1;
      __asm { fld     dbl_1000C000 }
      _ECX = 0;
      __asm
      {
        fld     dbl_1000C4D8
        fld     dbl_1000C310
        fxch    st(1)
        fxch    st(2)
        fxch    st(1)
        fld     dbl_1000C4D0
        fabs
        fstp    [ebp+var_2C]
      }
    }
    while ( 1 )
    {
      __asm
      {
        fld     [ebp+ecx+var_14]
        fsin
        fld     [ebp+ecx+var_14]
        fcos
        fxch    st(3)
        fcom    [ebp+var_2C]
        fnstsw  ax
      }
      if ( HIBYTE(_AX) & 1 )
      {
        __asm
        {
          fstp    st(5)
          fstp    st(4)
          fld     st(3)
          fmul    st, st(3)
          fchs
          fld     st(2)
          fmulp   st(4), st
          fxch    st(1)
          fmul    dbl_1000C560
          fchs
          fstp    [ebp+var_50]
          fld     st(3)
          fmul    dbl_1000C290
          fld     st(2)
          fmul    dbl_1000C288
          faddp   st(1), st
          fld     dbl_1000C558
          fmul    dbl_1000C2A0
          fsubp   st(1), st
          fmul    [ebp+var_98]
          fld     st(4)
          fmul    dbl_1000C270
          fld     st(3)
          fmul    dbl_1000C268
          faddp   st(1), st
          fld     dbl_1000C558
          fmul    dbl_1000C280
          fsubp   st(1), st
          fmul    [ebp+var_90]
          faddp   st(1), st
          fxch    st(4)
          fmul    dbl_1000C250
          fxch    st(2)
          fmul    dbl_1000C248
          faddp   st(2), st
          fld     dbl_1000C558
          fmul    dbl_1000C260
          fsubp   st(2), st
          fxch    st(1)
          fmul    [ebp+var_70]
          faddp   st(3), st
          fxch    st(2)
          fdiv    dbl_1000C4D0
          fstp    [ebp+var_38]
          fld     dbl_1000C310
          fld     dbl_1000C298
          fmul    st, st(1)
          fld     st(2)
          fmul    dbl_1000C290
          faddp   st(1), st
          fld     st(3)
          fmul    dbl_1000C288
          faddp   st(1), st
          fld     [ebp+var_50]
          fld     dbl_1000C2A0
          fmul    st, st(1)
          faddp   st(2), st
          fxch    st(1)
          fmul    [ebp+var_98]
          fld     st(2)
          fmul    dbl_1000C278
          fld     st(4)
          fmul    dbl_1000C270
          faddp   st(1), st
          fld     st(5)
          fmul    dbl_1000C268
          faddp   st(1), st
          fld     st(2)
          fmul    dbl_1000C280
          faddp   st(1), st
          fmul    [ebp+var_90]
          faddp   st(1), st
          fld     st(2)
          fmul    dbl_1000C258
          fxch    st(4)
          fmul    dbl_1000C250
          faddp   st(4), st
          fxch    st(4)
          fmul    dbl_1000C248
          faddp   st(3), st
          fmul    dbl_1000C260
          faddp   st(2), st
          fxch    st(1)
          fmul    [ebp+var_70]
          faddp   st(2), st
          fld     ds:dbl_100099D0
          fdiv    dbl_1000C4D0
          fmulp   st(2), st
          fldz
          fld     dbl_1000C000
          fld     dbl_1000C4D8
          fld     [ebp+var_38]
          fxch    st(3)
          fxch    st(5)
          fxch    st(1)
          fxch    st(4)
          fxch    st(2)
          fxch    st(3)
        }
      }
      else
      {
        __asm
        {
          fstp    st(3)
          fstp    st
          fld     st(3)
          fld     st(4)
        }
      }
      __asm
      {
        fld     st
        fabs
        fcomp   st(4)
        fnstsw  ax
      }
      if ( __SETP__(HIBYTE(_AX) & 0x41, 0) )
        goto LABEL_117;
      __asm
      {
        fld     st(1)
        fabs
        fcomp   st(4)
        fnstsw  ax
      }
      if ( __SETP__(HIBYTE(_AX) & 0x41, 0) )
      {
LABEL_117:
        __asm
        {
          fxch    st(1)
          fpatan
          fstp    [ebp+ecx+var_24]
          fxch    st(3)
        }
      }
      else
      {
        __asm { fstp    st(1) }
        v167 = 1;
        __asm
        {
          fstp    st
          fxch    st(3)
          fst     [ebp+ecx+var_24]
        }
      }
      _ECX += 8;
      if ( _ECX >= 16 )
        break;
      __asm { fxch    st(3) }
    }
    v19 = dword_1000C3D8;
    __asm { fstp    st }
    goto LABEL_63;
  }
  if ( dword_1000C3DC )
  {
    if ( dword_1000C3DC != 1 && dword_1000C3DC != 3 )
    {
      __asm
      {
        fstp    st
        fstp    st
        fstp    st
      }
      return 2;
    }
    __asm
    {
      fld     dbl_1000C300
      fld     st
      fld1
      fsub    st(1), st
      fxch    st(1)
      fabs
      fld     dbl_1000C000
      fcom    st(1)
      fnstsw  ax
      fstp    st(1)
    }
    if ( !(HIBYTE(_AX) & 1) )
      goto LABEL_116;
    __asm
    {
      fld     st(2)
      fmul    st, st(3)
      fsub    st(4), st
      fsubr   st, st(2)
      fdivp   st(4), st
      fld     st(3)
      fabs
      fld     st(1)
      fadd    st, st(3)
      fcompp
      fnstsw  ax
    }
    if ( __SETP__(HIBYTE(_AX) & 5, 0) )
    {
      __asm
      {
        fstp    st(4)
        fstp    st(4)
        fstp    st
        fstp    st(1)
        fstp    st(1)
        fstp    [esp+0D0h+var_D0]
      }
      sub_10001F50(v31);
      __asm
      {
        fst     [ebp+var_14]
        fchs
      }
      _ECX = 0;
      __asm
      {
        fstp    [ebp+var_C]
        fld     [ebp+var_60]
        fld     qword ptr [ebp+var_68]
        fld     dbl_1000C000
        fld     dbl_1000C300
        fld1
        fxch    st(3)
        fxch    st(4)
        fxch    st(3)
        fld     dbl_1000C2F8
      }
    }
    else
    {
LABEL_116:
      __asm { fstp    st(3) }
      v167 = 1;
      __asm { fld     dbl_1000C460 }
      _ECX = 0;
      __asm
      {
        fstp    [ebp+var_14]
        fld     dbl_1000C468
        fstp    [ebp+var_C]
        fld     dbl_1000C2F8
      }
    }
    while ( 1 )
    {
      __asm
      {
        fld     [ebp+ecx+var_14]
        fsin
        fld     [ebp+ecx+var_14]
        fcos
        fsubp   st(3), st
        fxch    st(2)
        fmulp   st(3), st
        fld     st(2)
        fmul    dbl_1000C2F0
        fld     st(1)
        fmul    st, st(3)
        faddp   st(1), st
        fxch    st(3)
        fmul    st, st(1)
        fld     dbl_1000C2F0
        fmulp   st(3), st
        fsubrp  st(2), st
        fld     st(1)
        fmul    st, st(5)
        fld     st(3)
        fmul    st, st(7)
        faddp   st(1), st
        fxch    st(3)
        fmul    st, st(5)
        fxch    st(2)
        fmul    st, st(6)
        fsubp   st(2), st
        fld     st(1)
        fabs
        fcomp   st(4)
        fnstsw  ax
      }
      if ( __SETP__(HIBYTE(_AX) & 0x41, 0) )
        goto LABEL_119;
      __asm
      {
        fld     st(2)
        fabs
        fcomp   st(4)
        fnstsw  ax
      }
      if ( __SETP__(HIBYTE(_AX) & 0x41, 0) )
      {
LABEL_119:
        __asm
        {
          fxch    st(2)
          fpatan
        }
      }
      else
      {
        __asm { fstp    st(1) }
        v167 = 1;
        __asm
        {
          fstp    st(1)
          fld     dbl_1000C318[ecx]
        }
      }
      __asm { fstp    [ebp+ecx+var_24] }
      _ECX += 8;
      if ( _ECX >= 16 )
        break;
      __asm
      {
        fld1
        fld     dbl_1000C300
        fxch    st(2)
      }
    }
    __asm { fstp    st(2) }
LABEL_63:
    __asm
    {
      fstp    st(2)
      fstp    st
    }
    if ( !v167 )
      goto LABEL_67;
    goto LABEL_64;
  }
  __asm
  {
    fstp    st
    fstp    st(1)
    fchs
    fstp    [ebp+var_14]
    fld     [ebp+var_58]
    fmul    st, st
    fld     qword ptr [ebp+var_68]
    fmul    st, st
    faddp   st(1), st
    fsqrt
    fst     [ebp+var_70]
    fstp    [esp+0D0h+var_D0]
  }
  sub_10001F50(v23);
  __asm
  {
    fst     [ebp+var_C]
    fsubr   [ebp+var_14]
    fabs
    fld     dbl_1000C000
    fcom    st(1)
    fnstsw  ax
    fstp    st(1)
  }
  if ( !(HIBYTE(_AX) & 1) )
  {
    __asm
    {
      fstp    st
      fld     [ebp+var_70]
      fchs
      fstp    [esp+0D0h+var_D0]
    }
    sub_10001F50(v25);
    __asm
    {
      fstp    [ebp+var_C]
      fld     dbl_1000C000
    }
  }
  __asm
  {
    fld     qword ptr [ebp+var_68]
    fld     st
    fabs
    fcomp   st(2)
    fnstsw  ax
    fld     [ebp+var_58]
  }
  if ( __SETP__(HIBYTE(_AX) & 0x41, 0) )
    goto LABEL_118;
  __asm
  {
    fld     st
    fabs
    fcomp   st(3)
    fnstsw  ax
  }
  if ( __SETP__(HIBYTE(_AX) & 0x41, 0) )
  {
LABEL_118:
    __asm
    {
      fld     st
      fld     st(2)
      fxch    st(1)
      fpatan
      fstp    [ebp+var_24]
      fxch    st(1)
      fchs
      fxch    st(1)
      fchs
      fpatan
      fstp    [ebp+var_1C]
    }
    goto LABEL_67;
  }
  __asm { fstp    st }
  v167 = 1;
  __asm
  {
    fstp    st
    fld     dbl_1000C318
    fstp    [ebp+var_24]
    fld     dbl_1000C320
    fstp    [ebp+var_1C]
  }
LABEL_64:
  if ( *(_DWORD *)v19 != 3 )
  {
    __asm
    {
      fld     dbl_1000C460
      fstp    [ebp+var_14]
      fld     dbl_1000C468
      fstp    [ebp+var_C]
      fld     dbl_1000C318
      fstp    [ebp+var_24]
      fld     dbl_1000C320
      fstp    [ebp+var_1C]
    }
  }
  v161 = 1;
LABEL_67:
  if ( byte_1000C009 && (*(_DWORD *)v19 == 2 || *(_DWORD *)v19 == 3) )
  {
    __asm { fstp    st }
    sub_10002430((int)&v163, (int)&v165);
    __asm { fld     [ebp+var_14] }
    result = v161;
    __asm
    {
      fstp    dbl_1000C530
      fld     [ebp+var_C]
      fstp    dbl_1000C538
      fld     [ebp+var_24]
      fstp    dbl_1000C2E0
      fld     [ebp+var_1C]
      fstp    dbl_1000C2E8
    }
    return result;
  }
  v53 = *(_DWORD *)v19;
  if ( *(_DWORD *)v19 == 1 )
  {
    _EDI = a5;
    v55 = v141;
    v56 = v142;
    v57 = v143;
    v58 = v144;
    *(_DWORD *)a5 = v141;
    *(_DWORD *)(a5 + 4) = v56;
    *(_DWORD *)(a5 + 8) = v57;
    *(_DWORD *)(a5 + 12) = v58;
    *(_DWORD *)(a5 + 16) = v145;
    v59 = v146;
    *(_DWORD *)(a5 + 20) = v146;
    *(_DWORD *)_EBX = v55;
    v60 = v145;
    *(_DWORD *)(_EBX + 4) = v56;
    *(_DWORD *)(_EBX + 8) = v57;
    *(_DWORD *)(_EBX + 12) = v144;
    *(_DWORD *)(_EBX + 16) = v60;
    *(_DWORD *)(_EBX + 20) = v59;
    goto LABEL_87;
  }
  if ( v53 != 2 && v53 != 3 )
  {
    _EDI = a5;
  }
  else
  {
    __asm { fstp    st }
    if ( byte_1000C588 )
    {
      ((void (__cdecl *)(_DWORD))printf)("About adjusting theta with initial angle...\n");
      __asm
      {
        fld     dbl_1000C2E0
        fld     ds:dbl_10009308
        fmul    st(1), st
        fld     [ebp+var_24]
        fsub    st(2), st
        fld     ds:dbl_100099E0
        fmul    st(3), st
        fxch    st(3)
        fstp    [esp+0E8h+var_D0]
        fld     dbl_1000C530
        fmulp   st(2), st
        fld     [ebp+var_14]
        fsub    st(2), st
        fxch    st(2)
        fmul    st, st(3)
        fstp    [esp+0E8h+var_DC+4]
        fmul    st, st(2)
        fstp    [esp+0E8h+var_E4+4]
        fmulp   st(1), st
        fstp    [esp+0E8h+var_EC+4]
      }
      printf("computing t1[0]=%f, t2[0]=%f, (Init_T1[0]*2-t1[0])=%f,(Init_T2[0]*2-t2[0])=%f\n", v64, v63, v62, v61);
      __asm
      {
        fld     dbl_1000C2E8
        fld     ds:dbl_10009308
        fmul    st(1), st
        fld     [ebp+var_1C]
        fsub    st(2), st
        fld     ds:dbl_100099E0
        fmul    st(3), st
        fxch    st(3)
        fstp    [esp+0E8h+var_D0]
        fld     dbl_1000C538
        fmulp   st(2), st
        fld     [ebp+var_C]
        fsub    st(2), st
        fxch    st(2)
        fmul    st, st(3)
        fstp    [esp+0E8h+var_DC+4]
        fmul    st, st(2)
        fstp    [esp+0E8h+var_E4+4]
        fmulp   st(1), st
        fstp    [esp+0E8h+var_EC+4]
      }
      printf("computing t1[1]=%f, t2[1]=%f, (Init_T1[1]*2-t1[1])=%f,(Init_T2[1]*2-t2[1])=%f\n", v68, v67, v66, v65);
    }
    sub_10002430((int)&v163, (int)&v165);
    if ( *(_DWORD *)dword_1000C3D8 == 2 )
    {
      __asm
      {
        fld     [ebp+var_14]
        fstp    [ebp+var_78]
        fld     [ebp+var_C]
        fstp    [ebp+var_70]
        fld     [ebp+var_24]
        fstp    [ebp+var_40]
        fld     [ebp+var_1C]
        fstp    [ebp+var_38]
      }
      sub_10002FE0((int)v154, (int)&v152);
      __asm { fld     [ebp+var_78] }
      _EDI = a5;
      __asm
      {
        fst     [ebp+var_14]
        fld     [ebp+var_70]
      }
      v69 = 1;
      __asm
      {
        fstp    [ebp+var_C]
        fld     [ebp+var_40]
      }
      v70 = a5;
      __asm { fst     [ebp+var_24] }
      v71 = (int)&v141;
      __asm
      {
        fld     [ebp+var_38]
        fstp    [ebp+var_1C]
        fstp    qword ptr [esp+8]
        fstp    [esp+0DCh+var_DC]
      }
      sub_10002150(v71, v70, v73, v72, v69);
      __asm { fld     [ebp+var_38] }
      v74 = 1;
      __asm { fstp    qword ptr [esp+8] }
      v76 = _EBX;
      __asm { fld     [ebp+var_70] }
      v77 = (int)&v141;
      __asm { fstp    [esp+0DCh+var_DC] }
      sub_10002150(v77, v76, v78, v75, v74);
LABEL_79:
      __asm { fld     dbl_1000C000 }
      goto LABEL_87;
    }
    _EDI = a5;
    __asm { fld     [ebp+var_24] }
    v79 = a5;
    __asm
    {
      fchs
      fstp    qword ptr [esp]
    }
    sub_10002350((int)&v141, v80, v79);
    __asm
    {
      fld     [ebp+var_1C]
      fchs
    }
    v81 = _EBX;
    __asm { fstp    qword ptr [esp] }
    sub_10002350((int)&v141, v82, v81);
    if ( dword_1000C3DC != 3 )
      goto LABEL_79;
    v83 = 0;
    do
    {
      v84 = a5;
      if ( v83 )
        v84 = _EBX;
      UF_MTX3_vec_multiply_t(v84, &unk_10009930, v84);
      ++v83;
    }
    while ( v83 < 2 );
    __asm { fld     dbl_1000C000 }
  }
LABEL_87:
  _ECX = dword_1000C3D8;
  v85 = *(_DWORD *)dword_1000C3D8;
  if ( *(_DWORD *)dword_1000C3D8 == 1 )
  {
    v87 = UF_VEC3_affine_comb;
    __asm
    {
      fstp    st
      fld     qword ptr [ecx+90h]
    }
    v88 = _EDI;
    __asm { fadd    qword ptr [ecx+88h] }
    v89 = v154;
    __asm
    {
      fst     [ebp+var_38]
      fstp    [esp+0D8h+var_DC+4]
    }
    v87(_EDI, v90, HIDWORD(v90), v89, v88);
    __asm { fld     [ebp+var_38] }
    v91 = _EBX;
    v92 = v154;
    __asm { fstp    [esp+0D8h+var_DC+4] }
    UF_VEC3_affine_comb(_EBX, v93, HIDWORD(v93), v92, v91);
    __asm { fld     [ebp+var_14] }
    v94 = _EDI;
    __asm { fstp    qword ptr [esp] }
    sub_100022D0(_EDI, v95, v94);
    __asm { fld     [ebp+var_C] }
    v96 = _EBX;
    __asm { fstp    qword ptr [esp] }
    sub_100022D0(_EBX, v97, v96);
  }
  else
  {
    if ( v85 == 3 )
    {
      __asm
      {
        fstp    st
        fld     [ebp+var_24]
      }
      v99 = (int)&v158;
      __asm
      {
        fchs
        fstp    qword ptr [esp]
      }
      sub_10002350((int)v154, v100, v99);
      __asm { fld     dbl_1000C000 }
      v101 = &v158;
      v102 = &v150;
      __asm { fstp    [esp+0D8h+var_DC+4] }
      UF_VEC3_unitize(&v158, v103, HIDWORD(v103), v102, v101);
      _EDX = dword_1000C3D8;
      __asm { fld     qword ptr [edx+88h] }
      v98 = UF_VEC3_affine_comb;
      v105 = _EDI;
      v106 = &v158;
      __asm { fstp    [esp+0D8h+var_DC+4] }
      v98(_EDI, v107, HIDWORD(v107), v106, v105);
      _ECX = dword_1000C3D8;
      __asm { fld     qword ptr [ecx+88h] }
      v140 = _EBX;
      v138 = &v158;
    }
    else
    {
      if ( v85 != 2 )
        goto LABEL_95;
      __asm { fstp    st }
      v109 = 0;
      __asm
      {
        fld     [ebp+var_24]
        fstp    qword ptr [esp+8]
      }
      v111 = (int)&v158;
      __asm { fld     [ebp+var_14] }
      v112 = (int)v154;
      __asm { fstp    [esp+0DCh+var_DC] }
      sub_10002150(v112, v111, v113, v110, v109);
      __asm { fld     [ebp+var_1C] }
      v114 = 0;
      __asm { fstp    qword ptr [esp+8] }
      v116 = (int)&v151;
      __asm { fld     [ebp+var_C] }
      v117 = (int)v154;
      __asm { fstp    [esp+0DCh+var_DC] }
      sub_10002150(v117, v116, v118, v115, v114);
      __asm { fld     dbl_1000C000 }
      v119 = UF_VEC3_unitize;
      v120 = &v158;
      v121 = &v150;
      __asm { fstp    [esp+0D8h+var_DC+4] }
      v119(&v158, v122, HIDWORD(v122), v121, v120);
      __asm { fld     dbl_1000C000 }
      v123 = &v151;
      v124 = &v150;
      __asm { fstp    [esp+0D8h+var_DC+4] }
      UF_VEC3_unitize(&v151, v125, HIDWORD(v125), v124, v123);
      _EAX = dword_1000C3D8;
      __asm { fld     qword ptr [eax+88h] }
      v98 = UF_VEC3_affine_comb;
      v127 = _EDI;
      v128 = &v158;
      __asm { fstp    [esp+0D8h+var_DC+4] }
      v98(_EDI, v129, HIDWORD(v129), v128, v127);
      _EDX = dword_1000C3D8;
      __asm { fld     qword ptr [edx+88h] }
      v140 = _EBX;
      v138 = (int *)&v151;
    }
    __asm { fstp    [esp+0D8h+var_DC+4] }
    v98(_EBX, v131, HIDWORD(v131), v138, v140);
  }
  __asm { fld     dbl_1000C000 }
LABEL_95:
  v132 = byte_1000C008 == 0;
  __asm
  {
    fld     [ebp+var_14]
    fld     st
    fld     ds:dbl_100099E0
    fmul    st(1), st
    fxch    st(1)
    fstp    qword ptr [edi+18h]
    fld     [ebp+var_C]
    fld     st
    fmul    st, st(2)
    fstp    qword ptr [ebx+18h]
    fld     [ebp+var_24]
    fld     st
    fmul    st, st(3)
    fstp    qword ptr [edi+20h]
    fld     [ebp+var_1C]
    fmulp   st(3), st
    fxch    st(2)
    fstp    qword ptr [ebx+20h]
  }
  if ( !v132 )
  {
    if ( *(_DWORD *)dword_1000C3D8 != 3 )
    {
      __asm
      {
        fld     qword ptr [edi+20h]
        fld     ds:dbl_10009A38
        fsub    st(1), st
        fxch    st(1)
        fst     qword ptr [edi+20h]
        fld     ds:dbl_10009A30
        fcom    st(1)
        fnstsw  ax
        fld     ds:dbl_100099F0
      }
      if ( HIBYTE(_AX) & 0x41 )
      {
        __asm { fstp    st(2) }
      }
      else
      {
        __asm
        {
          fadd    st(2), st
          fxch    st(2)
          fstp    qword ptr [edi+20h]
        }
      }
      __asm
      {
        fld     qword ptr [ebx+20h]
        fsubrp  st(3), st
        fxch    st(2)
        fst     qword ptr [ebx+20h]
        fcom    st(2)
        fnstsw  ax
        fstp    st(2)
      }
      if ( __SETP__(HIBYTE(_AX) & 5, 0) )
      {
        __asm
        {
          fstp    st(1)
          fstp    st
        }
      }
      else
      {
        __asm
        {
          faddp   st(1), st
          fstp    qword ptr [ebx+20h]
        }
      }
    }
  }
  if ( v167 )
  {
    if ( *(_DWORD *)dword_1000C3D8 != 3 )
    {
      *(_DWORD *)(_EDI + 24) = dword_1000C4F8;
      *(_DWORD *)(_EDI + 28) = dword_1000C4FC;
      *(_DWORD *)(_EDI + 32) = dword_1000C500;
      *(_DWORD *)(_EDI + 36) = dword_1000C504;
      *(_DWORD *)(_EBX + 24) = dword_1000C520;
      *(_DWORD *)(_EBX + 28) = dword_1000C524;
      *(_DWORD *)(_EBX + 32) = dword_1000C528;
      *(_DWORD *)(_EBX + 36) = dword_1000C52C;
    }
  }
  if ( byte_1000C588 )
  {
    __asm
    {
      fsubp   st(2), st
      fxch    st(1)
      fabs
      fcomp   st(2)
      fnstsw  ax
    }
    if ( !__SETP__(HIBYTE(_AX) & 0x41, 0) )
    {
      __asm
      {
        fsub    [ebp+var_1C]
        fabs
        fcompp
        fnstsw  ax
      }
      if ( !__SETP__(HIBYTE(_AX) & 0x41, 0) )
        printf("WARNING: same value of rotary produced:\n");
      goto LABEL_112;
    }
  }
  else
  {
    __asm
    {
      fstp    st
      fstp    st(1)
    }
  }
  __asm
  {
    fstp    st(1)
    fstp    st
  }
LABEL_112:
  __asm { fld     [ebp+var_14] }
  result = v161;
  memcpy(&dword_1000C4E0, (const void *)a5, 0x28u);
  memcpy(&dword_1000C508, (const void *)_EBX, 0x28u);
  __asm
  {
    fstp    dbl_1000C460
    fld     [ebp+var_C]
    fstp    dbl_1000C468
    fld     [ebp+var_24]
    fstp    dbl_1000C318
    fld     [ebp+var_1C]
    fstp    dbl_1000C320
  }
  return result;
}
// 10003220: inconsistent fpu stack
// 10003210: could not find valid save-restore pair for ebx
// 10003210: could not find valid save-restore pair for edi
// 10003210: could not find valid save-restore pair for esi
// 100090D8: using guessed type int __stdcall UF_VEC3_is_zero(_DWORD, _DWORD, _DWORD);
// 100090DC: using guessed type int __cdecl UF_VEC3_affine_comb(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10009128: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1000C008: using guessed type char byte_1000C008;
// 1000C009: using guessed type char byte_1000C009;
// 1000C3D8: using guessed type int dword_1000C3D8;
// 1000C3DC: using guessed type int dword_1000C3DC;
// 1000C4E0: using guessed type int dword_1000C4E0;
// 1000C4F8: using guessed type int dword_1000C4F8;
// 1000C4FC: using guessed type int dword_1000C4FC;
// 1000C500: using guessed type int dword_1000C500;
// 1000C504: using guessed type int dword_1000C504;
// 1000C508: using guessed type int dword_1000C508;
// 1000C520: using guessed type int dword_1000C520;
// 1000C524: using guessed type int dword_1000C524;
// 1000C528: using guessed type int dword_1000C528;
// 1000C52C: using guessed type int dword_1000C52C;
// 1000C588: using guessed type char byte_1000C588;

//----- (10003F80) --------------------------------------------------------
int __cdecl sub_10003F80(int a1, int a2, int a3, int a4, int a5, int a6)
{
  long double v6; // fst6@1
  int result; // eax@3
  long double v8; // fst3@8
  long double v9; // fst5@8
  long double v10; // fst2@9
  long double v11; // fst3@9
  long double v12; // fst4@9
  long double v13; // fst5@9
  long double v14; // fst7@9
  long double v15; // fst4@12
  long double v16; // fst5@12
  char v17; // [sp+Ch] [bp-70h]@1
  double v18; // [sp+24h] [bp-58h]@1
  double v19; // [sp+2Ch] [bp-50h]@12
  double v20; // [sp+34h] [bp-48h]@12
  double v21; // [sp+3Ch] [bp-40h]@1
  double v22; // [sp+44h] [bp-38h]@12
  double v23; // [sp+4Ch] [bp-30h]@12
  double v24; // [sp+54h] [bp-28h]@1
  double v25; // [sp+5Ch] [bp-20h]@1
  double v26; // [sp+64h] [bp-18h]@1
  double v27; // [sp+6Ch] [bp-10h]@1
  double v28; // [sp+74h] [bp-8h]@1

  UF_VEC3_sub(a1 + 24, a1, &v21);
  UF_VEC3_sub(a1, a2, &v17);
  UF_VEC3_sub(a2 + 24, a2, &v18);
  UF_VEC3_dot(&v21, &v17, &v25);
  UF_VEC3_dot(&v18, &v21, &v26);
  UF_VEC3_dot(&v18, &v17, &v24);
  UF_VEC3_dot(&v18, &v18, &v27);
  UF_VEC3_dot(&v21, &v21, &v28);
  v6 = v27;
  if ( v27 == 0.0 )
  {
    UF_VEC3_copy(a2, a4);
    *(double *)a6 = 0.0;
    if ( 0.0 == v28 )
    {
      UF_VEC3_copy(a1, a3);
      *(double *)a5 = 0.0;
      return 0;
    }
    result = sub_10002770(a4, a1, a3, a5);
    if ( result )
      return result;
    return 0;
  }
  if ( v28 == 0.0 )
  {
    UF_VEC3_copy(a1, a3);
    *(double *)a5 = 0.0;
    return 0;
  }
  v9 = v26 * v26;
  v8 = v28 * v6;
  if ( 0.0 != v9 - v8 )
  {
    v10 = v9;
    v13 = v9 - v8;
    v11 = v10 / v8;
    v12 = v11;
    v14 = v26;
    if ( v11 < 0.0 )
      v12 = -v11;
    if ( 1.0 - (dbl_1000C000 + dbl_1000C000) > v12 )
    {
      v15 = (v6 * v25 - v24 * v14) / v13;
      v16 = v24;
      *(double *)a5 = v15;
      *(double *)a6 = (v14 * v15 + v16) / v6;
      *(double *)a3 = *(double *)a5 * v21 + *(double *)a1;
      *(double *)a4 = *(double *)a6 * v18 + *(double *)a2;
      *(double *)(a3 + 8) = *(double *)a5 * v22 + *(double *)(a1 + 8);
      *(double *)(a4 + 8) = *(double *)a6 * v19 + *(double *)(a2 + 8);
      result = 0;
      *(double *)(a3 + 16) = *(double *)a5 * v23 + *(double *)(a1 + 16);
      *(double *)(a4 + 16) = *(double *)a6 * v20 + *(double *)(a2 + 16);
      return result;
    }
  }
  UF_VEC3_copy(a1, a3);
  *(double *)a5 = 0.0;
  result = sub_10002770(a3, a2, a4, a6);
  if ( !result )
    return 0;
  return result;
}
// 10002770: using guessed type _DWORD __cdecl sub_10002770(_DWORD, _DWORD, _DWORD, _DWORD);
// 100090EC: using guessed type int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD);
// 100090F0: using guessed type int __cdecl UF_VEC3_dot(_DWORD, _DWORD, _DWORD);
// 100090F4: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);
// 1000C000: using guessed type double dbl_1000C000;

//----- (100041A0) --------------------------------------------------------
signed int __cdecl sub_100041A0(int a1, const void *a2, int a3, int a4, int a5, int a6, int a7, int a8, const void *a9)
{
  int v9; // eax@1
  int v10; // ebx@1
  int v11; // edx@1
  char v12; // zf@1
  signed int result; // eax@4
  double v14; // ST5C_8@6
  int v15; // esi@13
  char v16; // zf@15
  long double v17; // fst7@24
  int v18; // edi@25
  double v19; // ST5C_8@31
  long double v20; // fst7@33
  double v21; // ST5C_8@35
  double v22; // ST5C_8@39
  long double v23; // fst7@41
  long double v24; // fst5@41
  long double v25; // fst7@41
  long double v26; // fst4@41
  long double v27; // fst3@41
  long double v28; // fst4@41
  long double v29; // fst6@41
  long double v30; // fst5@41
  long double v31; // fst6@41
  long double v32; // fst4@41
  long double v33; // fst2@41
  long double v34; // ft1@41
  long double v35; // fst6@41
  long double v36; // fst5@41
  long double v37; // fst6@41
  long double v38; // fst7@41
  long double v39; // fst4@41
  long double v40; // fst7@41
  long double v41; // fst7@45
  long double v42; // fst7@50
  long double v43; // fst7@53
  long double v44; // fst5@53
  long double v45; // fst7@53
  long double v46; // fst4@53
  long double v47; // fst3@53
  long double v48; // fst4@53
  long double v49; // fst6@53
  long double v50; // fst5@53
  long double v51; // fst6@53
  long double v52; // fst4@53
  long double v53; // fst2@53
  long double v54; // ft1@53
  long double v55; // fst6@53
  long double v56; // fst5@53
  long double v57; // fst6@53
  long double v58; // fst7@53
  long double v59; // fst4@53
  long double v60; // fst7@53
  long double v61; // fst7@56
  int v62; // esi@59
  long double v63; // fst7@61
  int v64; // eax@64
  int v65; // edx@64
  int v66; // ecx@64
  int v67; // eax@64
  int v68; // edx@64
  double v69; // ST5C_8@64
  double v70; // ST5C_8@64
  int v71; // ecx@67
  int v72; // edx@67
  int v73; // ecx@67
  int v74; // edx@67
  int v75; // eax@67
  int v76; // edx@67
  int v77; // ecx@67
  int v78; // edx@67
  int v79; // ecx@67
  int v80; // edx@67
  const char *v81; // [sp+5Ch] [bp-21Ch]@9
  char v82; // [sp+6Ch] [bp-20Ch]@67
  char v83; // [sp+7Ch] [bp-1FCh]@16
  char v84; // [sp+94h] [bp-1E4h]@67
  char v85; // [sp+A4h] [bp-1D4h]@16
  int v86; // [sp+BCh] [bp-1BCh]@64
  int v87; // [sp+C0h] [bp-1B8h]@64
  int v88; // [sp+C4h] [bp-1B4h]@64
  int v89; // [sp+C8h] [bp-1B0h]@64
  int v90; // [sp+CCh] [bp-1ACh]@64
  int v91; // [sp+D0h] [bp-1A8h]@64
  char v92; // [sp+D4h] [bp-1A4h]@64
  char v93; // [sp+ECh] [bp-18Ch]@64
  double v94; // [sp+104h] [bp-174h]@64
  double v95; // [sp+10Ch] [bp-16Ch]@64
  double v96; // [sp+114h] [bp-164h]@64
  char v97; // [sp+11Ch] [bp-15Ch]@41
  double v98; // [sp+134h] [bp-144h]@41
  double v99; // [sp+13Ch] [bp-13Ch]@41
  double v100; // [sp+144h] [bp-134h]@41
  double v101; // [sp+14Ch] [bp-12Ch]@41
  double v102; // [sp+154h] [bp-124h]@41
  double v103; // [sp+15Ch] [bp-11Ch]@41
  double v104; // [sp+164h] [bp-114h]@41
  double v105; // [sp+16Ch] [bp-10Ch]@41
  double v106; // [sp+174h] [bp-104h]@41
  double v107; // [sp+17Ch] [bp-FCh]@41
  double v108; // [sp+184h] [bp-F4h]@41
  double v109; // [sp+18Ch] [bp-ECh]@41
  char v110; // [sp+194h] [bp-E4h]@6
  int v111; // [sp+1ACh] [bp-CCh]@67
  int v112; // [sp+1B0h] [bp-C8h]@67
  int v113; // [sp+1B4h] [bp-C4h]@67
  int v114; // [sp+1B8h] [bp-C0h]@67
  int v115; // [sp+1BCh] [bp-BCh]@67
  int v116; // [sp+1C0h] [bp-B8h]@67
  int v117; // [sp+1C4h] [bp-B4h]@16
  int v118; // [sp+1C8h] [bp-B0h]@67
  int v119; // [sp+1CCh] [bp-ACh]@67
  int v120; // [sp+1D0h] [bp-A8h]@67
  int v121; // [sp+1D4h] [bp-A4h]@67
  int v122; // [sp+1D8h] [bp-A0h]@67
  char v123; // [sp+1DCh] [bp-9Ch]@7
  char v124; // [sp+1F4h] [bp-84h]@41
  double v125; // [sp+20Ch] [bp-6Ch]@1
  double v126; // [sp+214h] [bp-64h]@53
  double v127; // [sp+21Ch] [bp-5Ch]@53
  double v128; // [sp+224h] [bp-54h]@1
  double v129; // [sp+22Ch] [bp-4Ch]@41
  double v130; // [sp+234h] [bp-44h]@41
  double v131; // [sp+23Ch] [bp-3Ch]@17
  double v132; // [sp+244h] [bp-34h]@1
  double v133; // [sp+24Ch] [bp-2Ch]@41
  double v134; // [sp+254h] [bp-24h]@41
  double v135; // [sp+25Ch] [bp-1Ch]@41
  char v136; // [sp+264h] [bp-14h]@41
  int v137; // [sp+268h] [bp-10h]@1
  double v138; // [sp+26Ch] [bp-Ch]@1
  int v139; // [sp+274h] [bp-4h]@5

  v10 = a3;
  dword_1000C540 = *(_DWORD *)a3;
  dword_1000C544 = *(_DWORD *)(a3 + 4);
  dword_1000C548 = *(_DWORD *)(a3 + 8);
  dword_1000C54C = *(_DWORD *)(a3 + 12);
  dword_1000C550 = *(_DWORD *)(a3 + 16);
  dword_1000C554 = *(_DWORD *)(a3 + 20);
  dword_1000C2C8 = *(_DWORD *)a5;
  dword_1000C2CC = *(_DWORD *)(a5 + 4);
  dword_1000C2D0 = *(_DWORD *)(a5 + 8);
  dword_1000C2D4 = *(_DWORD *)(a5 + 12);
  dword_1000C2D8 = *(_DWORD *)(a5 + 16);
  v11 = *(_DWORD *)(a5 + 20);
  v137 = 0;
  dword_1000C2DC = v11;
  UF_VEC3_copy(a4, &v128);
  UF_VEC3_copy(a6, &v132);
  UF_VEC3_copy(a8, &v125);
  dbl_1000C558 = 0.0;
  dbl_1000C560 = 0.0;
  dbl_1000C568 = 0.0;
  dbl_1000C570 = 0.0;
  memcpy(&unk_1000C340, a9, 0x98u);
  dbl_1000C578 = 0.0;
  dbl_1000C580 = 0.0;
  dbl_1000C000 = dbl_1000C348;
  memcpy(&dbl_1000C470, a2, 0x60u);
  dbl_1000C538 = 0.0;
  dbl_1000C530 = 0.0;
  dbl_1000C2E8 = 0.0;
  dbl_1000C2E0 = 0.0;
  dbl_1000C468 = 0.0;
  dbl_1000C460 = 0.0;
  dbl_1000C320 = 0.0;
  dbl_1000C318 = 0.0;
  byte_1000C588 = 0;
  dword_1000C3D8 = (int)&unk_1000C340;
  UF_VEC3_unitize(a4, LODWORD(dbl_1000C348), HIDWORD(dbl_1000C348), &v138, &dbl_1000C2F0);
  UF_VEC3_unitize(a6, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), &v138, &dbl_1000C328);
  dword_1000C4E0 = 0;
  dword_1000C4E4 = 0;
  dword_1000C4E8 = 0;
  dword_1000C4EC = 0;
  dword_1000C4F0 = 0;
  dword_1000C4F4 = 0;
  dword_1000C4F8 = 0;
  dword_1000C4FC = 0;
  dword_1000C500 = 0;
  dword_1000C504 = 0;
  dword_1000C508 = 0;
  dword_1000C50C = 0;
  dword_1000C510 = 0;
  dword_1000C514 = 0;
  dword_1000C518 = 0;
  dword_1000C51C = 0;
  dword_1000C520 = 0;
  dword_1000C524 = 0;
  dword_1000C528 = 0;
  dword_1000C52C = 0;
  v9 = *(_DWORD *)dword_1000C3D8;
  v12 = *(_DWORD *)dword_1000C3D8 == 1;
  byte_1000C009 = 1;
  byte_1000C00A = 1;
  if ( !v12 && v9 != 2 && v9 != 3 )
    return 2;
  UF_VEC3_is_parallel(&v128, &v132, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), &v139);
  BYTE3(a2) = v139 != 0;
  UF_VEC3_is_parallel(&v128, &v125, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), &v139);
  BYTE3(a9) = v139 != 0;
  UF_VEC3_is_parallel(&v132, &v125, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), &v139);
  BYTE3(a3) = v139 != 0;
  if ( !BYTE3(a9) )
  {
    v14 = v138;
    sub_10001F20((int)&v125, (int)&v128, (int)&v110, SLOBYTE(v14));
  }
  UF_VEC3_cross(&v128, &v132);
  UF_VEC3_is_parallel(&v123, &v125, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), &v139);
  byte_1000C008 = v139 != 0;
  if ( byte_1000C588 )
  {
    printf("\n\n======================================================================\n");
    printf("Is_orthogonal_case = %d, ", (unsigned __int8)byte_1000C008);
    if ( *(_DWORD *)dword_1000C3D8 == 2 )
    {
      v81 = "is_5_axis_dual_table\n";
    }
    else
    {
      if ( *(_DWORD *)dword_1000C3D8 == 1 )
        v81 = "is_5_axis_dual_head\n";
      else
        v81 = "is_5_axis_head_table\n";
    }
    printf(v81);
    printf("primary=(%f,%f,%f)\n", *(double *)a4, *(double *)(a4 + 8), *(double *)(a4 + 16));
    printf("primary_machine_center=(%f,%f,%f)\n", *(double *)v10, *(double *)(v10 + 8), *(double *)(v10 + 16));
    printf("secondary=(%f,%f,%f)\n", *(double *)a6, *(double *)(a6 + 8), *(double *)(a6 + 16));
    v15 = a5;
    printf("secondary_machine_center=(%f,%f,%f)\n", *(double *)a5, *(double *)(a5 + 8), *(double *)(a5 + 16));
    printf("tool_machine_center=(%f,%f,%f)\n", *(double *)a7, *(double *)(a7 + 8), *(double *)(a7 + 16));
    printf("tool_vector=(%f,%f,%f)\n", *(double *)a8, *(double *)(a8 + 8), *(double *)(a8 + 16));
    printf(
      "Mcsys= (%f,%f,%f) (%f,%f,%f) (%f,%f,%f)  (%f,%f,%f)\n",
      *(_QWORD *)&dbl_1000C470,
      *(_QWORD *)&dbl_1000C478,
      *(_QWORD *)&dbl_1000C480,
      *(_QWORD *)&dbl_1000C488,
      *(_QWORD *)&dbl_1000C490,
      *(_QWORD *)&dbl_1000C498,
      *(_QWORD *)&dbl_1000C4A0,
      *(_QWORD *)&dbl_1000C4A8,
      *(_QWORD *)&dbl_1000C4B0,
      *(_QWORD *)&dbl_1000C4B8,
      *(_QWORD *)&dbl_1000C4C0,
      *(_QWORD *)&dbl_1000C4C8);
  }
  else
  {
    v15 = a5;
  }
  v16 = *(_DWORD *)dword_1000C3D8 == 3;
  dword_1000C3DC = -1;
  if ( !v16 )
  {
LABEL_23:
    if ( BYTE3(a2) )
    {
      v17 = 0.0;
    }
    else
    {
      v19 = v138;
      sub_10001F20((int)&v132, (int)&v128, (int)&v110, SLOBYTE(v19));
      v17 = sub_10002390((int)&v110, (int)&v132, (int)&v128);
      v15 = a5;
    }
    dbl_1000C578 = v17;
    if ( BYTE3(a3) )
    {
      printf("WARNING: Tool axis is parallelled with secondary axis that may cause unresolved rotaries");
      v20 = 0.0;
    }
    else
    {
      if ( fabs(v17) <= dbl_1000C000 )
      {
        v21 = v138;
        sub_10001F20((int)&v125, (int)&v132, (int)&v110, SLOBYTE(v21));
        if ( fabs(v138) <= dbl_1000C000 )
          return 3;
        v15 = a5;
      }
      if ( byte_1000C008 )
      {
        v22 = v138;
        sub_10001F20((int)&v125, (int)&v132, (int)&v85, SLOBYTE(v22));
        v20 = sub_10002390((int)&v85, (int)&v125, (int)&v132);
        v15 = a5;
      }
      else
      {
        v20 = sub_10002390((int)&v110, (int)&v125, (int)&v132);
      }
    }
    dbl_1000C580 = v20;
    v23 = v128 * 1000000.0;
    v24 = *(double *)v10 + v23;
    v25 = *(double *)v10 - v23;
    v26 = v132 * 1000000.0;
    v27 = *(double *)v15 + v26;
    v28 = *(double *)v15 - v26;
    v98 = v24;
    v104 = v27;
    v101 = v25;
    v107 = v28;
    v29 = v129 * 1000000.0;
    v30 = *(double *)(v10 + 8) + v29;
    v31 = *(double *)(v10 + 8) - v29;
    v32 = v133 * 1000000.0;
    v33 = *(double *)(v15 + 8);
    v34 = *(double *)(v15 + 8) + v32;
    v99 = v30;
    v105 = v34;
    v102 = v31;
    v108 = v33 - v32;
    v35 = v130 * 1000000.0;
    v36 = *(double *)(v10 + 16) + v35;
    v37 = *(double *)(v10 + 16) - v35;
    v38 = 1000000.0 * v134;
    v39 = *(double *)(v15 + 16) + v38;
    v40 = *(double *)(v15 + 16) - v38;
    v100 = v36;
    v106 = v39;
    v103 = v37;
    v109 = v40;
    if ( sub_10003F80((int)&v98, (int)&v104, (int)&v97, (int)&v124, (int)&v135, (int)&v136) )
      return 5;
    UF_VEC3_distance(&v97, &v124, &dbl_1000C558);
    if ( dbl_1000C000 >= (long double)dbl_1000C558 )
    {
      v41 = 0.0;
    }
    else
    {
      UF_VEC3_sub(&v124, &v97, &v123);
      UF_VEC3_dot(&v123, &v110, &v131);
      if ( v131 >= 0.0 )
        goto LABEL_48;
      v41 = -dbl_1000C558;
    }
    dbl_1000C558 = v41;
LABEL_48:
    UF_VEC3_distance(&v124, v10, &dbl_1000C560);
    if ( dbl_1000C000 >= (long double)dbl_1000C560 )
    {
      v42 = 0.0;
    }
    else
    {
      UF_VEC3_sub(&v124, v10, &v123);
      UF_VEC3_dot(&v123, &v128, &v131);
      if ( v131 >= 0.0 )
        goto LABEL_53;
      v42 = -dbl_1000C560;
    }
    dbl_1000C560 = v42;
LABEL_53:
    v43 = v132 * 1000000.0;
    v44 = *(double *)v15 + v43;
    v45 = *(double *)v15 - v43;
    v46 = v125 * 1000000.0;
    v47 = *(double *)a7 + v46;
    v48 = *(double *)a7 - v46;
    v98 = v44;
    v104 = v47;
    v101 = v45;
    v107 = v48;
    v49 = v133 * 1000000.0;
    v50 = *(double *)(v15 + 8) + v49;
    v51 = *(double *)(v15 + 8) - v49;
    v52 = v126 * 1000000.0;
    v53 = *(double *)(a7 + 8);
    v54 = *(double *)(a7 + 8) + v52;
    v99 = v50;
    v105 = v54;
    v102 = v51;
    v108 = v53 - v52;
    v55 = v134 * 1000000.0;
    v56 = *(double *)(v15 + 16) + v55;
    v57 = *(double *)(v15 + 16) - v55;
    v58 = 1000000.0 * v127;
    v59 = *(double *)(a7 + 16) + v58;
    v60 = *(double *)(a7 + 16) - v58;
    v100 = v56;
    v106 = v59;
    v103 = v57;
    v109 = v60;
    if ( sub_10003F80((int)&v98, (int)&v104, (int)&v97, (int)&v124, (int)&v135, (int)&v136) )
      return 5;
    UF_VEC3_distance(&v97, &v124, &dbl_1000C568);
    if ( dbl_1000C000 >= (long double)dbl_1000C568 )
    {
      v61 = 0.0;
    }
    else
    {
      UF_VEC3_sub(&v124, &v97, &v123);
      UF_VEC3_dot(&v123, &v110, &v135);
      if ( v135 >= 0.0 )
        goto LABEL_59;
      v61 = -dbl_1000C568;
    }
    dbl_1000C568 = v61;
LABEL_59:
    v62 = a7;
    UF_VEC3_distance(&v124, a7, &dbl_1000C570);
    if ( dbl_1000C000 >= (long double)dbl_1000C570 )
    {
      v63 = 0.0;
    }
    else
    {
      UF_VEC3_sub(&v124, v62, &v123);
      UF_VEC3_dot(&v123, &v132, &v135);
      if ( v135 >= 0.0 )
      {
LABEL_64:
        v64 = *(_DWORD *)(v10 + 8);
        v65 = *(_DWORD *)(v10 + 4);
        v86 = *(_DWORD *)v10;
        v66 = *(_DWORD *)(v10 + 12);
        v88 = v64;
        v67 = *(_DWORD *)(v10 + 20);
        v87 = v65;
        v68 = *(_DWORD *)(v10 + 16);
        v89 = v66;
        v91 = v67;
        v69 = v138;
        v90 = v68;
        sub_10001F20((int)&v132, (int)&v128, (int)&v92, SLOBYTE(v69));
        v94 = v128;
        v95 = v129;
        v96 = v130;
        v70 = v138;
        sub_10001F20((int)&v92, (int)&v128, (int)&v93, SLOBYTE(v70));
        sub_10002080((int)&v86, a1, (int)&unk_1000C3E0);
        sub_10002EB0((int)&unk_1000C3E0, (int)&dbl_1000C248);
        dbl_1000C310 = sin(dbl_1000C578);
        dbl_1000C4D0 = sin(dbl_1000C580);
        dbl_1000C4D8 = cos(dbl_1000C578);
        dbl_1000C308 = cos(dbl_1000C580);
        if ( byte_1000C588 )
          printf(
            "A1=%f,D1=%f,Alpha1=%f,A2=%f,D2=%f,Alpha2=%f\n",
            *(_QWORD *)&dbl_1000C558,
            *(_QWORD *)&dbl_1000C560,
            dbl_1000C578 * 57.29577951308235,
            *(_QWORD *)&dbl_1000C568,
            *(_QWORD *)&dbl_1000C570,
            dbl_1000C580 * 57.29577951308235);
        if ( *(_DWORD *)dword_1000C3D8 == 2 )
        {
          v71 = *(_DWORD *)(a7 + 4);
          v111 = *(_DWORD *)a7;
          v72 = *(_DWORD *)(a7 + 8);
          v112 = v71;
          v73 = *(_DWORD *)(a7 + 12);
          v113 = v72;
          v74 = *(_DWORD *)(a7 + 16);
          v75 = *(_DWORD *)(a7 + 20);
          v114 = v73;
          v115 = v74;
          v116 = v75;
          v76 = *(_DWORD *)(a8 + 4);
          v117 = *(_DWORD *)a8;
          v77 = *(_DWORD *)(a8 + 8);
          v118 = v76;
          v78 = *(_DWORD *)(a8 + 12);
          v119 = v77;
          v79 = *(_DWORD *)(a8 + 16);
          v120 = v78;
          v80 = *(_DWORD *)(a8 + 20);
          v121 = v79;
          v122 = v80;
          sub_10003210(v10, (int)printf, (int)&v93, &v111, (int)&v82, (int)&v84);
          if ( byte_1000C588 )
          {
            printf(
              "Init_T1[0], Init_T2[0] = (%f,%f)\n",
              57.29577951308235 * dbl_1000C530,
              dbl_1000C2E0 * 57.29577951308235);
            printf(
              "Init_T1[1], Init_T2[1] = (%f,%f)\n",
              57.29577951308235 * dbl_1000C538,
              dbl_1000C2E8 * 57.29577951308235);
          }
        }
        result = 0;
        byte_1000C009 = 0;
        return result;
      }
      v63 = -dbl_1000C570;
    }
    dbl_1000C570 = v63;
    goto LABEL_64;
  }
  UF_MTX3_x_vec(&unk_100098E8, &v85);
  UF_MTX3_y_vec(&unk_100098E8, &v83);
  UF_MTX3_z_vec(&unk_100098E8, &v117);
  UF_VEC3_is_equal(a8, &v117, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), &a9);
  if ( !a9 )
  {
    UF_VEC3_is_equal(a8, &v83, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), &v137);
    UF_VEC3_is_equal(&v128, &v117, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), (char *)&v131 + 4);
    if ( byte_1000C008 || !BYTE3(a3) || !v137 || !HIDWORD(v131) )
      return 2;
    dword_1000C3DC = 3;
    UF_MTX3_vec_multiply_t(&dbl_1000C2F0, &unk_10009978, &dbl_1000C2F0);
    UF_MTX3_vec_multiply_t(&dbl_1000C328, &unk_10009978, &dbl_1000C328);
    if ( byte_1000C588 )
    {
      printf("Sulzer case:\n");
      printf(
        "local PrimaryAxis=(%f,%f,%f)\n",
        *(_QWORD *)&dbl_1000C2F0,
        *(_QWORD *)&dbl_1000C2F8,
        *(_QWORD *)&dbl_1000C300);
      printf(
        "local SecondaryAxis=(%f,%f,%f)\n",
        *(_QWORD *)&dbl_1000C328,
        *(_QWORD *)&dbl_1000C330,
        *(_QWORD *)&dbl_1000C338);
    }
    goto LABEL_23;
  }
  UF_VEC3_is_equal(a4, &v85, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), &a5);
  v18 = a6;
  UF_VEC3_is_equal(a6, &v83, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), &a3);
  UF_VEC3_is_equal(v18, &v117, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), &a2);
  if ( a5 && a3 )
  {
    result = v137;
    dword_1000C3DC = 0;
    byte_1000C009 = 0;
  }
  else
  {
    if ( a2 )
    {
      result = v137;
      dword_1000C3DC = 1;
      byte_1000C009 = 0;
    }
    else
    {
      v137 = 2;
      result = 2;
      byte_1000C009 = 0;
    }
  }
  return result;
}
// 100090B0: using guessed type int __cdecl UF_VEC3_cross(_DWORD, _DWORD);
// 100090C8: using guessed type int __cdecl UF_VEC3_is_parallel(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090CC: using guessed type int __cdecl UF_MTX3_z_vec(_DWORD, _DWORD);
// 100090D0: using guessed type int __cdecl UF_VEC3_distance(_DWORD, _DWORD, _DWORD);
// 100090E0: using guessed type int __cdecl UF_VEC3_is_equal(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090EC: using guessed type int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD);
// 100090F0: using guessed type int __cdecl UF_VEC3_dot(_DWORD, _DWORD, _DWORD);
// 100090F4: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);
// 10009120: using guessed type int __cdecl UF_MTX3_x_vec(_DWORD, _DWORD);
// 10009124: using guessed type int __cdecl UF_MTX3_y_vec(_DWORD, _DWORD);
// 10009128: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1000C000: using guessed type double dbl_1000C000;
// 1000C008: using guessed type char byte_1000C008;
// 1000C009: using guessed type char byte_1000C009;
// 1000C00A: using guessed type char byte_1000C00A;
// 1000C248: using guessed type double dbl_1000C248;
// 1000C2C8: using guessed type int dword_1000C2C8;
// 1000C2CC: using guessed type int dword_1000C2CC;
// 1000C2D0: using guessed type int dword_1000C2D0;
// 1000C2D4: using guessed type int dword_1000C2D4;
// 1000C2D8: using guessed type int dword_1000C2D8;
// 1000C2DC: using guessed type int dword_1000C2DC;
// 1000C2E0: using guessed type double dbl_1000C2E0;
// 1000C2E8: using guessed type double dbl_1000C2E8;
// 1000C2F0: using guessed type double dbl_1000C2F0;
// 1000C2F8: using guessed type double dbl_1000C2F8;
// 1000C300: using guessed type double dbl_1000C300;
// 1000C308: using guessed type double dbl_1000C308;
// 1000C310: using guessed type double dbl_1000C310;
// 1000C318: using guessed type double dbl_1000C318;
// 1000C320: using guessed type double dbl_1000C320;
// 1000C328: using guessed type double dbl_1000C328;
// 1000C330: using guessed type double dbl_1000C330;
// 1000C338: using guessed type double dbl_1000C338;
// 1000C348: using guessed type double dbl_1000C348;
// 1000C3D8: using guessed type int dword_1000C3D8;
// 1000C3DC: using guessed type int dword_1000C3DC;
// 1000C460: using guessed type double dbl_1000C460;
// 1000C468: using guessed type double dbl_1000C468;
// 1000C470: using guessed type double dbl_1000C470;
// 1000C478: using guessed type double dbl_1000C478;
// 1000C480: using guessed type double dbl_1000C480;
// 1000C488: using guessed type double dbl_1000C488;
// 1000C490: using guessed type double dbl_1000C490;
// 1000C498: using guessed type double dbl_1000C498;
// 1000C4A0: using guessed type double dbl_1000C4A0;
// 1000C4A8: using guessed type double dbl_1000C4A8;
// 1000C4B0: using guessed type double dbl_1000C4B0;
// 1000C4B8: using guessed type double dbl_1000C4B8;
// 1000C4C0: using guessed type double dbl_1000C4C0;
// 1000C4C8: using guessed type double dbl_1000C4C8;
// 1000C4D0: using guessed type double dbl_1000C4D0;
// 1000C4D8: using guessed type double dbl_1000C4D8;
// 1000C4E0: using guessed type int dword_1000C4E0;
// 1000C4E4: using guessed type int dword_1000C4E4;
// 1000C4E8: using guessed type int dword_1000C4E8;
// 1000C4EC: using guessed type int dword_1000C4EC;
// 1000C4F0: using guessed type int dword_1000C4F0;
// 1000C4F4: using guessed type int dword_1000C4F4;
// 1000C4F8: using guessed type int dword_1000C4F8;
// 1000C4FC: using guessed type int dword_1000C4FC;
// 1000C500: using guessed type int dword_1000C500;
// 1000C504: using guessed type int dword_1000C504;
// 1000C508: using guessed type int dword_1000C508;
// 1000C50C: using guessed type int dword_1000C50C;
// 1000C510: using guessed type int dword_1000C510;
// 1000C514: using guessed type int dword_1000C514;
// 1000C518: using guessed type int dword_1000C518;
// 1000C51C: using guessed type int dword_1000C51C;
// 1000C520: using guessed type int dword_1000C520;
// 1000C524: using guessed type int dword_1000C524;
// 1000C528: using guessed type int dword_1000C528;
// 1000C52C: using guessed type int dword_1000C52C;
// 1000C530: using guessed type double dbl_1000C530;
// 1000C538: using guessed type double dbl_1000C538;
// 1000C540: using guessed type int dword_1000C540;
// 1000C544: using guessed type int dword_1000C544;
// 1000C548: using guessed type int dword_1000C548;
// 1000C54C: using guessed type int dword_1000C54C;
// 1000C550: using guessed type int dword_1000C550;
// 1000C554: using guessed type int dword_1000C554;
// 1000C558: using guessed type double dbl_1000C558;
// 1000C560: using guessed type double dbl_1000C560;
// 1000C568: using guessed type double dbl_1000C568;
// 1000C570: using guessed type double dbl_1000C570;
// 1000C578: using guessed type double dbl_1000C578;
// 1000C580: using guessed type double dbl_1000C580;
// 1000C588: using guessed type char byte_1000C588;

//----- (10004F70) --------------------------------------------------------
signed int __cdecl sub_10004F70(int a1, int a2, int a3)
{
  int v3; // ebx@1
  signed int v4; // esi@3
  char v5; // zf@8
  char v7; // [sp+34h] [bp-98h]@1
  _BYTE v8[40]; // [sp+64h] [bp-68h]@1
  _BYTE v9[40]; // [sp+8Ch] [bp-40h]@1
  double v10; // [sp+B4h] [bp-18h]@2
  double v11; // [sp+BCh] [bp-10h]@2
  double v12; // [sp+C4h] [bp-8h]@2
  signed int v13; // [sp+D4h] [bp+8h]@1

  v3 = a1;
  memcpy(&v7, (const void *)a1, 0x30u);
  UF_VEC3_add(&v7, dword_1000C3D8 + 16, &v7);
  UF_VEC3_sub(&v7, dword_1000C3D8 + 40, &v7);
  v13 = sub_10003210(a1, (int)v8, (int)UF_VEC3_add, &v7, (int)v9, (int)v8);
  UF_VEC3_add(v9, dword_1000C3D8 + 64, v9);
  UF_VEC3_add(v8, dword_1000C3D8 + 64, v8);
  if ( *(_BYTE *)(dword_1000C3D8 + 88) )
  {
    v10 = *(double *)(v3 + 24);
    v11 = *(double *)(v3 + 32);
    v12 = *(double *)(v3 + 40);
    UF_VEC3_scale(
      COERCE_UNSIGNED_INT64(*(double *)(dword_1000C3D8 + 96)),
      COERCE_UNSIGNED_INT64(*(double *)(dword_1000C3D8 + 96)) >> 32,
      &v10,
      &v10);
    UF_VEC3_add(v9, &v10, v9);
    UF_VEC3_add(v8, &v10, v8);
  }
  v4 = 0;
  do
  {
    *(double *)&v9[v4] = sub_10005200((int)&v9[v4], (long double *)(dword_1000C3D8 + 8));
    *(double *)&v8[v4] = sub_10005200((int)&v8[v4], (long double *)(dword_1000C3D8 + 8));
    v4 += 8;
  }
  while ( v4 <= 16 );
  if ( byte_1000C00A )
    byte_1000C00A = 0;
  else
    sub_100025B0((int)v9, (int)v8);
  v5 = byte_1000C588 == 0;
  memcpy((void *)a2, v9, 0x28u);
  memcpy((void *)a3, v8, 0x28u);
  memcpy(&unk_1000C5B8, (const void *)a2, 0x28u);
  memcpy(&unk_1000C590, (const void *)a3, 0x28u);
  if ( !v5 )
  {
    printf(
      "final ufunc mcoord[] = (%f,%f,%f), (%f,%f)\n",
      *(double *)a2,
      *(double *)(a2 + 8),
      *(double *)(a2 + 16),
      *(double *)(a2 + 24),
      *(double *)(a2 + 32));
    printf(
      "final ufunc alt_mcoord[] = (%f,%f,%f), (%f,%f)\n",
      *(double *)a3,
      *(double *)(a3 + 8),
      *(double *)(a3 + 16),
      *(double *)(a3 + 24),
      *(double *)(a3 + 32));
  }
  return v13;
}
// 100090C4: using guessed type int __cdecl UF_VEC3_scale(_DWORD, _DWORD, _DWORD, _DWORD);
// 100090EC: using guessed type int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD);
// 10009100: using guessed type int __cdecl UF_VEC3_add(_DWORD, _DWORD, _DWORD);
// 1000C00A: using guessed type char byte_1000C00A;
// 1000C3D8: using guessed type int dword_1000C3D8;
// 1000C588: using guessed type char byte_1000C588;

//----- (10005200) --------------------------------------------------------
long double __cdecl sub_10005200(int a1, long double *a2)
{
  long double result; // fst7@2
  long double v3; // fst7@3
  long double v4; // fst7@3
  double v5; // [sp+8h] [bp-8h]@3

  if ( fabs(fabs(*(double *)a2)) > 1.0e-10 )
  {
    v4 = 1.0 / *(double *)a2;
    v5 = v4;
    v3 = v4 * *(double *)a1;
    if ( v3 >= 0.000001 )
    {
      result = floor(v3 + 0.5) / v5;
    }
    else
    {
      if ( v3 <= -0.000001 )
        result = ceil(v3 - 0.5) / v5;
      else
        result = 0.0 / v5;
    }
  }
  else
  {
    result = 0.0;
  }
  return result;
}

//----- (10005290) --------------------------------------------------------
signed int __usercall sub_10005290<eax>(int a1<eax>)
{
  signed int v1; // ecx@1
  int v2; // esi@1
  long double v3; // fst4@1
  long double v4; // fst6@1
  long double v5; // ft0@2
  long double v6; // fst3@3
  long double v7; // fst4@4
  long double v8; // fst6@4
  long double v9; // ft1@4
  long double v10; // ft2@5
  long double v11; // fst3@7
  signed int result; // eax@13
  char v13; // [sp+1Ch] [bp-98h]@1
  char v14; // [sp+64h] [bp-50h]@1
  char v15; // [sp+7Ch] [bp-38h]@1
  char v16; // [sp+94h] [bp-20h]@1
  char v17; // [sp+ACh] [bp-8h]@11

  v2 = a1;
  UF_VEC3_copy(a1, &v16);
  UF_VEC3_copy(v2 + 24, &v15);
  UF_VEC3_copy(v2 + 48, &v14);
  UF_MTX3_copy(v2, &v13);
  v4 = 0.0;
  v1 = 0;
  v3 = -1.0;
  while ( 1 )
  {
    v6 = fabs(*(double *)(v2 + 8 * v1));
    if ( v6 > 1.0e-10 )
    {
      v10 = v3;
      v7 = v4;
      v8 = v10;
      if ( fabs(v6 - 1.0) <= 1.0e-10 )
      {
        if ( v7 >= *(double *)(v2 + 8 * v1) )
          v11 = v8;
        else
          v11 = 1.0;
        *(double *)(v2 + 8 * v1) = v11;
      }
    }
    else
    {
      v9 = v3;
      v7 = v4;
      v8 = v9;
      *(double *)(v2 + 8 * v1) = v7;
    }
    ++v1;
    if ( v1 >= 9 )
      break;
    v5 = v7;
    v3 = v8;
    v4 = v5;
  }
  if ( UF_VEC3_unitize(&v16, COERCE_UNSIGNED_INT64(1.0e-10), COERCE_UNSIGNED_INT64(1.0e-10) >> 32, &v17, &v16)
    && UF_VEC3_unitize(&v15, COERCE_UNSIGNED_INT64(1.0e-10), COERCE_UNSIGNED_INT64(1.0e-10) >> 32, &v17, &v15) )
  {
    ((void (__cdecl *)(char *, char *, char *))UF_VEC3_cross)(&v16, &v15, &v14);
    UF_VEC3_cross(&v14, &v16);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100090B0: using guessed type int __cdecl UF_VEC3_cross(_DWORD, _DWORD);
// 100090F4: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);
// 1000911C: using guessed type int __cdecl UF_MTX3_copy(_DWORD, _DWORD);
// 10009128: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (100053B0) --------------------------------------------------------
signed int __cdecl sub_100053B0(int a1)
{
  signed int v2; // edi@1
  char v3; // [sp+8h] [bp-48h]@1

  UF_MTX4_ask_rotation(a1, &v3);
  v2 = sub_10005290((int)&v3);
  UF_MTX4_edit_rotation(a1, &v3);
  return v2;
}
// 100090C0: using guessed type int __cdecl UF_MTX4_edit_rotation(_DWORD, _DWORD);
// 10009108: using guessed type int __cdecl UF_MTX4_ask_rotation(_DWORD, _DWORD);

//----- (100053F0) --------------------------------------------------------
int __fastcall sub_100053F0(int a1, int a2, char a3)
{
  return UF_MOM_ask_string(a2, a1, &a3);
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10005410) --------------------------------------------------------
int __cdecl sub_10005410(int a1, int a2)
{
  char v2; // zf@1
  int v3; // eax@1
  signed int v4; // ecx@1
  char v5[4]; // edi@1
  int v6; // esi@1
  int v7; // esi@6
  char *v8; // eax@7
  int v9; // edx@9
  char v10; // cl@10
  char *v11; // eax@12
  int v12; // edx@14
  char v13; // cl@15
  char *v14; // eax@17
  int v15; // edx@19
  char v16; // cl@20
  char *v17; // eax@22
  int v18; // edx@24
  char v19; // cl@25
  char *v20; // eax@27
  char *v21; // eax@30
  char v22; // zf@33
  signed int v23; // ecx@33
  char v24[4]; // edi@33
  int v25; // esi@33
  int v27; // [sp+Ch] [bp-24h]@5
  int v28; // [sp+10h] [bp-20h]@5
  int v29; // [sp+14h] [bp-1Ch]@5
  int v30; // [sp+18h] [bp-18h]@5
  int v31; // [sp+1Ch] [bp-14h]@5
  char v32[4]; // [sp+20h] [bp-10h]@1
  int v33; // [sp+24h] [bp-Ch]@6
  int v34; // [sp+28h] [bp-8h]@5
  char *v35; // [sp+2Ch] [bp-4h]@6

  v3 = (int)"mom_kin_nurbs_output_type";
  *(_DWORD *)v5 = "END";
  v6 = (int)"mom_kin_nurbs_output_type";
  v4 = 26;
  v2 = 1;
  *(_DWORD *)v32 = "END";
  do
  {
    if ( !v4 )
      break;
    v2 = *(_BYTE *)v6++ == **(_BYTE **)v5;
    ++*(_DWORD *)v5;
    --v4;
  }
  while ( v2 );
  v27 = (int)"mom_kin_output_unit";
  v28 = (int)"mom_kin_polar_radius_side";
  v29 = (int)"mom_kin_read_ahead_next_motion";
  v30 = (int)"mom_kin_pivot_gauge_offset";
  v31 = (int)"mom_kin_rapid_feed_rate";
  v34 = 0;
  if ( !v2 )
  {
    do
    {
      v7 = v34;
      v33 = UF_MOM_ask_string(a1, v3 + 4, &v35);
      switch ( v34 )
      {
        case 0:
          v8 = v35;
          if ( !v35 )
          {
            v8 = "NONE";
            v35 = "NONE";
          }
          v9 = a2 - (_DWORD)v8;
          do
          {
            v10 = *v8;
            v8[v9] = *v8;
            ++v8;
          }
          while ( v10 );
          break;
        case 1:
          v11 = v35;
          if ( !v35 )
          {
            v11 = "IN";
            v35 = "IN";
          }
          v12 = a2 - (_DWORD)v11 + 133;
          do
          {
            v13 = *v11;
            v11[v12] = *v11;
            ++v11;
          }
          while ( v13 );
          break;
        case 2:
          v14 = v35;
          if ( !v35 )
          {
            v14 = "NONE";
            v35 = "NONE";
          }
          v15 = a2 - (_DWORD)v14 + 266;
          do
          {
            v16 = *v14;
            v14[v15] = *v14;
            ++v14;
          }
          while ( v16 );
          break;
        case 3:
          v17 = v35;
          if ( !v35 )
          {
            v17 = (char *)L"F";
            v35 = (char *)L"F";
          }
          v18 = a2 - (_DWORD)v17 + 399;
          do
          {
            v19 = *v17;
            v17[v18] = *v17;
            ++v17;
          }
          while ( v19 );
          break;
        case 4:
          v20 = v35;
          if ( !v35 )
          {
            v20 = "0.0";
            v35 = "0.0";
          }
          *(double *)(a2 + 536) = strtod(v20, 0);
          break;
        case 5:
          v21 = v35;
          if ( !v35 )
          {
            v21 = "400.00";
            v35 = "400.00";
          }
          *(double *)(a2 + 544) = strtod(v21, 0);
          break;
        default:
          break;
      }
      v3 = *(&v27 + v7);
      v34 = v7 + 1;
      *(_DWORD *)v24 = "END";
      v25 = v3;
      v23 = 4;
      v22 = 1;
      do
      {
        if ( !v23 )
          break;
        v22 = *(_BYTE *)v25++ == **(_BYTE **)v24;
        ++*(_DWORD *)v24;
        --v23;
      }
      while ( v22 );
    }
    while ( !v22 );
  }
  return v33;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);
// 10009F34: using guessed type wchar_t aF[2];

//----- (100055C0) --------------------------------------------------------
int __cdecl sub_100055C0(int a1, int a2)
{
  char v2; // zf@1
  int v3; // eax@1
  signed int v4; // ecx@1
  int v5; // ebx@1
  char v6[4]; // edi@1
  int v7; // esi@1
  char *v8; // eax@7
  int v9; // edx@9
  char v10; // cl@10
  char *v11; // eax@12
  int v12; // edx@14
  char v13; // cl@15
  char *v14; // eax@17
  char *v15; // eax@20
  char v16; // zf@23
  signed int v17; // ecx@23
  char v18[4]; // edi@23
  int v19; // esi@23
  int v21; // [sp+10h] [bp-18h]@5
  int v22; // [sp+14h] [bp-14h]@5
  int v23; // [sp+18h] [bp-10h]@5
  char v24[4]; // [sp+1Ch] [bp-Ch]@1
  int v25; // [sp+20h] [bp-8h]@6
  char *v26; // [sp+24h] [bp-4h]@6

  v3 = (int)"mom_kin_arc_output_mode";
  *(_DWORD *)v6 = "END";
  v5 = 0;
  v7 = (int)"mom_kin_arc_output_mode";
  v4 = 24;
  v2 = 1;
  *(_DWORD *)v24 = "END";
  do
  {
    if ( !v4 )
      break;
    v2 = *(_BYTE *)v7++ == **(_BYTE **)v6;
    ++*(_DWORD *)v6;
    --v4;
  }
  while ( v2 );
  v21 = (int)"mom_kin_arc_valid_plane";
  v22 = (int)"mom_kin_min_arc_radius";
  v23 = (int)"mom_kin_max_arc_radius";
  if ( !v2 )
  {
    do
    {
      v25 = UF_MOM_ask_string(a1, v3 + 4, &v26);
      switch ( v5 )
      {
        case 0:
          v8 = v26;
          if ( !v26 )
          {
            v8 = "FULL_CIRCLE";
            v26 = "FULL_CIRCLE";
          }
          v9 = a2 - (_DWORD)v8;
          do
          {
            v10 = *v8;
            v8[v9] = *v8;
            ++v8;
          }
          while ( v10 );
          break;
        case 1:
          v11 = v26;
          if ( !v26 )
          {
            v11 = "XY";
            v26 = "XY";
          }
          v12 = a2 - (_DWORD)v11 + 133;
          do
          {
            v13 = *v11;
            v11[v12] = *v11;
            ++v11;
          }
          while ( v13 );
          break;
        case 2:
          v14 = v26;
          if ( !v26 )
          {
            v14 = "0.0001";
            v26 = "0.0001";
          }
          *(double *)(a2 + 272) = strtod(v14, 0);
          break;
        case 3:
          v15 = v26;
          if ( !v26 )
          {
            v15 = "9999.9999";
            v26 = "9999.9999";
          }
          *(double *)(a2 + 280) = strtod(v15, 0);
          break;
        default:
          break;
      }
      v3 = *(&v21 + v5++);
      *(_DWORD *)v18 = "END";
      v19 = v3;
      v17 = 4;
      v16 = 1;
      do
      {
        if ( !v17 )
          break;
        v16 = *(_BYTE *)v19++ == **(_BYTE **)v18;
        ++*(_DWORD *)v18;
        --v17;
      }
      while ( v16 );
    }
    while ( !v16 );
  }
  return v25;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10005700) --------------------------------------------------------
int __cdecl sub_10005700(int a1, int a2)
{
  char v2; // zf@1
  int v3; // eax@1
  signed int v4; // ecx@1
  char v5[4]; // edi@1
  int v6; // esi@1
  int v7; // esi@6
  char *v8; // eax@7
  char *v9; // eax@10
  char *v10; // eax@13
  char *v11; // eax@16
  char *v12; // eax@19
  char *v13; // eax@22
  char *v14; // eax@25
  char *v15; // eax@28
  char v16; // zf@31
  signed int v17; // ecx@31
  char v18[4]; // edi@31
  int v19; // esi@31
  int v21; // [sp+Ch] [bp-2Ch]@5
  int v22; // [sp+10h] [bp-28h]@5
  int v23; // [sp+14h] [bp-24h]@5
  int v24; // [sp+18h] [bp-20h]@5
  int v25; // [sp+1Ch] [bp-1Ch]@5
  int v26; // [sp+20h] [bp-18h]@5
  int v27; // [sp+24h] [bp-14h]@5
  char v28[4]; // [sp+28h] [bp-10h]@1
  int v29; // [sp+2Ch] [bp-Ch]@6
  int v30; // [sp+30h] [bp-8h]@5
  char *v31; // [sp+34h] [bp-4h]@6

  v3 = (int)"mom_kin_max_fpm";
  *(_DWORD *)v5 = "END";
  v6 = (int)"mom_kin_max_fpm";
  v4 = 16;
  v2 = 1;
  *(_DWORD *)v28 = "END";
  do
  {
    if ( !v4 )
      break;
    v2 = *(_BYTE *)v6++ == **(_BYTE **)v5;
    ++*(_DWORD *)v5;
    --v4;
  }
  while ( v2 );
  v21 = (int)"mom_kin_min_fpm";
  v22 = (int)"mom_kin_max_fpr";
  v23 = (int)"mom_kin_min_fpr";
  v24 = (int)"mom_kin_max_frn";
  v25 = (int)"mom_kin_min_frn";
  v26 = (int)"mom_kin_max_dpm";
  v27 = (int)"mom_kin_min_dpm";
  v30 = 0;
  if ( !v2 )
  {
    do
    {
      v7 = v30;
      v29 = UF_MOM_ask_string(a1, v3 + 4, &v31);
      switch ( v30 )
      {
        case 0:
          v8 = v31;
          if ( !v31 )
          {
            v8 = "999.999";
            v31 = "999.999";
          }
          *(double *)a2 = strtod(v8, 0);
          break;
        case 1:
          v9 = v31;
          if ( !v31 )
          {
            v9 = "0.001";
            v31 = "0.001";
          }
          *(double *)(a2 + 32) = strtod(v9, 0);
          break;
        case 2:
          v10 = v31;
          if ( !v31 )
          {
            v10 = "99.999";
            v31 = "99.999";
          }
          *(double *)(a2 + 8) = strtod(v10, 0);
          break;
        case 3:
          v11 = v31;
          if ( !v31 )
          {
            v11 = "0.001";
            v31 = "0.001";
          }
          *(double *)(a2 + 40) = strtod(v11, 0);
          break;
        case 4:
          v12 = v31;
          if ( !v31 )
          {
            v12 = "99999.999";
            v31 = "99999.999";
          }
          *(double *)(a2 + 16) = strtod(v12, 0);
          break;
        case 5:
          v13 = v31;
          if ( !v31 )
          {
            v13 = "0.001";
            v31 = "0.001";
          }
          *(double *)(a2 + 48) = strtod(v13, 0);
          break;
        case 6:
          v14 = v31;
          if ( !v31 )
          {
            v14 = "99.999";
            v31 = "99.999";
          }
          *(double *)(a2 + 24) = strtod(v14, 0);
          break;
        case 7:
          v15 = v31;
          if ( !v31 )
          {
            v15 = "0.0";
            v31 = "0.0";
          }
          *(double *)(a2 + 56) = strtod(v15, 0);
          break;
        default:
          break;
      }
      v3 = *(&v21 + v7);
      v30 = v7 + 1;
      *(_DWORD *)v18 = "END";
      v19 = v3;
      v17 = 4;
      v16 = 1;
      do
      {
        if ( !v17 )
          break;
        v16 = *(_BYTE *)v19++ == **(_BYTE **)v18;
        ++*(_DWORD *)v18;
        --v17;
      }
      while ( v16 );
    }
    while ( !v16 );
  }
  return v29;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (100058D0) --------------------------------------------------------
int __cdecl sub_100058D0(int a1, int a2)
{
  char v2; // zf@1
  int v3; // eax@1
  signed int v4; // ecx@1
  char v5[4]; // edi@1
  int v6; // esi@1
  int v7; // esi@6
  char *v8; // eax@7
  int v9; // edx@9
  char v10; // cl@10
  char *v11; // eax@12
  int v12; // edx@14
  char v13; // cl@15
  char *v14; // eax@17
  int v15; // edx@19
  char v16; // cl@20
  char *v17; // eax@22
  char *v18; // eax@25
  char *v19; // eax@28
  char *v20; // eax@31
  char *v21; // eax@34
  char *v22; // eax@37
  char *v23; // eax@40
  char *v24; // eax@43
  char *v25; // eax@46
  char *v26; // eax@49
  char *v27; // eax@52
  char *v28; // eax@55
  char v29; // zf@58
  signed int v30; // ecx@58
  char v31[4]; // edi@58
  int v32; // esi@58
  int v34; // [sp+Ch] [bp-48h]@5
  int v35; // [sp+10h] [bp-44h]@5
  int v36; // [sp+14h] [bp-40h]@5
  int v37; // [sp+18h] [bp-3Ch]@5
  int v38; // [sp+1Ch] [bp-38h]@5
  int v39; // [sp+20h] [bp-34h]@5
  int v40; // [sp+24h] [bp-30h]@5
  int v41; // [sp+28h] [bp-2Ch]@5
  int v42; // [sp+2Ch] [bp-28h]@5
  int v43; // [sp+30h] [bp-24h]@5
  int v44; // [sp+34h] [bp-20h]@5
  int v45; // [sp+38h] [bp-1Ch]@5
  int v46; // [sp+3Ch] [bp-18h]@5
  int v47; // [sp+40h] [bp-14h]@5
  char v48[4]; // [sp+44h] [bp-10h]@1
  int v49; // [sp+48h] [bp-Ch]@6
  int v50; // [sp+4Ch] [bp-8h]@5
  char *v51; // [sp+50h] [bp-4h]@6

  v3 = (int)"mom_kin_4th_axis_plane";
  *(_DWORD *)v5 = "END";
  v6 = (int)"mom_kin_4th_axis_plane";
  v4 = 23;
  v2 = 1;
  *(_DWORD *)v48 = "END";
  do
  {
    if ( !v4 )
      break;
    v2 = *(_BYTE *)v6++ == **(_BYTE **)v5;
    ++*(_DWORD *)v5;
    --v4;
  }
  while ( v2 );
  v34 = (int)"mom_kin_4th_axis_direction";
  v35 = (int)"mom_kin_4th_axis_rotation";
  v36 = (int)"mom_kin_4th_axis_min_incr";
  v37 = (int)"mom_kin_4th_axis_min_limit";
  v38 = (int)"mom_kin_4th_axis_max_limit";
  v39 = (int)"mom_kin_4th_axis_zero";
  v40 = (int)"mom_kin_4th_axis_center_offset_x";
  v41 = (int)"mom_kin_4th_axis_center_offset_y";
  v42 = (int)"mom_kin_4th_axis_center_offset_z";
  v43 = (int)"mom_kin_4th_axis_vector_i";
  v44 = (int)"mom_kin_4th_axis_vector_j";
  v45 = (int)"mom_kin_4th_axis_vector_k";
  v46 = (int)"mom_kin_4th_axis_angles_a1";
  v47 = (int)"mom_kin_4th_axis_angles_a2";
  v50 = 0;
  if ( !v2 )
  {
    do
    {
      v7 = v50;
      v49 = UF_MOM_ask_string(a1, v3 + 4, &v51);
      switch ( v50 )
      {
        case 0:
          v8 = v51;
          if ( !v51 )
          {
            v8 = "YZ";
            v51 = "YZ";
          }
          v9 = a2 - (_DWORD)v8;
          do
          {
            v10 = *v8;
            v8[v9] = *v8;
            ++v8;
          }
          while ( v10 );
          break;
        case 1:
          v11 = v51;
          if ( !v51 )
          {
            v11 = "MAGNITUDE_DETERMINES_DIRECTION";
            v51 = "MAGNITUDE_DETERMINES_DIRECTION";
          }
          v12 = a2 - (_DWORD)v11 + 133;
          do
          {
            v13 = *v11;
            v11[v12] = *v11;
            ++v11;
          }
          while ( v13 );
          break;
        case 2:
          v14 = v51;
          if ( !v51 )
          {
            v14 = "STANDARD";
            v51 = "STANDARD";
          }
          v15 = a2 - (_DWORD)v14 + 266;
          do
          {
            v16 = *v14;
            v14[v15] = *v14;
            ++v14;
          }
          while ( v16 );
          break;
        case 3:
          v17 = v51;
          if ( !v51 )
          {
            v17 = "0.001";
            v51 = "0.001";
          }
          *(double *)(a2 + 400) = strtod(v17, 0);
          break;
        case 4:
          v18 = v51;
          if ( !v51 )
          {
            v18 = "0.0";
            v51 = "0.0";
          }
          *(double *)(a2 + 408) = strtod(v18, 0);
          break;
        case 5:
          v19 = v51;
          if ( !v51 )
          {
            v19 = "360.0";
            v51 = "360.0";
          }
          *(double *)(a2 + 416) = strtod(v19, 0);
          break;
        case 6:
          v20 = v51;
          if ( !v51 )
          {
            v20 = "0.0";
            v51 = "0.0";
          }
          *(double *)(a2 + 424) = strtod(v20, 0);
          break;
        case 7:
          v21 = v51;
          if ( !v51 )
          {
            v21 = "0.0";
            v51 = "0.0";
          }
          *(double *)(a2 + 432) = strtod(v21, 0);
          break;
        case 8:
          v22 = v51;
          if ( !v51 )
          {
            v22 = "0.0";
            v51 = "0.0";
          }
          *(double *)(a2 + 440) = strtod(v22, 0);
          break;
        case 9:
          v23 = v51;
          if ( !v51 )
          {
            v23 = "0.0";
            v51 = "0.0";
          }
          *(double *)(a2 + 448) = strtod(v23, 0);
          break;
        case 10:
          v24 = v51;
          if ( !v51 )
          {
            v24 = "0.0";
            v51 = "0.0";
          }
          *(double *)(a2 + 456) = strtod(v24, 0);
          break;
        case 11:
          v25 = v51;
          if ( !v51 )
          {
            v25 = "0.0";
            v51 = "0.0";
          }
          *(double *)(a2 + 464) = strtod(v25, 0);
          break;
        case 12:
          v26 = v51;
          if ( !v51 )
          {
            v26 = "0.0";
            v51 = "0.0";
          }
          *(double *)(a2 + 472) = strtod(v26, 0);
          break;
        case 13:
          v27 = v51;
          if ( !v51 )
          {
            v27 = "0.0";
            v51 = "0.0";
          }
          *(double *)(a2 + 480) = strtod(v27, 0);
          break;
        case 14:
          v28 = v51;
          if ( !v51 )
          {
            v28 = "0.0";
            v51 = "0.0";
          }
          *(double *)(a2 + 488) = strtod(v28, 0);
          break;
        default:
          break;
      }
      v3 = *(&v34 + v7);
      v50 = v7 + 1;
      *(_DWORD *)v31 = "END";
      v32 = v3;
      v30 = 4;
      v29 = 1;
      do
      {
        if ( !v30 )
          break;
        v29 = *(_BYTE *)v32++ == **(_BYTE **)v31;
        ++*(_DWORD *)v31;
        --v30;
      }
      while ( v29 );
    }
    while ( !v29 );
  }
  return v49;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10005C10) --------------------------------------------------------
int __cdecl sub_10005C10(int a1, int a2)
{
  char v2; // zf@1
  int v3; // eax@1
  signed int v4; // ecx@1
  char v5[4]; // edi@1
  int v6; // esi@1
  int v7; // esi@6
  char *v8; // eax@7
  int v9; // edx@9
  char v10; // cl@10
  char *v11; // eax@12
  int v12; // edx@14
  char v13; // cl@15
  char *v14; // eax@17
  int v15; // edx@19
  char v16; // cl@20
  char *v17; // eax@22
  char *v18; // eax@25
  char *v19; // eax@28
  char *v20; // eax@31
  char *v21; // eax@34
  char *v22; // eax@37
  char *v23; // eax@40
  char *v24; // eax@43
  char *v25; // eax@46
  char *v26; // eax@49
  char *v27; // eax@52
  char *v28; // eax@55
  char v29; // zf@58
  signed int v30; // ecx@58
  char v31[4]; // edi@58
  int v32; // esi@58
  int v34; // [sp+Ch] [bp-48h]@5
  int v35; // [sp+10h] [bp-44h]@5
  int v36; // [sp+14h] [bp-40h]@5
  int v37; // [sp+18h] [bp-3Ch]@5
  int v38; // [sp+1Ch] [bp-38h]@5
  int v39; // [sp+20h] [bp-34h]@5
  int v40; // [sp+24h] [bp-30h]@5
  int v41; // [sp+28h] [bp-2Ch]@5
  int v42; // [sp+2Ch] [bp-28h]@5
  int v43; // [sp+30h] [bp-24h]@5
  int v44; // [sp+34h] [bp-20h]@5
  int v45; // [sp+38h] [bp-1Ch]@5
  int v46; // [sp+3Ch] [bp-18h]@5
  int v47; // [sp+40h] [bp-14h]@5
  char v48[4]; // [sp+44h] [bp-10h]@1
  int v49; // [sp+48h] [bp-Ch]@6
  int v50; // [sp+4Ch] [bp-8h]@5
  char *v51; // [sp+50h] [bp-4h]@6

  v3 = (int)"mom_kin_5th_axis_plane";
  *(_DWORD *)v5 = "END";
  v6 = (int)"mom_kin_5th_axis_plane";
  v4 = 23;
  v2 = 1;
  *(_DWORD *)v48 = "END";
  do
  {
    if ( !v4 )
      break;
    v2 = *(_BYTE *)v6++ == **(_BYTE **)v5;
    ++*(_DWORD *)v5;
    --v4;
  }
  while ( v2 );
  v34 = (int)"mom_kin_5th_axis_direction";
  v35 = (int)"mom_kin_5th_axis_rotation";
  v36 = (int)"mom_kin_5th_axis_min_incr";
  v37 = (int)"mom_kin_5th_axis_min_limit";
  v38 = (int)"mom_kin_5th_axis_max_limit";
  v39 = (int)"mom_kin_5th_axis_zero";
  v40 = (int)"mom_kin_5th_axis_center_offset_x";
  v41 = (int)"mom_kin_5th_axis_center_offset_y";
  v42 = (int)"mom_kin_5th_axis_center_offset_z";
  v43 = (int)"mom_kin_5th_axis_vector_i";
  v44 = (int)"mom_kin_5th_axis_vector_j";
  v45 = (int)"mom_kin_5th_axis_vector_k";
  v46 = (int)"mom_kin_5th_axis_angles_a1";
  v47 = (int)"mom_kin_5th_axis_angles_a2";
  v50 = 0;
  if ( !v2 )
  {
    do
    {
      v7 = v50;
      v49 = UF_MOM_ask_string(a1, v3 + 4, &v51);
      switch ( v50 )
      {
        case 0:
          v8 = v51;
          if ( !v51 )
          {
            v8 = "YZ";
            v51 = "YZ";
          }
          v9 = a2 - (_DWORD)v8;
          do
          {
            v10 = *v8;
            v8[v9] = *v8;
            ++v8;
          }
          while ( v10 );
          break;
        case 1:
          v11 = v51;
          if ( !v51 )
          {
            v11 = "MAGNITUDE_DETERMINES_DIRECTION";
            v51 = "MAGNITUDE_DETERMINES_DIRECTION";
          }
          v12 = a2 - (_DWORD)v11 + 133;
          do
          {
            v13 = *v11;
            v11[v12] = *v11;
            ++v11;
          }
          while ( v13 );
          break;
        case 2:
          v14 = v51;
          if ( !v51 )
          {
            v14 = "STANDARD";
            v51 = "STANDARD";
          }
          v15 = a2 - (_DWORD)v14 + 266;
          do
          {
            v16 = *v14;
            v14[v15] = *v14;
            ++v14;
          }
          while ( v16 );
          break;
        case 3:
          v17 = v51;
          if ( !v51 )
          {
            v17 = "0.001";
            v51 = "0.001";
          }
          *(double *)(a2 + 400) = strtod(v17, 0);
          break;
        case 4:
          v18 = v51;
          if ( !v51 )
          {
            v18 = "0.0";
            v51 = "0.0";
          }
          *(double *)(a2 + 408) = strtod(v18, 0);
          break;
        case 5:
          v19 = v51;
          if ( !v51 )
          {
            v19 = "360.0";
            v51 = "360.0";
          }
          *(double *)(a2 + 416) = strtod(v19, 0);
          break;
        case 6:
          v20 = v51;
          if ( !v51 )
          {
            v20 = "0.0";
            v51 = "0.0";
          }
          *(double *)(a2 + 424) = strtod(v20, 0);
          break;
        case 7:
          v21 = v51;
          if ( !v51 )
          {
            v21 = "0.0";
            v51 = "0.0";
          }
          *(double *)(a2 + 432) = strtod(v21, 0);
          break;
        case 8:
          v22 = v51;
          if ( !v51 )
          {
            v22 = "0.0";
            v51 = "0.0";
          }
          *(double *)(a2 + 440) = strtod(v22, 0);
          break;
        case 9:
          v23 = v51;
          if ( !v51 )
          {
            v23 = "0.0";
            v51 = "0.0";
          }
          *(double *)(a2 + 448) = strtod(v23, 0);
          break;
        case 10:
          v24 = v51;
          if ( !v51 )
          {
            v24 = "0.0";
            v51 = "0.0";
          }
          *(double *)(a2 + 456) = strtod(v24, 0);
          break;
        case 11:
          v25 = v51;
          if ( !v51 )
          {
            v25 = "0.0";
            v51 = "0.0";
          }
          *(double *)(a2 + 464) = strtod(v25, 0);
          break;
        case 12:
          v26 = v51;
          if ( !v51 )
          {
            v26 = "0.0";
            v51 = "0.0";
          }
          *(double *)(a2 + 472) = strtod(v26, 0);
          break;
        case 13:
          v27 = v51;
          if ( !v51 )
          {
            v27 = "0.0";
            v51 = "0.0";
          }
          *(double *)(a2 + 480) = strtod(v27, 0);
          break;
        case 14:
          v28 = v51;
          if ( !v51 )
          {
            v28 = "0.0";
            v51 = "0.0";
          }
          *(double *)(a2 + 488) = strtod(v28, 0);
          break;
        default:
          break;
      }
      v3 = *(&v34 + v7);
      v50 = v7 + 1;
      *(_DWORD *)v31 = "END";
      v32 = v3;
      v30 = 4;
      v29 = 1;
      do
      {
        if ( !v30 )
          break;
        v29 = *(_BYTE *)v32++ == **(_BYTE **)v31;
        ++*(_DWORD *)v31;
        --v30;
      }
      while ( v29 );
    }
    while ( !v29 );
  }
  return v49;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10005F50) --------------------------------------------------------
int __cdecl sub_10005F50(int a1, int a2)
{
  char v2; // zf@1
  int v3; // eax@1
  signed int v4; // ecx@1
  int v5; // ebx@1
  char v6[4]; // edi@1
  int v7; // esi@1
  char *v8; // eax@9
  char *v9; // eax@12
  char *v10; // eax@15
  int v11; // edx@17
  char v12; // cl@18
  char v13; // zf@19
  signed int v14; // ecx@19
  char v15[4]; // edi@19
  int v16; // esi@19
  int v18; // [sp+10h] [bp-14h]@5
  int v19; // [sp+14h] [bp-10h]@5
  char v20[4]; // [sp+18h] [bp-Ch]@1
  int v21; // [sp+1Ch] [bp-8h]@6
  char *v22; // [sp+20h] [bp-4h]@6

  v3 = (int)"mom_kin_independent_head";
  *(_DWORD *)v6 = "END";
  v5 = 0;
  v7 = (int)"mom_kin_independent_head";
  v4 = 25;
  v2 = 1;
  *(_DWORD *)v20 = "END";
  do
  {
    if ( !v4 )
      break;
    v2 = *(_BYTE *)v7++ == **(_BYTE **)v6;
    ++*(_DWORD *)v6;
    --v4;
  }
  while ( v2 );
  v18 = (int)"mom_kin_ind_to_dependent_head_x";
  v19 = (int)"mom_kin_ind_to_dependent_head_z";
  if ( !v2 )
  {
    do
    {
      v21 = UF_MOM_ask_string(a1, v3 + 4, &v22);
      if ( v5 )
      {
        if ( v5 == 1 )
        {
          v9 = v22;
          if ( !v22 )
          {
            v9 = "0.0";
            v22 = "0.0";
          }
          *(double *)(a2 + 136) = strtod(v9, 0);
        }
        else
        {
          if ( v5 == 2 )
          {
            v8 = v22;
            if ( !v22 )
            {
              v8 = "0.0";
              v22 = "0.0";
            }
            *(double *)(a2 + 144) = strtod(v8, 0);
          }
        }
      }
      else
      {
        v10 = v22;
        if ( !v22 )
        {
          v10 = "FRONT";
          v22 = "FRONT";
        }
        v11 = a2 - (_DWORD)v10;
        do
        {
          v12 = *v10;
          v10[v11] = *v10;
          ++v10;
        }
        while ( v12 );
      }
      v3 = *(&v18 + v5++);
      *(_DWORD *)v15 = "END";
      v16 = v3;
      v14 = 4;
      v13 = 1;
      do
      {
        if ( !v14 )
          break;
        v13 = *(_BYTE *)v16++ == **(_BYTE **)v15;
        ++*(_DWORD *)v15;
        --v14;
      }
      while ( v13 );
    }
    while ( !v13 );
  }
  return v21;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10006060) --------------------------------------------------------
int __cdecl sub_10006060(int a1, int a2)
{
  char v2; // zf@1
  int v3; // eax@1
  signed int v4; // ecx@1
  int v5; // ebx@1
  char v6[4]; // edi@1
  int v7; // esi@1
  char *v8; // eax@9
  char *v9; // eax@12
  char *v10; // eax@15
  char v11; // zf@18
  signed int v12; // ecx@18
  char v13[4]; // edi@18
  int v14; // esi@18
  int v16; // [sp+10h] [bp-14h]@5
  int v17; // [sp+14h] [bp-10h]@5
  char v18[4]; // [sp+18h] [bp-Ch]@1
  int v19; // [sp+1Ch] [bp-8h]@6
  char *v20; // [sp+20h] [bp-4h]@6

  v3 = (int)"mom_kin_tool_change_time";
  *(_DWORD *)v6 = "END";
  v5 = 0;
  v7 = (int)"mom_kin_tool_change_time";
  v4 = 25;
  v2 = 1;
  *(_DWORD *)v18 = "END";
  do
  {
    if ( !v4 )
      break;
    v2 = *(_BYTE *)v7++ == **(_BYTE **)v6;
    ++*(_DWORD *)v6;
    --v4;
  }
  while ( v2 );
  v16 = (int)"mom_kin_clamp_time";
  v17 = (int)"mom_kin_flush_time";
  if ( !v2 )
  {
    do
    {
      v19 = UF_MOM_ask_string(a1, v3 + 4, &v20);
      if ( v5 )
      {
        if ( v5 == 1 )
        {
          v9 = v20;
          if ( !v20 )
          {
            v9 = "0.5";
            v20 = "0.5";
          }
          *(double *)(a2 + 8) = strtod(v9, 0);
        }
        else
        {
          if ( v5 == 2 )
          {
            v8 = v20;
            if ( !v20 )
            {
              v8 = "0.5";
              v20 = "0.5";
            }
            *(double *)(a2 + 16) = strtod(v8, 0);
          }
        }
      }
      else
      {
        v10 = v20;
        if ( !v20 )
        {
          v10 = "3.0";
          v20 = "3.0";
        }
        *(double *)a2 = strtod(v10, 0);
      }
      v3 = *(&v16 + v5++);
      *(_DWORD *)v13 = "END";
      v14 = v3;
      v12 = 4;
      v11 = 1;
      do
      {
        if ( !v12 )
          break;
        v11 = *(_BYTE *)v14++ == **(_BYTE **)v13;
        ++*(_DWORD *)v13;
        --v12;
      }
      while ( v11 );
    }
    while ( !v11 );
  }
  return v19;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10006150) --------------------------------------------------------
int __cdecl sub_10006150(int a1, int a2)
{
  char v2; // zf@1
  int v3; // eax@1
  signed int v4; // ecx@1
  char v5[4]; // edi@1
  int v6; // esi@1
  char *v7; // eax@7
  int v8; // edx@9
  char v9; // cl@10
  char *v10; // eax@12
  int v11; // edx@14
  char v12; // cl@15
  char *v13; // eax@17
  int v14; // edx@19
  char v15; // cl@20
  char *v16; // eax@22
  int v17; // edx@24
  char v18; // cl@25
  char *v19; // eax@27
  int v20; // edx@29
  char v21; // cl@30
  char *v22; // eax@32
  int v23; // edx@34
  char v24; // cl@35
  char *v25; // eax@37
  char *v26; // eax@40
  char *v27; // eax@43
  char *v28; // eax@46
  char *v29; // eax@49
  char *v30; // eax@52
  char *v31; // eax@55
  char *v32; // eax@58
  char *v33; // eax@61
  char *v34; // eax@64
  char *v35; // eax@67
  char *v36; // eax@70
  char *v37; // eax@73
  char *v38; // eax@76
  char *v39; // eax@79
  char *v40; // eax@82
  char *v41; // eax@85
  char *v42; // eax@88
  char v43; // zf@91
  signed int v44; // ecx@91
  char v45[4]; // edi@91
  int v46; // esi@91
  int v47; // eax@91
  int v49; // [sp+8h] [bp-70h]@5
  int v50; // [sp+Ch] [bp-6Ch]@5
  int v51; // [sp+10h] [bp-68h]@5
  int v52; // [sp+14h] [bp-64h]@5
  int v53; // [sp+18h] [bp-60h]@5
  int v54; // [sp+1Ch] [bp-5Ch]@5
  int v55; // [sp+20h] [bp-58h]@5
  int v56; // [sp+24h] [bp-54h]@5
  int v57; // [sp+28h] [bp-50h]@5
  int v58; // [sp+2Ch] [bp-4Ch]@5
  int v59; // [sp+30h] [bp-48h]@5
  int v60; // [sp+34h] [bp-44h]@5
  int v61; // [sp+38h] [bp-40h]@5
  int v62; // [sp+3Ch] [bp-3Ch]@5
  int v63; // [sp+40h] [bp-38h]@5
  int v64; // [sp+44h] [bp-34h]@5
  int v65; // [sp+48h] [bp-30h]@5
  int v66; // [sp+4Ch] [bp-2Ch]@5
  int v67; // [sp+50h] [bp-28h]@5
  int v68; // [sp+54h] [bp-24h]@5
  int v69; // [sp+58h] [bp-20h]@5
  int v70; // [sp+5Ch] [bp-1Ch]@5
  int v71; // [sp+60h] [bp-18h]@5
  int v72; // [sp+64h] [bp-14h]@5
  char v73[4]; // [sp+68h] [bp-10h]@1
  int v74; // [sp+6Ch] [bp-Ch]@6
  int v75; // [sp+70h] [bp-8h]@5
  char *v76; // [sp+74h] [bp-4h]@6

  v3 = (int)"mom_kin_holder1_orientation";
  *(_DWORD *)v5 = "END";
  v6 = (int)"mom_kin_holder1_orientation";
  v4 = 28;
  v2 = 1;
  *(_DWORD *)v73 = "END";
  do
  {
    if ( !v4 )
      break;
    v2 = *(_BYTE *)v6++ == **(_BYTE **)v5;
    ++*(_DWORD *)v5;
    --v4;
  }
  while ( v2 );
  v49 = (int)"mom_kin_holder1_orientation";
  v50 = (int)"mom_kin_holder2_orientation";
  v51 = (int)"mom_kin_holder3_orientation";
  v52 = (int)"mom_kin_holder4_orientation";
  v53 = (int)"mom_kin_holder5_orientation";
  v54 = (int)"mom_kin_holder6_orientation";
  v55 = (int)"mom_kin_holder1_offset_x";
  v56 = (int)"mom_kin_holder1_offset_y";
  v57 = (int)"mom_kin_holder1_offset_z";
  v58 = (int)"mom_kin_holder2_offset_x";
  v59 = (int)"mom_kin_holder2_offset_y";
  v60 = (int)"mom_kin_holder2_offset_z";
  v61 = (int)"mom_kin_holder3_offset_x";
  v62 = (int)"mom_kin_holder3_offset_y";
  v63 = (int)"mom_kin_holder3_offset_z";
  v64 = (int)"mom_kin_holder4_offset_x";
  v65 = (int)"mom_kin_holder4_offset_y";
  v66 = (int)"mom_kin_holder4_offset_z";
  v67 = (int)"mom_kin_holder5_offset_x";
  v68 = (int)"mom_kin_holder5_offset_y";
  v69 = (int)"mom_kin_holder5_offset_z";
  v70 = (int)"mom_kin_holder6_offset_x";
  v71 = (int)"mom_kin_holder6_offset_y";
  v72 = (int)"mom_kin_holder6_offset_z";
  v75 = 0;
  if ( !v2 )
  {
    do
    {
      v74 = UF_MOM_ask_string(a1, v3 + 4, &v76);
      switch ( v75 )
      {
        case 0:
          v7 = v76;
          if ( !v76 )
          {
            v7 = "POSZ";
            v76 = "POSZ";
          }
          v8 = a2 - (_DWORD)v7;
          do
          {
            v9 = *v7;
            v7[v8] = *v7;
            ++v7;
          }
          while ( v9 );
          break;
        case 1:
          v10 = v76;
          if ( !v76 )
          {
            v10 = "POSZ";
            v76 = "POSZ";
          }
          v11 = a2 - (_DWORD)v10 + 133;
          do
          {
            v12 = *v10;
            v10[v11] = *v10;
            ++v10;
          }
          while ( v12 );
          break;
        case 2:
          v13 = v76;
          if ( !v76 )
          {
            v13 = "POSZ";
            v76 = "POSZ";
          }
          v14 = a2 - (_DWORD)v13 + 266;
          do
          {
            v15 = *v13;
            v13[v14] = *v13;
            ++v13;
          }
          while ( v15 );
          break;
        case 3:
          v16 = v76;
          if ( !v76 )
          {
            v16 = "POSZ";
            v76 = "POSZ";
          }
          v17 = a2 - (_DWORD)v16 + 399;
          do
          {
            v18 = *v16;
            v16[v17] = *v16;
            ++v16;
          }
          while ( v18 );
          break;
        case 4:
          v19 = v76;
          if ( !v76 )
          {
            v19 = "POSZ";
            v76 = "POSZ";
          }
          v20 = a2 - (_DWORD)v19 + 532;
          do
          {
            v21 = *v19;
            v19[v20] = *v19;
            ++v19;
          }
          while ( v21 );
          break;
        case 5:
          v22 = v76;
          if ( !v76 )
          {
            v22 = "POSZ";
            v76 = "POSZ";
          }
          v23 = a2 - (_DWORD)v22 + 665;
          do
          {
            v24 = *v22;
            v22[v23] = *v22;
            ++v22;
          }
          while ( v24 );
          break;
        case 6:
          v25 = v76;
          if ( !v76 )
          {
            v25 = "0.0";
            v76 = "0.0";
          }
          *(double *)(a2 + 800) = strtod(v25, 0);
          break;
        case 7:
          v26 = v76;
          if ( !v76 )
          {
            v26 = "0.0";
            v76 = "0.0";
          }
          *(double *)(a2 + 808) = strtod(v26, 0);
          break;
        case 8:
          v27 = v76;
          if ( !v76 )
          {
            v27 = "0.0";
            v76 = "0.0";
          }
          *(double *)(a2 + 816) = strtod(v27, 0);
          break;
        case 9:
          v28 = v76;
          if ( !v76 )
          {
            v28 = "0.0";
            v76 = "0.0";
          }
          *(double *)(a2 + 824) = strtod(v28, 0);
          break;
        case 10:
          v29 = v76;
          if ( !v76 )
          {
            v29 = "0.0";
            v76 = "0.0";
          }
          *(double *)(a2 + 832) = strtod(v29, 0);
          break;
        case 11:
          v30 = v76;
          if ( !v76 )
          {
            v30 = "0.0";
            v76 = "0.0";
          }
          *(double *)(a2 + 840) = strtod(v30, 0);
          break;
        case 12:
          v31 = v76;
          if ( !v76 )
          {
            v31 = "0.0";
            v76 = "0.0";
          }
          *(double *)(a2 + 848) = strtod(v31, 0);
          break;
        case 13:
          v32 = v76;
          if ( !v76 )
          {
            v32 = "0.0";
            v76 = "0.0";
          }
          *(double *)(a2 + 856) = strtod(v32, 0);
          break;
        case 14:
          v33 = v76;
          if ( !v76 )
          {
            v33 = "0.0";
            v76 = "0.0";
          }
          *(double *)(a2 + 864) = strtod(v33, 0);
          break;
        case 15:
          v34 = v76;
          if ( !v76 )
          {
            v34 = "0.0";
            v76 = "0.0";
          }
          *(double *)(a2 + 872) = strtod(v34, 0);
          break;
        case 16:
          v35 = v76;
          if ( !v76 )
          {
            v35 = "0.0";
            v76 = "0.0";
          }
          *(double *)(a2 + 880) = strtod(v35, 0);
          break;
        case 17:
          v36 = v76;
          if ( !v76 )
          {
            v36 = "0.0";
            v76 = "0.0";
          }
          *(double *)(a2 + 888) = strtod(v36, 0);
          break;
        case 18:
          v37 = v76;
          if ( !v76 )
          {
            v37 = "0.0";
            v76 = "0.0";
          }
          *(double *)(a2 + 896) = strtod(v37, 0);
          break;
        case 19:
          v38 = v76;
          if ( !v76 )
          {
            v38 = "0.0";
            v76 = "0.0";
          }
          *(double *)(a2 + 904) = strtod(v38, 0);
          break;
        case 20:
          v39 = v76;
          if ( !v76 )
          {
            v39 = "0.0";
            v76 = "0.0";
          }
          *(double *)(a2 + 912) = strtod(v39, 0);
          break;
        case 21:
          v40 = v76;
          if ( !v76 )
          {
            v40 = "0.0";
            v76 = "0.0";
          }
          *(double *)(a2 + 920) = strtod(v40, 0);
          break;
        case 22:
          v41 = v76;
          if ( !v76 )
          {
            v41 = "0.0";
            v76 = "0.0";
          }
          *(double *)(a2 + 928) = strtod(v41, 0);
          break;
        case 23:
          v42 = v76;
          if ( !v76 )
          {
            v42 = "0.0";
            v76 = "0.0";
          }
          *(double *)(a2 + 936) = strtod(v42, 0);
          break;
        default:
          break;
      }
      v47 = v75 + 1;
      v75 = v47;
      v3 = *(&v49 + v47);
      *(_DWORD *)v45 = "END";
      v46 = v3;
      v44 = 4;
      v43 = 1;
      do
      {
        if ( !v44 )
          break;
        v43 = *(_BYTE *)v46++ == **(_BYTE **)v45;
        ++*(_DWORD *)v45;
        --v44;
      }
      while ( v43 );
    }
    while ( !v43 );
  }
  return v74;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10006660) --------------------------------------------------------
int __cdecl sub_10006660(int a1, int a2)
{
  char v2; // zf@1
  signed int v3; // ecx@1
  char v4[4]; // edi@1
  int v5; // esi@1
  int v6; // eax@6
  char *v7; // eax@8
  int v8; // edx@10
  char v9; // cl@11
  char *v10; // eax@13
  int v11; // edx@15
  char v12; // cl@16
  char *v13; // eax@18
  int v14; // edx@20
  char v15; // cl@21
  char *v16; // eax@23
  int v17; // edx@25
  char v18; // cl@26
  char *v19; // eax@28
  int v20; // edx@30
  char v21; // cl@31
  char *v22; // eax@33
  int v23; // edx@35
  char v24; // cl@36
  char *v25; // eax@38
  char *v26; // eax@41
  char *v27; // eax@44
  char *v28; // eax@47
  char *v29; // ecx@50
  int v30; // eax@51
  char *v31; // ecx@55
  int v32; // eax@56
  char *v33; // ecx@60
  int v34; // eax@61
  char v35; // zf@65
  signed int v36; // ecx@65
  char v37[4]; // edi@65
  int v38; // esi@65
  int v39; // eax@65
  char v41; // [sp+8h] [bp-98h]@56
  char v42; // [sp+24h] [bp-7Ch]@61
  char v43; // [sp+40h] [bp-60h]@51
  int v44; // [sp+5Ch] [bp-44h]@5
  int v45; // [sp+60h] [bp-40h]@5
  int v46; // [sp+64h] [bp-3Ch]@5
  int v47; // [sp+68h] [bp-38h]@5
  int v48; // [sp+6Ch] [bp-34h]@5
  int v49; // [sp+70h] [bp-30h]@5
  int v50; // [sp+74h] [bp-2Ch]@5
  int v51; // [sp+78h] [bp-28h]@5
  int v52; // [sp+7Ch] [bp-24h]@5
  int v53; // [sp+80h] [bp-20h]@5
  int v54; // [sp+84h] [bp-1Ch]@1
  int v55; // [sp+88h] [bp-18h]@5
  int v56; // [sp+8Ch] [bp-14h]@1
  char v57[4]; // [sp+90h] [bp-10h]@1
  int v58; // [sp+94h] [bp-Ch]@7
  int v59; // [sp+98h] [bp-8h]@5
  char *v60; // [sp+9Ch] [bp-4h]@7

  *(_DWORD *)v4 = "END";
  v54 = (int)"mom_kin_gauge_to_pivot_x";
  v56 = (int)"mom_kin_gauge_to_pivot_x";
  v5 = (int)"mom_kin_machine_type";
  v3 = 21;
  v2 = 1;
  *(_DWORD *)v57 = "END";
  do
  {
    if ( !v3 )
      break;
    v2 = *(_BYTE *)v5++ == **(_BYTE **)v4;
    ++*(_DWORD *)v4;
    --v3;
  }
  while ( v2 );
  v44 = (int)"mom_kin_machine_type";
  v45 = (int)"mom_kin_track_center_of_ball";
  v46 = (int)"mom_kin_wire_tilt_output_type";
  v47 = (int)"mom_kin_clsf_generation";
  v48 = (int)"mom_kin_coordinate_type";
  v49 = (int)"mom_kin_linearization_flag";
  v50 = (int)"mom_kin_machine_resolution";
  v51 = (int)"mom_kin_tool_tracking_height";
  v52 = (int)"mom_kin_5th_axis_inclination_to_4th";
  v53 = (int)"mom_kin_linearization_tol";
  v55 = (int)"mom_kin_gauge_to_pivot_y";
  v59 = 0;
  if ( !v2 )
  {
    v6 = (int)"mom_kin_machine_type";
    do
    {
      v58 = UF_MOM_ask_string(a1, v6 + 4, &v60);
      switch ( v59 )
      {
        case 0:
          v7 = v60;
          if ( !v60 )
          {
            v7 = "3_axis_mill";
            v60 = "3_axis_mill";
          }
          v8 = a2 - (_DWORD)v7;
          do
          {
            v9 = *v7;
            v7[v8] = *v7;
            ++v7;
          }
          while ( v9 );
          break;
        case 1:
          v10 = v60;
          if ( !v60 )
          {
            v10 = (char *)L"T";
            v60 = (char *)L"T";
          }
          v11 = a2 - (_DWORD)v10 + 133;
          do
          {
            v12 = *v10;
            v10[v11] = *v10;
            ++v10;
          }
          while ( v12 );
          break;
        case 2:
          v13 = v60;
          if ( !v60 )
          {
            v13 = "NONE";
            v60 = "NONE";
          }
          v14 = a2 - (_DWORD)v13 + 266;
          do
          {
            v15 = *v13;
            v13[v14] = *v13;
            ++v13;
          }
          while ( v15 );
          break;
        case 3:
          v16 = v60;
          if ( !v60 )
          {
            v16 = (char *)L"F";
            v60 = (char *)L"F";
          }
          v17 = a2 - (_DWORD)v16 + 399;
          do
          {
            v18 = *v16;
            v16[v17] = *v16;
            ++v16;
          }
          while ( v18 );
          break;
        case 4:
          v19 = v60;
          if ( !v60 )
          {
            v19 = "CARTESIAN";
            v60 = "CARTESIAN";
          }
          v20 = a2 - (_DWORD)v19 + 532;
          do
          {
            v21 = *v19;
            v19[v20] = *v19;
            ++v19;
          }
          while ( v21 );
          break;
        case 5:
          v22 = v60;
          if ( !v60 )
          {
            v22 = (char *)L"F";
            v60 = (char *)L"F";
          }
          v23 = a2 - (_DWORD)v22 + 665;
          do
          {
            v24 = *v22;
            v22[v23] = *v22;
            ++v22;
          }
          while ( v24 );
          break;
        case 6:
          v25 = v60;
          if ( !v60 )
          {
            v25 = "0.0001";
            v60 = "0.0001";
          }
          *(double *)(a2 + 800) = strtod(v25, 0);
          break;
        case 7:
          v26 = v60;
          if ( !v60 )
          {
            v26 = "0.0";
            v60 = "0.0";
          }
          *(double *)(a2 + 808) = strtod(v26, 0);
          break;
        case 8:
          v27 = v60;
          if ( !v60 )
          {
            v27 = "90.0";
            v60 = "90.0";
          }
          *(double *)(a2 + 816) = strtod(v27, 0);
          break;
        case 9:
          v28 = v60;
          if ( !v60 )
          {
            v28 = "0.0001";
            v60 = "0.0001";
          }
          *(double *)(a2 + 824) = strtod(v28, 0);
          break;
        case 10:
          v29 = v60;
          if ( !v60 )
          {
            memcpy(&v43, "kin_4th_to_tracking_point_x", 0x1Cu);
            v30 = sub_100053F0((int)&v43, a1, 0);
            v29 = v60;
            if ( !v60 || v30 )
            {
              v29 = "0.0";
              v60 = "0.0";
            }
          }
          *(double *)(a2 + 832) = strtod(v29, 0);
          break;
        case 11:
          v31 = v60;
          if ( !v60 )
          {
            memcpy(&v41, "kin_4th_to_tracking_point_y", 0x1Cu);
            v32 = sub_100053F0((int)&v41, a1, 0);
            v31 = v60;
            if ( !v60 || v32 )
            {
              v31 = "0.0";
              v60 = "0.0";
            }
          }
          *(double *)(a2 + 840) = strtod(v31, 0);
          break;
        case 12:
          v33 = v60;
          if ( !v60 )
          {
            memcpy(&v42, "kin_4th_to_tracking_point_z", 0x1Cu);
            v34 = sub_100053F0((int)&v42, a1, 0);
            v33 = v60;
            if ( !v60 || v34 )
            {
              v33 = "0.0";
              v60 = "0.0";
            }
          }
          *(double *)(a2 + 848) = strtod(v33, 0);
          break;
        default:
          break;
      }
      v39 = v59 + 1;
      v59 = v39;
      v6 = *(&v44 + v39);
      *(_DWORD *)v37 = "END";
      v38 = v6;
      v36 = 4;
      v35 = 1;
      do
      {
        if ( !v36 )
          break;
        v35 = *(_BYTE *)v38++ == **(_BYTE **)v37;
        ++*(_DWORD *)v37;
        --v36;
      }
      while ( v35 );
    }
    while ( !v35 );
  }
  return v58;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);
// 10009F34: using guessed type wchar_t aF[2];
// 1000A868: using guessed type wchar_t aT[2];

//----- (10006A10) --------------------------------------------------------
int __cdecl sub_10006A10(int a1, int a2)
{
  char v2; // zf@1
  int v3; // eax@1
  signed int v4; // ecx@1
  char v5[4]; // edi@1
  int v6; // esi@1
  int v7; // esi@6
  char *v8; // eax@7
  char *v9; // eax@10
  char *v10; // eax@13
  char *v11; // eax@16
  char *v12; // eax@19
  char *v13; // eax@22
  char *v14; // eax@25
  char *v15; // eax@28
  char *v16; // eax@31
  char *v17; // eax@34
  char *v18; // eax@37
  char *v19; // eax@40
  char v20; // zf@43
  signed int v21; // ecx@43
  char v22[4]; // edi@43
  int v23; // esi@43
  int v25; // [sp+Ch] [bp-3Ch]@5
  int v26; // [sp+10h] [bp-38h]@5
  int v27; // [sp+14h] [bp-34h]@5
  int v28; // [sp+18h] [bp-30h]@5
  int v29; // [sp+1Ch] [bp-2Ch]@5
  int v30; // [sp+20h] [bp-28h]@5
  int v31; // [sp+24h] [bp-24h]@5
  int v32; // [sp+28h] [bp-20h]@5
  int v33; // [sp+2Ch] [bp-1Ch]@5
  int v34; // [sp+30h] [bp-18h]@5
  int v35; // [sp+34h] [bp-14h]@5
  char v36[4]; // [sp+38h] [bp-10h]@1
  int v37; // [sp+3Ch] [bp-Ch]@6
  int v38; // [sp+40h] [bp-8h]@5
  char *v39; // [sp+44h] [bp-4h]@6

  v3 = (int)"mom_msys_origin_x";
  *(_DWORD *)v5 = "END";
  v6 = (int)"mom_msys_origin_x";
  v4 = 18;
  v2 = 1;
  *(_DWORD *)v36 = "END";
  do
  {
    if ( !v4 )
      break;
    v2 = *(_BYTE *)v6++ == **(_BYTE **)v5;
    ++*(_DWORD *)v5;
    --v4;
  }
  while ( v2 );
  v25 = (int)"mom_msys_origin_y";
  v26 = (int)"mom_msys_origin_z";
  v27 = (int)"mom_msys_x_axis_i";
  v28 = (int)"mom_msys_x_axis_j";
  v29 = (int)"mom_msys_x_axis_k";
  v30 = (int)"mom_msys_y_axis_i";
  v31 = (int)"mom_msys_y_axis_j";
  v32 = (int)"mom_msys_y_axis_k";
  v33 = (int)"mom_msys_z_axis_i";
  v34 = (int)"mom_msys_z_axis_j";
  v35 = (int)"mom_msys_z_axis_k";
  v38 = 0;
  if ( !v2 )
  {
    do
    {
      v7 = v38;
      v37 = UF_MOM_ask_string(a1, v3 + 4, &v39);
      switch ( v38 )
      {
        case 0:
          v8 = v39;
          if ( !v39 )
          {
            v8 = "0.0";
            v39 = "0.0";
          }
          *(double *)a2 = strtod(v8, 0);
          break;
        case 1:
          v9 = v39;
          if ( !v39 )
          {
            v9 = "0.0";
            v39 = "0.0";
          }
          *(double *)(a2 + 8) = strtod(v9, 0);
          break;
        case 2:
          v10 = v39;
          if ( !v39 )
          {
            v10 = "0.0";
            v39 = "0.0";
          }
          *(double *)(a2 + 16) = strtod(v10, 0);
          break;
        case 3:
          v11 = v39;
          if ( !v39 )
          {
            v11 = "1.0";
            v39 = "1.0";
          }
          *(double *)(a2 + 24) = strtod(v11, 0);
          break;
        case 4:
          v12 = v39;
          if ( !v39 )
          {
            v12 = "0.0";
            v39 = "0.0";
          }
          *(double *)(a2 + 32) = strtod(v12, 0);
          break;
        case 5:
          v13 = v39;
          if ( !v39 )
          {
            v13 = "0.0";
            v39 = "0.0";
          }
          *(double *)(a2 + 40) = strtod(v13, 0);
          break;
        case 6:
          v14 = v39;
          if ( !v39 )
          {
            v14 = "0.0";
            v39 = "0.0";
          }
          *(double *)(a2 + 48) = strtod(v14, 0);
          break;
        case 7:
          v15 = v39;
          if ( !v39 )
          {
            v15 = "1.0";
            v39 = "1.0";
          }
          *(double *)(a2 + 56) = strtod(v15, 0);
          break;
        case 8:
          v16 = v39;
          if ( !v39 )
          {
            v16 = "0.0";
            v39 = "0.0";
          }
          *(double *)(a2 + 64) = strtod(v16, 0);
          break;
        case 9:
          v17 = v39;
          if ( !v39 )
          {
            v17 = "0.0";
            v39 = "0.0";
          }
          *(double *)(a2 + 72) = strtod(v17, 0);
          break;
        case 10:
          v18 = v39;
          if ( !v39 )
          {
            v18 = "0.0";
            v39 = "0.0";
          }
          *(double *)(a2 + 80) = strtod(v18, 0);
          break;
        case 11:
          v19 = v39;
          if ( !v39 )
          {
            v19 = "1.0";
            v39 = "1.0";
          }
          *(double *)(a2 + 88) = strtod(v19, 0);
          break;
        default:
          break;
      }
      v3 = *(&v25 + v7);
      v38 = v7 + 1;
      *(_DWORD *)v22 = "END";
      v23 = v3;
      v21 = 4;
      v20 = 1;
      do
      {
        if ( !v21 )
          break;
        v20 = *(_BYTE *)v23++ == **(_BYTE **)v22;
        ++*(_DWORD *)v22;
        --v21;
      }
      while ( v20 );
    }
    while ( !v20 );
  }
  return v37;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10006C90) --------------------------------------------------------
int __cdecl sub_10006C90(int a1, int a2)
{
  char v2; // zf@1
  int v3; // eax@1
  signed int v4; // ecx@1
  char v5[4]; // edi@1
  int v6; // esi@1
  int v7; // esi@6
  char *v8; // eax@7
  char *v9; // eax@10
  char *v10; // eax@13
  char *v11; // eax@16
  char *v12; // eax@19
  char *v13; // eax@22
  char *v14; // eax@25
  char *v15; // eax@28
  char *v16; // eax@31
  char *v17; // eax@34
  char *v18; // eax@37
  char *v19; // eax@40
  char v20; // zf@43
  signed int v21; // ecx@43
  char v22[4]; // edi@43
  int v23; // esi@43
  int v25; // [sp+Ch] [bp-3Ch]@5
  int v26; // [sp+10h] [bp-38h]@5
  int v27; // [sp+14h] [bp-34h]@5
  int v28; // [sp+18h] [bp-30h]@5
  int v29; // [sp+1Ch] [bp-2Ch]@5
  int v30; // [sp+20h] [bp-28h]@5
  int v31; // [sp+24h] [bp-24h]@5
  int v32; // [sp+28h] [bp-20h]@5
  int v33; // [sp+2Ch] [bp-1Ch]@5
  int v34; // [sp+30h] [bp-18h]@5
  int v35; // [sp+34h] [bp-14h]@5
  char v36[4]; // [sp+38h] [bp-10h]@1
  int v37; // [sp+3Ch] [bp-Ch]@6
  int v38; // [sp+40h] [bp-8h]@5
  char *v39; // [sp+44h] [bp-4h]@6

  v3 = (int)"mom_mtsys_origin_x";
  *(_DWORD *)v5 = "END";
  v6 = (int)"mom_mtsys_origin_x";
  v4 = 19;
  v2 = 1;
  *(_DWORD *)v36 = "END";
  do
  {
    if ( !v4 )
      break;
    v2 = *(_BYTE *)v6++ == **(_BYTE **)v5;
    ++*(_DWORD *)v5;
    --v4;
  }
  while ( v2 );
  v25 = (int)"mom_mtsys_origin_y";
  v26 = (int)"mom_mtsys_origin_z";
  v27 = (int)"mom_mtsys_x_axis_i";
  v28 = (int)"mom_mtsys_x_axis_j";
  v29 = (int)"mom_mtsys_x_axis_k";
  v30 = (int)"mom_mtsys_y_axis_i";
  v31 = (int)"mom_mtsys_y_axis_j";
  v32 = (int)"mom_mtsys_y_axis_k";
  v33 = (int)"mom_mtsys_z_axis_i";
  v34 = (int)"mom_mtsys_z_axis_j";
  v35 = (int)"mom_mtsys_z_axis_k";
  v38 = 0;
  if ( !v2 )
  {
    do
    {
      v7 = v38;
      v37 = UF_MOM_ask_string(a1, v3 + 4, &v39);
      switch ( v38 )
      {
        case 0:
          v8 = v39;
          if ( !v39 )
          {
            v8 = "0.0";
            v39 = "0.0";
          }
          *(double *)(a2 + 96) = strtod(v8, 0);
          break;
        case 1:
          v9 = v39;
          if ( !v39 )
          {
            v9 = "0.0";
            v39 = "0.0";
          }
          *(double *)(a2 + 104) = strtod(v9, 0);
          break;
        case 2:
          v10 = v39;
          if ( !v39 )
          {
            v10 = "0.0";
            v39 = "0.0";
          }
          *(double *)(a2 + 112) = strtod(v10, 0);
          break;
        case 3:
          v11 = v39;
          if ( !v39 )
          {
            v11 = "1.0";
            v39 = "1.0";
          }
          *(double *)(a2 + 120) = strtod(v11, 0);
          break;
        case 4:
          v12 = v39;
          if ( !v39 )
          {
            v12 = "0.0";
            v39 = "0.0";
          }
          *(double *)(a2 + 128) = strtod(v12, 0);
          break;
        case 5:
          v13 = v39;
          if ( !v39 )
          {
            v13 = "0.0";
            v39 = "0.0";
          }
          *(double *)(a2 + 136) = strtod(v13, 0);
          break;
        case 6:
          v14 = v39;
          if ( !v39 )
          {
            v14 = "0.0";
            v39 = "0.0";
          }
          *(double *)(a2 + 144) = strtod(v14, 0);
          break;
        case 7:
          v15 = v39;
          if ( !v39 )
          {
            v15 = "1.0";
            v39 = "1.0";
          }
          *(double *)(a2 + 152) = strtod(v15, 0);
          break;
        case 8:
          v16 = v39;
          if ( !v39 )
          {
            v16 = "0.0";
            v39 = "0.0";
          }
          *(double *)(a2 + 160) = strtod(v16, 0);
          break;
        case 9:
          v17 = v39;
          if ( !v39 )
          {
            v17 = "0.0";
            v39 = "0.0";
          }
          *(double *)(a2 + 168) = strtod(v17, 0);
          break;
        case 10:
          v18 = v39;
          if ( !v39 )
          {
            v18 = "0.0";
            v39 = "0.0";
          }
          *(double *)(a2 + 176) = strtod(v18, 0);
          break;
        case 11:
          v19 = v39;
          if ( !v39 )
          {
            v19 = "1.0";
            v39 = "1.0";
          }
          *(double *)(a2 + 184) = strtod(v19, 0);
          break;
        default:
          break;
      }
      v3 = *(&v25 + v7);
      v38 = v7 + 1;
      *(_DWORD *)v22 = "END";
      v23 = v3;
      v21 = 4;
      v20 = 1;
      do
      {
        if ( !v21 )
          break;
        v20 = *(_BYTE *)v23++ == **(_BYTE **)v22;
        ++*(_DWORD *)v22;
        --v21;
      }
      while ( v20 );
    }
    while ( !v20 );
  }
  return v37;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10006F30) --------------------------------------------------------
int __cdecl sub_10006F30(int a1, int a2)
{
  char v2; // zf@1
  int v3; // eax@1
  signed int v4; // ecx@1
  char v5[4]; // edi@1
  int v6; // esi@1
  int v7; // esi@6
  char *v8; // eax@7
  char *v9; // eax@10
  char *v10; // eax@13
  char *v11; // eax@16
  char *v12; // eax@19
  char *v13; // eax@22
  char *v14; // eax@25
  int v15; // edx@27
  char v16; // cl@28
  char *v17; // eax@30
  char *v18; // eax@33
  char v19; // zf@36
  signed int v20; // ecx@36
  char v21[4]; // edi@36
  int v22; // esi@36
  int v24; // [sp+Ch] [bp-2Ch]@5
  int v25; // [sp+10h] [bp-28h]@5
  int v26; // [sp+14h] [bp-24h]@5
  int v27; // [sp+18h] [bp-20h]@5
  int v28; // [sp+1Ch] [bp-1Ch]@5
  int v29; // [sp+20h] [bp-18h]@5
  int v30; // [sp+24h] [bp-14h]@5
  int v31; // [sp+28h] [bp-10h]@5
  char v32[4]; // [sp+2Ch] [bp-Ch]@1
  int v33; // [sp+30h] [bp-8h]@5
  char *v34; // [sp+34h] [bp-4h]@6

  v3 = (int)"mom_origin_x";
  *(_DWORD *)v5 = "END";
  v6 = (int)"mom_origin_x";
  v4 = 13;
  v2 = 1;
  *(_DWORD *)v32 = "END";
  do
  {
    if ( !v4 )
      break;
    v2 = *(_BYTE *)v6++ == **(_BYTE **)v5;
    ++*(_DWORD *)v5;
    --v4;
  }
  while ( v2 );
  v24 = (int)"mom_origin_y";
  v25 = (int)"mom_origin_z";
  v26 = (int)"mom_translate_x";
  v27 = (int)"mom_translate_y";
  v28 = (int)"mom_translate_z";
  v29 = (int)"mom_tool_type";
  v30 = (int)"mom_tool_z_offset";
  v31 = (int)"mom_tool_corner1_radius";
  v33 = 0;
  if ( !v2 )
  {
    do
    {
      UF_MOM_ask_string(a1, v3 + 4, &v34);
      v7 = v33;
      switch ( v33 )
      {
        case 0:
          v8 = v34;
          if ( !v34 )
          {
            v8 = "0.0";
            v34 = "0.0";
          }
          *(double *)(a2 + 216) = strtod(v8, 0);
          break;
        case 1:
          v9 = v34;
          if ( !v34 )
          {
            v9 = "0.0";
            v34 = "0.0";
          }
          *(double *)(a2 + 224) = strtod(v9, 0);
          break;
        case 2:
          v10 = v34;
          if ( !v34 )
          {
            v10 = "0.0";
            v34 = "0.0";
          }
          *(double *)(a2 + 232) = strtod(v10, 0);
          break;
        case 3:
          v11 = v34;
          if ( !v34 )
          {
            v11 = "0.0";
            v34 = "0.0";
          }
          *(double *)(a2 + 192) = strtod(v11, 0);
          break;
        case 4:
          v12 = v34;
          if ( !v34 )
          {
            v12 = "0.0";
            v34 = "0.0";
          }
          *(double *)(a2 + 200) = strtod(v12, 0);
          break;
        case 5:
          v13 = v34;
          if ( !v34 )
          {
            v13 = "0.0";
            v34 = "0.0";
          }
          *(double *)(a2 + 208) = strtod(v13, 0);
          break;
        case 6:
          v14 = v34;
          if ( !v34 )
          {
            v14 = "MILL";
            v34 = "MILL";
          }
          v15 = a2 - (_DWORD)v14 + 240;
          do
          {
            v16 = *v14;
            v14[v15] = *v14;
            ++v14;
          }
          while ( v16 );
          break;
        case 7:
          v17 = v34;
          if ( !v34 )
          {
            v17 = "0.0";
            v34 = "0.0";
          }
          *(double *)(a2 + 376) = strtod(v17, 0);
          break;
        case 8:
          v18 = v34;
          if ( !v34 )
          {
            v18 = "0.0";
            v34 = "0.0";
          }
          *(double *)(a2 + 384) = strtod(v18, 0);
          break;
        default:
          break;
      }
      v3 = *(&v24 + v7);
      v33 = v7 + 1;
      *(_DWORD *)v21 = "END";
      v22 = v3;
      v20 = 4;
      v19 = 1;
      do
      {
        if ( !v20 )
          break;
        v19 = *(_BYTE *)v22++ == **(_BYTE **)v21;
        ++*(_DWORD *)v21;
        --v20;
      }
      while ( v19 );
    }
    while ( !v19 );
  }
  return 0;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10007150) --------------------------------------------------------
int __cdecl sub_10007150(int a1, int a2)
{
  char v2; // zf@1
  int v3; // eax@1
  signed int v4; // ecx@1
  char v5[4]; // edi@1
  int v6; // esi@1
  int v7; // esi@6
  char *v8; // eax@7
  char *v9; // eax@10
  char *v10; // eax@13
  char *v11; // eax@16
  char *v12; // eax@19
  char *v13; // eax@22
  char v14; // zf@25
  signed int v15; // ecx@25
  char v16[4]; // edi@25
  int v17; // esi@25
  int v19; // [sp+Ch] [bp-24h]@5
  int v20; // [sp+10h] [bp-20h]@5
  int v21; // [sp+14h] [bp-1Ch]@5
  int v22; // [sp+18h] [bp-18h]@5
  int v23; // [sp+1Ch] [bp-14h]@5
  char v24[4]; // [sp+20h] [bp-10h]@1
  int v25; // [sp+24h] [bp-Ch]@6
  int v26; // [sp+28h] [bp-8h]@5
  char *v27; // [sp+2Ch] [bp-4h]@6

  v3 = (int)"mom_mcs_goto_x";
  *(_DWORD *)v5 = "END";
  v6 = (int)"mom_mcs_goto_x";
  v4 = 15;
  v2 = 1;
  *(_DWORD *)v24 = "END";
  do
  {
    if ( !v4 )
      break;
    v2 = *(_BYTE *)v6++ == **(_BYTE **)v5;
    ++*(_DWORD *)v5;
    --v4;
  }
  while ( v2 );
  v19 = (int)"mom_mcs_goto_y";
  v20 = (int)"mom_mcs_goto_z";
  v21 = (int)"mom_tool_axis_i";
  v22 = (int)"mom_tool_axis_j";
  v23 = (int)"mom_tool_axis_k";
  v26 = 0;
  if ( !v2 )
  {
    do
    {
      v7 = v26;
      v25 = UF_MOM_ask_string(a1, v3 + 4, &v27);
      switch ( v26 )
      {
        case 0:
          v8 = v27;
          if ( !v27 )
          {
            v8 = "0.0";
            v27 = "0.0";
          }
          *(double *)a2 = strtod(v8, 0);
          break;
        case 1:
          v9 = v27;
          if ( !v27 )
          {
            v9 = "0.0";
            v27 = "0.0";
          }
          *(double *)(a2 + 8) = strtod(v9, 0);
          break;
        case 2:
          v10 = v27;
          if ( !v27 )
          {
            v10 = "0.0";
            v27 = "0.0";
          }
          *(double *)(a2 + 16) = strtod(v10, 0);
          break;
        case 3:
          v11 = v27;
          if ( !v27 )
          {
            v11 = "0.0";
            v27 = "0.0";
          }
          *(double *)(a2 + 24) = strtod(v11, 0);
          break;
        case 4:
          v12 = v27;
          if ( !v27 )
          {
            v12 = "0.0";
            v27 = "0.0";
          }
          *(double *)(a2 + 32) = strtod(v12, 0);
          break;
        case 5:
          v13 = v27;
          if ( !v27 )
          {
            v13 = "0.0";
            v27 = "0.0";
          }
          *(double *)(a2 + 40) = strtod(v13, 0);
          break;
        default:
          break;
      }
      v3 = *(&v19 + v7);
      v26 = v7 + 1;
      *(_DWORD *)v16 = "END";
      v17 = v3;
      v15 = 4;
      v14 = 1;
      do
      {
        if ( !v15 )
          break;
        v14 = *(_BYTE *)v17++ == **(_BYTE **)v16;
        ++*(_DWORD *)v16;
        --v15;
      }
      while ( v14 );
    }
    while ( !v14 );
  }
  return v25;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (100072D0) --------------------------------------------------------
int __cdecl sub_100072D0(int a1, char *a2)
{
  char v2; // zf@1
  int v3; // eax@1
  signed int v4; // ecx@1
  char *v5; // ebx@1
  char v6[4]; // edi@1
  int v7; // esi@1
  int v8; // esi@6
  const char *v9; // eax@7
  const char *v10; // eax@10
  const char *v11; // eax@13
  const char *v12; // eax@16
  const char *v13; // eax@19
  const char *v14; // eax@22
  const char *v15; // eax@25
  const char *v16; // eax@28
  const char *v17; // eax@31
  char v18; // zf@34
  signed int v19; // ecx@34
  char v20[4]; // edi@34
  int v21; // esi@34
  int result; // eax@39
  int v23; // [sp+10h] [bp-2Ch]@5
  int v24; // [sp+14h] [bp-28h]@5
  int v25; // [sp+18h] [bp-24h]@5
  int v26; // [sp+1Ch] [bp-20h]@5
  int v27; // [sp+20h] [bp-1Ch]@5
  int v28; // [sp+24h] [bp-18h]@5
  int v29; // [sp+28h] [bp-14h]@5
  int v30; // [sp+2Ch] [bp-10h]@5
  char v31[4]; // [sp+30h] [bp-Ch]@1
  int v32; // [sp+34h] [bp-8h]@6
  int v33; // [sp+38h] [bp-4h]@5

  v5 = a2;
  v3 = (int)"mom_origin_x";
  *(_DWORD *)v6 = "END";
  v7 = (int)"mom_origin_x";
  v4 = 13;
  v2 = 1;
  *(_DWORD *)v31 = "END";
  do
  {
    if ( !v4 )
      break;
    v2 = *(_BYTE *)v7++ == **(_BYTE **)v6;
    ++*(_DWORD *)v6;
    --v4;
  }
  while ( v2 );
  v23 = (int)"mom_origin_y";
  v24 = (int)"mom_origin_z";
  v25 = (int)"mom_translate_x";
  v26 = (int)"mom_translate_y";
  v27 = (int)"mom_translate_z";
  v28 = (int)"mom_tool_z_offset";
  v29 = (int)"mom_kin_track_center_of_ball";
  v30 = (int)"mom_tool_corner1_radius";
  v33 = 0;
  if ( !v2 )
  {
    do
    {
      v8 = v33;
      v32 = UF_MOM_ask_string(a1, v3 + 4, &a2);
      switch ( v33 )
      {
        case 0:
          v9 = a2;
          if ( !a2 )
          {
            v9 = "0.0";
            a2 = "0.0";
          }
          *(double *)v5 = strtod(v9, 0);
          break;
        case 1:
          v10 = a2;
          if ( !a2 )
          {
            v10 = "0.0";
            a2 = "0.0";
          }
          *((double *)v5 + 1) = strtod(v10, 0);
          break;
        case 2:
          v11 = a2;
          if ( !a2 )
          {
            v11 = "0.0";
            a2 = "0.0";
          }
          *((double *)v5 + 2) = strtod(v11, 0);
          break;
        case 3:
          v12 = a2;
          if ( !a2 )
          {
            v12 = "0.0";
            a2 = "0.0";
          }
          *((double *)v5 + 12) = strtod(v12, 0);
          break;
        case 4:
          v13 = a2;
          if ( !a2 )
          {
            v13 = "0.0";
            a2 = "0.0";
          }
          *((double *)v5 + 13) = strtod(v13, 0);
          break;
        case 5:
          v14 = a2;
          if ( !a2 )
          {
            v14 = "0.0";
            a2 = "0.0";
          }
          *((double *)v5 + 14) = strtod(v14, 0);
          break;
        case 6:
          v15 = a2;
          if ( !a2 )
          {
            v15 = "0.0";
            a2 = "0.0";
          }
          *((double *)v5 + 15) = strtod(v15, 0);
          break;
        case 7:
          v16 = a2;
          if ( !a2 )
          {
            v16 = "0.0";
            a2 = "0.0";
          }
          *((_DWORD *)v5 + 32) = (signed int)strtod(v16, 0);
          break;
        case 8:
          v17 = a2;
          if ( !a2 )
          {
            v17 = "0.0";
            a2 = "0.0";
          }
          *((double *)v5 + 17) = strtod(v17, 0);
          break;
        default:
          break;
      }
      v3 = *(&v23 + v8);
      v33 = v8 + 1;
      *(_DWORD *)v20 = "END";
      v21 = v3;
      v19 = 4;
      v18 = 1;
      do
      {
        if ( !v19 )
          break;
        v18 = *(_BYTE *)v21++ == **(_BYTE **)v20;
        ++*(_DWORD *)v20;
        --v19;
      }
      while ( v18 );
    }
    while ( !v18 );
  }
  result = v32;
  memcpy(&unk_1000C5E0, v5, 0x90u);
  return result;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (100074F0) --------------------------------------------------------
int __cdecl sub_100074F0(int a1, int a2)
{
  int v2; // esi@1
  int v4; // ebx@5
  double v5; // [sp+18h] [bp-78h]@1
  double v6; // [sp+20h] [bp-70h]@1
  double v7; // [sp+28h] [bp-68h]@1
  double v8; // [sp+30h] [bp-60h]@1
  double v9; // [sp+38h] [bp-58h]@1
  double v10; // [sp+40h] [bp-50h]@1
  double v11; // [sp+48h] [bp-48h]@1
  double v12; // [sp+50h] [bp-40h]@1
  double v13; // [sp+58h] [bp-38h]@1
  char v14; // [sp+60h] [bp-30h]@5
  char v15; // [sp+78h] [bp-18h]@5

  v5 = dbl_1000C5F8;
  v8 = dbl_1000C610;
  v2 = a1;
  v11 = dbl_1000C628;
  v6 = dbl_1000C600;
  v9 = dbl_1000C618;
  v12 = dbl_1000C630;
  v7 = dbl_1000C608;
  v10 = dbl_1000C620;
  v13 = dbl_1000C638;
  if ( !dword_1000C670 )
  {
    UF_VEC3_is_equal(
      a1 + 24,
      &dbl_1000C628,
      COERCE_UNSIGNED_INT64(0.00000001),
      COERCE_UNSIGNED_INT64(0.00000001) >> 32,
      &a1);
    if ( !a1 )
    {
      printf("WARNING  The tool axis is not matching with the                 rotated MCS-Z axis. The output may be INCORRECT\n");
      uc1601(
        "WARNING  The tool axis is not matching with the *                     rotated MCS-Z axis. The output may be INCORRECT\n",
        1);
    }
    dword_1000C670 = 1;
  }
  UF_VEC3_copy(v2, &v15);
  UF_VEC3_copy(v2 + 24, &v14);
  v4 = a2;
  UF_MTX3_vec_multiply(v2, &v5, a2);
  UF_MTX3_vec_multiply(v2 + 24, &v5, v4 + 24);
  return 0;
}
// 100090E0: using guessed type int __cdecl UF_VEC3_is_equal(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090F4: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);
// 1000910C: using guessed type int __cdecl UF_MTX3_vec_multiply(_DWORD, _DWORD, _DWORD);
// 10009160: using guessed type int __cdecl uc1601(_DWORD, _DWORD);
// 1000C5F8: using guessed type double dbl_1000C5F8;
// 1000C600: using guessed type double dbl_1000C600;
// 1000C608: using guessed type double dbl_1000C608;
// 1000C610: using guessed type double dbl_1000C610;
// 1000C618: using guessed type double dbl_1000C618;
// 1000C620: using guessed type double dbl_1000C620;
// 1000C628: using guessed type double dbl_1000C628;
// 1000C630: using guessed type double dbl_1000C630;
// 1000C638: using guessed type double dbl_1000C638;
// 1000C670: using guessed type int dword_1000C670;

//----- (100075F0) --------------------------------------------------------
int __cdecl sub_100075F0(int a1, int a2)
{
  char v3; // [sp+1Ch] [bp-18h]@1

  UF_VEC3_add(a1, &unk_1000C640, a2);
  UF_VEC3_sub(a1, &unk_1000C5E0, a2);
  UF_VEC3_copy(a1 + 24, a2 + 24);
  UF_VEC3_scale(LODWORD(dbl_1000C658), HIDWORD(dbl_1000C658), a2 + 24, &v3);
  UF_VEC3_add(a2, &v3, a2);
  if ( dword_1000C660 == 1 )
  {
    UF_VEC3_scale(LODWORD(dbl_1000C668), HIDWORD(dbl_1000C668), a2 + 24, &v3);
    UF_VEC3_add(a2, &v3, a2);
  }
  return 0;
}
// 100090C4: using guessed type int __cdecl UF_VEC3_scale(_DWORD, _DWORD, _DWORD, _DWORD);
// 100090EC: using guessed type int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD);
// 100090F4: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);
// 10009100: using guessed type int __cdecl UF_VEC3_add(_DWORD, _DWORD, _DWORD);
// 1000C658: using guessed type double dbl_1000C658;
// 1000C660: using guessed type int dword_1000C660;
// 1000C668: using guessed type double dbl_1000C668;

//----- (10007690) --------------------------------------------------------
int __cdecl sub_10007690(int a1, int a2, int a3)
{
  char *v3; // edi@1
  int v4; // esi@1
  long double v5; // fst6@1
  long double v6; // fst7@1
  int v8; // edi@10
  char *v9; // esi@11
  char v11; // [sp+18h] [bp-150h]@1
  char v12; // [sp+F0h] [bp-78h]@5
  double v13; // [sp+108h] [bp-60h]@1
  double v14; // [sp+110h] [bp-58h]@1
  double v15; // [sp+118h] [bp-50h]@1
  double v16; // [sp+120h] [bp-48h]@1
  double v17; // [sp+128h] [bp-40h]@1
  double v18; // [sp+130h] [bp-38h]@1
  double v19; // [sp+138h] [bp-30h]@1
  double v20; // [sp+140h] [bp-28h]@1
  double v21; // [sp+148h] [bp-20h]@1
  double v22; // [sp+150h] [bp-18h]@1
  double v23; // [sp+158h] [bp-10h]@5
  int v24; // [sp+160h] [bp-8h]@1
  int v25; // [sp+164h] [bp-4h]@1

  v14 = 1.0;
  v15 = 0.0;
  v16 = 0.0;
  v17 = 0.0;
  v19 = 0.0;
  v20 = 0.0;
  v21 = 0.0;
  v18 = 1.0;
  v22 = 1.0;
  v6 = asin(1.0) * 0.01111111111111111;
  v25 = 0;
  v13 = v6;
  v3 = &v11;
  v5 = -1.0;
  v4 = a3 + 8;
  v24 = 3;
  do
  {
    if ( (signed int)*(double *)(v4 - 8) == 1 )
    {
      v23 = v6 * *(double *)v4 * v5;
      UF_MTX3_x_vec(&v14, &v12);
    }
    else
    {
      if ( (signed int)*(double *)(v4 - 8) == 2 )
      {
        v23 = v6 * *(double *)v4 * v5;
        UF_MTX3_y_vec(&v14, &v12);
      }
      else
      {
        if ( (signed int)*(double *)(v4 - 8) != 3 )
          goto LABEL_9;
        v23 = v6 * *(double *)v4 * v5;
        UF_MTX3_z_vec(&v14, &v12);
      }
    }
    UF_MTX3_rotate_about_axis(&v12, LODWORD(v23), HIDWORD(v23), v3);
    v6 = v13;
    ++v25;
    v5 = -1.0;
    v3 += 72;
LABEL_9:
    v4 += 16;
  }
  while ( v24-- != 1 );
  v8 = v25;
  if ( v25 > 0 )
  {
    v9 = &v11;
    do
    {
      UF_MTX3_multiply(&v14, v9, &v14);
      v9 += 72;
      --v8;
    }
    while ( v8 );
  }
  *(double *)(a2 + 24) = v14;
  *(double *)(a2 + 48) = v17;
  dword_1000C670 = 0;
  *(double *)(a2 + 72) = v20;
  *(double *)(a2 + 32) = v15;
  *(double *)(a2 + 56) = v18;
  *(double *)(a2 + 80) = v21;
  *(double *)(a2 + 40) = v16;
  *(double *)(a2 + 64) = v19;
  *(double *)(a2 + 88) = v22;
  return 0;
}
// 10007690: could not find valid save-restore pair for ebx
// 10007690: could not find valid save-restore pair for edi
// 10007690: could not find valid save-restore pair for esi
// 100090B8: using guessed type int __cdecl UF_MTX3_rotate_about_axis(_DWORD, _DWORD, _DWORD, _DWORD);
// 100090BC: using guessed type int __cdecl UF_MTX3_multiply(_DWORD, _DWORD, _DWORD);
// 100090CC: using guessed type int __cdecl UF_MTX3_z_vec(_DWORD, _DWORD);
// 10009120: using guessed type int __cdecl UF_MTX3_x_vec(_DWORD, _DWORD);
// 10009124: using guessed type int __cdecl UF_MTX3_y_vec(_DWORD, _DWORD);
// 1000C670: using guessed type int dword_1000C670;

//----- (10007D6B) --------------------------------------------------------
int __cdecl sub_10007D6B()
{
  return _clean_type_info_names_internal(&unk_1000C67C);
}
// 100081D2: using guessed type int __cdecl _clean_type_info_names_internal(_DWORD);

//----- (10007E2E) --------------------------------------------------------
int (*__cdecl sub_10007E2E())(void)
{
  int (*result)(void); // eax@1
  unsigned int v1; // esi@1

  result = (int (*)(void))&unk_1000AE78;
  v1 = (unsigned int)&unk_1000AE78;
  if ( &unk_1000AE78 < &unk_1000AE78 )
  {
    do
    {
      result = *(int (**)(void))v1;
      if ( *(_DWORD *)v1 )
        result = (int (*)(void))result();
      v1 += 4;
    }
    while ( v1 < (unsigned int)&unk_1000AE78 );
  }
  return result;
}

//----- (10007E52) --------------------------------------------------------
int (*__cdecl sub_10007E52())(void)
{
  int (*result)(void); // eax@1
  unsigned int v1; // esi@1

  result = (int (*)(void))&unk_1000AE80;
  v1 = (unsigned int)&unk_1000AE80;
  if ( &unk_1000AE80 < &unk_1000AE80 )
  {
    do
    {
      result = *(int (**)(void))v1;
      if ( *(_DWORD *)v1 )
        result = (int (*)(void))result();
      v1 += 4;
    }
    while ( v1 < (unsigned int)&unk_1000AE80 );
  }
  return result;
}

//----- (10007FE4) --------------------------------------------------------
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
  if ( fdwReason == 1 )
  {
    if ( !dword_1000ADB8 )
      DisableThreadLibraryCalls(hinstDLL);
  }
  return 1;
}
// 1000ADB8: using guessed type int dword_1000ADB8;

//----- (100081C4) --------------------------------------------------------
int __cdecl sub_100081C4()
{
  dword_1000C9AC = unknown_libname_1();
  return 0;
}
// 10008164: using guessed type int unknown_libname_1(void);
// 1000C9AC: using guessed type int dword_1000C9AC;

// ALL OK, 56 function(s) have been successfully decompiled
