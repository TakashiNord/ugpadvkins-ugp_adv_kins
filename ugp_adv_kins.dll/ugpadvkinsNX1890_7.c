/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 sub_180001000();
signed __int64 __fastcall sub_180001020(__int64 a1);
__int64 __fastcall sub_180001070(const char *a1, unsigned int a2, __int64 a3, unsigned int a4);
__int64 __fastcall sub_180001130(__int64 a1);
signed __int64 __fastcall sub_180001270(__int64 a1, __int64 a2, int a3, __int64 a4);
signed __int64 __fastcall sub_1800014C0(__int64 a1);
__int64 __fastcall sub_180001B60(__int64 a1);
signed __int64 __fastcall sub_180001C90(__int64 a1, __int64 a2, signed int a3, __int64 a4);
void *sub_180001F00();
__int64 sub_180001F10(__int64 a1, __int64 a2, ...);
__int64 __fastcall ufusr(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_180002170(double *a1, double *a2, double *a3, double *a4);
__int64 __fastcall sub_180002400(__int64 a1, double *a2, double *a3, double *a4);
__int64 __fastcall sub_180002500(__int64 a1);
signed __int64 __fastcall sub_180002550(__int64 a1, _QWORD *a2, _QWORD *a3);
__int64 __fastcall sub_1800038B0(__int128 *a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_180003B80(__int64 a1, __int128 *a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_180004A70(__int64 a1, __int64 a2, double a3, __int64 a4);
__int64 __fastcall sub_180004AB0(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_180004BC0(double *a1, double *a2);
signed __int64 __fastcall PtFuncCompare(const void *a1, const void *a2);
signed __int64 __fastcall sub_180004DB0(double a1, double *a2, __int64 a3);
signed __int64 __fastcall sub_180004F40(__int64 a1, int a2, __int64 a3, _QWORD *a4);
signed __int64 __fastcall sub_1800051C0(__int64 *a1, int a2, __int64 a3, _QWORD *a4);
__int64 __fastcall sub_180005840(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_1800059B0(double a1);
double __fastcall sub_180005A00(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_180005A20(__int64 *a1, __int64 a2);
__int64 __fastcall sub_180005BC0(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_180005C60(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_180005DF0(__int64 a1, double a2, __int64 a3);
void __fastcall sub_180005E50(__int64 a1, double *a2, double *a3);
double __fastcall sub_1800060E0(double result);
__int64 sub_180006110(__int64 a1, ...);
__m128 __fastcall sub_180006170(double *a1, double *a2);
signed __int64 __fastcall sub_180006210(double *a1);
__int64 __fastcall sub_180006500(__int64 a1);
__int64 __fastcall sub_180006550(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_180006570(__int64 a1, double *a2);
__int64 __fastcall sub_1800069B0(__int64 a1, double *a2);
__int64 __fastcall sub_180006DF0(__int64 a1, __int64 a2);
__int64 __fastcall sub_180006FB0(__int64 a1, double *a2);
__int64 __fastcall sub_180007220(__int64 a1, __int64 a2);
__int64 __fastcall sub_180007370(__int64 a1, double *a2);
__int64 __fastcall sub_180007A00(__int64 a1, double *a2);
__int64 __fastcall sub_180007ED0(__int64 a1, __int64 a2);
__int64 __fastcall sub_180008140(__int64 a1, double *a2);
__int64 __fastcall sub_180008270(__int64 a1, double *a2);
__int64 __fastcall sub_180008490(__int64 a1, double *a2);
__int64 __fastcall sub_1800087D0(__int64 a1, double *a2);
__int64 __fastcall sub_180008B30(__int64 a1, double *a2);
__int64 __fastcall sub_180008DF0(__int64 a1, _QWORD *a2, __int64 a3);
__int64 __fastcall sub_180009010(__int64 a1, __int64 a2);
__int64 __fastcall sub_180009320(__int64 a1, __int64 a2);
__int64 __fastcall sub_1800093E0(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_180009594(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_1800096AC(char a1);
void sub_180009974();
__int64 sub_180009984();
void *sub_180009990();
// __int64 _scrt_initialize_default_local_stdio_options(void); weak
// __int64 _scrt_acquire_startup_lock(void); weak
// __int64 _scrt_dllmain_after_initialize_c(void); weak
// __int64 _scrt_dllmain_before_initialize_c(void); weak
// __int64 sub_180009ADC(void); weak
// __int64 _scrt_dllmain_uninitialize_critical(void); weak
// __int64 __fastcall _scrt_initialize_crt(_QWORD); weak
char __fastcall sub_180009B6C(unsigned int a1);
char __fastcall sub_180009C1C(__int64 a1);
// __int64 __fastcall _scrt_release_startup_lock(_QWORD); weak
char __fastcall sub_180009CD8(__int64 a1, char a2);
void *sub_180009D04();
void sub_180009D0C();
// __int64 __fastcall _scrt_fastfail(_QWORD); weak
__int64 __fastcall sub_180009E60(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_180009E9C(__int64 a1, __int64 a2, __int64 a3);
__int64 sub_180009ED8();
signed __int64 sub_18000A054();
// bool __uncaught_exception(void); idb
// char *__cdecl strstr(const char *Str, const char *SubStr);
// __int64 __fastcall _std_type_info_destroy_list(_QWORD); weak
// double __cdecl acos(double X);
// double __cdecl asin(double X);
// double __cdecl atan2(double Y, double X);
// double __cdecl cos(double X);
// double __cdecl sin(double X);
// double __cdecl sqrt(double X);
// double __cdecl ceil(double X);
// double __cdecl floor(double X);
// __int64 __fastcall initterm(_QWORD, _QWORD); weak
// __int64 __fastcall initterm_e(_QWORD, _QWORD); weak
// __int64 __fastcall initialize_onexit_table(_QWORD); weak
char sub_18000A0F0();
__int64 sub_18000A0F4();
__int64 __fastcall sub_18000A110(_QWORD, _QWORD, _QWORD); // weak
// void __stdcall InitializeSListHead(PSLIST_HEADER ListHead);
// int __cdecl atoi(const char *Str);
// double __cdecl strtod(const char *Str, char **EndPtr);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Memory);
// __int64 __fastcall _stdio_common_vfprintf(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall _stdio_common_vsprintf(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall _acrt_iob_func(_QWORD); weak
// void __cdecl qsort(void *Base, size_t NumOfElements, size_t SizeOfElements, int (__cdecl *PtFuncCompare)(const void *, const void *));
// _DWORD UGS::System::SYSS_fprintf(UGS::System *__hidden this, struct _iobuf *, const char *, ...); weak
// _DWORD UGS::System::SYSS_printf(UGS::System *__hidden this, const char *, ...); weak
// _QWORD UGS::System::L10N::LibraryRegistrant::LibraryRegistrant(UGS::System::L10N::LibraryRegistrant *__hidden this, const char *); weak
// __int64 __fastcall UF_MISC_set_program_name(_QWORD); weak
// __int64 UF_initialize(void); weak
// __int64 __fastcall UF_VEC3_angle_between(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall UF_VEC3_dot(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall UF_get_fail_message(_QWORD, _QWORD); weak
// __int64 __fastcall UF_MTX3_rotate_about_axis(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall UF_MTX3_multiply(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall UF_MTX4_edit_rotation(_QWORD, _QWORD); weak
// __int64 __fastcall UF_MTX4_csys_to_csys(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall UF_MTX4_rotation(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall UF_VEC3_copy(_QWORD, _QWORD); weak
// __int64 __fastcall UF_MTX4_vec3_multiply(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall UF_MTX4_vec_multiply(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall UF_MTX4_multiply(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall UF_MTX4_ask_rotation(_QWORD, _QWORD); weak
// __int64 __fastcall UF_MTX3_z_vec(_QWORD, _QWORD); weak
// __int64 __fastcall UF_MTX3_y_vec(_QWORD, _QWORD); weak
// __int64 __fastcall UF_MTX3_x_vec(_QWORD, _QWORD); weak
// __int64 __fastcall UF_MTX3_vec_multiply_t(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall UF_MTX3_vec_multiply(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall UF_MTX3_copy(_QWORD, _QWORD); weak
// __int64 __fastcall UF_VEC3_is_parallel(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall UF_VEC3_unitize(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall UF_VEC3_sub(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall UF_VEC3_scale(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall UF_VEC3_is_equal(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// __int64 __fastcall UF_VEC3_cross(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall UF_VEC3_distance(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall UF_VEC3_is_zero(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall UF_MTX4_vec3_multiply_t(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall UF_VEC3_affine_comb(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall UF_VEC3_add(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall UF_allocate_memory(_QWORD, _QWORD); weak
// __int64 __fastcall UF_free(_QWORD); weak
// __int64 __fastcall UF_MOM_ask_mom(_QWORD, _QWORD); weak
// __int64 __fastcall UF_MOM_ask_interp_from_param(_QWORD, _QWORD); weak
// __int64 __fastcall UF_MOM_set_double(_QWORD, _QWORD); weak
// __int64 __fastcall UF_MOM_set_string(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall UF_MOM_ask_string(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall UF_MOM_extend_xlator(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall UF_OBJ_cycle_by_name(_QWORD, _QWORD); weak
// __int64 __cdecl UF_terminate(_QWORD); weak
// __int64 __fastcall UF_ATTR_read_value(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall uc1601(_QWORD, _QWORD); weak

//-------------------------------------------------------------------------
// Data declarations

// extern _UNKNOWN UF_terminate; weak
char byte_1800096A9 = 'лю'; // weak
char byte_18000972E = 'лю'; // weak
_UNKNOWN unk_18000B328; // weak
_UNKNOWN unk_18000B338; // weak
_UNKNOWN unk_18000B340; // weak
_UNKNOWN unk_18000B348; // weak
char aAaxis[6] = "AAXIS"; // weak
char aBaxis[6] = "BAXIS"; // weak
char aCaxis[6] = "CAXIS"; // weak
__int128 xmmword_18000BA18 = 0x745F6574756269727474615F6C6F6F74i64; // weak
__int128 xmmword_18000BA40 = 0x6F207265626D756E2064696C61766E49i64; // weak
__int128 xmmword_18000BA70 = 0x74626F20656D614E206C6F6F54206F4Ei64; // weak
__int128 xmmword_18000BA80 = 0x736F504755206D6F72662064656E6961i64; // weak
__int128 xmmword_18000BB10 = 0x80000000000000008000000000000000i64; // weak
_UNKNOWN unk_18000BB20; // weak
_UNKNOWN unk_18000BB70; // weak
_UNKNOWN unk_18000BBC0; // weak
__int128 xmmword_18000C190 = 0x7FFFFFFFFFFFFFFF7FFFFFFFFFFFFFFFi64; // weak
char aEnd[4] = "END"; // weak
__int128 xmmword_18000C368 = 0x6B636172745F6F745F6874345F6E696Bi64; // weak
__int128 xmmword_18000C388 = 0x6B636172745F6F745F6874345F6E696Bi64; // weak
__int128 xmmword_18000C3A8 = 0x6B636172745F6F745F6874345F6E696Bi64; // weak
__int128 xmmword_18000D1C0 = 4607182418800017408i64; // weak
_UNKNOWN unk_18000D630; // weak
_UNKNOWN unk_18000D640; // weak
__int64 qword_18000F000 = 4457293557087583675i64; // weak
char byte_18000F008 = '\x01'; // weak
char byte_18000F009 = '\x01'; // weak
char byte_18000F00A = '\x01'; // weak
uintptr_t _security_cookie = 47936899621426ui64;
int dword_18000F240 = 1; // weak
int dword_18000F244 = 2; // weak
__int64 qword_18000F248 = 8239i64; // weak
_UNKNOWN unk_18000F270; // weak
__int64 qword_18000F278 = 0i64; // weak
__int64 qword_18000F280 = 0i64; // weak
__int64 qword_18000F288 = 0i64; // weak
__int64 qword_18000F290 = 0i64; // weak
__int64 qword_18000F298 = 0i64; // weak
double X =  0.0; // idb
double qword_18000F2A8 =  0.0; // idb
__int64 qword_18000F2B0 = 0i64; // weak
__int64 qword_18000F2B8 = 0i64; // weak
__int64 qword_18000F2C0 = 0i64; // weak
__int64 qword_18000F2C8 = 0i64; // weak
__int128 xmmword_18000F2D0 = 0i64; // weak
__int128 xmmword_18000F2E0 = 0i64; // weak
__int128 xmmword_18000F2F0 = 0i64; // weak
__int128 xmmword_18000F300 = 0i64; // weak
__int128 xmmword_18000F310 = 0i64; // weak
__int128 xmmword_18000F320 = 0i64; // weak
__int128 xmmword_18000F330 = 0i64; // weak
__int128 xmmword_18000F340 = 0i64; // weak
__int128 xmmword_18000F350 = 0i64; // weak
__int128 xmmword_18000F360 = 0i64; // weak
__int128 xmmword_18000F370 = 0i64; // weak
__int128 xmmword_18000F380 = 0i64; // weak
__int128 xmmword_18000F390 = 0i64; // weak
__int128 xmmword_18000F3A0 = 0i64; // weak
__int128 xmmword_18000F3B0 = 0i64; // weak
__int64 qword_18000F3C0 = 0i64; // weak
__int64 qword_18000F3C8 = 0i64; // weak
_UNKNOWN unk_18000F3D0; // weak
__int64 qword_18000F450; // weak
__int64 qword_18000F458; // weak
__int64 qword_18000F460; // weak
__int64 qword_18000F468; // weak
__int64 qword_18000F470; // weak
__int64 qword_18000F478; // weak
__int64 qword_18000F480; // weak
__int64 qword_18000F488; // weak
__int64 qword_18000F490; // weak
__int64 qword_18000F498; // weak
__int64 qword_18000F4A0; // weak
__int64 qword_18000F4A8; // weak
__int128 xmmword_18000F4D0; // weak
__int128 xmmword_18000F4E0; // weak
__int64 qword_18000F4F0; // weak
__int64 qword_18000F4F8; // weak
__int64 qword_18000F500; // weak
__int64 qword_18000F508; // weak
__int64 qword_18000F510; // weak
__int64 qword_18000F518; // weak
__int128 xmmword_18000F520; // weak
__int64 qword_18000F530; // weak
__int128 xmmword_18000F538; // weak
__int64 qword_18000F548; // weak
int dword_18000F550; // weak
char byte_18000F554; // weak
__int128 xmmword_18000F558; // weak
__int128 xmmword_18000F568; // weak
__int64 qword_18000F578; // weak
__int128 xmmword_18000F580; // weak
__int128 xmmword_18000F590; // weak
__int64 qword_18000F5A0; // weak
__int128 xmmword_18000F5A8; // weak
__int128 xmmword_18000F5B8; // weak
__int128 xmmword_18000F5C8; // weak
__int128 xmmword_18000F5D8; // weak
__int64 qword_18000F5E8; // weak
__int128 xmmword_18000F5F0; // weak
__int128 xmmword_18000F600; // weak
__int64 qword_18000F610; // weak
__int128 xmmword_18000F620; // weak
__int128 xmmword_18000F630; // weak
__int128 xmmword_18000F640; // weak
__int128 xmmword_18000F650; // weak
__int128 xmmword_18000F660; // weak
__int128 xmmword_18000F670; // weak
__int128 xmmword_18000F680; // weak
__int128 xmmword_18000F690; // weak
__int128 xmmword_18000F6A0; // weak
int dword_18000F6B0; // weak
_UNKNOWN unk_18000F6B4; // weak
int dword_18000F6BC; // weak
_UNKNOWN unk_18000F6C0; // weak
_UNKNOWN unk_18000F6D0; // weak
int dword_18000F6D8; // weak
char byte_18000F6E8; // weak
char byte_18000F6E9; // weak
__int64 qword_18000F6F0; // weak
__int64 qword_18000F6F8; // weak
__int64 qword_18000F700; // weak
__int64 qword_18000F708; // weak
__int64 qword_18000F710; // weak
__int64 qword_18000F718; // weak
int dword_18000F720; // weak
int dword_18000F724; // weak
_UNKNOWN unk_18000F728; // weak


//----- (0000000180001000) ----------------------------------------------------
__int64 sub_180001000()
{
  return UGS::System::L10N::LibraryRegistrant::LibraryRegistrant(
           (UGS::System::L10N::LibraryRegistrant *)&unk_18000F6B4,
           "libugpadvkins");
}
// 18000B198: using guessed type _QWORD UGS::System::L10N::LibraryRegistrant::LibraryRegistrant(UGS::System::L10N::LibraryRegistrant *__hidden this, const char *);

//----- (0000000180001020) ----------------------------------------------------
signed __int64 __fastcall sub_180001020(__int64 a1)
{
  __int64 v1; // rbx
  signed __int64 result; // rax

  v1 = a1;
  UF_MISC_set_program_name("<!<UGPKIN>!>");
  if ( (unsigned int)UF_initialize() )
  {
    sub_180001F10(v1, (__int64)"ERROR!: Advanced Kinematics Module Unavailable");
    result = 1i64;
  }
  else
  {
    UF_MISC_set_program_name("Kinematics");
    result = 0i64;
  }
  return result;
}
// 18000B1A8: using guessed type __int64 __fastcall UF_MISC_set_program_name(_QWORD);
// 18000B1B0: using guessed type __int64 UF_initialize(void);

//----- (0000000180001070) ----------------------------------------------------
__int64 __fastcall sub_180001070(const char *a1, unsigned int a2, __int64 a3, unsigned int a4)
{
  unsigned int v4; // ebx
  __int64 v5; // rdi
  unsigned int v6; // esi
  const char *v7; // rbp
  UGS::System *v8; // rax
  UGS::System *v9; // rax
  UGS::System *v10; // rax
  char v12; // [rsp+30h] [rbp-98h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( a4 )
  {
    v8 = (UGS::System *)_acrt_iob_func(1i64);
    UGS::System::SYSS_fprintf(v8, (struct _iobuf *)"%s, line %d:  %s\n", v7, v6, v5);
    if ( (unsigned int)UF_get_fail_message(v4, &v12) )
    {
      v9 = (UGS::System *)_acrt_iob_func(1i64);
      UGS::System::SYSS_fprintf(v9, (struct _iobuf *)"    returned a %d\n", (const char *)v4);
    }
    else
    {
      v10 = (UGS::System *)_acrt_iob_func(1i64);
      UGS::System::SYSS_fprintf(v10, (struct _iobuf *)"    returned error %d:  %s\n", (const char *)v4, &v12);
    }
  }
  return v4;
}
// 18000B168: using guessed type __int64 __fastcall _acrt_iob_func(_QWORD);
// 18000B188: using guessed type _DWORD UGS::System::SYSS_fprintf(UGS::System *__hidden this, struct _iobuf *, const char *, ...);
// 18000B1C8: using guessed type __int64 __fastcall UF_get_fail_message(_QWORD, _QWORD);

//----- (0000000180001130) ----------------------------------------------------
__int64 __fastcall sub_180001130(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v3; // [rsp+20h] [rbp-318h]
  __int64 v4; // [rsp+48h] [rbp-2F0h]
  __int128 v5[3]; // [rsp+70h] [rbp-2C8h]
  char v6; // [rsp+A0h] [rbp-298h]

  v1 = a1;
  sub_180008B30(a1, (double *)&v6);
  sub_180002500((__int64)&v6);
  sub_180008270(v1, (double *)v5);
  sub_1800038B0(v5, (__int64)&v3, (__int64)&v4);
  UF_MOM_set_double(v1, "pos_x");
  UF_MOM_set_double(v1, "pos_y");
  UF_MOM_set_double(v1, "pos_z");
  UF_MOM_set_double(v1, "pos_a1");
  UF_MOM_set_double(v1, "pos_a2");
  UF_MOM_set_double(v1, "alt_pos_x");
  UF_MOM_set_double(v1, "alt_pos_y");
  UF_MOM_set_double(v1, "alt_pos_z");
  UF_MOM_set_double(v1, "alt_pos_a1");
  UF_MOM_set_double(v1, "alt_pos_a2");
  return 0i64;
}
// 18000B2C8: using guessed type __int64 __fastcall UF_MOM_set_double(_QWORD, _QWORD);

//----- (0000000180001270) ----------------------------------------------------
signed __int64 __fastcall sub_180001270(__int64 a1, __int64 a2, int a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 v5; // rsi
  __int64 v6; // rdi
  __int128 v7; // xmm0
  UGS::System *v8; // rax
  char *v10; // rcx
  char *v11; // rdx
  char v12; // al
  char *v13; // rcx
  char *v14; // rdx
  char v15; // al
  UGS::System *v16; // rax
  const char *v17; // r8
  UGS::System *v18; // rax
  const char *v19; // r8
  char v20; // al
  char v21; // al
  int v22; // [rsp+20h] [rbp-E0h]
  char *v23; // [rsp+28h] [rbp-D8h]
  __int128 v24; // [rsp+30h] [rbp-D0h]
  __int128 v25; // [rsp+40h] [rbp-C0h]
  __int16 v26; // [rsp+50h] [rbp-B0h]
  char v27[160]; // [rsp+230h] [rbp+130h]
  char v28[400]; // [rsp+2D0h] [rbp+1D0h]
  __int64 v29; // [rsp+460h] [rbp+360h]
  __int16 v30; // [rsp+468h] [rbp+368h]
  int v31; // [rsp+5F0h] [rbp+4F0h]
  __int128 v32; // [rsp+780h] [rbp+680h]
  int v33; // [rsp+790h] [rbp+690h]
  char v34[416]; // [rsp+910h] [rbp+810h]
  char *v35; // [rsp+AC0h] [rbp+9C0h]
  unsigned int v36; // [rsp+AD0h] [rbp+9D0h]

  v4 = 0i64;
  v33 = 7632997;
  v5 = a4;
  v6 = a1;
  v32 = xmmword_18000BA18;
  v29 = 7881702178995269492i64;
  v36 = 0;
  v31 = 2105376;
  v30 = 101;
  if ( a3 != 2 )
  {
    v7 = xmmword_18000BA40;
    DWORD2(v25) = 7566446;
    *(_QWORD *)&v25 = 7308626857453232230i64;
LABEL_3:
    v24 = v7;
    v8 = (UGS::System *)_acrt_iob_func(1i64);
    UGS::System::SYSS_fprintf(v8, (struct _iobuf *)" ERROR : %s \n ", (const char *)&v24);
    return 1i64;
  }
  if ( (unsigned int)UF_MOM_ask_string(a1, &v29, &v35) )
  {
    v7 = xmmword_18000BA70;
    v26 = 116;
    v25 = xmmword_18000BA80;
    goto LABEL_3;
  }
  v10 = v35;
  v11 = (char *)(v34 - v35);
  do
  {
    v12 = *v10;
    v10[(_QWORD)v11] = *v10;
    ++v10;
  }
  while ( v12 );
  v13 = *(char **)(v5 + 8);
  v14 = (char *)(v27 - v13);
  do
  {
    v15 = *v13;
    v13[(_QWORD)v14] = *v13;
    ++v13;
  }
  while ( v15 );
  if ( (unsigned int)UF_OBJ_cycle_by_name(v34, &v36) )
  {
    v16 = (UGS::System *)_acrt_iob_func(1i64);
    UGS::System::SYSS_fprintf(v16, (struct _iobuf *)" UF_OBJ_cycle_by_name could not get the tool_object_tag \n", v17);
    return 1i64;
  }
  if ( v36 )
  {
    v23 = v28;
    if ( (unsigned int)UF_ATTR_read_value(v36, v27, 5i64, &v22) )
    {
      v18 = (UGS::System *)_acrt_iob_func(1i64);
      UGS::System::SYSS_fprintf(v18, (struct _iobuf *)" UF_ATTR_read_value could not return tool string \n", v19);
      return 1i64;
    }
    if ( v22 != 5 )
    {
      do
      {
        v20 = *((_BYTE *)&v31 + v4);
        v28[v4++] = v20;
      }
      while ( v20 );
    }
  }
  else
  {
    do
    {
      v21 = *((_BYTE *)&v31 + v4);
      v28[v4++] = v21;
    }
    while ( v21 );
  }
  UF_MOM_set_string(v6, &v32, v28);
  return 0i64;
}
// 18000B168: using guessed type __int64 __fastcall _acrt_iob_func(_QWORD);
// 18000B188: using guessed type _DWORD UGS::System::SYSS_fprintf(UGS::System *__hidden this, struct _iobuf *, const char *, ...);
// 18000B2D0: using guessed type __int64 __fastcall UF_MOM_set_string(_QWORD, _QWORD, _QWORD);
// 18000B2D8: using guessed type __int64 __fastcall UF_MOM_ask_string(_QWORD, _QWORD, _QWORD);
// 18000B2E8: using guessed type __int64 __fastcall UF_OBJ_cycle_by_name(_QWORD, _QWORD);
// 18000B2F8: using guessed type __int64 __fastcall UF_ATTR_read_value(_QWORD, _QWORD, _QWORD, _QWORD);
// 18000BA18: using guessed type __int128 xmmword_18000BA18;
// 18000BA40: using guessed type __int128 xmmword_18000BA40;
// 18000BA70: using guessed type __int128 xmmword_18000BA70;
// 18000BA80: using guessed type __int128 xmmword_18000BA80;
// 180001270: using guessed type char var_1A0[416];
// 180001270: using guessed type char var_880[160];
// 180001270: using guessed type char var_7E0[400];

//----- (00000001800014C0) ----------------------------------------------------
signed __int64 __fastcall sub_1800014C0(__int64 a1)
{
  __int64 v1; // r13
  void *v2; // rdi
  _QWORD *v3; // r14
  double *v4; // rsi
  double *v5; // rbx
  double *v6; // r12
  _QWORD *v7; // rax
  _QWORD *v8; // r15
  double v10; // xmm2_8
  double v11; // xmm0_8
  double v12; // xmm1_8
  double v13; // xmm0_8
  double v14; // xmm2_8
  double v15; // xmm1_8
  double v16; // xmm0_8
  double v17; // xmm1_8
  __m128 v18; // xmm0
  __int64 v19; // xmm1_8
  char *v20; // rax
  signed int v21; // ecx
  __int128 v22; // xmm1
  __int64 v23; // xmm0_8
  int v24; // eax
  bool v25; // zf
  __int64 v26; // rax
  __int64 v27; // xmm0_8
  __int64 v28; // rax
  __int64 v29; // xmm0_8
  __m128 v30; // [rsp+50h] [rbp-B0h]
  __int64 v31; // [rsp+60h] [rbp-A0h]
  void *Memory; // [rsp+68h] [rbp-98h]
  void *v33; // [rsp+70h] [rbp-90h]
  void *v34; // [rsp+78h] [rbp-88h]
  double v35; // [rsp+80h] [rbp-80h]
  double v36; // [rsp+88h] [rbp-78h]
  double v37; // [rsp+90h] [rbp-70h]
  double v38; // [rsp+98h] [rbp-68h]
  double v39; // [rsp+A0h] [rbp-60h]
  double v40; // [rsp+A8h] [rbp-58h]
  double v41; // [rsp+B0h] [rbp-50h]
  double v42; // [rsp+B8h] [rbp-48h]
  double v43; // [rsp+C0h] [rbp-40h]
  int v44; // [rsp+D0h] [rbp-30h]
  __int64 v45; // [rsp+D8h] [rbp-28h]
  __int128 v46; // [rsp+E0h] [rbp-20h]
  __int64 v47; // [rsp+F0h] [rbp-10h]
  __int128 v48; // [rsp+F8h] [rbp-8h]
  __int64 v49; // [rsp+108h] [rbp+8h]
  __int128 v50; // [rsp+110h] [rbp+10h]
  __int64 v51; // [rsp+120h] [rbp+20h]
  bool v52; // [rsp+128h] [rbp+28h]
  __int64 v53; // [rsp+130h] [rbp+30h]
  __int64 v54; // [rsp+138h] [rbp+38h]
  __int64 v55; // [rsp+140h] [rbp+40h]
  __int64 v56; // [rsp+148h] [rbp+48h]
  __int64 v57; // [rsp+150h] [rbp+50h]
  __int64 v58; // [rsp+158h] [rbp+58h]
  __int64 v59; // [rsp+160h] [rbp+60h]
  __m128d v60; // [rsp+170h] [rbp+70h]
  double v61; // [rsp+180h] [rbp+80h]
  __m128 v62; // [rsp+188h] [rbp+88h]
  __int64 v63; // [rsp+198h] [rbp+98h]
  __m128 v64; // [rsp+1A0h] [rbp+A0h]
  __int64 v65; // [rsp+1B0h] [rbp+B0h]
  __m128 v66; // [rsp+1B8h] [rbp+B8h]
  __int64 v67; // [rsp+1C8h] [rbp+C8h]
  __int128 v68; // [rsp+1D0h] [rbp+D0h]
  __int64 v69; // [rsp+1E0h] [rbp+E0h]
  __int128 v70; // [rsp+1E8h] [rbp+E8h]
  __int64 v71; // [rsp+1F8h] [rbp+F8h]
  __int128 v72; // [rsp+200h] [rbp+100h]
  __int64 v73; // [rsp+210h] [rbp+110h]
  __int128 v74; // [rsp+218h] [rbp+118h]
  __int64 v75; // [rsp+228h] [rbp+128h]
  __m128d v76; // [rsp+230h] [rbp+130h]
  double v77; // [rsp+240h] [rbp+140h]
  __m128 v78; // [rsp+248h] [rbp+148h]
  __int64 v79; // [rsp+258h] [rbp+158h]
  __m128 v80; // [rsp+260h] [rbp+160h]
  __int64 v81; // [rsp+270h] [rbp+170h]
  __m128 v82; // [rsp+278h] [rbp+178h]
  __int64 v83; // [rsp+288h] [rbp+188h]
  __int128 v84; // [rsp+290h] [rbp+190h]
  __int64 v85; // [rsp+2A0h] [rbp+1A0h]
  __int128 v86; // [rsp+2A8h] [rbp+1A8h]
  __int64 v87; // [rsp+2B8h] [rbp+1B8h]
  __int128 v88; // [rsp+2C0h] [rbp+1C0h]
  __int64 v89; // [rsp+2D0h] [rbp+1D0h]
  __int128 v90; // [rsp+2D8h] [rbp+1D8h]
  __int64 v91; // [rsp+2E8h] [rbp+1E8h]
  __int128 v92; // [rsp+2F0h] [rbp+1F0h]
  __int64 v93; // [rsp+300h] [rbp+200h]
  __int128 v94; // [rsp+308h] [rbp+208h]
  __int64 v95; // [rsp+318h] [rbp+218h]
  __int64 v96; // [rsp+4B0h] [rbp+3B0h]
  __int64 v97; // [rsp+4B8h] [rbp+3B8h]
  double *v98; // [rsp+4F0h] [rbp+3F0h]

  v1 = a1;
  v2 = malloc(0x988ui64);
  sub_180007A00(v1, (double *)v2);
  v3 = malloc(0x648ui64);
  sub_180007ED0(v1, (__int64)v3);
  Memory = malloc(0x330ui64);
  sub_180006DF0(v1, (__int64)Memory);
  v33 = malloc(0x40ui64);
  sub_180006FB0(v1, (double *)v33);
  v4 = (double *)malloc(0x508ui64);
  sub_180006570(v1, v4);
  v98 = (double *)malloc(0x508ui64);
  sub_1800069B0(v1, v98);
  v34 = malloc(0x1A0ui64);
  sub_180007220(v1, (__int64)v34);
  v5 = (double *)malloc(0x9E0ui64);
  sub_180007370(v1, v5);
  v6 = (double *)malloc(0x18ui64);
  sub_180008140(v1, v6);
  v7 = malloc(0x48ui64);
  v8 = v7;
  if ( !v7 )
    return 1i64;
  *v7 = v2;
  v7[1] = v3;
  v7[2] = Memory;
  v7[3] = v33;
  v7[5] = v98;
  v7[6] = v34;
  v7[4] = v4;
  v7[7] = v5;
  v7[8] = v6;
  sub_180008490(v1, v76.m128d_f64);
  sub_1800087D0(v1, v76.m128d_f64);
  sub_180008B30(v1, v76.m128d_f64);
  v10 = v76.m128d_f64[1] + v4[154];
  v41 = v76.m128d_f64[0] + v4[153];
  v11 = v41 + v98[153];
  v12 = v41 + *((double *)v2 + 302);
  v61 = v77;
  v42 = v10;
  v38 = v11;
  v13 = v10 + v98[154];
  v14 = v10 + *((double *)v2 + 303);
  v35 = v12;
  v15 = v77 + v4[155];
  v39 = v13;
  v36 = v14;
  v43 = v15;
  v16 = v15 + v98[155];
  v17 = v15 + *((double *)v2 + 304);
  v40 = v16;
  v76 = _mm_unpckl_pd((__m128d)*(unsigned __int64 *)&v76.m128d_f64[0], (__m128d)*(unsigned __int64 *)&v76.m128d_f64[1]);
  v60 = v76;
  v37 = v17;
  v62 = v78;
  v63 = v79;
  v64 = v80;
  v65 = v81;
  v66 = v82;
  v67 = v83;
  v68 = v84;
  v69 = v85;
  v70 = v86;
  v71 = v87;
  v72 = v88;
  v73 = v89;
  v74 = v90;
  v75 = v91;
  if ( strstr((const char *)v5, "POSX") )
  {
    v18 = v78;
    v19 = v79;
LABEL_15:
    v31 = v19;
    goto LABEL_16;
  }
  if ( strstr((const char *)v5, "POSY") )
  {
    v18 = v80;
    v19 = v81;
    goto LABEL_15;
  }
  if ( strstr((const char *)v5, "POSZ") )
    goto LABEL_14;
  if ( !strstr((const char *)v5, "NEGX") )
  {
    if ( strstr((const char *)v5, "NEGY") )
    {
      v31 = v81 ^ xmmword_18000BB10;
      v18 = _mm_xor_ps(v80, (__m128)xmmword_18000BB10);
      goto LABEL_16;
    }
    if ( strstr((const char *)v5, "NEGZ") )
    {
      v18 = _mm_xor_ps(v82, (__m128)xmmword_18000BB10);
      v31 = v83 ^ xmmword_18000BB10;
      goto LABEL_16;
    }
LABEL_14:
    v19 = v83;
    v18 = v82;
    goto LABEL_15;
  }
  v18 = _mm_xor_ps(v78, (__m128)xmmword_18000BB10);
  v31 = v79 ^ xmmword_18000BB10;
LABEL_16:
  v30 = v18;
  if ( strstr((const char *)v2, "5_axis_dual_table") )
  {
    v44 = 2;
  }
  else if ( strstr((const char *)v2, "5_axis_dual_head") )
  {
    v44 = 1;
  }
  else
  {
    v20 = strstr((const char *)v2, "5_axis_head_table");
    v21 = v44;
    if ( v20 )
      v21 = 3;
    v44 = v21;
  }
  v45 = *((_QWORD *)v2 + 298);
  v46 = v92;
  v47 = v93;
  v48 = v94;
  v22 = *(_OWORD *)(v4 + 153);
  v49 = v95;
  v23 = *((_QWORD *)v4 + 155);
  v50 = v22;
  v51 = v23;
  v24 = atoi((const char *)v2 + 397);
  v53 = v97;
  v25 = v24 == 1;
  v26 = v8[4];
  v52 = v25;
  v54 = *(_QWORD *)(v26 + 1200);
  v27 = *(_QWORD *)(v26 + 1208);
  v28 = v8[5];
  v55 = v27;
  v56 = *(_QWORD *)(v28 + 1200);
  v57 = *(_QWORD *)(v28 + 1208);
  v58 = v96;
  if ( strstr((const char *)v2, "5_axis_dual_table") )
    v29 = 0i64;
  else
    v29 = v3[199];
  v59 = v29;
  sub_180003B80((__int64)&v68, (__int128 *)&v60, (__int64)&v41, (__int64)(v4 + 156));
  free(v8);
  free(v2);
  if ( v3 )
    free(v3);
  if ( Memory )
    free(Memory);
  if ( v33 )
    free(v33);
  free(v4);
  free(v98);
  if ( v34 )
    free(v34);
  if ( v5 )
    free(v5);
  if ( v6 )
    free(v6);
  return 0i64;
}
// 18000BB10: using guessed type __int128 xmmword_18000BB10;

//----- (0000000180001B60) ----------------------------------------------------
__int64 __fastcall sub_180001B60(__int64 a1)
{
  __int64 v1; // rdi
  unsigned int v2; // ebx
  UGS::System *v3; // rax
  const char *v4; // r8
  __int64 result; // rax
  unsigned int v6; // ebx
  __int64 v7; // r8
  UGS::System *v8; // rax
  const char *v9; // r8
  unsigned int v10; // ebx
  UGS::System *v11; // rax
  const char *v12; // r8
  __int64 v13; // [rsp+20h] [rbp-98h]
  char v14; // [rsp+50h] [rbp-68h]
  char v15; // [rsp+80h] [rbp-38h]

  v1 = a1;
  v2 = sub_180008270(a1, (double *)&v14);
  if ( v2 )
  {
    v3 = (UGS::System *)_acrt_iob_func(1i64);
    UGS::System::SYSS_fprintf(v3, (struct _iobuf *)" SET_input_point failed in mom_map_to_rotated_csys\n ", v4);
    result = v2;
  }
  else
  {
    v6 = sub_180009320((__int64)&v14, (__int64)&v15);
    if ( v6 )
    {
      v8 = (UGS::System *)_acrt_iob_func(1i64);
      UGS::System::SYSS_fprintf(
        v8,
        (struct _iobuf *)" mom_process_input_gotos failed in mom_map_to_rotated_csys\n ",
        v9);
      result = v6;
    }
    else
    {
      v10 = sub_1800093E0((__int64)&v15, (__int64)&v13, v7);
      if ( v10 )
      {
        v11 = (UGS::System *)_acrt_iob_func(1i64);
        UGS::System::SYSS_fprintf(
          v11,
          (struct _iobuf *)" mom_transfer_gotos_rotd_mcsys failed in mom_map_to_rotated_csys\n ",
          v12);
        result = v10;
      }
      else
      {
        UF_MOM_set_double(v1, "pos_x");
        UF_MOM_set_double(v1, "pos_y");
        UF_MOM_set_double(v1, "pos_z");
        result = 0i64;
      }
    }
  }
  return result;
}
// 18000B168: using guessed type __int64 __fastcall _acrt_iob_func(_QWORD);
// 18000B188: using guessed type _DWORD UGS::System::SYSS_fprintf(UGS::System *__hidden this, struct _iobuf *, const char *, ...);
// 18000B2C8: using guessed type __int64 __fastcall UF_MOM_set_double(_QWORD, _QWORD);

//----- (0000000180001C90) ----------------------------------------------------
signed __int64 __fastcall sub_180001C90(__int64 a1, __int64 a2, signed int a3, __int64 a4)
{
  __int64 v4; // r14
  __int64 v5; // rbp
  signed int v6; // ebx
  _QWORD *v7; // rsi
  UGS::System *v8; // rax
  const char *v9; // r8
  char *v10; // rdx
  __int128 *v11; // rdi
  __int64 v12; // rbp
  __int64 v13; // rbx
  __int64 v14; // rdx
  __int64 v15; // rcx
  char v16; // al
  __int64 v17; // rcx
  char v18; // al
  __int64 v19; // rcx
  char v20; // al
  unsigned int v21; // ebx
  UGS::System *v22; // rax
  const char *v23; // r8
  signed __int64 result; // rax
  unsigned int v25; // ebx
  UGS::System *v26; // rax
  const char *v27; // r8
  UGS::System *v28; // rax
  const char *v29; // r8
  _QWORD *v30; // [rsp+20h] [rbp-68h]
  __int128 v31; // [rsp+28h] [rbp-60h]
  __int128 v32; // [rsp+38h] [rbp-50h]
  __int128 v33; // [rsp+48h] [rbp-40h]
  __int64 v34; // [rsp+90h] [rbp+8h]

  v34 = a1;
  v4 = a1;
  v31 = 0i64;
  v5 = a4;
  v6 = a3;
  v32 = 0i64;
  v33 = 0i64;
  v30 = malloc(0x90ui64);
  v7 = v30;
  if ( v6 > 7 || v6 == 1 )
  {
    v28 = (UGS::System *)_acrt_iob_func(1i64);
    UGS::System::SYSS_fprintf(v28, (struct _iobuf *)" Incorrect number of arguments\n", v29);
    v8 = (UGS::System *)_acrt_iob_func(1i64);
    v10 = " Number of arguments should be between 1 and 6\n ";
    goto LABEL_29;
  }
  if ( v6 == 2 * (v6 / 2) )
  {
    v8 = (UGS::System *)_acrt_iob_func(1i64);
    v10 = " Insufficient number of arguments, There should be               atleast 2 arguments\n ";
LABEL_29:
    UGS::System::SYSS_fprintf(v8, (struct _iobuf *)v10, v9);
    return 999i64;
  }
  if ( v6 > 1 )
  {
    v11 = &v31;
    v12 = v5 - (_QWORD)&v31;
    v13 = ((unsigned int)(v6 - 2) >> 1) + 1;
    do
    {
      v14 = *(_QWORD *)((char *)v11 + v12 + 8);
      v15 = 0i64;
      while ( 1 )
      {
        v16 = *(_BYTE *)(v14 + v15++);
        if ( v16 != aAaxis[v15 - 1] )
          break;
        if ( v15 == 6 )
        {
          *(_QWORD *)v11 = 4607182418800017408i64;
          goto LABEL_19;
        }
      }
      v17 = 0i64;
      while ( 1 )
      {
        v18 = *(_BYTE *)(v14 + v17++);
        if ( v18 != aBaxis[v17 - 1] )
          break;
        if ( v17 == 6 )
        {
          *(_QWORD *)v11 = 0x4000000000000000i64;
          goto LABEL_19;
        }
      }
      v19 = 0i64;
      while ( 1 )
      {
        v20 = *(_BYTE *)(v14 + v19++);
        if ( v20 != aCaxis[v19 - 1] )
          break;
        if ( v19 == 6 )
        {
          *(_QWORD *)v11 = 4613937818241073152i64;
          break;
        }
      }
LABEL_19:
      *((double *)v11 + 1) = strtod(*(const char **)((char *)v11 + v12 + 16), 0i64);
      ++v11;
      --v13;
    }
    while ( v13 );
    v7 = v30;
    v4 = v34;
  }
  v21 = sub_180008DF0(v4, v7, (__int64)&v31);
  if ( v21 )
  {
    v22 = (UGS::System *)_acrt_iob_func(1i64);
    UGS::System::SYSS_fprintf(v22, (struct _iobuf *)" SET_rotd_mcs_matrix failed in mom_rotate_mach_csys \n ", v23);
    result = v21;
  }
  else
  {
    v25 = sub_180009010(v4, (__int64)v7);
    if ( v25 )
    {
      v26 = (UGS::System *)_acrt_iob_func(1i64);
      UGS::System::SYSS_fprintf(
        v26,
        (struct _iobuf *)" SET_rotd_operation_data failed in mom_rotate_mach_csys \n ",
        v27);
      result = v25;
    }
    else
    {
      if ( v7 )
        free(v7);
      result = 0i64;
    }
  }
  return result;
}
// 18000B168: using guessed type __int64 __fastcall _acrt_iob_func(_QWORD);
// 18000B188: using guessed type _DWORD UGS::System::SYSS_fprintf(UGS::System *__hidden this, struct _iobuf *, const char *, ...);

//----- (0000000180001F00) ----------------------------------------------------
void *sub_180001F00()
{
  return &unk_18000F270;
}

//----- (0000000180001F10) ----------------------------------------------------
__int64 sub_180001F10(__int64 a1, __int64 a2, ...)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  _QWORD *v4; // rax
  __int64 result; // rax
  va_list va; // [rsp+60h] [rbp+18h]

  va_start(va, a2);
  v2 = a2;
  v3 = a1;
  v4 = sub_180001F00();
  result = _stdio_common_vsprintf(*v4 | 1i64, v3, -1i64, v2, 0i64, (__int64 *)va);
  if ( (signed int)result < 0 )
    result = 0xFFFFFFFFi64;
  return result;
}
// 18000B160: using guessed type __int64 __fastcall _stdio_common_vsprintf(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180001F70) ----------------------------------------------------
__int64 __fastcall ufusr(__int64 a1, _DWORD *a2)
{
  __int64 v2; // rbx
  _DWORD *v3; // rdi
  UGS::System *v4; // rax
  const char *v5; // r8
  __int64 v6; // rcx
  __int64 result; // rax
  unsigned int v8; // eax
  unsigned int v9; // eax
  unsigned int v10; // eax
  unsigned int v11; // eax
  unsigned int v12; // eax
  unsigned int v13; // eax
  __int64 v14; // [rsp+20h] [rbp-A8h]
  char v15; // [rsp+30h] [rbp-98h]
  __int64 v16; // [rsp+E8h] [rbp+20h]

  v2 = a1;
  v14 = 0i64;
  v3 = a2;
  if ( (unsigned int)sub_180001020((__int64)&v15) )
  {
    v4 = (UGS::System *)_acrt_iob_func(1i64);
    UGS::System::SYSS_fprintf(v4, (struct _iobuf *)"ERROR : Ugpost Advanced Kinematics license not found \n", v5);
    uc1601(&v15, 1i64);
    result = UF_terminate(v6);
  }
  else
  {
    UF_MOM_ask_interp_from_param(v2, &v14);
    UF_MOM_ask_mom(v2, &v16);
    v8 = UF_MOM_extend_xlator(v16, "MOM_load_kinematics", sub_1800014C0);
    sub_180001070(
      "o:\\nx1980\\ip1700\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      0x77u,
      (__int64)"UF_MOM_extend_xlator ( mom, \"MOM_load_kinematics\", mom_load_kinematics )",
      v8);
    v9 = UF_MOM_extend_xlator(v16, "MOM_convert_point", sub_180001130);
    sub_180001070(
      "o:\\nx1980\\ip1700\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      0x81u,
      (__int64)"UF_MOM_extend_xlator ( mom, \"MOM_convert_point\", mom_convert_point )",
      v9);
    v10 = UF_MOM_extend_xlator(v16, "MOM_get_tool_attribute", sub_180001270);
    sub_180001070(
      "o:\\nx1980\\ip1700\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      0x8Bu,
      (__int64)"UF_MOM_extend_xlator ( mom , \"MOM_get_tool_attribute\", mom_get_tool_attribute )",
      v10);
    v11 = UF_MOM_extend_xlator(v16, "MOM_rotate_mach_csys", sub_180001C90);
    sub_180001070(
      "o:\\nx1980\\ip1700\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      0x95u,
      (__int64)"UF_MOM_extend_xlator ( mom, \"MOM_rotate_mach_csys\", mom_rotate_mach_csys )",
      v11);
    v12 = UF_MOM_extend_xlator(v16, "MOM_map_to_rotated_csys", sub_180001B60);
    sub_180001070(
      "o:\\nx1980\\ip1700\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      0x9Fu,
      (__int64)"UF_MOM_extend_xlator ( mom, \"MOM_map_to_rotated_csys\", mom_map_to_rotated_csys )",
      v12);
    v13 = UF_MOM_extend_xlator(v16, "MOM_exit_kinematics_module", &UF_terminate);
    sub_180001070(
      "o:\\nx1980\\ip1700\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      0xA9u,
      (__int64)"UF_MOM_extend_xlator ( mom, \"MOM_exit_kinematics_module\", mom_exit_kinematics_module )",
      v13);
    result = v16;
    qword_18000F278 = v16;
    *v3 = 0;
  }
  return result;
}
// 18000B168: using guessed type __int64 __fastcall _acrt_iob_func(_QWORD);
// 18000B188: using guessed type _DWORD UGS::System::SYSS_fprintf(UGS::System *__hidden this, struct _iobuf *, const char *, ...);
// 18000B2B8: using guessed type __int64 __fastcall UF_MOM_ask_mom(_QWORD, _QWORD);
// 18000B2C0: using guessed type __int64 __fastcall UF_MOM_ask_interp_from_param(_QWORD, _QWORD);
// 18000B2E0: using guessed type __int64 __fastcall UF_MOM_extend_xlator(_QWORD, _QWORD, _QWORD);
// 18000B2F0: using guessed type __int64 __cdecl UF_terminate(_QWORD);
// 18000B308: using guessed type __int64 __fastcall uc1601(_QWORD, _QWORD);
// 18000F278: using guessed type __int64 qword_18000F278;

//----- (0000000180002170) ----------------------------------------------------
__int64 __fastcall sub_180002170(double *a1, double *a2, double *a3, double *a4)
{
  double *v4; // rsi
  double *v5; // rdi
  double *v6; // r15
  double *v7; // r14
  double v8; // xmm5_8
  bool v9; // zf
  __int64 result; // rax
  double v11; // xmm4_8
  double v12; // xmm3_8
  double v13; // xmm2_8
  double v14; // xmm1_8
  double v15; // xmm0_8
  double v16; // xmm2_8
  double v17; // xmm0_8
  double v18; // xmm1_8
  double v19; // xmm0_8
  double v20; // xmm1_8
  double v21; // [rsp+8h] [rbp-39h]
  double v22; // [rsp+10h] [rbp-31h]
  double v23; // [rsp+18h] [rbp-29h]
  double v24; // [rsp+20h] [rbp-21h]
  double v25; // [rsp+28h] [rbp-19h]
  double v26; // [rsp+30h] [rbp-11h]
  double v27; // [rsp+38h] [rbp-9h]
  double v28; // [rsp+40h] [rbp-1h]
  double v29; // [rsp+48h] [rbp+7h]
  char v30; // [rsp+50h] [rbp+Fh]
  double v31; // [rsp+98h] [rbp+57h]
  double vars0; // [rsp+A0h] [rbp+5Fh]
  double *v33; // [rsp+B8h] [rbp+77h]
  double *v34; // [rsp+C0h] [rbp+7Fh]

  v4 = a1;
  v5 = a3;
  v6 = a2;
  v7 = a4;
  UF_VEC3_sub(a1 + 3, a1, &v24);
  UF_VEC3_sub(v4, v6, &v30);
  UF_VEC3_sub(v6 + 3, v6, &v24);
  UF_VEC3_dot(&v21, &v30, &v28);
  UF_VEC3_dot(&v24, &v21, &v27);
  UF_VEC3_dot(&v24, &v30, &v29);
  UF_VEC3_dot(&v24, &v24, &vars0);
  UF_VEC3_dot(&v21, &v21, &v31);
  v8 = vars0;
  if ( vars0 != 0.0 )
  {
    if ( v31 != 0.0 )
    {
      v11 = v27;
      v12 = v11 * v11 - v31 * vars0;
      if ( v12 == 0.0 )
        goto LABEL_16;
      v13 = v27 * v27 / (v31 * vars0);
      if ( v13 < 0.0 )
        *(_QWORD *)&v13 ^= xmmword_18000BB10;
      if ( v13 >= 1.0 - *(double *)&qword_18000F000 * 2.0 )
      {
LABEL_16:
        UF_VEC3_copy(v4, v5);
        *v33 = 0.0;
        result = sub_180002400((__int64)v5, v6, v7, v34);
        if ( (_DWORD)result )
          return result;
      }
      else
      {
        v14 = v24;
        v15 = v21;
        v16 = (vars0 * v28 - v29 * v27) / v12;
        *v33 = v16;
        *v34 = (v16 * v11 + v29) / v8;
        *v5 = v15 * *v33 + *v4;
        v17 = v22;
        *v7 = v14 * *v34 + *v6;
        v18 = v25;
        v5[1] = v17 * *v33 + v4[1];
        v19 = v23;
        v7[1] = v18 * *v34 + v6[1];
        v20 = v26;
        v5[2] = v19 * *v33 + v4[2];
        v7[2] = v20 * *v34 + v6[2];
      }
      return 0i64;
    }
    goto LABEL_6;
  }
  UF_VEC3_copy(v6, v7);
  v9 = v31 == 0.0;
  *v34 = 0.0;
  if ( v9 )
  {
LABEL_6:
    UF_VEC3_copy(v4, v5);
    *v33 = 0.0;
    return 0i64;
  }
  result = sub_180002400((__int64)v7, v4, v5, v33);
  if ( !(_DWORD)result )
    return 0i64;
  return result;
}
// 18000B1C0: using guessed type __int64 __fastcall UF_VEC3_dot(_QWORD, _QWORD, _QWORD);
// 18000B1F8: using guessed type __int64 __fastcall UF_VEC3_copy(_QWORD, _QWORD);
// 18000B260: using guessed type __int64 __fastcall UF_VEC3_sub(_QWORD, _QWORD, _QWORD);
// 18000BB10: using guessed type __int128 xmmword_18000BB10;
// 18000F000: using guessed type __int64 qword_18000F000;

//----- (0000000180002400) ----------------------------------------------------
__int64 __fastcall sub_180002400(__int64 a1, double *a2, double *a3, double *a4)
{
  double *v4; // rbp
  __int64 v5; // rbx
  double *v6; // rsi
  double *v7; // rdi
  double v8; // xmm6_8
  double v9; // xmm1_8
  double v10; // xmm0_8
  double v12; // [rsp+20h] [rbp-48h]
  double v13; // [rsp+28h] [rbp-40h]
  double v14; // [rsp+30h] [rbp-38h]
  char v15; // [rsp+38h] [rbp-30h]
  double v16; // [rsp+78h] [rbp+10h]

  v4 = a3;
  v5 = a1;
  v6 = a4;
  v7 = a2;
  UF_VEC3_sub(a2 + 3, a2, &v12);
  UF_VEC3_sub(v5, v7, &v15);
  v8 = v12 * v12 + v13 * v13 + v14 * v14;
  if ( v8 <= 0.0 )
  {
    *v6 = 0.0;
    UF_VEC3_copy(v7, v4);
  }
  else
  {
    UF_VEC3_dot(&v12, &v15, &v16);
    v9 = v14;
    v10 = v16 / v8;
    *v6 = v16 / v8;
    *v4 = v10 * v12 + *v7;
    v4[1] = v13 * *v6 + v7[1];
    v4[2] = v9 * *v6 + v7[2];
  }
  return 0i64;
}
// 18000B1C0: using guessed type __int64 __fastcall UF_VEC3_dot(_QWORD, _QWORD, _QWORD);
// 18000B1F8: using guessed type __int64 __fastcall UF_VEC3_copy(_QWORD, _QWORD);
// 18000B260: using guessed type __int64 __fastcall UF_VEC3_sub(_QWORD, _QWORD, _QWORD);

//----- (0000000180002500) ----------------------------------------------------
__int64 __fastcall sub_180002500(__int64 a1)
{
  __int64 v1; // rdx

  v1 = qword_18000F3C8;
  *(_OWORD *)(qword_18000F3C8 + 16) = *(_OWORD *)(a1 + 192);
  *(_QWORD *)(v1 + 32) = *(_QWORD *)(a1 + 208);
  *(_OWORD *)(v1 + 40) = *(_OWORD *)(a1 + 216);
  *(_QWORD *)(v1 + 56) = *(_QWORD *)(a1 + 232);
  *(_QWORD *)(v1 + 136) = *(_QWORD *)(a1 + 640);
  return 0i64;
}
// 18000F3C8: using guessed type __int64 qword_18000F3C8;

//----- (0000000180002550) ----------------------------------------------------
signed __int64 __fastcall sub_180002550(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  char v3; // r15
  bool v4; // zf
  __int64 v5; // rbx
  __int64 v6; // rdi
  __int64 v7; // r14
  unsigned int v8; // er13
  __int128 v9; // xmm1
  __int128 v10; // xmm0
  __int64 v11; // rdx
  __int64 v13; // rsi
  double v14; // xmm14_8
  double v15; // xmm15_8
  double v16; // xmm11_8
  int v17; // eax
  double v18; // xmm8_8
  double v19; // xmm0_8
  const char *v20; // rdx
  __int64 v21; // r8
  __int64 v22; // xmm12_8
  double v23; // xmm9_8
  double v24; // xmm7_8
  double v25; // xmm0_8
  double v26; // xmm10_8
  double v27; // xmm11_8
  double v28; // xmm10_8
  double v29; // xmm11_8
  double v30; // xmm11_8
  double v31; // xmm0_8
  double v32; // xmm10_8
  double v33; // xmm6_8
  double v34; // xmm0_8
  double v35; // xmm3_8
  double v36; // xmm2_8
  double v37; // xmm1_8
  double v38; // xmm4_8
  double v39; // xmm6_8
  double v40; // xmm13_8
  double v41; // xmm1_8
  double v42; // xmm13_8
  double v43; // xmm11_8
  double v44; // xmm1_8
  double v45; // xmm15_8
  double v46; // xmm0_8
  double v47; // xmm6_8
  double v48; // xmm10_8
  double v49; // xmm9_8
  double v50; // xmm8_8
  double v51; // xmm0_8
  double v52; // xmm13_8
  double v53; // xmm0_8
  double v54; // xmm6_8
  __int64 v55; // xmm13_8
  double v56; // xmm1_8
  double v57; // xmm9_8
  double v58; // xmm0_8
  double v59; // xmm6_8
  double v60; // xmm0_8
  double v61; // xmm10_8
  double v62; // xmm2_8
  double v63; // xmm4_8
  double v64; // xmm6_8
  double v65; // xmm5_8
  double v66; // xmm10_8
  double v67; // xmm2_8
  double v68; // xmm0_8
  double v69; // xmm0_8
  double v70; // xmm2_8
  __int128 v71; // xmm2
  __int64 v72; // xmm1_8
  __int64 v73; // xmm6_8
  int v74; // eax
  double v75; // xmm6_8
  __int64 v76; // rdx
  __int64 v77; // ST20_8
  __int64 v78; // rdx
  __int64 v79; // r8
  __int64 v80; // rdx
  __int64 v81; // r8
  __m128i v82; // xmm1
  __m128 v83; // xmm6
  __m128i v84; // xmm7
  __int64 v85; // rdx
  __int64 v86; // r8
  __int64 v87; // rdx
  __int64 v88; // r8
  __m128 v89; // xmm0
  signed int v90; // esi
  __int64 v91; // rcx
  __int64 v92; // rdx
  __int128 v93; // xmm1
  __int64 v94; // rdx
  __int64 v95; // rdx
  __int128 *v96; // r8
  __int64 v97; // rdx
  __int64 v98; // r8
  __int64 v99; // rdx
  __int64 v100; // rdx
  __int128 v101; // xmm1
  __int64 v102; // rdx
  __int128 v103; // xmm1
  double v104; // xmm0_8
  double v105; // xmm0_8
  __int64 v106; // [rsp+20h] [rbp-E0h]
  __int64 v107; // [rsp+20h] [rbp-E0h]
  __m128 v108; // [rsp+40h] [rbp-C0h]
  __m128 v109; // [rsp+50h] [rbp-B0h]
  __m128i v110; // [rsp+60h] [rbp-A0h]
  char v111; // [rsp+80h] [rbp-80h]
  double v112; // [rsp+88h] [rbp-78h]
  double v113; // [rsp+90h] [rbp-70h]
  double v114; // [rsp+98h] [rbp-68h]
  __int128 v115; // [rsp+A0h] [rbp-60h]
  __int128 v116; // [rsp+B0h] [rbp-50h]
  __int128 v117; // [rsp+C0h] [rbp-40h]
  char v118; // [rsp+D0h] [rbp-30h]
  int v119; // [rsp+1D8h] [rbp+D8h]
  double v120; // [rsp+1E0h] [rbp+E0h]
  double v121; // [rsp+1E8h] [rbp+E8h]

  v3 = 0;
  v4 = byte_18000F554 == 0;
  v5 = (__int64)a3;
  *a3 = 0i64;
  v6 = (__int64)a2;
  *a2 = 0i64;
  v7 = a1;
  a3[1] = 0i64;
  v8 = 0;
  a2[1] = 0i64;
  a3[2] = 0i64;
  a2[2] = 0i64;
  a3[3] = 0i64;
  a2[3] = 0i64;
  a3[4] = 0i64;
  a2[4] = 0i64;
  if ( !v4 )
  {
    sub_180006110((__int64)"\n------------------------------------------------------\n");
    UGS::System::SYSS_printf(
      (UGS::System *)"Starting old_pcoord_t[] = (%f,%f,%f,%f,%f,%f)\n",
      *(const char **)v7,
      *(_QWORD *)(v7 + 8),
      *(_QWORD *)(v7 + 16),
      *(_QWORD *)(v7 + 24),
      *(_OWORD *)(v7 + 32));
  }
  if ( dword_18000F550 == 3 )
  {
    UF_MTX3_vec_multiply_t(v7, &unk_18000BBC0, &v115);
    UF_MTX3_vec_multiply_t(v7 + 24, &unk_18000BBC0, (char *)&v116 + 8);
  }
  else
  {
    v9 = *(_OWORD *)(v7 + 16);
    v115 = *(_OWORD *)v7;
    v10 = *(_OWORD *)(v7 + 32);
    v116 = v9;
    v117 = v10;
  }
  UF_VEC3_is_zero((char *)&v116 + 8, a2, &v119);
  if ( v119 )
    return 4i64;
  UF_VEC3_unitize((char *)&v116 + 8, v11, &v111, &v112);
  v13 = qword_18000F3C8;
  v14 = v112;
  v15 = v113;
  v16 = v114;
  v17 = *(_DWORD *)qword_18000F3C8;
  if ( *(_DWORD *)qword_18000F3C8 != 3 )
  {
    v47 = 0.0;
    v48 = *(double *)&qword_18000F458;
    v22 = xmmword_18000C190;
    v24 = *(double *)&qword_18000F000;
    v49 = *(double *)&qword_18000F470 * v113 + *(double *)&qword_18000F450 * v112 + *(double *)&qword_18000F490 * v114;
    v50 = *(double *)&qword_18000F478 * v113 + *(double *)&qword_18000F458 * v112 + *(double *)&qword_18000F498 * v114;
    if ( *(double *)&qword_18000F000 < COERCE_DOUBLE(qword_18000F2B8 & xmmword_18000C190) )
    {
      if ( v17 == 1 || v17 == 2 )
        v47 = *(double *)&qword_18000F2C0;
      v47 = (v47
           - (*(double *)&qword_18000F480 * v113
            + *(double *)&qword_18000F460 * v112
            + *(double *)&qword_18000F4A0 * v114
            - (*(double *)&qword_18000F488 * v113
             + *(double *)&qword_18000F468 * v112
             + *(double *)&qword_18000F4A8 * v114)
            * *(double *)&qword_18000F288)
           * *(double *)&qword_18000F2B0)
          / *(double *)&qword_18000F2B8;
    }
    else
    {
      v3 = 1;
    }
    v51 = sqrt(v50 * v50 + v49 * v49);
    v121 = v51;
    if ( v24 < COERCE_DOUBLE(*(_QWORD *)&v49 & xmmword_18000C190)
      || v24 < COERCE_DOUBLE(*(_QWORD *)&v50 & xmmword_18000C190) )
    {
      v53 = atan2(v50, v49);
      v120 = v53;
      v52 = v53;
      v51 = v121;
    }
    else
    {
      v52 = 0.0;
      v120 = 0.0;
    }
    if ( v24 < COERCE_DOUBLE(*(_QWORD *)&v51 & xmmword_18000C190) )
      v54 = v47 / v51;
    else
      v54 = 0.0;
    if ( COERCE_DOUBLE(*(_QWORD *)&v54 & xmmword_18000C190) <= v24 + 1.0 )
    {
      v56 = 1.0 - v54 * v54;
      if ( v24 >= COERCE_DOUBLE(*(_QWORD *)&v56 & xmmword_18000C190) )
        v56 = 0.0;
      if ( v24 < COERCE_DOUBLE(COERCE_UNSIGNED_INT64(v54 - 1.0) & xmmword_18000C190) )
        v57 = sqrt(v56);
      else
        v57 = 0.0;
      v18 = atan2(v54, v57) + v52;
      v55 = xmmword_18000BB10;
      *(double *)v108.m128_u64 = v18;
      v58 = atan2(v54, COERCE_DOUBLE(*(_QWORD *)&v57 ^ xmmword_18000BB10));
      v23 = v58 + v120;
    }
    else
    {
      UGS::System::SYSS_printf(
        (UGS::System *)"INPUT Point =%-.4f,%-.4f,%-.4f,%-.8f,%-.8f,%-.8f\n",
        *(const char **)v7,
        *(_QWORD *)(v7 + 8),
        *(_QWORD *)(v7 + 16),
        *(_QWORD *)(v7 + 24),
        *(_OWORD *)(v7 + 32));
      UGS::System::SYSS_printf(
        (UGS::System *)"WARNING: Degenerated G_lambda(%f) out of range (-1, 1)\n",
        *(const char **)&v54);
      v24 = *(double *)&qword_18000F000;
      v18 = 0.0;
      v13 = qword_18000F3C8;
      v3 = 1;
      v48 = *(double *)&qword_18000F458;
      v23 = 0.0;
      v55 = xmmword_18000BB10;
      v108.m128_u64[0] = 0i64;
    }
    *(_QWORD *)&v59 = qword_18000F2C8 & xmmword_18000C190;
    *(double *)&v108.m128_u64[1] = v23;
    *(double *)v110.m128i_i64 = v59;
    v120 = sin(v18);
    v60 = cos(v18);
    *(double *)v109.m128_u64 = v60;
    if ( v24 < v59 )
    {
      v63 = v60 * *(double *)&qword_18000F2B0;
      *(_QWORD *)&v64 = COERCE_UNSIGNED_INT64(*(double *)&qword_18000F2B8 * *(double *)&qword_18000F288) ^ v55;
      *(_QWORD *)&v65 = COERCE_UNSIGNED_INT64(v120 * *(double *)&qword_18000F2B0) ^ v55;
      v121 = (v48 * v120 + *(double *)&qword_18000F450 * v60 - *(double *)&qword_18000F468 * *(double *)&qword_18000F280)
           * v14
           + (*(double *)&qword_18000F478 * v120
            + *(double *)&qword_18000F470 * *(double *)v109.m128_u64
            - *(double *)&qword_18000F488 * *(double *)&qword_18000F280)
           * v15;
      v121 = (v121
            + (*(double *)&qword_18000F498 * v120
             + *(double *)&qword_18000F490 * *(double *)v109.m128_u64
             - *(double *)&qword_18000F4A8 * *(double *)&qword_18000F280)
            * v16)
           / *(double *)&qword_18000F2C8;
      v66 = (v48 * (v60 * *(double *)&qword_18000F2B0)
           + *(double *)&qword_18000F450 * v65
           + *(double *)&qword_18000F460 * *(double *)&qword_18000F2B8
           + *(double *)&qword_18000F468 * v64)
          * v14;
      v67 = (*(double *)&qword_18000F478 * (v60 * *(double *)&qword_18000F2B0)
           + *(double *)&qword_18000F470 * v65
           + *(double *)&qword_18000F480 * *(double *)&qword_18000F2B8
           + *(double *)&qword_18000F488 * v64)
          * v15;
      v68 = *(double *)&qword_18000F4A8 * v64;
      v59 = *(double *)v110.m128i_i64;
      *(_QWORD *)&v61 = COERCE_UNSIGNED_INT64(
                          (v66
                         + v67
                         + (*(double *)&qword_18000F498 * v63
                          + *(double *)&qword_18000F490 * v65
                          + *(double *)&qword_18000F4A0 * *(double *)&qword_18000F2B8
                          + v68)
                         * v16)
                        / *(double *)&qword_18000F2C8) ^ v55;
      v62 = v121;
    }
    else
    {
      v61 = 0.0;
      v62 = 0.0;
    }
    if ( v24 < COERCE_DOUBLE(*(_QWORD *)&v62 & xmmword_18000C190)
      || v24 < COERCE_DOUBLE(*(_QWORD *)&v61 & xmmword_18000C190) )
    {
      v109.m128_u64[0] = atan2(v62, v61);
      v26 = *(double *)v109.m128_u64;
    }
    else
    {
      v26 = 0.0;
      v3 = 1;
      v109.m128_u64[0] = 0i64;
    }
    v120 = sin(v23);
    v69 = cos(v23);
    v121 = v69;
    if ( v24 < v59 )
    {
      *(double *)v110.m128i_i64 = (*(double *)&qword_18000F458 * v120
                                 + *(double *)&qword_18000F450 * v69
                                 - *(double *)&qword_18000F468 * *(double *)&qword_18000F280)
                                * v14
                                + (*(double *)&qword_18000F478 * v120
                                 + *(double *)&qword_18000F470 * v121
                                 - *(double *)&qword_18000F488 * *(double *)&qword_18000F280)
                                * v15;
      v70 = (*(double *)v110.m128i_i64
           + (*(double *)&qword_18000F498 * v120
            + *(double *)&qword_18000F490 * v121
            - *(double *)&qword_18000F4A8 * *(double *)&qword_18000F280)
           * v16)
          / *(double *)&qword_18000F2C8;
      *(_QWORD *)&v44 = COERCE_UNSIGNED_INT64(
                          ((*(double *)&qword_18000F458 * (v69 * *(double *)&qword_18000F2B0)
                          + *(double *)&qword_18000F450
                          * COERCE_DOUBLE(COERCE_UNSIGNED_INT64(v120 * *(double *)&qword_18000F2B0) ^ v55)
                          + *(double *)&qword_18000F460 * *(double *)&qword_18000F2B8
                          + *(double *)&qword_18000F468
                          * COERCE_DOUBLE(COERCE_UNSIGNED_INT64(*(double *)&qword_18000F2B8 * *(double *)&qword_18000F288) ^ v55))
                         * v14
                         + (*(double *)&qword_18000F478 * (v69 * *(double *)&qword_18000F2B0)
                          + *(double *)&qword_18000F470
                          * COERCE_DOUBLE(COERCE_UNSIGNED_INT64(v120 * *(double *)&qword_18000F2B0) ^ v55)
                          + *(double *)&qword_18000F480 * *(double *)&qword_18000F2B8
                          + *(double *)&qword_18000F488
                          * COERCE_DOUBLE(COERCE_UNSIGNED_INT64(*(double *)&qword_18000F2B8 * *(double *)&qword_18000F288) ^ v55))
                         * v15
                         + (*(double *)&qword_18000F498 * (v69 * *(double *)&qword_18000F2B0)
                          + *(double *)&qword_18000F490
                          * COERCE_DOUBLE(COERCE_UNSIGNED_INT64(v120 * *(double *)&qword_18000F2B0) ^ v55)
                          + *(double *)&qword_18000F4A0 * *(double *)&qword_18000F2B8
                          + *(double *)&qword_18000F4A8
                          * COERCE_DOUBLE(COERCE_UNSIGNED_INT64(*(double *)&qword_18000F2B8 * *(double *)&qword_18000F288) ^ v55))
                         * v16)
                        / *(double *)&qword_18000F2C8) ^ v55;
      v24 = *(double *)&qword_18000F000;
      v22 = xmmword_18000C190;
    }
    else
    {
      v44 = 0.0;
      v70 = 0.0;
    }
    if ( v24 >= COERCE_DOUBLE(*(_QWORD *)&v70 & v22) && v24 >= COERCE_DOUBLE(*(_QWORD *)&v44 & v22) )
    {
      v27 = 0.0;
      v3 = 1;
      v109.m128_u64[1] = 0i64;
      goto LABEL_66;
    }
    v46 = v70;
    goto LABEL_65;
  }
  if ( dword_18000F550 )
  {
    if ( (dword_18000F550 - 1) & 0xFFFFFFFD )
      return 2i64;
    v28 = *(double *)&qword_18000F500;
    v22 = xmmword_18000C190;
    v24 = *(double *)&qword_18000F000;
    if ( *(double *)&qword_18000F000 >= COERCE_DOUBLE(COERCE_UNSIGNED_INT64(*(double *)&qword_18000F500 - 1.0) & xmmword_18000C190)
      || (v29 = (v114 - *(double *)&qword_18000F500 * *(double *)&qword_18000F500)
              / (1.0 - *(double *)&qword_18000F500 * *(double *)&qword_18000F500),
          COERCE_DOUBLE(*(_QWORD *)&v29 & xmmword_18000C190) > *(double *)&qword_18000F000 + 1.0) )
    {
      v3 = 1;
      v108 = (__m128)xmmword_18000F5A8;
      v18 = *(double *)&xmmword_18000F5A8;
      *(_QWORD *)&v23 = (unsigned __int128)_mm_shuffle_ps(v108, v108, 238);
    }
    else
    {
      sub_1800059B0(v29);
      *(double *)v108.m128_u64 = v29;
      *(_QWORD *)&v23 = *(_QWORD *)&v29 ^ xmmword_18000BB10;
      v18 = v29;
      v108.m128_u64[1] = *(_QWORD *)&v29 ^ xmmword_18000BB10;
    }
    v30 = *(double *)&qword_18000F4F8;
    v31 = v28 * *(double *)&qword_18000F4F0;
    v32 = v28 * *(double *)&qword_18000F4F8;
    v120 = v31;
    v121 = v32;
    v33 = sin(v18);
    v34 = cos(v18);
    v35 = (1.0 - v34) * v32 - *(double *)&qword_18000F4F0 * v33;
    v36 = v30 * v33 + (1.0 - v34) * v120;
    v37 = v15 * v35 + v14 * v36;
    v38 = v15 * v36 - v14 * v35;
    if ( v24 < COERCE_DOUBLE(*(_QWORD *)&v38 & xmmword_18000C190)
      || v24 < COERCE_DOUBLE(*(_QWORD *)&v37 & xmmword_18000C190) )
    {
      v109.m128_u64[0] = atan2(v38, v37);
      v26 = *(double *)v109.m128_u64;
    }
    else
    {
      v26 = *(double *)&xmmword_18000F5B8;
      v3 = 1;
      v109.m128_u64[0] = xmmword_18000F5B8;
    }
    v39 = sin(v23);
    v40 = 1.0 - cos(v23);
    v41 = v40;
    v42 = v40 * v121 - *(double *)&qword_18000F4F0 * v39;
    v43 = v30 * v39 + v41 * v120;
    v44 = v15 * v42 + v43 * v14;
    v45 = v15 * v43 - v42 * v14;
    if ( v24 >= COERCE_DOUBLE(*(_QWORD *)&v45 & xmmword_18000C190)
      && v24 >= COERCE_DOUBLE(*(_QWORD *)&v44 & xmmword_18000C190) )
    {
      v27 = *((double *)&xmmword_18000F5B8 + 1);
      v3 = 1;
      v109.m128_u64[1] = *((_QWORD *)&xmmword_18000F5B8 + 1);
      goto LABEL_66;
    }
    v46 = v45;
LABEL_65:
    v109.m128_u64[1] = atan2(v46, v44);
    v27 = *(double *)&v109.m128_u64[1];
    if ( !v3 )
      goto LABEL_69;
    goto LABEL_66;
  }
  v108.m128_u64[0] = asin(COERCE_DOUBLE(*(_QWORD *)&v113 ^ xmmword_18000BB10));
  v18 = *(double *)v108.m128_u64;
  v19 = sqrt(v14 * v14 + v16 * v16);
  sub_1800059B0(v19);
  v22 = xmmword_18000C190;
  v23 = v19;
  v24 = *(double *)&qword_18000F000;
  *(double *)&v108.m128_u64[1] = v19;
  if ( *(double *)&qword_18000F000 >= COERCE_DOUBLE(COERCE_UNSIGNED_INT64(*(double *)v108.m128_u64 - v19) & xmmword_18000C190) )
  {
    *(_QWORD *)&v25 = *(_QWORD *)&v19 ^ xmmword_18000BB10;
    sub_1800059B0(v25);
    *(double *)&v108.m128_u64[1] = v25;
    v23 = v25;
  }
  if ( v24 < COERCE_DOUBLE(*(_QWORD *)&v14 & xmmword_18000C190)
    || v24 < COERCE_DOUBLE(*(_QWORD *)&v16 & xmmword_18000C190) )
  {
    v109.m128_u64[0] = atan2(v14, v16);
    v26 = *(double *)v109.m128_u64;
    v109.m128_u64[1] = atan2(
                         COERCE_DOUBLE(*(_QWORD *)&v14 ^ xmmword_18000BB10),
                         COERCE_DOUBLE(*(_QWORD *)&v16 ^ xmmword_18000BB10));
    v27 = *(double *)&v109.m128_u64[1];
    goto LABEL_69;
  }
  v3 = 1;
  v109 = (__m128)xmmword_18000F5B8;
  v26 = *(double *)&xmmword_18000F5B8;
  *(_QWORD *)&v27 = (unsigned __int128)_mm_shuffle_ps(v109, v109, 238);
LABEL_66:
  if ( *(_DWORD *)v13 != 3 )
  {
    v108 = (__m128)xmmword_18000F5A8;
    v18 = *(double *)&xmmword_18000F5A8;
    *(_QWORD *)&v23 = (unsigned __int128)_mm_shuffle_ps(v108, v108, 238);
    v109 = (__m128)xmmword_18000F5B8;
    v26 = *(double *)&xmmword_18000F5B8;
    *(_QWORD *)&v27 = (unsigned __int128)_mm_shuffle_ps((__m128)xmmword_18000F5B8, (__m128)xmmword_18000F5B8, 238);
  }
  v8 = 1;
LABEL_69:
  if ( !byte_18000F009 || (unsigned int)(*(_DWORD *)v13 - 2) > 1 )
  {
    if ( *(_DWORD *)v13 == 1 )
    {
      v71 = v115;
      v72 = v116;
      *(_OWORD *)v6 = v115;
      *(_QWORD *)(v6 + 16) = v72;
      *(_OWORD *)v5 = v71;
      *(_QWORD *)(v5 + 16) = v72;
    }
    else if ( (unsigned int)(*(_DWORD *)v13 - 2) <= 1 )
    {
      if ( byte_18000F554 )
      {
        UGS::System::SYSS_printf((UGS::System *)"About adjusting theta with initial angle...\n", v20);
        UGS::System::SYSS_printf(
          (UGS::System *)"computing t1[0]=%f, t2[0]=%f, (Init_T1[0]*2-t1[0])=%f,(Init_T2[0]*2-t2[0])=%f\n",
          COERCE_CONST_CHAR__(v18 * 57.29577951308235),
          v26 * 57.29577951308235,
          (*(double *)&xmmword_18000F4D0 * 2.0 - v18) * 57.29577951308235,
          (*(double *)&xmmword_18000F4E0 * 2.0 - v26) * 57.29577951308235);
        UGS::System::SYSS_printf(
          (UGS::System *)"computing t1[1]=%f, t2[1]=%f, (Init_T1[1]*2-t1[1])=%f,(Init_T2[1]*2-t2[1])=%f\n",
          COERCE_CONST_CHAR__(v23 * 57.29577951308235),
          v27 * 57.29577951308235,
          (*((double *)&xmmword_18000F4D0 + 1) * 2.0 - v23) * 57.29577951308235,
          (*((double *)&xmmword_18000F4E0 + 1) * 2.0 - v27) * 57.29577951308235);
        v13 = qword_18000F3C8;
      }
      sub_180004BC0((double *)v108.m128_u64, (double *)v109.m128_u64);
      if ( *(_DWORD *)v13 != 2 )
      {
        v26 = *(double *)v109.m128_u64;
        v73 = xmmword_18000BB10;
        sub_180005DF0((__int64)&v115, COERCE_DOUBLE(v109.m128_u64[0] ^ xmmword_18000BB10), v6);
        v27 = *(double *)&v109.m128_u64[1];
        sub_180005DF0((__int64)&v115, COERCE_DOUBLE(v109.m128_u64[1] ^ xmmword_18000BB10), v5);
        if ( dword_18000F550 == 3 )
        {
          v90 = 0;
          do
          {
            v91 = v5;
            if ( !v90 )
              v91 = v6;
            UF_MTX3_vec_multiply_t(v91, &unk_18000BB70, v91);
            ++v90;
          }
          while ( v90 < 2 );
        }
        v23 = *(double *)&v108.m128_u64[1];
        v18 = *(double *)v108.m128_u64;
        v24 = *(double *)&qword_18000F000;
        v13 = qword_18000F3C8;
LABEL_75:
        v74 = *(_DWORD *)v13;
        if ( *(_DWORD *)v13 == 1 )
        {
          v75 = *(double *)(v13 + 144) + *(double *)(v13 + 136);
          UF_VEC3_affine_comb(v6, v20, &v112, v6, v106);
          UF_VEC3_affine_comb(v5, v76, &v112, v5, v77);
          sub_180005BC0(v6, v78, v79, v6);
          sub_180005BC0(v5, v80, v81, v5);
        }
        else
        {
          if ( v74 == 3 )
          {
            sub_180005DF0((__int64)&v112, COERCE_DOUBLE(*(_QWORD *)&v26 ^ v73), (__int64)&v110);
            UF_VEC3_unitize(&v110, v92, &v111, &v110);
            v93 = *(unsigned __int64 *)(qword_18000F3C8 + 136);
            UF_VEC3_affine_comb(v6, v94, &v110, v6, v106);
            v96 = (__int128 *)&v110;
          }
          else
          {
            if ( v74 != 2 )
              goto LABEL_94;
            sub_180005C60((__int64)&v112, (__int64)v20, v21, (__int64)&v110);
            LODWORD(v106) = 0;
            sub_180005C60((__int64)&v112, v97, v98, (__int64)&v118);
            UF_VEC3_unitize(&v110, v99, &v111, &v110);
            UF_VEC3_unitize(&v118, v100, &v111, &v118);
            v101 = *(unsigned __int64 *)(qword_18000F3C8 + 136);
            UF_VEC3_affine_comb(v6, v102, &v110, v6, v106);
            v96 = (__int128 *)&v118;
          }
          v103 = *(unsigned __int64 *)(qword_18000F3C8 + 136);
          UF_VEC3_affine_comb(v5, v95, v96, v5, v107);
        }
        v24 = *(double *)&qword_18000F000;
        v13 = qword_18000F3C8;
LABEL_94:
        v4 = byte_18000F008 == 0;
        *(double *)(v6 + 24) = v18 * 57.29577951308235;
        *(double *)(v5 + 24) = v23 * 57.29577951308235;
        *(double *)(v6 + 32) = v26 * 57.29577951308235;
        *(double *)(v5 + 32) = v27 * 57.29577951308235;
        if ( !v4 && *(_DWORD *)v13 != 3 )
        {
          v104 = *(double *)(v6 + 32) - 90.0;
          *(double *)(v6 + 32) = v104;
          if ( v104 < -360.0 )
            *(double *)(v6 + 32) = v104 + 360.0;
          v105 = *(double *)(v5 + 32) - 90.0;
          *(double *)(v5 + 32) = v105;
          if ( v105 < -360.0 )
            *(double *)(v5 + 32) = v105 + 360.0;
        }
        if ( v3 && *(_DWORD *)v13 != 3 )
        {
          *(_OWORD *)(v6 + 24) = *(__int128 *)((char *)&xmmword_18000F568 + 8);
          *(_OWORD *)(v5 + 24) = *(__int128 *)((char *)&xmmword_18000F590 + 8);
        }
        if ( byte_18000F554
          && v24 >= COERCE_DOUBLE(COERCE_UNSIGNED_INT64(v18 - v23) & v22)
          && v24 >= COERCE_DOUBLE(COERCE_UNSIGNED_INT64(v26 - v27) & v22) )
        {
          UGS::System::SYSS_printf((UGS::System *)"WARNING: same value of rotary produced:\n", v20);
        }
        xmmword_18000F558 = *(_OWORD *)v6;
        xmmword_18000F568 = *(_OWORD *)(v6 + 16);
        qword_18000F578 = *(_QWORD *)(v6 + 32);
        xmmword_18000F580 = *(_OWORD *)v5;
        xmmword_18000F590 = *(_OWORD *)(v5 + 16);
        qword_18000F5A0 = *(_QWORD *)(v5 + 32);
        xmmword_18000F5B8 = (__int128)v109;
        xmmword_18000F5A8 = (__int128)v108;
        return v8;
      }
      v82 = (__m128i)v109;
      _mm_store_si128((__m128i *)&v108, (__m128i)v108);
      _mm_store_si128(&v110, v82);
      sub_180005E50((__int64)&v112, (double *)v108.m128_u64, (double *)v110.m128i_i64);
      v83 = v108;
      v84 = v110;
      sub_180005C60((__int64)&v115, v85, v86, v6);
      LODWORD(v106) = 1;
      sub_180005C60((__int64)&v115, v87, v88, v5);
      v13 = qword_18000F3C8;
      *(_QWORD *)&v23 = (unsigned __int128)_mm_shuffle_ps(v83, v83, 238);
      _mm_store_si128((__m128i *)&v109, v84);
      v26 = *(double *)v109.m128_u64;
      v89 = (__m128)v84;
      v24 = *(double *)&qword_18000F000;
      _mm_store_si128((__m128i *)&v108, (__m128i)v83);
      *(_QWORD *)&v27 = (unsigned __int128)_mm_shuffle_ps(v89, v89, 238);
      v18 = *(double *)v108.m128_u64;
    }
    v73 = xmmword_18000BB10;
    goto LABEL_75;
  }
  sub_180004BC0((double *)v108.m128_u64, (double *)v109.m128_u64);
  xmmword_18000F4D0 = (__int128)v108;
  xmmword_18000F4E0 = (__int128)v109;
  return v8;
}
// 18000B190: using guessed type _DWORD UGS::System::SYSS_printf(UGS::System *__hidden this, const char *, ...);
// 18000B238: using guessed type __int64 __fastcall UF_MTX3_vec_multiply_t(_QWORD, _QWORD, _QWORD);
// 18000B258: using guessed type __int64 __fastcall UF_VEC3_unitize(_QWORD, _QWORD, _QWORD, _QWORD);
// 18000B288: using guessed type __int64 __fastcall UF_VEC3_is_zero(_QWORD, _QWORD, _QWORD);
// 18000B298: using guessed type __int64 __fastcall UF_VEC3_affine_comb(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 18000BB10: using guessed type __int128 xmmword_18000BB10;
// 18000C190: using guessed type __int128 xmmword_18000C190;
// 18000F000: using guessed type __int64 qword_18000F000;
// 18000F008: using guessed type char byte_18000F008;
// 18000F009: using guessed type char byte_18000F009;
// 18000F280: using guessed type __int64 qword_18000F280;
// 18000F288: using guessed type __int64 qword_18000F288;
// 18000F2B0: using guessed type __int64 qword_18000F2B0;
// 18000F2B8: using guessed type __int64 qword_18000F2B8;
// 18000F2C0: using guessed type __int64 qword_18000F2C0;
// 18000F2C8: using guessed type __int64 qword_18000F2C8;
// 18000F3C8: using guessed type __int64 qword_18000F3C8;
// 18000F450: using guessed type __int64 qword_18000F450;
// 18000F458: using guessed type __int64 qword_18000F458;
// 18000F460: using guessed type __int64 qword_18000F460;
// 18000F468: using guessed type __int64 qword_18000F468;
// 18000F470: using guessed type __int64 qword_18000F470;
// 18000F478: using guessed type __int64 qword_18000F478;
// 18000F480: using guessed type __int64 qword_18000F480;
// 18000F488: using guessed type __int64 qword_18000F488;
// 18000F490: using guessed type __int64 qword_18000F490;
// 18000F498: using guessed type __int64 qword_18000F498;
// 18000F4A0: using guessed type __int64 qword_18000F4A0;
// 18000F4A8: using guessed type __int64 qword_18000F4A8;
// 18000F4D0: using guessed type __int128 xmmword_18000F4D0;
// 18000F4E0: using guessed type __int128 xmmword_18000F4E0;
// 18000F4F0: using guessed type __int64 qword_18000F4F0;
// 18000F4F8: using guessed type __int64 qword_18000F4F8;
// 18000F500: using guessed type __int64 qword_18000F500;
// 18000F550: using guessed type int dword_18000F550;
// 18000F554: using guessed type char byte_18000F554;
// 18000F558: using guessed type __int128 xmmword_18000F558;
// 18000F568: using guessed type __int128 xmmword_18000F568;
// 18000F578: using guessed type __int64 qword_18000F578;
// 18000F580: using guessed type __int128 xmmword_18000F580;
// 18000F590: using guessed type __int128 xmmword_18000F590;
// 18000F5A0: using guessed type __int64 qword_18000F5A0;
// 18000F5A8: using guessed type __int128 xmmword_18000F5A8;
// 18000F5B8: using guessed type __int128 xmmword_18000F5B8;

//----- (00000001800038B0) ----------------------------------------------------
__int64 __fastcall sub_1800038B0(__int128 *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r15
  __int128 v4; // xmm1
  __int64 v5; // r14
  __int128 *v6; // rbx
  __int128 v7; // xmm0
  unsigned int v8; // er12
  __int64 v9; // rcx
  __int128 v10; // xmm0
  __int64 v11; // rbx
  __int64 v12; // rdi
  signed __int64 v13; // rsi
  __m128 v14; // xmm0
  double *v15; // rdx
  __m128 v16; // xmm0
  bool v17; // zf
  __int128 v18; // xmm1
  __int64 v19; // xmm0_8
  __int128 v20; // xmm1
  __int128 v21; // xmm0
  __int128 v23; // [rsp+30h] [rbp-59h]
  __int64 v24; // [rsp+40h] [rbp-49h]
  __int128 v25; // [rsp+48h] [rbp-41h]
  __int128 v26; // [rsp+58h] [rbp-31h]
  __int64 v27; // [rsp+68h] [rbp-21h]
  __int128 v28; // [rsp+70h] [rbp-19h]
  __int128 v29; // [rsp+80h] [rbp-9h]
  __int64 v30; // [rsp+90h] [rbp+7h]
  __int128 v31; // [rsp+98h] [rbp+Fh]
  __int128 v32; // [rsp+A8h] [rbp+1Fh]
  __int128 v33; // [rsp+B8h] [rbp+2Fh]

  v3 = a2;
  v4 = a1[1];
  v5 = a3;
  v6 = a1;
  v31 = *a1;
  v7 = a1[2];
  v32 = v4;
  v33 = v7;
  UF_VEC3_add(&v31, qword_18000F3C8 + 16, &v31);
  UF_VEC3_sub(&v31, qword_18000F3C8 + 40, &v31);
  v8 = sub_180002550((__int64)&v31, &v25, &v28);
  UF_VEC3_add(&v25, qword_18000F3C8 + 64, &v25);
  UF_VEC3_add(&v28, qword_18000F3C8 + 64, &v28);
  v9 = qword_18000F3C8;
  if ( *(_BYTE *)(qword_18000F3C8 + 88) )
  {
    v10 = *(unsigned __int64 *)(qword_18000F3C8 + 96);
    v23 = *(__int128 *)((char *)v6 + 24);
    v24 = *((_QWORD *)v6 + 5);
    UF_VEC3_scale(qword_18000F3C8, &v23, &v23);
    UF_VEC3_add(&v25, &v23, &v25);
    UF_VEC3_add(&v28, &v23, &v28);
    v9 = qword_18000F3C8;
  }
  v11 = 0i64;
  v12 = 0i64;
  v13 = 3i64;
  while ( 1 )
  {
    v14 = sub_180006170((double *)((char *)&v25 + v11), (double *)(v9 + 8));
    v15 = (double *)(qword_18000F3C8 + 8);
    *(_QWORD *)((char *)&v25 + v12) = v14.m128_u64[0];
    v16 = sub_180006170((double *)((char *)&v28 + v11), v15);
    v11 += 8i64;
    *(_QWORD *)((char *)&v28 + v12) = v16.m128_u64[0];
    v12 += 8i64;
    if ( !--v13 )
      break;
    v9 = qword_18000F3C8;
  }
  if ( byte_18000F00A )
    byte_18000F00A = 0;
  else
    sub_180005840((__int64)&xmmword_18000F5C8, (__int64)&xmmword_18000F5F0, (__int64)&v25);
  v17 = byte_18000F554 == 0;
  v18 = v26;
  *(_OWORD *)v3 = v25;
  v19 = v27;
  *(_OWORD *)(v3 + 16) = v18;
  v20 = v28;
  *(_QWORD *)(v3 + 32) = v19;
  v21 = v29;
  *(_OWORD *)v5 = v20;
  *(_QWORD *)&v20 = v30;
  *(_OWORD *)(v5 + 16) = v21;
  *(_QWORD *)(v5 + 32) = v20;
  xmmword_18000F5C8 = *(_OWORD *)v3;
  xmmword_18000F5D8 = *(_OWORD *)(v3 + 16);
  qword_18000F5E8 = *(_QWORD *)(v3 + 32);
  xmmword_18000F5F0 = *(_OWORD *)v5;
  xmmword_18000F600 = *(_OWORD *)(v5 + 16);
  qword_18000F610 = *(_QWORD *)(v5 + 32);
  if ( !v17 )
  {
    UGS::System::SYSS_printf(
      (UGS::System *)"final ufunc mcoord[] = (%f,%f,%f), (%f,%f)\n",
      *(const char **)v3,
      *(_QWORD *)(v3 + 8),
      *(_QWORD *)(v3 + 16),
      *(_OWORD *)(v3 + 24));
    UGS::System::SYSS_printf(
      (UGS::System *)"final ufunc alt_mcoord[] = (%f,%f,%f), (%f,%f)\n",
      *(const char **)v5,
      *(_QWORD *)(v5 + 8),
      *(_QWORD *)(v5 + 16),
      *(_OWORD *)(v5 + 24));
  }
  return v8;
}
// 18000B190: using guessed type _DWORD UGS::System::SYSS_printf(UGS::System *__hidden this, const char *, ...);
// 18000B260: using guessed type __int64 __fastcall UF_VEC3_sub(_QWORD, _QWORD, _QWORD);
// 18000B268: using guessed type __int64 __fastcall UF_VEC3_scale(_QWORD, _QWORD, _QWORD);
// 18000B2A0: using guessed type __int64 __fastcall UF_VEC3_add(_QWORD, _QWORD, _QWORD);
// 18000F00A: using guessed type char byte_18000F00A;
// 18000F3C8: using guessed type __int64 qword_18000F3C8;
// 18000F554: using guessed type char byte_18000F554;
// 18000F5C8: using guessed type __int128 xmmword_18000F5C8;
// 18000F5D8: using guessed type __int128 xmmword_18000F5D8;
// 18000F5E8: using guessed type __int64 qword_18000F5E8;
// 18000F5F0: using guessed type __int128 xmmword_18000F5F0;
// 18000F600: using guessed type __int128 xmmword_18000F600;
// 18000F610: using guessed type __int64 qword_18000F610;

//----- (0000000180003B80) ----------------------------------------------------
signed __int64 __fastcall sub_180003B80(__int64 a1, __int128 *a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r15
  __int128 *v5; // rbx
  __int64 v6; // r13
  __int64 v7; // rsi
  __int128 v8; // xmm0
  __int64 v9; // r12
  __m128d v10; // xmm3
  __int128 v11; // xmm1
  __int128 v12; // xmm0
  __int128 v13; // xmm0
  __int128 v14; // xmm2
  __int64 v15; // rdx
  __int64 v16; // rdx
  __int64 v17; // r8
  __int64 v18; // r8
  bool v19; // bl
  __int64 v20; // r8
  bool v21; // r13
  __int64 v22; // r8
  const char *v23; // rdx
  __int64 v24; // rbx
  const char *v25; // rdx
  char *v26; // rcx
  __int64 v27; // r8
  __int64 v28; // r8
  __int64 v29; // r8
  __int64 v30; // ST20_8
  __int64 v31; // ST28_8
  __int64 v32; // ST30_8
  double v33; // xmm1_8
  __int64 v34; // r8
  __int64 v35; // ST20_8
  __int64 v36; // ST28_8
  __int64 v37; // ST30_8
  __int64 v38; // r8
  __int64 v39; // ST20_8
  __int64 v40; // ST28_8
  __int64 v41; // ST30_8
  signed __int64 result; // rax
  double v43; // xmm0_8
  double v44; // xmm2_8
  __int64 *v45; // r8
  double v46; // xmm3_8
  double v47; // xmm2_8
  double v48; // xmm1_8
  double v49; // xmm0_8
  double v50; // xmm3_8
  double v51; // xmm2_8
  double v52; // xmm0_8
  double v53; // xmm1_8
  double v54; // xmm3_8
  double v55; // xmm2_8
  double v56; // xmm0_8
  double v57; // xmm1_8
  double v58; // xmm3_8
  double v59; // xmm2_8
  double v60; // xmm0_8
  double v61; // xmm1_8
  double v62; // xmm3_8
  double v63; // xmm2_8
  __int64 v64; // xmm1_8
  double v65; // xmm7_8
  double v66; // xmm0_8
  double v67; // xmm8_8
  __int64 v68; // xmm1_8
  __int128 v69; // xmm0
  __int64 v70; // xmm1_8
  __int64 v71; // [rsp+20h] [rbp-A0h]
  __int64 v72; // [rsp+20h] [rbp-A0h]
  __int64 v73; // [rsp+28h] [rbp-98h]
  __int64 v74; // [rsp+28h] [rbp-98h]
  __int64 v75; // [rsp+30h] [rbp-90h]
  __int64 v76; // [rsp+30h] [rbp-90h]
  __int128 v77; // [rsp+38h] [rbp-88h]
  __int128 v78; // [rsp+48h] [rbp-78h]
  __int128 v79; // [rsp+58h] [rbp-68h]
  double v80; // [rsp+68h] [rbp-58h]
  double v81; // [rsp+70h] [rbp-50h]
  double v82; // [rsp+78h] [rbp-48h]
  double v83; // [rsp+80h] [rbp-40h]
  char v84; // [rsp+88h] [rbp-38h]
  __int64 v85; // [rsp+98h] [rbp-28h]
  char v86; // [rsp+A0h] [rbp-20h]
  __int64 v87; // [rsp+B8h] [rbp-8h]
  __int128 v88; // [rsp+C0h] [rbp+0h]
  double v89; // [rsp+D0h] [rbp+10h]
  double v90; // [rsp+D8h] [rbp+18h]
  double v91; // [rsp+E0h] [rbp+20h]
  double v92; // [rsp+E8h] [rbp+28h]
  double v93; // [rsp+F0h] [rbp+30h]
  double v94; // [rsp+F8h] [rbp+38h]
  double v95; // [rsp+100h] [rbp+40h]
  double v96; // [rsp+108h] [rbp+48h]
  double v97; // [rsp+110h] [rbp+50h]
  double v98; // [rsp+118h] [rbp+58h]
  double v99; // [rsp+120h] [rbp+60h]
  double v100; // [rsp+128h] [rbp+68h]
  char v101; // [rsp+130h] [rbp+70h]
  __int128 v102; // [rsp+148h] [rbp+88h]
  __int64 v103; // [rsp+158h] [rbp+98h]
  __int128 v104; // [rsp+160h] [rbp+A0h]
  __int64 v105; // [rsp+170h] [rbp+B0h]
  char v106; // [rsp+178h] [rbp+B8h]
  char v107; // [rsp+1A0h] [rbp+E0h]
  __int128 v108; // [rsp+1D0h] [rbp+110h]
  __int64 v109; // [rsp+1E0h] [rbp+120h]
  char v110; // [rsp+1E8h] [rbp+128h]
  char v111; // [rsp+200h] [rbp+140h]
  __int128 v112; // [rsp+218h] [rbp+158h]
  double v113; // [rsp+228h] [rbp+168h]
  __int64 v114; // [rsp+2B0h] [rbp+1F0h]
  int v115; // [rsp+2B8h] [rbp+1F8h]
  int v116; // [rsp+2C0h] [rbp+200h]
  __int64 v117; // [rsp+2C8h] [rbp+208h]
  double v118; // [rsp+2D0h] [rbp+210h]
  __int64 v119; // [rsp+2D8h] [rbp+218h]
  __int64 vars0; // [rsp+2E0h] [rbp+220h]
  const char **retaddr; // [rsp+2E8h] [rbp+228h]
  __int64 v122; // [rsp+2F0h] [rbp+230h]
  __int64 v123; // [rsp+308h] [rbp+248h]

  v123 = a4;
  v122 = a1;
  v4 = *(_QWORD *)&v118;
  v88 = 0i64;
  v5 = a2;
  v6 = a4;
  v7 = a3;
  xmmword_18000F520 = *(_OWORD *)a3;
  qword_18000F530 = *(_QWORD *)(a3 + 16);
  v8 = **(_OWORD **)&v118;
  v87 = 0i64;
  xmmword_18000F538 = v8;
  qword_18000F548 = *(_QWORD *)(*(_QWORD *)&v118 + 16i64);
  UF_VEC3_copy(a4, &v85);
  v9 = v119;
  UF_VEC3_copy(v119, (char *)&v77 + 8);
  UF_VEC3_copy(retaddr, &v81);
  qword_18000F280 = 0i64;
  qword_18000F288 = 0i64;
  qword_18000F290 = 0i64;
  qword_18000F298 = 0i64;
  v10 = *(__m128d *)v122;
  byte_18000F554 = 0;
  X = 0.0;
  xmmword_18000F330 = (__int128)v10;
  xmmword_18000F340 = *(_OWORD *)(v122 + 16);
  v11 = *(_OWORD *)(v122 + 32);
  qword_18000F2A8 = 0.0;
  xmmword_18000F350 = v11;
  v12 = *(_OWORD *)(v122 + 48);
  qword_18000F000 = (unsigned __int128)_mm_unpckh_pd(v10, v10);
  xmmword_18000F360 = v12;
  xmmword_18000F370 = *(_OWORD *)(v122 + 64);
  xmmword_18000F380 = *(_OWORD *)(v122 + 80);
  xmmword_18000F390 = *(_OWORD *)(v122 + 96);
  xmmword_18000F3A0 = *(_OWORD *)(v122 + 112);
  xmmword_18000F3B0 = *(_OWORD *)(v122 + 128);
  qword_18000F3C0 = *(_QWORD *)(v122 + 144);
  v13 = *v5;
  qword_18000F3C8 = (__int64)&xmmword_18000F330;
  xmmword_18000F2D0 = v13;
  xmmword_18000F2E0 = v5[1];
  xmmword_18000F2F0 = v5[2];
  xmmword_18000F300 = v5[3];
  xmmword_18000F310 = v5[4];
  v14 = v5[5];
  xmmword_18000F4D0 = 0i64;
  xmmword_18000F320 = v14;
  xmmword_18000F4E0 = 0i64;
  xmmword_18000F5A8 = 0i64;
  xmmword_18000F5B8 = 0i64;
  UF_VEC3_unitize(v6, v15, &v81, &qword_18000F4F0);
  UF_VEC3_unitize(v9, v16, &v81, &qword_18000F508);
  byte_18000F009 = 1;
  qword_18000F578 = 0i64;
  qword_18000F5A0 = 0i64;
  xmmword_18000F558 = 0i64;
  byte_18000F00A = 1;
  xmmword_18000F568 = 0i64;
  xmmword_18000F580 = 0i64;
  xmmword_18000F590 = 0i64;
  if ( (unsigned int)(*(_DWORD *)qword_18000F3C8 - 1) > 2 )
    return 2i64;
  UF_VEC3_is_parallel(&v79, (char *)&v77 + 8, v17, &v115);
  LOBYTE(v118) = v115 != 0;
  UF_VEC3_is_parallel(&v79, &v81, v18, &v115);
  v19 = v115 != 0;
  UF_VEC3_is_parallel((char *)&v77 + 8, &v81, v20, &v115);
  v21 = v115 != 0;
  if ( !v19 )
    sub_180004A70((__int64)&v79, (__int64)&v81, v81, (__int64)&v87);
  UF_VEC3_cross(&v79, (char *)&v77 + 8, &v86);
  UF_VEC3_is_parallel(&v86, &v81, v22, &v115);
  v24 = vars0;
  byte_18000F008 = v115 != 0;
  if ( byte_18000F554 )
  {
    UGS::System::SYSS_printf(
      (UGS::System *)"\n\n======================================================================\n",
      v23);
    UGS::System::SYSS_printf((UGS::System *)"Is_orthogonal_case = %d, ", (const char *)(unsigned __int8)byte_18000F008);
    if ( *(_DWORD *)qword_18000F3C8 == 2 )
    {
      v26 = "is_5_axis_dual_table\n";
    }
    else
    {
      v26 = "is_5_axis_dual_head\n";
      if ( *(_DWORD *)qword_18000F3C8 != 1 )
        v26 = "is_5_axis_head_table\n";
    }
    UGS::System::SYSS_printf((UGS::System *)v26, v25);
    UGS::System::SYSS_printf(
      (UGS::System *)"primary=(%f,%f,%f)\n",
      *(const char **)v117,
      *(_QWORD *)(v117 + 8),
      *(_QWORD *)(v117 + 16));
    UGS::System::SYSS_printf(
      (UGS::System *)"primary_machine_center=(%f,%f,%f)\n",
      *(const char **)v7,
      *(_QWORD *)(v7 + 8),
      *(_QWORD *)(v7 + 16));
    UGS::System::SYSS_printf(
      (UGS::System *)"secondary=(%f,%f,%f)\n",
      *(const char **)v9,
      *(_QWORD *)(v9 + 8),
      *(_QWORD *)(v9 + 16));
    UGS::System::SYSS_printf(
      (UGS::System *)"secondary_machine_center=(%f,%f,%f)\n",
      *(const char **)v4,
      *(_QWORD *)(v4 + 8),
      *(_QWORD *)(v4 + 16));
    UGS::System::SYSS_printf(
      (UGS::System *)"tool_machine_center=(%f,%f,%f)\n",
      *(const char **)v24,
      *(_QWORD *)(v24 + 8),
      *(_QWORD *)(v24 + 16));
    UGS::System::SYSS_printf((UGS::System *)"tool_vector=(%f,%f,%f)\n", *retaddr, retaddr[1], retaddr[2]);
    v79 = xmmword_18000F320;
    v78 = xmmword_18000F310;
    v77 = xmmword_18000F300;
    v75 = *((_QWORD *)&xmmword_18000F2F0 + 1);
    UGS::System::SYSS_printf(
      (UGS::System *)"Mcsys= (%f,%f,%f) (%f,%f,%f) (%f,%f,%f)  (%f,%f,%f)\n",
      (const char *)xmmword_18000F2D0,
      *((_QWORD *)&xmmword_18000F2D0 + 1),
      xmmword_18000F2E0,
      (_QWORD)xmmword_18000F2F0);
  }
  dword_18000F550 = -1;
  if ( *(_DWORD *)qword_18000F3C8 != 3 )
    goto LABEL_18;
  UF_MTX3_x_vec(&unk_18000BB20, &v106);
  UF_MTX3_y_vec(&unk_18000BB20, &v107);
  UF_MTX3_z_vec(&unk_18000BB20, &v102);
  UF_VEC3_is_equal(retaddr, &v102, v27, &v122, v71, v73, v75);
  if ( (_DWORD)v122 )
  {
    UF_VEC3_is_equal(v117, &v106, v28, &v118, v72, v74, v76);
    UF_VEC3_is_equal(v9, &v107, v34, &v116, v35, v36, v37);
    UF_VEC3_is_equal(v9, &v102, v38, &v82, v39, v40, v41);
    if ( LODWORD(v118) && v116 )
    {
      dword_18000F550 = 0;
      result = 0i64;
      byte_18000F009 = 0;
    }
    else if ( LODWORD(v82) )
    {
      dword_18000F550 = 1;
      result = 0i64;
      byte_18000F009 = 0;
    }
    else
    {
      byte_18000F009 = 0;
      result = 2i64;
    }
    return result;
  }
  UF_VEC3_is_equal(retaddr, &v107, v28, &v116, v72, v74, v76);
  UF_VEC3_is_equal(&v79, &v102, v29, &v82, v30, v31, v32);
  if ( byte_18000F008 || !v21 || !v116 || !LODWORD(v82) )
    return 2i64;
  dword_18000F550 = 3;
  UF_MTX3_vec_multiply_t(&qword_18000F4F0, &unk_18000BBC0, &qword_18000F4F0);
  UF_MTX3_vec_multiply_t(&qword_18000F508, &unk_18000BBC0, &qword_18000F508);
  if ( byte_18000F554 )
  {
    UGS::System::SYSS_printf((UGS::System *)"Sulzer case:\n", v23);
    UGS::System::SYSS_printf(
      (UGS::System *)"local PrimaryAxis=(%f,%f,%f)\n",
      (const char *)qword_18000F4F0,
      qword_18000F4F8,
      qword_18000F500);
    UGS::System::SYSS_printf(
      (UGS::System *)"local SecondaryAxis=(%f,%f,%f)\n",
      (const char *)qword_18000F508,
      qword_18000F510,
      qword_18000F518);
  }
LABEL_18:
  if ( LOBYTE(v118) )
  {
    v33 = 0.0;
  }
  else
  {
    sub_180004A70((__int64)&v79, (__int64)&v77 + 8, v81, (__int64)&v87);
    v33 = sub_180005A00((__int64)&v79, (__int64)&v77 + 8, (__int64)&v87);
  }
  X = v33;
  if ( v21 )
  {
    UGS::System::SYSS_printf(
      (UGS::System *)"WARNING: Tool axis is parallelled with secondary axis that may cause unresolved rotaries",
      v23);
    v43 = 0.0;
  }
  else
  {
    v44 = v81;
    if ( *(double *)&qword_18000F000 >= COERCE_DOUBLE(*(_QWORD *)&v33 & xmmword_18000C190) )
    {
      sub_180004A70((__int64)&v77 + 8, (__int64)&v81, v81, (__int64)&v87);
      v44 = v81;
      if ( *(double *)&qword_18000F000 >= COERCE_DOUBLE(*(_QWORD *)&v81 & xmmword_18000C190) )
        return 3i64;
    }
    if ( byte_18000F008 )
    {
      sub_180004A70((__int64)&v77 + 8, (__int64)&v81, v44, (__int64)&v106);
      v45 = (__int64 *)&v106;
    }
    else
    {
      v45 = &v87;
    }
    v43 = sub_180005A00((__int64)&v77 + 8, (__int64)&v81, (__int64)v45);
  }
  v46 = *(double *)v7;
  v47 = *(double *)v4;
  v48 = *(double *)v4;
  qword_18000F2A8 = v43;
  v49 = v46;
  v98 = v46 - *(double *)&v79 * 1000000.0;
  v50 = *(double *)(v7 + 8);
  v92 = v47 - *((double *)&v77 + 1) * 1000000.0;
  v51 = *(double *)(v4 + 8);
  v95 = v49 + *(double *)&v79 * 1000000.0;
  v52 = v50;
  v89 = v48 + *((double *)&v77 + 1) * 1000000.0;
  v53 = v51;
  v99 = v50 - *((double *)&v79 + 1) * 1000000.0;
  v54 = *(double *)(v7 + 16);
  v93 = v51 - *(double *)&v78 * 1000000.0;
  v55 = *(double *)(v4 + 16);
  v96 = v52 + *((double *)&v79 + 1) * 1000000.0;
  v90 = v53 + *(double *)&v78 * 1000000.0;
  v97 = v54 + v80 * 1000000.0;
  v100 = v54 - v80 * 1000000.0;
  v91 = v55 + *((double *)&v78 + 1) * 1000000.0;
  v94 = v55 - *((double *)&v78 + 1) * 1000000.0;
  if ( (unsigned int)sub_180002170(&v95, &v89, (double *)&v101, (double *)&v84) )
    return 5i64;
  UF_VEC3_distance(&v101, &v84, &qword_18000F280);
  if ( *(double *)&qword_18000F280 <= *(double *)&qword_18000F000 + 0.0 )
  {
    qword_18000F280 = 0i64;
  }
  else
  {
    UF_VEC3_sub(&v84, &v101, &v86);
    UF_VEC3_dot(&v86, &v87, &v118);
    if ( v118 < 0.0 )
      qword_18000F280 ^= xmmword_18000BB10;
  }
  UF_VEC3_distance(&v84, v7, &qword_18000F288);
  if ( *(double *)&qword_18000F288 <= *(double *)&qword_18000F000 + 0.0 )
  {
    qword_18000F288 = 0i64;
  }
  else
  {
    UF_VEC3_sub(&v84, v7, &v86);
    UF_VEC3_dot(&v86, &v79, &v118);
    if ( v118 < 0.0 )
      qword_18000F288 ^= xmmword_18000BB10;
  }
  v56 = *(double *)v4;
  v57 = *(double *)v24;
  v98 = *(double *)v4 - *((double *)&v77 + 1) * 1000000.0;
  v58 = *(double *)(v4 + 8);
  v92 = v57 - v81 * 1000000.0;
  v59 = *(double *)(v24 + 8);
  v95 = v56 + *((double *)&v77 + 1) * 1000000.0;
  v60 = v58;
  v89 = v57 + v81 * 1000000.0;
  v61 = v59;
  v99 = v58 - *(double *)&v78 * 1000000.0;
  v62 = *(double *)(v4 + 16);
  v93 = v59 - v82 * 1000000.0;
  v63 = *(double *)(v24 + 16);
  v96 = v60 + *(double *)&v78 * 1000000.0;
  v90 = v61 + v82 * 1000000.0;
  v97 = v62 + *((double *)&v78 + 1) * 1000000.0;
  v100 = v62 - *((double *)&v78 + 1) * 1000000.0;
  v91 = v63 + v83 * 1000000.0;
  v94 = v63 - v83 * 1000000.0;
  if ( (unsigned int)sub_180002170(&v95, &v89, (double *)&v101, (double *)&v84) )
    return 5i64;
  UF_VEC3_distance(&v101, &v84, &qword_18000F290);
  if ( *(double *)&qword_18000F290 <= *(double *)&qword_18000F000 + 0.0 )
  {
    qword_18000F290 = 0i64;
  }
  else
  {
    UF_VEC3_sub(&v84, &v101, &v86);
    UF_VEC3_dot(&v86, &v87, &v118);
    if ( v118 < 0.0 )
      qword_18000F290 ^= xmmword_18000BB10;
  }
  UF_VEC3_distance(&v84, v24, &qword_18000F298);
  if ( *(double *)&qword_18000F298 <= *(double *)&qword_18000F000 + 0.0 )
  {
    qword_18000F298 = 0i64;
  }
  else
  {
    UF_VEC3_sub(&v84, v24, &v86);
    UF_VEC3_dot(&v86, (char *)&v77 + 8, &v118);
    if ( v118 < 0.0 )
      qword_18000F298 ^= xmmword_18000BB10;
  }
  v64 = *(_QWORD *)(v7 + 16);
  v108 = *(_OWORD *)v7;
  v109 = v64;
  sub_180004A70((__int64)&v79, (__int64)&v77 + 8, v81, (__int64)&v110);
  v112 = v79;
  v113 = v80;
  sub_180004A70((__int64)&v79, (__int64)&v110, v81, (__int64)&v111);
  sub_180004AB0(v114, (__int64)&v108, (__int64)&unk_18000F3D0);
  sub_180005A20((__int64 *)&unk_18000F3D0, (__int64)&qword_18000F450);
  v65 = X;
  v66 = sin(X);
  v67 = qword_18000F2A8;
  qword_18000F2B8 = *(_QWORD *)&v66;
  qword_18000F2C8 = sin(qword_18000F2A8);
  qword_18000F2B0 = cos(v65);
  qword_18000F2C0 = cos(v67);
  if ( byte_18000F554 )
    UGS::System::SYSS_printf(
      (UGS::System *)"A1=%f,D1=%f,Alpha1=%f,A2=%f,D2=%f,Alpha2=%f\n",
      (const char *)qword_18000F280,
      qword_18000F288,
      v65 * 57.29577951308235,
      qword_18000F290,
      qword_18000F298,
      v67 * 57.29577951308235);
  if ( *(_DWORD *)qword_18000F3C8 == 2 )
  {
    v68 = *(_QWORD *)(v24 + 16);
    v102 = *(_OWORD *)v24;
    v69 = *(_OWORD *)retaddr;
    v103 = v68;
    v70 = (__int64)retaddr[2];
    v104 = v69;
    v105 = v70;
    sub_180002550((__int64)&v102, &v107, &v106);
    if ( byte_18000F554 )
    {
      UGS::System::SYSS_printf(
        (UGS::System *)"Init_T1[0], Init_T2[0] = (%f,%f)\n",
        COERCE_CONST_CHAR__(*(double *)&xmmword_18000F4D0 * 57.29577951308235),
        *(double *)&xmmword_18000F4E0 * 57.29577951308235);
      UGS::System::SYSS_printf(
        (UGS::System *)"Init_T1[1], Init_T2[1] = (%f,%f)\n",
        COERCE_CONST_CHAR__(*((double *)&xmmword_18000F4D0 + 1) * 57.29577951308235),
        *((double *)&xmmword_18000F4E0 + 1) * 57.29577951308235);
    }
  }
  byte_18000F009 = 0;
  return 0i64;
}
// 18000B190: using guessed type _DWORD UGS::System::SYSS_printf(UGS::System *__hidden this, const char *, ...);
// 18000B1C0: using guessed type __int64 __fastcall UF_VEC3_dot(_QWORD, _QWORD, _QWORD);
// 18000B1F8: using guessed type __int64 __fastcall UF_VEC3_copy(_QWORD, _QWORD);
// 18000B220: using guessed type __int64 __fastcall UF_MTX3_z_vec(_QWORD, _QWORD);
// 18000B228: using guessed type __int64 __fastcall UF_MTX3_y_vec(_QWORD, _QWORD);
// 18000B230: using guessed type __int64 __fastcall UF_MTX3_x_vec(_QWORD, _QWORD);
// 18000B238: using guessed type __int64 __fastcall UF_MTX3_vec_multiply_t(_QWORD, _QWORD, _QWORD);
// 18000B250: using guessed type __int64 __fastcall UF_VEC3_is_parallel(_QWORD, _QWORD, _QWORD, _QWORD);
// 18000B258: using guessed type __int64 __fastcall UF_VEC3_unitize(_QWORD, _QWORD, _QWORD, _QWORD);
// 18000B260: using guessed type __int64 __fastcall UF_VEC3_sub(_QWORD, _QWORD, _QWORD);
// 18000B278: using guessed type __int64 __fastcall UF_VEC3_cross(_QWORD, _QWORD, _QWORD);
// 18000B280: using guessed type __int64 __fastcall UF_VEC3_distance(_QWORD, _QWORD, _QWORD);
// 18000BB10: using guessed type __int128 xmmword_18000BB10;
// 18000C190: using guessed type __int128 xmmword_18000C190;
// 18000F000: using guessed type __int64 qword_18000F000;
// 18000F008: using guessed type char byte_18000F008;
// 18000F009: using guessed type char byte_18000F009;
// 18000F00A: using guessed type char byte_18000F00A;
// 18000F280: using guessed type __int64 qword_18000F280;
// 18000F288: using guessed type __int64 qword_18000F288;
// 18000F290: using guessed type __int64 qword_18000F290;
// 18000F298: using guessed type __int64 qword_18000F298;
// 18000F2B0: using guessed type __int64 qword_18000F2B0;
// 18000F2B8: using guessed type __int64 qword_18000F2B8;
// 18000F2C0: using guessed type __int64 qword_18000F2C0;
// 18000F2C8: using guessed type __int64 qword_18000F2C8;
// 18000F2D0: using guessed type __int128 xmmword_18000F2D0;
// 18000F2E0: using guessed type __int128 xmmword_18000F2E0;
// 18000F2F0: using guessed type __int128 xmmword_18000F2F0;
// 18000F300: using guessed type __int128 xmmword_18000F300;
// 18000F310: using guessed type __int128 xmmword_18000F310;
// 18000F320: using guessed type __int128 xmmword_18000F320;
// 18000F330: using guessed type __int128 xmmword_18000F330;
// 18000F340: using guessed type __int128 xmmword_18000F340;
// 18000F350: using guessed type __int128 xmmword_18000F350;
// 18000F360: using guessed type __int128 xmmword_18000F360;
// 18000F370: using guessed type __int128 xmmword_18000F370;
// 18000F380: using guessed type __int128 xmmword_18000F380;
// 18000F390: using guessed type __int128 xmmword_18000F390;
// 18000F3A0: using guessed type __int128 xmmword_18000F3A0;
// 18000F3B0: using guessed type __int128 xmmword_18000F3B0;
// 18000F3C0: using guessed type __int64 qword_18000F3C0;
// 18000F3C8: using guessed type __int64 qword_18000F3C8;
// 18000F450: using guessed type __int64 qword_18000F450;
// 18000F4D0: using guessed type __int128 xmmword_18000F4D0;
// 18000F4E0: using guessed type __int128 xmmword_18000F4E0;
// 18000F4F0: using guessed type __int64 qword_18000F4F0;
// 18000F4F8: using guessed type __int64 qword_18000F4F8;
// 18000F500: using guessed type __int64 qword_18000F500;
// 18000F508: using guessed type __int64 qword_18000F508;
// 18000F510: using guessed type __int64 qword_18000F510;
// 18000F518: using guessed type __int64 qword_18000F518;
// 18000F520: using guessed type __int128 xmmword_18000F520;
// 18000F530: using guessed type __int64 qword_18000F530;
// 18000F538: using guessed type __int128 xmmword_18000F538;
// 18000F548: using guessed type __int64 qword_18000F548;
// 18000F550: using guessed type int dword_18000F550;
// 18000F554: using guessed type char byte_18000F554;
// 18000F558: using guessed type __int128 xmmword_18000F558;
// 18000F568: using guessed type __int128 xmmword_18000F568;
// 18000F578: using guessed type __int64 qword_18000F578;
// 18000F580: using guessed type __int128 xmmword_18000F580;
// 18000F590: using guessed type __int128 xmmword_18000F590;
// 18000F5A0: using guessed type __int64 qword_18000F5A0;
// 18000F5A8: using guessed type __int128 xmmword_18000F5A8;
// 18000F5B8: using guessed type __int128 xmmword_18000F5B8;

//----- (0000000180004A70) ----------------------------------------------------
__int64 __fastcall sub_180004A70(__int64 a1, __int64 a2, double a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 v5; // rdx
  double v7; // [rsp+40h] [rbp+18h]

  v7 = a3;
  v4 = a4;
  UF_VEC3_cross(a1, a2, a4);
  return UF_VEC3_unitize(v4, v5, &v7, v4);
}
// 18000B258: using guessed type __int64 __fastcall UF_VEC3_unitize(_QWORD, _QWORD, _QWORD, _QWORD);
// 18000B278: using guessed type __int64 __fastcall UF_VEC3_cross(_QWORD, _QWORD, _QWORD);

//----- (0000000180004AB0) ----------------------------------------------------
__int64 __fastcall sub_180004AB0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rbx
  __int64 v5; // rsi
  __int128 v6; // xmm1
  __int64 v7; // xmm0_8
  __int128 v9; // [rsp+40h] [rbp-138h]
  __int64 v10; // [rsp+50h] [rbp-128h]
  __int128 v11; // [rsp+58h] [rbp-120h]
  __int64 v12; // [rsp+68h] [rbp-110h]
  char v13; // [rsp+70h] [rbp-108h]
  char v14; // [rsp+88h] [rbp-F0h]
  char v15; // [rsp+A0h] [rbp-D8h]
  char v16; // [rsp+B8h] [rbp-C0h]
  char v17; // [rsp+D0h] [rbp-A8h]
  char v18; // [rsp+120h] [rbp-58h]

  v3 = a1;
  v4 = a2;
  v5 = a3;
  UF_MTX3_copy(a2 + 24, &v17);
  UF_MTX3_copy(v3 + 24, &v18);
  v6 = *(_OWORD *)v3;
  v11 = *(_OWORD *)v4;
  v7 = *(_QWORD *)(v4 + 16);
  v9 = v6;
  *(_QWORD *)&v6 = *(_QWORD *)(v3 + 16);
  v12 = v7;
  v10 = v6;
  UF_MTX3_x_vec(&v17, &v16);
  UF_MTX3_y_vec(&v17, &v15);
  UF_MTX3_x_vec(&v18, &v14);
  UF_MTX3_y_vec(&v18, &v13);
  return UF_MTX4_csys_to_csys(&v11, &v16, &v15, &v9, &v14, &v13, v5);
}
// 18000B1E8: using guessed type __int64 __fastcall UF_MTX4_csys_to_csys(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 18000B228: using guessed type __int64 __fastcall UF_MTX3_y_vec(_QWORD, _QWORD);
// 18000B230: using guessed type __int64 __fastcall UF_MTX3_x_vec(_QWORD, _QWORD);
// 18000B248: using guessed type __int64 __fastcall UF_MTX3_copy(_QWORD, _QWORD);

//----- (0000000180004BC0) ----------------------------------------------------
signed __int64 __fastcall sub_180004BC0(double *a1, double *a2)
{
  double v2; // xmm5_8
  double v3; // xmm1_8
  double v4; // xmm6_8
  double v5; // xmm3_8
  double v6; // xmm7_8
  double v7; // xmm5_8
  double v8; // xmm6_8
  double v9; // xmm3_8
  double v10; // xmm3_8
  signed __int64 result; // rax

  v2 = *a1;
  v3 = *(double *)&qword_18000F000;
  if ( *(double *)&qword_18000F000 < COERCE_DOUBLE(COERCE_UNSIGNED_INT64(*a1 - a1[1]) & xmmword_18000C190) )
    goto LABEL_15;
  v4 = *a2;
  v5 = a2[1];
  if ( *(double *)&qword_18000F000 < COERCE_DOUBLE(COERCE_UNSIGNED_INT64(*a2 - v5) & xmmword_18000C190)
    || *(double *)&qword_18000F000 >= COERCE_DOUBLE(COERCE_UNSIGNED_INT64(v2 - v4) & xmmword_18000C190) )
  {
    goto LABEL_15;
  }
  v6 = 0.0 - *(double *)&qword_18000F000;
  if ( 0.0 - *(double *)&qword_18000F000 > v2 )
  {
    v7 = v2 + 6.283185307179586;
    *a1 = v7;
    a1[1] = 6.283185307179586 - v7;
    goto LABEL_15;
  }
  if ( v6 <= v4 )
  {
    if ( v5 <= *(double *)&qword_18000F000 + 0.0 )
      goto LABEL_15;
    v9 = v5 - 6.283185307179586;
    goto LABEL_14;
  }
  v8 = v4 + 6.283185307179586;
  if ( *(double *)&qword_18000F000 >= COERCE_DOUBLE(COERCE_UNSIGNED_INT64(v8 - v2) & xmmword_18000C190) )
  {
    if ( v6 <= v5 )
      goto LABEL_15;
    v9 = v5 + 6.283185307179586;
LABEL_14:
    a2[1] = v9;
    goto LABEL_15;
  }
  *a2 = v8;
  if ( v3 >= COERCE_DOUBLE(COERCE_UNSIGNED_INT64(v8 - v5) & xmmword_18000C190) )
    a2[1] = 6.283185307179586 - v8;
LABEL_15:
  if ( v3 >= COERCE_DOUBLE(COERCE_UNSIGNED_INT64(*a1 - *a2) & xmmword_18000C190) )
  {
    v10 = a2[1];
    if ( v3 >= COERCE_DOUBLE(COERCE_UNSIGNED_INT64(a1[1] - v10) & xmmword_18000C190) )
    {
      if ( 0.0 - v3 <= v10 )
      {
        if ( v10 <= v3 + 0.0 )
        {
          if ( v3 >= COERCE_DOUBLE(*(_QWORD *)a1 & xmmword_18000C190)
            && v3 >= COERCE_DOUBLE(*(_QWORD *)a2 & xmmword_18000C190) )
          {
            result = 4618760256179416344i64;
            a2[1] = 6.283185307179586;
          }
        }
        else
        {
          a2[1] = 6.283185307179586 - v10;
        }
      }
      else
      {
        a2[1] = v10 + 6.283185307179586;
      }
    }
  }
  return result;
}
// 18000C190: using guessed type __int128 xmmword_18000C190;
// 18000F000: using guessed type __int64 qword_18000F000;

//----- (0000000180004D70) ----------------------------------------------------
signed __int64 __fastcall PtFuncCompare(const void *a1, const void *a2)
{
  signed __int64 result; // rax

  if ( *(double *)&qword_18000F000 >= COERCE_DOUBLE(COERCE_UNSIGNED_INT64(*(double *)a1 - *(double *)a2) & xmmword_18000C190) )
    return 0i64;
  result = 0xFFFFFFFFi64;
  if ( *(double *)a1 > *(double *)a2 + *(double *)&qword_18000F000 )
    result = 1i64;
  return result;
}
// 18000C190: using guessed type __int128 xmmword_18000C190;
// 18000F000: using guessed type __int64 qword_18000F000;

//----- (0000000180004DB0) ----------------------------------------------------
signed __int64 __fastcall sub_180004DB0(double a1, double *a2, __int64 a3)
{
  __int64 v3; // rdi
  double *v4; // rbx
  double v5; // xmm6_8
  double v6; // xmm8_8
  double v7; // xmm7_8
  double v8; // xmm3_8
  double v9; // xmm6_8
  double v10; // xmm0_8
  double v11; // xmm2_8
  double v12; // xmm0_8
  double v13; // xmm2_8
  double v14; // xmm2_8
  double v15; // xmm7_8
  signed __int64 result; // rax

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = cos(a1);
  v7 = sin(v5);
  v8 = v4[1] * v4[1];
  v9 = v4[2] * v4[2];
  *(double *)v3 = (1.0 - *v4 * *v4) * v6 + *v4 * *v4;
  *(double *)(v3 + 8) = v4[1] * *v4 * (1.0 - v6) + v7 * v4[2];
  v10 = v7 * v4[1];
  v11 = v4[2] * *v4;
  *(_QWORD *)(v3 + 24) = 0i64;
  *(double *)(v3 + 16) = v11 * (1.0 - v6) - v10;
  *(double *)(v3 + 32) = v4[1] * *v4 * (1.0 - v6) - v7 * v4[2];
  *(double *)(v3 + 40) = (1.0 - v8) * v6 + v8;
  v12 = v7 * *v4;
  v13 = v4[2] * v4[1];
  *(_QWORD *)(v3 + 56) = 0i64;
  *(double *)(v3 + 48) = v13 * (1.0 - v6) + v12;
  *(double *)(v3 + 64) = v4[2] * *v4 * (1.0 - v6) + v7 * v4[1];
  v14 = v4[2] * v4[1];
  v15 = v7 * *v4;
  *(double *)(v3 + 80) = (1.0 - v9) * v6 + v9;
  *(double *)(v3 + 72) = v14 * (1.0 - v6) - v15;
  *(_QWORD *)(v3 + 88) = 0i64;
  *(_QWORD *)(v3 + 96) = 0i64;
  *(_QWORD *)(v3 + 104) = 0i64;
  *(_QWORD *)(v3 + 112) = 0i64;
  result = 4607182418800017408i64;
  *(_QWORD *)(v3 + 120) = 4607182418800017408i64;
  return result;
}

//----- (0000000180004F40) ----------------------------------------------------
signed __int64 __fastcall sub_180004F40(__int64 a1, int a2, __int64 a3, _QWORD *a4)
{
  signed int v4; // esi
  _QWORD *v5; // rbx
  signed __int64 v6; // r15
  __int64 v7; // r12
  __int64 v8; // r13
  signed __int64 v9; // r9
  __int64 v10; // rbp
  __int64 v11; // r14
  signed __int64 v12; // r10
  _QWORD *v13; // rdi
  __int64 v14; // rcx
  double v15; // xmm2_8
  signed __int64 v16; // r11
  __int64 v17; // rdx
  double *v18; // rax
  __int64 v19; // r8
  unsigned __int64 v20; // rcx
  double v21; // xmm0_8
  double v22; // xmm2_8
  double v23; // xmm1_8
  __int64 v24; // rdx
  double *v25; // rax
  signed __int64 v26; // rcx
  double v27; // xmm0_8
  signed __int64 result; // rax
  signed __int64 v29; // r10
  signed __int64 v30; // rsi
  __int64 v31; // r8
  char *v32; // rbp
  double v33; // xmm2_8
  signed __int64 v34; // r11
  __int64 v35; // r9
  double *v36; // rax
  __int64 v37; // rdx
  unsigned __int64 v38; // rcx
  double v39; // xmm0_8
  double v40; // xmm2_8
  double v41; // xmm1_8
  __int64 v42; // r9
  double *v43; // rax
  signed __int64 v44; // rcx
  double v45; // xmm0_8

  v4 = 0;
  v5 = a4;
  v6 = a2;
  v7 = a3;
  v8 = a1;
  if ( a2 > 0 )
  {
    v9 = 0i64;
    v10 = (unsigned int)v6;
    v11 = a1 - (_QWORD)v5;
    v12 = 0i64;
    v13 = v5;
    do
    {
      v14 = *(signed int *)(v7 + 4 * v12);
      v15 = *(double *)&v5[v14];
      v5[v14] = *v13;
      if ( v4 )
      {
        v16 = v9;
        if ( v9 < v12 )
        {
          v17 = *(_QWORD *)((char *)v13 + v11);
          if ( v12 - v9 < 4 )
            goto LABEL_27;
          v18 = (double *)&v5[v9 + 1];
          v19 = v17 - (_QWORD)v5;
          v20 = ((unsigned __int64)(v12 - v9 - 4) >> 2) + 1;
          v16 = v9 + 4 * v20;
          do
          {
            v21 = *(double *)((char *)v18 + v19 + 8) * v18[1];
            v22 = v15 - *(double *)((char *)v18 + v19 - 8) * *(v18 - 1) - *(double *)((char *)v18 + v19) * *v18;
            v23 = *(double *)((char *)v18 + v19 + 16) * v18[2];
            v18 += 4;
            v15 = v22 - v21 - v23;
            --v20;
          }
          while ( v20 );
          if ( v16 < v12 )
          {
LABEL_27:
            v24 = v17 - (_QWORD)v5;
            v25 = (double *)&v5[v16];
            v26 = v12 - v16;
            do
            {
              v27 = *(double *)((char *)v25 + v24) * *v25;
              ++v25;
              v15 = v15 - v27;
              --v26;
            }
            while ( v26 );
          }
        }
      }
      else if ( v15 != 0.0 )
      {
        v4 = 1;
        v9 = v12;
      }
      *(double *)v13 = v15;
      ++v12;
      ++v13;
      --v10;
    }
    while ( v10 );
  }
  result = (unsigned int)(v6 - 1);
  if ( (signed int)result >= 0 )
  {
    v29 = (signed int)result + 1i64;
    v30 = v6 - (signed int)result - 1;
    v31 = v8 + 8i64 * (signed int)result;
    v32 = (char *)v5 - v8;
    do
    {
      v33 = *(double *)&v32[v31];
      v34 = v29;
      if ( v29 < v6 )
      {
        v35 = *(_QWORD *)v31;
        if ( v30 < 4 )
          goto LABEL_28;
        v36 = (double *)&v32[v31 + 16];
        v37 = v35 - (_QWORD)v5;
        v38 = ((unsigned __int64)(v6 - v29 - 4) >> 2) + 1;
        v34 = v29 + 4 * v38;
        do
        {
          v39 = *(double *)((char *)v36 + v37 + 8) * v36[1];
          v40 = v33 - *(double *)((char *)v36 + v37 - 8) * *(v36 - 1) - *(double *)((char *)v36 + v37) * *v36;
          v41 = *(double *)((char *)v36 + v37 + 16) * v36[2];
          v36 += 4;
          v33 = v40 - v39 - v41;
          --v38;
        }
        while ( v38 );
        if ( v34 < v6 )
        {
LABEL_28:
          v42 = v35 - (_QWORD)v5;
          v43 = (double *)&v5[v34];
          v44 = v6 - v34;
          do
          {
            v45 = *(double *)((char *)v43 + v42) * *v43;
            ++v43;
            v33 = v33 - v45;
            --v44;
          }
          while ( v44 );
        }
      }
      --v29;
      ++v30;
      result = v29 - 1;
      *(double *)&v32[v31] = v33 / *(double *)(v31 - v8 + *(_QWORD *)v31);
      v31 -= 8i64;
    }
    while ( v29 - 1 >= 0 );
  }
  return result;
}

//----- (00000001800051C0) ----------------------------------------------------
signed __int64 __fastcall sub_1800051C0(__int64 *a1, int a2, __int64 a3, _QWORD *a4)
{
  signed __int64 v4; // r12
  __int64 *v5; // rsi
  _QWORD *v6; // rdi
  __int64 v7; // rbx
  signed __int64 v8; // r15
  signed __int64 v9; // r10
  __int64 *v10; // r8
  __int64 v11; // r9
  signed __int64 v12; // rdx
  double v13; // xmm1_8
  __int64 *v14; // rax
  unsigned __int64 v15; // rcx
  __int64 v16; // xmm2_8
  double v17; // xmm0_8
  __int64 v18; // xmm1_8
  __int64 *v19; // rax
  signed __int64 v20; // rcx
  __int64 v21; // xmm0_8
  signed int v22; // er13
  signed __int64 v23; // rbp
  __int64 v24; // r14
  signed __int64 v25; // rcx
  signed __int64 v26; // r9
  __int64 v27; // r11
  signed __int64 v28; // rbx
  double v29; // xmm2_8
  char *v30; // r8
  unsigned __int64 v31; // r10
  double *v32; // rdx
  double v33; // xmm2_8
  double v34; // xmm0_8
  double v35; // xmm1_8
  double *v37; // rdx
  signed __int64 v38; // r8
  double v39; // xmm0_8
  double v40; // xmm3_8
  signed int v41; // edi
  signed __int64 v42; // rbx
  __int64 v43; // r15
  __int64 v44; // r11
  signed __int64 v45; // r10
  double v46; // xmm4_8
  double v47; // xmm5_8
  double v48; // xmm2_8
  char *v49; // r9
  unsigned __int64 v50; // r8
  double *v51; // rdx
  double v52; // xmm2_8
  double v53; // xmm0_8
  double v54; // xmm1_8
  double *v55; // rdx
  signed __int64 v56; // r8
  double v57; // xmm0_8
  double v58; // xmm2_8
  signed __int64 v59; // rax
  signed int v60; // eax
  signed int v61; // edx
  signed __int64 v62; // rbx
  __int64 v63; // r11
  __int64 v64; // r9
  __int64 v65; // r8
  unsigned __int64 v66; // r10
  __int64 *v67; // rdx
  __int64 v68; // xmm0_8
  __int64 v69; // rax
  __int64 v70; // xmm0_8
  __int64 v71; // rax
  __int64 v72; // xmm1_8
  __int64 v73; // rax
  __int64 v74; // xmm0_8
  __int64 v75; // r9
  _QWORD *v76; // rdx
  signed __int64 v77; // r8
  __int64 v78; // xmm0_8
  __int64 v79; // rax
  double v80; // xmm0_8
  int v81; // er9
  signed __int64 v82; // r10
  double v83; // xmm1_8
  __int64 v84; // rdx
  unsigned int v85; // eax
  __int64 v86; // r8
  __int64 v87; // rax
  __int64 *v88; // rdx
  __int64 v89; // r8
  __int64 v90; // rax
  signed int v91; // [rsp+20h] [rbp-A8h]
  char v92; // [rsp+24h] [rbp-A4h]
  __int64 v93; // [rsp+28h] [rbp-A0h]
  _QWORD *v94; // [rsp+30h] [rbp-98h]
  __int64 v95; // [rsp+38h] [rbp-90h]
  signed int v96; // [rsp+D8h] [rbp+10h]
  __int64 v97; // [rsp+E0h] [rbp+18h]
  _QWORD *v98; // [rsp+E8h] [rbp+20h]

  v98 = a4;
  v97 = a3;
  v4 = a2;
  v5 = a1;
  v6 = a4;
  v96 = 0;
  v7 = UF_allocate_memory((unsigned int)(8 * a2), &v92);
  v8 = v4;
  v93 = v7;
  *v6 = 4607182418800017408i64;
  if ( (signed int)v4 <= 0 )
  {
LABEL_11:
    v22 = 0;
    if ( (signed int)v4 <= 0 )
    {
LABEL_67:
      UF_free(v7);
      return 0i64;
    }
    v91 = v4 - 1;
    v23 = 0i64;
    v24 = 0i64;
    v94 = (__int64 *)((char *)v5 - v7);
    v25 = 0i64;
    v95 = v7 - (_QWORD)v5;
    while ( 1 )
    {
      v26 = 0i64;
      if ( v23 > 0 )
      {
        while ( 1 )
        {
          v27 = v5[v26];
          v28 = 0i64;
          v29 = *(double *)(v25 + v27);
          if ( v26 >= 4 )
            break;
          if ( v26 > 0 )
            goto LABEL_21;
LABEL_23:
          ++v26;
          *(double *)(v25 + v27) = v29;
          if ( v26 >= v23 )
            goto LABEL_24;
        }
        v30 = (char *)v5 - v27;
        v31 = ((unsigned __int64)(v26 - 4) >> 2) + 1;
        v32 = (double *)(v27 + 8);
        v28 = 4 * v31;
        do
        {
          v33 = v29
              - *(double *)(*(_QWORD *)((char *)v32 + (_QWORD)v30 - 8) + v25) * *(v32 - 1)
              - *(double *)(*(_QWORD *)((char *)v32 + (_QWORD)v30) + v25) * *v32;
          v34 = *(double *)(*(_QWORD *)((char *)v32 + (_QWORD)v30 + 8) + v25) * v32[1];
          v35 = *(double *)(*(_QWORD *)((char *)v32 + (_QWORD)v30 + 16) + v25) * v32[2];
          v32 += 4;
          v29 = v33 - v34 - v35;
          --v31;
        }
        while ( v31 );
        if ( v28 >= v26 )
          goto LABEL_23;
LABEL_21:
        v37 = (double *)(v27 + 8 * v28);
        v38 = v26 - v28;
        do
        {
          v39 = *(double *)(*(_QWORD *)((char *)v37 + (_QWORD)v5 - v27) + v25) * *v37;
          ++v37;
          v29 = v29 - v39;
          --v38;
        }
        while ( v38 );
        goto LABEL_23;
      }
LABEL_24:
      v40 = 0.0;
      v41 = v22;
      v42 = v23;
      if ( v22 < (signed int)v4 )
      {
        v43 = v93;
        while ( 1 )
        {
          v44 = v5[v42];
          v45 = 0i64;
          v46 = v40;
          v47 = v40;
          v48 = *(double *)(v25 + v44);
          if ( v25 >= 32 )
            break;
          if ( v25 > 0 )
            goto LABEL_32;
LABEL_34:
          *(double *)(v25 + v44) = v48;
          v58 = COERCE_DOUBLE(*(_QWORD *)&v48 & xmmword_18000C190) * *(double *)(v43 + 8 * v42);
          if ( v58 >= v40 )
            v40 = v58;
          v59 = v42;
          if ( v58 < v46 )
            v59 = v24;
          v24 = v59;
          v60 = v41;
          if ( v58 < v47 )
            v60 = v96;
          ++v41;
          ++v42;
          v96 = v60;
          v61 = v60;
          if ( v41 >= (signed int)v4 )
          {
            v96 = v60;
            v8 = v4;
            goto LABEL_43;
          }
        }
        v49 = (char *)v5 - v44;
        v50 = ((unsigned __int64)(v23 - 4) >> 2) + 1;
        v51 = (double *)(v44 + 8);
        v45 = 4 * v50;
        do
        {
          v52 = v48
              - *(double *)(*(_QWORD *)((char *)v51 + (_QWORD)v49 - 8) + v25) * *(v51 - 1)
              - *(double *)(*(_QWORD *)&v49[(_QWORD)v51] + v25) * *v51;
          v53 = *(double *)(*(_QWORD *)((char *)v51 + (_QWORD)v49 + 8) + v25) * v51[1];
          v54 = *(double *)(*(_QWORD *)((char *)v51 + (_QWORD)v49 + 16) + v25) * v51[2];
          v51 += 4;
          v48 = v52 - v53 - v54;
          --v50;
        }
        while ( v50 );
        if ( v45 >= v23 )
          goto LABEL_34;
LABEL_32:
        v55 = (double *)(v44 + 8 * v45);
        v56 = v23 - v45;
        do
        {
          v57 = *(double *)(*(__int64 *)((char *)v5 + (_QWORD)v55 - v44) + v25) * *v55;
          ++v55;
          v48 = v48 - v57;
          --v56;
        }
        while ( v56 );
        goto LABEL_34;
      }
      v61 = v96;
LABEL_43:
      if ( v22 == v61 )
      {
        v7 = v93;
        goto LABEL_56;
      }
      v62 = 0i64;
      if ( v8 >= 4 )
        break;
      if ( v8 > 0 )
      {
        v64 = v5[v24];
        v63 = v5[(unsigned __int64)v25 / 8];
        goto LABEL_51;
      }
LABEL_54:
      v7 = v93;
      *v98 ^= xmmword_18000BB10;
      *(_QWORD *)(v7 + 8 * v24) = *(_QWORD *)(v25 + v7);
LABEL_56:
      *(_DWORD *)(v97 + 4 * v23) = v61;
      v79 = v5[(unsigned __int64)v25 / 8];
      v80 = *(double *)(v25 + v79);
      if ( v80 == 0.0 )
      {
        v80 = 9.999999999999999e-21;
        *(_QWORD *)(v25 + v79) = 4307583784117748259i64;
      }
      if ( v22 != (_DWORD)v4 - 1 )
      {
        v81 = v22 + 1;
        v82 = v23 + 1;
        v83 = 1.0 / v80;
        if ( v22 + 1 < (signed int)v4 )
        {
          if ( v91 >= 4 )
          {
            v84 = (__int64)&v5[(unsigned __int64)v25 / 8] + (_QWORD)v94 + v95 + 24;
            v85 = ((unsigned int)(v4 - v81 - 4) >> 2) + 1;
            v86 = v85;
            v81 += 4 * v85;
            v82 += 4i64 * v85;
            do
            {
              v87 = *(_QWORD *)(v84 - 16);
              v84 += 32i64;
              *(double *)(v87 + v25) = v83 * *(double *)(v87 + v25);
              *(double *)(*(_QWORD *)(v84 - 40) + v25) = v83 * *(double *)(*(_QWORD *)(v84 - 40) + v25);
              *(double *)(v25 + *(_QWORD *)(v84 - 32)) = v83 * *(double *)(v25 + *(_QWORD *)(v84 - 32));
              *(double *)(*(_QWORD *)(v84 - 24) + v25) = v83 * *(double *)(*(_QWORD *)(v84 - 24) + v25);
              --v86;
            }
            while ( v86 );
          }
          if ( v81 < (signed int)v4 )
          {
            v88 = &v5[v82];
            v89 = (signed int)v4 - v81;
            do
            {
              v90 = *v88;
              ++v88;
              *(double *)(v25 + v90) = v83 * *(double *)(v25 + v90);
              --v89;
            }
            while ( v89 );
          }
        }
      }
      --v91;
      ++v22;
      ++v23;
      v25 += 8i64;
      if ( v22 >= (signed int)v4 )
        goto LABEL_67;
    }
    v63 = v5[(unsigned __int64)v25 / 8];
    v64 = v5[v24];
    v65 = v5[v24] - v63;
    v66 = ((unsigned __int64)(v8 - 4) >> 2) + 1;
    v67 = (__int64 *)(v63 + 8);
    v62 = 4 * v66;
    do
    {
      v68 = *(__int64 *)((char *)v67 + v65 - 8);
      *(__int64 *)((char *)v67 + v65 - 8) = *(v67 - 1);
      v69 = *v67;
      *(v67 - 1) = v68;
      v70 = *(__int64 *)((char *)v67 + v65);
      *(__int64 *)((char *)v67 + v65) = v69;
      v71 = v67[1];
      *v67 = v70;
      v72 = *(__int64 *)((char *)v67 + v65 + 8);
      *(__int64 *)((char *)v67 + v65 + 8) = v71;
      v73 = v67[2];
      v67[1] = v72;
      v74 = *(__int64 *)((char *)v67 + v65 + 16);
      *(__int64 *)((char *)v67 + v65 + 16) = v73;
      v67[2] = v74;
      v67 += 4;
      --v66;
    }
    while ( v66 );
    if ( v62 < v8 )
    {
LABEL_51:
      v75 = v64 - v63;
      v76 = (_QWORD *)(v63 + 8 * v62);
      v77 = v8 - v62;
      do
      {
        v78 = *(_QWORD *)((char *)v76 + v75);
        *(_QWORD *)((char *)v76 + v75) = *v76;
        *v76 = v78;
        ++v76;
        --v77;
      }
      while ( v77 );
    }
    v61 = v96;
    goto LABEL_54;
  }
  v9 = 0i64;
  v10 = v5;
  while ( 1 )
  {
    v11 = *v10;
    v12 = 0i64;
    v13 = 0.0;
    if ( v4 < 4 )
      goto LABEL_70;
    v14 = (__int64 *)(v11 + 16);
    v15 = ((unsigned __int64)(v4 - 4) >> 2) + 1;
    v12 = 4 * v15;
    do
    {
      v16 = *v14;
      v17 = fmax(COERCE_DOUBLE(*(v14 - 2) & xmmword_18000C190), v13);
      v18 = *(v14 - 1);
      v14 += 4;
      v13 = fmax(
              COERCE_DOUBLE(*(v14 - 3) & xmmword_18000C190),
              fmax(COERCE_DOUBLE(v16 & xmmword_18000C190), fmax(COERCE_DOUBLE(v18 & xmmword_18000C190), v17)));
      --v15;
    }
    while ( v15 );
    if ( v12 < v4 )
    {
LABEL_70:
      v19 = (__int64 *)(v11 + 8 * v12);
      v20 = v4 - v12;
      do
      {
        v21 = *v19;
        ++v19;
        v13 = fmax(COERCE_DOUBLE(v21 & xmmword_18000C190), v13);
        --v20;
      }
      while ( v20 );
    }
    if ( v13 == 0.0 )
      break;
    ++v9;
    *(double *)((char *)v10 + v7 - (_QWORD)v5) = 1.0 / v13;
    ++v10;
    if ( v9 >= v4 )
      goto LABEL_11;
  }
  UF_free(v7);
  return 1i64;
}
// 18000B2A8: using guessed type __int64 __fastcall UF_allocate_memory(_QWORD, _QWORD);
// 18000B2B0: using guessed type __int64 __fastcall UF_free(_QWORD);
// 18000BB10: using guessed type __int128 xmmword_18000BB10;
// 18000C190: using guessed type __int128 xmmword_18000C190;

//----- (0000000180005840) ----------------------------------------------------
__int64 __fastcall sub_180005840(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r8
  double v4; // xmm0_8
  __int64 v5; // rcx
  double v6; // xmm5_8
  __int64 v7; // rcx
  double *v8; // r8
  double *v9; // r9
  double v10; // xmm0_8
  double v11; // xmm5_8
  __int128 v12; // xmm3
  __int128 v13; // xmm4
  __int64 v14; // xmm2_8
  __int64 result; // rax
  double v16; // xmm2_8
  __int128 v17; // xmm3
  __int128 v18; // xmm4
  __int64 v19; // xmm2_8

  v4 = sub_1800060E0(*(double *)(a3 + 24));
  if ( COERCE_DOUBLE(COERCE_UNSIGNED_INT64(*(double *)(v5 + 24) - v6) & xmmword_18000C190) > COERCE_DOUBLE(COERCE_UNSIGNED_INT64(*(double *)(v5 + 24) - v4) & xmmword_18000C190) )
    *(double *)(v3 + 24) = v4;
  v10 = sub_1800060E0(*(double *)(v3 + 32));
  if ( COERCE_DOUBLE(COERCE_UNSIGNED_INT64(*(double *)(v7 + 32) - v8[4]) & xmmword_18000C190) > COERCE_DOUBLE(COERCE_UNSIGNED_INT64(*(double *)(v7 + 32) - v10) & xmmword_18000C190) )
    v8[4] = v10;
  if ( COERCE_DOUBLE(COERCE_UNSIGNED_INT64(*(double *)(v7 + 24) - v11) & xmmword_18000C190) > COERCE_DOUBLE(COERCE_UNSIGNED_INT64(*(double *)(v7 + 24) - v9[3]) & xmmword_18000C190) )
  {
    v12 = *(_OWORD *)v8;
    v13 = *((_OWORD *)v8 + 1);
    v14 = *((_QWORD *)v8 + 4);
    *(_OWORD *)v8 = *(_OWORD *)v9;
    *((_OWORD *)v8 + 1) = *((_OWORD *)v9 + 1);
    v8[4] = v9[4];
    *(_OWORD *)v9 = v12;
    *((_OWORD *)v9 + 1) = v13;
    *((_QWORD *)v9 + 4) = v14;
    v11 = v8[3];
  }
  result = qword_18000F3C8;
  if ( v11 <= *(double *)(qword_18000F3C8 + 104) - *(double *)&qword_18000F000
    || *(double *)&qword_18000F000 + *(double *)(qword_18000F3C8 + 112) <= v11 )
  {
    v16 = v9[3];
    if ( v16 > *(double *)(qword_18000F3C8 + 120) - *(double *)&qword_18000F000
      && *(double *)&qword_18000F000 + *(double *)(qword_18000F3C8 + 128) > v16 )
    {
      v17 = *(_OWORD *)v8;
      v18 = *((_OWORD *)v8 + 1);
      v19 = *((_QWORD *)v8 + 4);
      *(_OWORD *)v8 = *(_OWORD *)v9;
      *((_OWORD *)v8 + 1) = *((_OWORD *)v9 + 1);
      v8[4] = v9[4];
      *(_OWORD *)v9 = v17;
      *((_OWORD *)v9 + 1) = v18;
      *((_QWORD *)v9 + 4) = v19;
    }
  }
  return result;
}
// 18000C190: using guessed type __int128 xmmword_18000C190;
// 18000F000: using guessed type __int64 qword_18000F000;
// 18000F3C8: using guessed type __int64 qword_18000F3C8;

//----- (00000001800059B0) ----------------------------------------------------
void __fastcall sub_1800059B0(double a1)
{
  if ( *(double *)&qword_18000F000 < COERCE_DOUBLE(COERCE_UNSIGNED_INT64(a1 - 1.0) & xmmword_18000C190)
    && *(double *)&qword_18000F000 < COERCE_DOUBLE(COERCE_UNSIGNED_INT64(a1 - -1.0) & xmmword_18000C190) )
  {
    acos(a1);
  }
}
// 18000C190: using guessed type __int128 xmmword_18000C190;
// 18000F000: using guessed type __int64 qword_18000F000;

//----- (0000000180005A00) ----------------------------------------------------
double __fastcall sub_180005A00(__int64 a1, __int64 a2, __int64 a3)
{
  double v4; // [rsp+48h] [rbp+20h]

  UF_VEC3_angle_between(a1, a2, a3, &v4);
  return v4;
}
// 18000B1B8: using guessed type __int64 __fastcall UF_VEC3_angle_between(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180005A20) ----------------------------------------------------
signed __int64 __fastcall sub_180005A20(__int64 *a1, __int64 a2)
{
  __int64 v2; // xmm1_8
  __int64 v3; // xmm0_8
  __int64 v4; // rdi
  __int64 v5; // xmm1_8
  __int64 v6; // xmm0_8
  __int64 v7; // xmm1_8
  __int64 v8; // xmm0_8
  __int64 v9; // xmm1_8
  __int64 v10; // xmm0_8
  __int64 v11; // xmm1_8
  __int64 v12; // xmm0_8
  __int64 v13; // xmm1_8
  __int64 v14; // xmm0_8
  __int64 v15; // xmm1_8
  __int64 v16; // xmm0_8
  __int64 v17; // xmm1_8
  signed __int64 result; // rax
  signed __int64 v19; // rbx
  char *v20; // rsi
  signed __int64 v21; // rdi
  __m128d v22; // xmm0
  __m128d v23; // xmm1
  __int64 *v24; // [rsp+20h] [rbp-89h]
  __int64 *v25; // [rsp+28h] [rbp-81h]
  __int64 *v26; // [rsp+30h] [rbp-79h]
  __int64 *v27; // [rsp+38h] [rbp-71h]
  __m128d v28; // [rsp+40h] [rbp-69h]
  __m128d v29; // [rsp+50h] [rbp-59h]
  __int64 v30; // [rsp+60h] [rbp-49h]
  __int64 v31; // [rsp+68h] [rbp-41h]
  __int64 v32; // [rsp+70h] [rbp-39h]
  __int64 v33; // [rsp+78h] [rbp-31h]
  __int64 v34; // [rsp+80h] [rbp-29h]
  __int64 v35; // [rsp+88h] [rbp-21h]
  __int64 v36; // [rsp+90h] [rbp-19h]
  __int64 v37; // [rsp+98h] [rbp-11h]
  __int64 v38; // [rsp+A0h] [rbp-9h]
  __int64 v39; // [rsp+A8h] [rbp-1h]
  __int64 v40; // [rsp+B0h] [rbp+7h]
  __int64 v41; // [rsp+B8h] [rbp+Fh]
  __int64 v42; // [rsp+C0h] [rbp+17h]
  __int64 v43; // [rsp+C8h] [rbp+1Fh]
  __int64 v44; // [rsp+D0h] [rbp+27h]
  __int64 v45; // [rsp+D8h] [rbp+2Fh]
  char v46; // [rsp+E0h] [rbp+37h]
  char v47; // [rsp+120h] [rbp+77h]

  v2 = a1[4];
  v30 = *a1;
  v3 = a1[8];
  v4 = a2;
  v34 = v2;
  v5 = a1[12];
  v38 = v3;
  v6 = a1[1];
  v42 = v5;
  v7 = a1[5];
  v31 = v6;
  v8 = a1[9];
  v35 = v7;
  v9 = a1[13];
  v39 = v8;
  v10 = a1[2];
  v43 = v9;
  v11 = a1[6];
  v32 = v10;
  v12 = a1[10];
  v36 = v11;
  v13 = a1[14];
  v24 = &v30;
  v40 = v12;
  v14 = a1[3];
  v44 = v13;
  v15 = a1[7];
  v25 = &v34;
  v33 = v14;
  v16 = a1[11];
  v37 = v15;
  v17 = a1[15];
  v26 = &v38;
  v41 = v16;
  v45 = v17;
  v27 = &v42;
  result = sub_1800051C0((__int64 *)&v24, 4, (__int64)&v46, &v47);
  if ( !(_DWORD)result )
  {
    v19 = v4 + 64;
    v20 = (char *)&v28 - v4;
    v21 = 4i64;
    do
    {
      v28 = 0i64;
      v29 = 0i64;
      *(_QWORD *)&v20[v19 - 64] = 4607182418800017408i64;
      result = sub_180004F40((__int64)&v24, 4, (__int64)&v46, &v28);
      v19 += 8i64;
      v22 = v28;
      v23 = v29;
      *(double *)(v19 - 72) = v28.m128d_f64[0];
      *(double *)(v19 - 8) = v23.m128d_f64[0];
      *(_QWORD *)(v19 - 40) = (unsigned __int128)_mm_unpckh_pd(v22, v22);
      *(_QWORD *)(v19 + 24) = (unsigned __int128)_mm_unpckh_pd(v23, v23);
      --v21;
    }
    while ( v21 );
  }
  return result;
}

//----- (0000000180005BC0) ----------------------------------------------------
__int64 __fastcall sub_180005BC0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rdi
  __int64 v5; // rbx
  char v7; // [rsp+20h] [rbp-F8h]
  char v8; // [rsp+40h] [rbp-D8h]
  char v9; // [rsp+90h] [rbp-88h]

  v4 = a4;
  v5 = a1;
  UF_MTX4_rotation(&xmmword_18000F520, &qword_18000F4F0, a3, &v9);
  sub_180006500((__int64)&v9);
  UF_MTX4_ask_rotation(&v9, &v8);
  UF_MTX3_vec_multiply(&xmmword_18000F538, &v8, &v7);
  return UF_VEC3_add(v5, &v7, v4);
}
// 18000B1F0: using guessed type __int64 __fastcall UF_MTX4_rotation(_QWORD, _QWORD, _QWORD, _QWORD);
// 18000B218: using guessed type __int64 __fastcall UF_MTX4_ask_rotation(_QWORD, _QWORD);
// 18000B240: using guessed type __int64 __fastcall UF_MTX3_vec_multiply(_QWORD, _QWORD, _QWORD);
// 18000B2A0: using guessed type __int64 __fastcall UF_VEC3_add(_QWORD, _QWORD, _QWORD);
// 18000F4F0: using guessed type __int64 qword_18000F4F0;
// 18000F520: using guessed type __int128 xmmword_18000F520;
// 18000F538: using guessed type __int128 xmmword_18000F538;

//----- (0000000180005C60) ----------------------------------------------------
__int64 __fastcall sub_180005C60(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 v5; // xmm3_8
  __int128 v6; // xmm6
  __int64 v7; // rdx
  __int64 v8; // r8
  __int64 result; // rax
  __int64 v10; // xmm1_8
  char v11; // [rsp+20h] [rbp-D8h]
  __int128 v12; // [rsp+38h] [rbp-C0h]
  __int64 v13; // [rsp+48h] [rbp-B0h]
  __int128 v14; // [rsp+50h] [rbp-A8h]
  __int64 v15; // [rsp+60h] [rbp-98h]
  double v16; // [rsp+68h] [rbp-90h]
  __int128 v17; // [rsp+70h] [rbp-88h]
  char v18; // [rsp+88h] [rbp-70h]
  char v19; // [rsp+A8h] [rbp-50h]
  __int64 v20; // [rsp+B0h] [rbp-48h]
  char v21; // [rsp+128h] [rbp+30h]
  char v22; // [rsp+178h] [rbp+80h]
  char v23; // [rsp+1F8h] [rbp+100h]
  void *retaddr; // [rsp+2A8h] [rbp+1B0h]
  signed int v25; // [rsp+2C8h] [rbp+1D0h]

  v4 = a4;
  v5 = *(_QWORD *)(a1 + 16);
  v14 = *(_OWORD *)a1;
  v16 = (double)v25;
  v13 = 0i64;
  v12 = 0i64;
  v6 = *(unsigned __int64 *)(qword_18000F3C8 + 8);
  v15 = v5;
  UF_MTX4_rotation(&xmmword_18000F538, &qword_18000F508, a3, &v20);
  sub_180006500((__int64)&v19);
  UF_MTX4_ask_rotation(&v19, &v21);
  UF_MTX3_vec_multiply(&qword_18000F4F0, &v21, &v11);
  UF_VEC3_unitize(&v11, v7, &retaddr, &v11);
  UF_MTX4_vec3_multiply(&v12, &v19, &v18);
  UF_MTX4_rotation(&v18, &v11, v8, &v22);
  sub_180006500((__int64)&v22);
  UF_MTX4_multiply(&v19, &v22, &v23);
  sub_180006500((__int64)&v23);
  result = UF_MTX4_vec_multiply(&v14, &v23, &v17);
  v10 = *((_QWORD *)&v17 + 1);
  *(_OWORD *)v4 = v17;
  *(_QWORD *)(v4 + 16) = v10;
  return result;
}
// 18000B1F0: using guessed type __int64 __fastcall UF_MTX4_rotation(_QWORD, _QWORD, _QWORD, _QWORD);
// 18000B200: using guessed type __int64 __fastcall UF_MTX4_vec3_multiply(_QWORD, _QWORD, _QWORD);
// 18000B208: using guessed type __int64 __fastcall UF_MTX4_vec_multiply(_QWORD, _QWORD, _QWORD);
// 18000B210: using guessed type __int64 __fastcall UF_MTX4_multiply(_QWORD, _QWORD, _QWORD);
// 18000B218: using guessed type __int64 __fastcall UF_MTX4_ask_rotation(_QWORD, _QWORD);
// 18000B240: using guessed type __int64 __fastcall UF_MTX3_vec_multiply(_QWORD, _QWORD, _QWORD);
// 18000B258: using guessed type __int64 __fastcall UF_VEC3_unitize(_QWORD, _QWORD, _QWORD, _QWORD);
// 18000F3C8: using guessed type __int64 qword_18000F3C8;
// 18000F4F0: using guessed type __int64 qword_18000F4F0;
// 18000F508: using guessed type __int64 qword_18000F508;
// 18000F538: using guessed type __int128 xmmword_18000F538;

//----- (0000000180005DF0) ----------------------------------------------------
__int64 __fastcall sub_180005DF0(__int64 a1, double a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rdi
  char v6; // [rsp+20h] [rbp-88h]

  v3 = a3;
  v4 = a1;
  sub_180004DB0(a2, (double *)&qword_18000F508, (__int64)&v6);
  sub_180006500((__int64)&v6);
  return UF_MTX4_vec3_multiply_t(v4, &v6, v3);
}
// 18000B290: using guessed type __int64 __fastcall UF_MTX4_vec3_multiply_t(_QWORD, _QWORD, _QWORD);
// 18000F508: using guessed type __int64 qword_18000F508;

//----- (0000000180005E50) ----------------------------------------------------
void __fastcall sub_180005E50(__int64 a1, double *a2, double *a3)
{
  double v3; // xmm3_8
  double v4; // xmm5_8
  double *v5; // r15
  __int64 v6; // r14
  double v7; // xmm8_8
  double v8; // xmm7_8
  __int64 *v9; // rdi
  int v10; // esi
  signed __int64 v11; // rbx
  __int64 v12; // xmm6_8
  __int64 v13; // rdx
  __int64 v14; // r8
  __int64 v15; // rdx
  __int64 v16; // r8
  __int64 *v17; // rdi
  int v18; // esi
  signed __int64 v19; // rbx
  __int64 v20; // xmm6_8
  __int64 v21; // rdx
  __int64 v22; // r8
  __int64 v23; // [rsp+20h] [rbp-B8h]
  __int64 v24; // [rsp+28h] [rbp-B0h]
  char v25; // [rsp+30h] [rbp-A8h]
  __int128 v26; // [rsp+48h] [rbp-90h]
  double v27; // [rsp+58h] [rbp-80h]
  double v28; // [rsp+60h] [rbp-78h]
  double v29; // [rsp+68h] [rbp-70h]
  double v30; // [rsp+70h] [rbp-68h]
  double v31; // [rsp+78h] [rbp-60h]
  double v32; // [rsp+80h] [rbp-58h]
  double v33; // [rsp+88h] [rbp-50h]
  double v34; // [rsp+90h] [rbp-48h]
  __int64 Base; // [rsp+98h] [rbp-40h]
  int v36; // [rsp+130h] [rbp+58h]
  char v37; // [rsp+138h] [rbp+60h]

  v3 = *a2;
  v4 = a2[1];
  v26 = 0i64;
  v5 = a2;
  v6 = a1;
  v27 = 1.0;
  v31 = 3.141592653589793 - v3;
  v28 = 3.141592653589793 - v3;
  v30 = v3 + 3.141592653589793;
  v7 = *a3;
  v8 = a3[1];
  v32 = 3.141592653589793 - v4;
  v34 = 3.141592653589793 - v4;
  v27 = 3.141592653589793 - v3 * -1.0;
  v28 = v3;
  v29 = v4;
  v30 = v4 * -1.0;
  v31 = v4 + 3.141592653589793;
  v33 = 3.141592653589793 - v4 * -1.0;
  if ( *(double *)&qword_18000F000 >= COERCE_DOUBLE(COERCE_UNSIGNED_INT64(v7 - v8) & xmmword_18000C190) )
    a3[1] = v8 * -1.0;
  v9 = &Base;
  v10 = 0;
  v11 = 0i64;
  do
  {
    v12 = *((_QWORD *)&v28 + v11);
    LODWORD(v23) = 0;
    sub_180005C60(v6, (__int64)a2, (__int64)a3, (__int64)&v25);
    UF_VEC3_unitize(&v25, v13, &v37, &v25);
    UF_VEC3_is_equal(&v26, &v25, v14, &v36, v23, v24, *(_QWORD *)&v25);
    if ( v36 )
    {
      ++v10;
      *v9 = v12;
      ++v9;
    }
    ++v11;
  }
  while ( v11 < 6 );
  qsort(&Base, v10 - 1, 8ui64, (int (__cdecl *)(const void *, const void *))PtFuncCompare);
  v17 = &Base;
  *(_QWORD *)v5 = Base;
  v18 = 0;
  v19 = 0i64;
  do
  {
    v20 = *((_QWORD *)&v29 + v19);
    LODWORD(v23) = 0;
    sub_180005C60(v6, v15, v16, (__int64)&v25);
    UF_VEC3_unitize(&v25, v21, &v37, &v25);
    UF_VEC3_is_equal(&v26, &v25, v22, &v36, v23, v24, *(_QWORD *)&v25);
    if ( v36 )
    {
      ++v18;
      *v17 = v20;
      ++v17;
    }
    ++v19;
  }
  while ( v19 < 6 );
  qsort(&Base, v18 - 1, 8ui64, (int (__cdecl *)(const void *, const void *))PtFuncCompare);
  *((_QWORD *)v5 + 1) = Base;
}
// 18000B258: using guessed type __int64 __fastcall UF_VEC3_unitize(_QWORD, _QWORD, _QWORD, _QWORD);
// 18000C190: using guessed type __int128 xmmword_18000C190;
// 18000F000: using guessed type __int64 qword_18000F000;

//----- (00000001800060E0) ----------------------------------------------------
double __fastcall sub_1800060E0(double result)
{
  if ( result > 0.0 )
    return result - 360.0;
  if ( result < 0.0 )
    result = result + 360.0;
  return result;
}

//----- (0000000180006110) ----------------------------------------------------
__int64 sub_180006110(__int64 a1, ...)
{
  __int64 v1; // rbx
  _QWORD *v2; // rax
  __int64 v4; // [rsp+50h] [rbp+8h]
  va_list va; // [rsp+58h] [rbp+10h]

  va_start(va, a1);
  v4 = a1;
  v1 = _acrt_iob_func(1i64);
  v2 = sub_180001F00();
  return _stdio_common_vfprintf(*v2, v1, v4, 0i64, (__int64 *)va);
}
// 18000B158: using guessed type __int64 __fastcall _stdio_common_vfprintf(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 18000B168: using guessed type __int64 __fastcall _acrt_iob_func(_QWORD);

//----- (0000000180006170) ----------------------------------------------------
__m128 __fastcall sub_180006170(double *a1, double *a2)
{
  double v2; // xmm3_8
  __int128 v3; // xmm2
  double v5; // xmm1_8
  __int128 v6; // xmm0

  v2 = *a2;
  v3 = 0i64;
  if ( COERCE_DOUBLE(COERCE_UNSIGNED_INT64(COERCE_DOUBLE(*(_QWORD *)a2 & xmmword_18000C190) - 0.0) & xmmword_18000C190) <= 1.0e-10 )
    return (__m128)0i64;
  v5 = 1.0 / v2 * *a1;
  if ( v5 >= 0.000001 )
  {
    *((_QWORD *)&v6 + 1) = 0i64;
    *(double *)&v6 = floor(v5 + 0.5);
    goto LABEL_7;
  }
  if ( v5 <= -0.000001 )
  {
    *((_QWORD *)&v6 + 1) = 0i64;
    *(double *)&v6 = ceil(v5 - 0.5);
LABEL_7:
    v3 = v6;
  }
  *(double *)&v3 = *(double *)&v3 / (1.0 / v2);
  return (__m128)v3;
}
// 18000C190: using guessed type __int128 xmmword_18000C190;

//----- (0000000180006210) ----------------------------------------------------
signed __int64 __fastcall sub_180006210(double *a1)
{
  double *v1; // rbx
  __int64 v2; // rdx
  double v3; // xmm2_8
  signed __int64 v4; // xmm0_8
  signed __int64 v5; // xmm2_8
  double v6; // xmm2_8
  signed __int64 v7; // xmm2_8
  double v8; // xmm2_8
  signed __int64 v9; // xmm2_8
  double v10; // xmm2_8
  signed __int64 v11; // xmm2_8
  double v12; // xmm2_8
  signed __int64 v13; // xmm2_8
  double v14; // xmm2_8
  signed __int64 v15; // xmm2_8
  double v16; // xmm2_8
  signed __int64 v17; // xmm2_8
  double v18; // xmm2_8
  signed __int64 v19; // xmm2_8
  double v20; // xmm2_8
  __int64 v21; // rdx
  char v23; // [rsp+20h] [rbp-B8h]
  char v24; // [rsp+38h] [rbp-A0h]
  char v25; // [rsp+50h] [rbp-88h]
  char v26; // [rsp+70h] [rbp-68h]
  char v27; // [rsp+E0h] [rbp+8h]

  v1 = a1;
  UF_VEC3_copy(a1, &v24);
  UF_VEC3_copy(v1 + 3, &v23);
  UF_VEC3_copy(v1 + 6, &v25);
  UF_MTX3_copy(v1, &v26);
  *(_QWORD *)&v3 = *(_QWORD *)v1 & xmmword_18000C190;
  v4 = 4607182418800017408i64;
  if ( v3 > 1.0e-10 )
  {
    if ( COERCE_DOUBLE(COERCE_UNSIGNED_INT64(v3 - 1.0) & xmmword_18000C190) <= 1.0e-10 )
    {
      if ( *v1 <= 0.0 )
        v5 = -4616189618054758400i64;
      else
        v5 = 4607182418800017408i64;
      *(_QWORD *)v1 = v5;
    }
  }
  else
  {
    *v1 = 0.0;
  }
  *(_QWORD *)&v6 = (_QWORD)v1[1] & xmmword_18000C190;
  if ( v6 > 1.0e-10 )
  {
    if ( COERCE_DOUBLE(COERCE_UNSIGNED_INT64(v6 - 1.0) & xmmword_18000C190) <= 1.0e-10 )
    {
      if ( v1[1] <= 0.0 )
        v7 = -4616189618054758400i64;
      else
        v7 = 4607182418800017408i64;
      *((_QWORD *)v1 + 1) = v7;
    }
  }
  else
  {
    v1[1] = 0.0;
  }
  *(_QWORD *)&v8 = (_QWORD)v1[2] & xmmword_18000C190;
  if ( v8 > 1.0e-10 )
  {
    if ( COERCE_DOUBLE(COERCE_UNSIGNED_INT64(v8 - 1.0) & xmmword_18000C190) <= 1.0e-10 )
    {
      if ( v1[2] <= 0.0 )
        v9 = -4616189618054758400i64;
      else
        v9 = 4607182418800017408i64;
      *((_QWORD *)v1 + 2) = v9;
    }
  }
  else
  {
    v1[2] = 0.0;
  }
  *(_QWORD *)&v10 = (_QWORD)v1[3] & xmmword_18000C190;
  if ( v10 > 1.0e-10 )
  {
    if ( COERCE_DOUBLE(COERCE_UNSIGNED_INT64(v10 - 1.0) & xmmword_18000C190) <= 1.0e-10 )
    {
      if ( v1[3] <= 0.0 )
        v11 = -4616189618054758400i64;
      else
        v11 = 4607182418800017408i64;
      *((_QWORD *)v1 + 3) = v11;
    }
  }
  else
  {
    v1[3] = 0.0;
  }
  *(_QWORD *)&v12 = (_QWORD)v1[4] & xmmword_18000C190;
  if ( v12 > 1.0e-10 )
  {
    if ( COERCE_DOUBLE(COERCE_UNSIGNED_INT64(v12 - 1.0) & xmmword_18000C190) <= 1.0e-10 )
    {
      if ( v1[4] <= 0.0 )
        v13 = -4616189618054758400i64;
      else
        v13 = 4607182418800017408i64;
      *((_QWORD *)v1 + 4) = v13;
    }
  }
  else
  {
    v1[4] = 0.0;
  }
  *(_QWORD *)&v14 = (_QWORD)v1[5] & xmmword_18000C190;
  if ( v14 > 1.0e-10 )
  {
    if ( COERCE_DOUBLE(COERCE_UNSIGNED_INT64(v14 - 1.0) & xmmword_18000C190) <= 1.0e-10 )
    {
      if ( v1[5] <= 0.0 )
        v15 = -4616189618054758400i64;
      else
        v15 = 4607182418800017408i64;
      *((_QWORD *)v1 + 5) = v15;
    }
  }
  else
  {
    v1[5] = 0.0;
  }
  *(_QWORD *)&v16 = (_QWORD)v1[6] & xmmword_18000C190;
  if ( v16 > 1.0e-10 )
  {
    if ( COERCE_DOUBLE(COERCE_UNSIGNED_INT64(v16 - 1.0) & xmmword_18000C190) <= 1.0e-10 )
    {
      if ( v1[6] <= 0.0 )
        v17 = -4616189618054758400i64;
      else
        v17 = 4607182418800017408i64;
      *((_QWORD *)v1 + 6) = v17;
    }
  }
  else
  {
    v1[6] = 0.0;
  }
  *(_QWORD *)&v18 = (_QWORD)v1[7] & xmmword_18000C190;
  if ( v18 > 1.0e-10 )
  {
    if ( COERCE_DOUBLE(COERCE_UNSIGNED_INT64(v18 - 1.0) & xmmword_18000C190) <= 1.0e-10 )
    {
      if ( v1[7] <= 0.0 )
        v19 = -4616189618054758400i64;
      else
        v19 = 4607182418800017408i64;
      *((_QWORD *)v1 + 7) = v19;
    }
  }
  else
  {
    v1[7] = 0.0;
  }
  *(_QWORD *)&v20 = (_QWORD)v1[8] & xmmword_18000C190;
  if ( v20 > 1.0e-10 )
  {
    if ( COERCE_DOUBLE(COERCE_UNSIGNED_INT64(v20 - 1.0) & xmmword_18000C190) <= 1.0e-10 )
    {
      if ( v1[8] <= 0.0 )
        v4 = -4616189618054758400i64;
      *((_QWORD *)v1 + 8) = v4;
    }
  }
  else
  {
    v1[8] = 0.0;
  }
  if ( !(unsigned int)UF_VEC3_unitize(&v24, v2, &v27, &v24) || !(unsigned int)UF_VEC3_unitize(&v23, v21, &v27, &v23) )
    return 0i64;
  UF_VEC3_cross(&v24, &v23, &v25);
  UF_VEC3_cross(&v25, &v24, &v23);
  return 1i64;
}
// 18000B1F8: using guessed type __int64 __fastcall UF_VEC3_copy(_QWORD, _QWORD);
// 18000B248: using guessed type __int64 __fastcall UF_MTX3_copy(_QWORD, _QWORD);
// 18000B258: using guessed type __int64 __fastcall UF_VEC3_unitize(_QWORD, _QWORD, _QWORD, _QWORD);
// 18000B278: using guessed type __int64 __fastcall UF_VEC3_cross(_QWORD, _QWORD, _QWORD);
// 18000C190: using guessed type __int128 xmmword_18000C190;

//----- (0000000180006500) ----------------------------------------------------
__int64 __fastcall sub_180006500(__int64 a1)
{
  __int64 v1; // rdi
  unsigned int v2; // ebx
  char v4; // [rsp+20h] [rbp-58h]

  v1 = a1;
  UF_MTX4_ask_rotation(a1, &v4);
  v2 = sub_180006210((double *)&v4);
  UF_MTX4_edit_rotation(v1, &v4);
  return v2;
}
// 18000B1E0: using guessed type __int64 __fastcall UF_MTX4_edit_rotation(_QWORD, _QWORD);
// 18000B218: using guessed type __int64 __fastcall UF_MTX4_ask_rotation(_QWORD, _QWORD);

//----- (0000000180006550) ----------------------------------------------------
__int64 __fastcall sub_180006550(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // [rsp+40h] [rbp+18h]

  v4 = a3;
  return UF_MOM_ask_string(a1, a2, &v4);
}
// 18000B2D8: using guessed type __int64 __fastcall UF_MOM_ask_string(_QWORD, _QWORD, _QWORD);

//----- (0000000180006570) ----------------------------------------------------
__int64 __fastcall sub_180006570(__int64 a1, double *a2)
{
  int v2; // ebx
  const char *v3; // r8
  double *v4; // rdi
  __int64 v5; // r15
  __int64 v6; // rsi
  unsigned int v7; // er14
  char *v8; // rdx
  signed __int64 v9; // rcx
  char v10; // al
  char *v11; // rcx
  signed __int64 v12; // rdx
  char v13; // al
  char *v14; // rcx
  signed __int64 v15; // rdx
  char v16; // al
  char *v17; // rcx
  char *v18; // rcx
  char *v19; // rcx
  char *v20; // rcx
  char *v21; // rcx
  char *v22; // rcx
  char *v23; // rcx
  char *v24; // rcx
  char *v25; // rcx
  char *v26; // rcx
  char *v27; // rcx
  char *v28; // rcx
  __int64 v29; // rcx
  char v30; // al
  const char *v32; // [rsp+28h] [rbp-41h]
  const char *v33; // [rsp+30h] [rbp-39h]
  const char *v34; // [rsp+38h] [rbp-31h]
  const char *v35; // [rsp+40h] [rbp-29h]
  const char *v36; // [rsp+48h] [rbp-21h]
  const char *v37; // [rsp+50h] [rbp-19h]
  const char *v38; // [rsp+58h] [rbp-11h]
  const char *v39; // [rsp+60h] [rbp-9h]
  const char *v40; // [rsp+68h] [rbp-1h]
  const char *v41; // [rsp+70h] [rbp+7h]
  const char *v42; // [rsp+78h] [rbp+Fh]
  const char *v43; // [rsp+80h] [rbp+17h]
  const char *v44; // [rsp+88h] [rbp+1Fh]
  const char *v45; // [rsp+90h] [rbp+27h]
  const char *v46; // [rsp+98h] [rbp+2Fh]
  char *Str; // [rsp+E0h] [rbp+77h]

  v2 = 0;
  v32 = "mom_kin_4th_axis_direction";
  v3 = "mom_kin_4th_axis_plane";
  v33 = "mom_kin_4th_axis_rotation";
  v46 = "END";
  v34 = "mom_kin_4th_axis_min_incr";
  v4 = a2;
  v35 = "mom_kin_4th_axis_min_limit";
  v5 = a1;
  v6 = 0i64;
  v36 = "mom_kin_4th_axis_max_limit";
  v37 = "mom_kin_4th_axis_zero";
  v38 = "mom_kin_4th_axis_center_offset_x";
  v39 = "mom_kin_4th_axis_center_offset_y";
  v40 = "mom_kin_4th_axis_center_offset_z";
  v41 = "mom_kin_4th_axis_vector_i";
  v42 = "mom_kin_4th_axis_vector_j";
  v43 = "mom_kin_4th_axis_vector_k";
  v44 = "mom_kin_4th_axis_angles_a1";
  v45 = "mom_kin_4th_axis_angles_a2";
LABEL_2:
  v7 = UF_MOM_ask_string(v5, v3 + 4, &Str);
  switch ( v2 )
  {
    case 0:
      v8 = "YZ";
      if ( Str )
        v8 = Str;
      v9 = (char *)v4 - v8;
      Str = v8;
      do
      {
        v10 = *v8;
        v8[v9] = *v8;
        ++v8;
      }
      while ( v10 );
      break;
    case 1:
      v11 = "MAGNITUDE_DETERMINES_DIRECTION";
      if ( Str )
        v11 = Str;
      Str = v11;
      v12 = (char *)v4 - v11;
      do
      {
        v13 = *v11;
        v11[v12 + 397] = *v11;
        ++v11;
      }
      while ( v13 );
      break;
    case 2:
      v14 = "STANDARD";
      if ( Str )
        v14 = Str;
      Str = v14;
      v15 = (char *)v4 - v14;
      do
      {
        v16 = *v14;
        v14[v15 + 794] = *v14;
        ++v14;
      }
      while ( v16 );
      break;
    case 3:
      v17 = "0.001";
      if ( Str )
        v17 = Str;
      Str = v17;
      v4[149] = strtod(v17, 0i64);
      break;
    case 4:
      v18 = "0.0";
      if ( Str )
        v18 = Str;
      Str = v18;
      v4[150] = strtod(v18, 0i64);
      break;
    case 5:
      v19 = "360.0";
      if ( Str )
        v19 = Str;
      Str = v19;
      v4[151] = strtod(v19, 0i64);
      break;
    case 6:
      v20 = "0.0";
      if ( Str )
        v20 = Str;
      Str = v20;
      v4[152] = strtod(v20, 0i64);
      break;
    case 7:
      v21 = "0.0";
      if ( Str )
        v21 = Str;
      Str = v21;
      v4[153] = strtod(v21, 0i64);
      break;
    case 8:
      v22 = "0.0";
      if ( Str )
        v22 = Str;
      Str = v22;
      v4[154] = strtod(v22, 0i64);
      break;
    case 9:
      v23 = "0.0";
      if ( Str )
        v23 = Str;
      Str = v23;
      v4[155] = strtod(v23, 0i64);
      break;
    case 10:
      v24 = "0.0";
      if ( Str )
        v24 = Str;
      Str = v24;
      v4[156] = strtod(v24, 0i64);
      break;
    case 11:
      v25 = "0.0";
      if ( Str )
        v25 = Str;
      Str = v25;
      v4[157] = strtod(v25, 0i64);
      break;
    case 12:
      v26 = "0.0";
      if ( Str )
        v26 = Str;
      Str = v26;
      v4[158] = strtod(v26, 0i64);
      break;
    case 13:
      v27 = "0.0";
      if ( Str )
        v27 = Str;
      Str = v27;
      v4[159] = strtod(v27, 0i64);
      break;
    case 14:
      v28 = "0.0";
      if ( Str )
        v28 = Str;
      Str = v28;
      v4[160] = strtod(v28, 0i64);
      break;
    default:
      break;
  }
  v3 = (&v32)[v6++];
  ++v2;
  v29 = 0i64;
  do
  {
    v30 = v3[v29++];
    if ( v30 != aEnd[v29 - 1] )
      goto LABEL_2;
  }
  while ( v29 != 4 );
  return v7;
}
// 18000B2D8: using guessed type __int64 __fastcall UF_MOM_ask_string(_QWORD, _QWORD, _QWORD);

//----- (00000001800069B0) ----------------------------------------------------
__int64 __fastcall sub_1800069B0(__int64 a1, double *a2)
{
  int v2; // ebx
  const char *v3; // r8
  double *v4; // rdi
  __int64 v5; // r15
  __int64 v6; // rsi
  unsigned int v7; // er14
  char *v8; // rdx
  signed __int64 v9; // rcx
  char v10; // al
  char *v11; // rcx
  signed __int64 v12; // rdx
  char v13; // al
  char *v14; // rcx
  signed __int64 v15; // rdx
  char v16; // al
  char *v17; // rcx
  char *v18; // rcx
  char *v19; // rcx
  char *v20; // rcx
  char *v21; // rcx
  char *v22; // rcx
  char *v23; // rcx
  char *v24; // rcx
  char *v25; // rcx
  char *v26; // rcx
  char *v27; // rcx
  char *v28; // rcx
  __int64 v29; // rcx
  char v30; // al
  const char *v32; // [rsp+28h] [rbp-41h]
  const char *v33; // [rsp+30h] [rbp-39h]
  const char *v34; // [rsp+38h] [rbp-31h]
  const char *v35; // [rsp+40h] [rbp-29h]
  const char *v36; // [rsp+48h] [rbp-21h]
  const char *v37; // [rsp+50h] [rbp-19h]
  const char *v38; // [rsp+58h] [rbp-11h]
  const char *v39; // [rsp+60h] [rbp-9h]
  const char *v40; // [rsp+68h] [rbp-1h]
  const char *v41; // [rsp+70h] [rbp+7h]
  const char *v42; // [rsp+78h] [rbp+Fh]
  const char *v43; // [rsp+80h] [rbp+17h]
  const char *v44; // [rsp+88h] [rbp+1Fh]
  const char *v45; // [rsp+90h] [rbp+27h]
  const char *v46; // [rsp+98h] [rbp+2Fh]
  char *Str; // [rsp+E0h] [rbp+77h]

  v2 = 0;
  v32 = "mom_kin_5th_axis_direction";
  v3 = "mom_kin_5th_axis_plane";
  v33 = "mom_kin_5th_axis_rotation";
  v46 = "END";
  v34 = "mom_kin_5th_axis_min_incr";
  v4 = a2;
  v35 = "mom_kin_5th_axis_min_limit";
  v5 = a1;
  v6 = 0i64;
  v36 = "mom_kin_5th_axis_max_limit";
  v37 = "mom_kin_5th_axis_zero";
  v38 = "mom_kin_5th_axis_center_offset_x";
  v39 = "mom_kin_5th_axis_center_offset_y";
  v40 = "mom_kin_5th_axis_center_offset_z";
  v41 = "mom_kin_5th_axis_vector_i";
  v42 = "mom_kin_5th_axis_vector_j";
  v43 = "mom_kin_5th_axis_vector_k";
  v44 = "mom_kin_5th_axis_angles_a1";
  v45 = "mom_kin_5th_axis_angles_a2";
LABEL_2:
  v7 = UF_MOM_ask_string(v5, v3 + 4, &Str);
  switch ( v2 )
  {
    case 0:
      v8 = "YZ";
      if ( Str )
        v8 = Str;
      v9 = (char *)v4 - v8;
      Str = v8;
      do
      {
        v10 = *v8;
        v8[v9] = *v8;
        ++v8;
      }
      while ( v10 );
      break;
    case 1:
      v11 = "MAGNITUDE_DETERMINES_DIRECTION";
      if ( Str )
        v11 = Str;
      Str = v11;
      v12 = (char *)v4 - v11;
      do
      {
        v13 = *v11;
        v11[v12 + 397] = *v11;
        ++v11;
      }
      while ( v13 );
      break;
    case 2:
      v14 = "STANDARD";
      if ( Str )
        v14 = Str;
      Str = v14;
      v15 = (char *)v4 - v14;
      do
      {
        v16 = *v14;
        v14[v15 + 794] = *v14;
        ++v14;
      }
      while ( v16 );
      break;
    case 3:
      v17 = "0.001";
      if ( Str )
        v17 = Str;
      Str = v17;
      v4[149] = strtod(v17, 0i64);
      break;
    case 4:
      v18 = "0.0";
      if ( Str )
        v18 = Str;
      Str = v18;
      v4[150] = strtod(v18, 0i64);
      break;
    case 5:
      v19 = "360.0";
      if ( Str )
        v19 = Str;
      Str = v19;
      v4[151] = strtod(v19, 0i64);
      break;
    case 6:
      v20 = "0.0";
      if ( Str )
        v20 = Str;
      Str = v20;
      v4[152] = strtod(v20, 0i64);
      break;
    case 7:
      v21 = "0.0";
      if ( Str )
        v21 = Str;
      Str = v21;
      v4[153] = strtod(v21, 0i64);
      break;
    case 8:
      v22 = "0.0";
      if ( Str )
        v22 = Str;
      Str = v22;
      v4[154] = strtod(v22, 0i64);
      break;
    case 9:
      v23 = "0.0";
      if ( Str )
        v23 = Str;
      Str = v23;
      v4[155] = strtod(v23, 0i64);
      break;
    case 10:
      v24 = "0.0";
      if ( Str )
        v24 = Str;
      Str = v24;
      v4[156] = strtod(v24, 0i64);
      break;
    case 11:
      v25 = "0.0";
      if ( Str )
        v25 = Str;
      Str = v25;
      v4[157] = strtod(v25, 0i64);
      break;
    case 12:
      v26 = "0.0";
      if ( Str )
        v26 = Str;
      Str = v26;
      v4[158] = strtod(v26, 0i64);
      break;
    case 13:
      v27 = "0.0";
      if ( Str )
        v27 = Str;
      Str = v27;
      v4[159] = strtod(v27, 0i64);
      break;
    case 14:
      v28 = "0.0";
      if ( Str )
        v28 = Str;
      Str = v28;
      v4[160] = strtod(v28, 0i64);
      break;
    default:
      break;
  }
  v3 = (&v32)[v6++];
  ++v2;
  v29 = 0i64;
  do
  {
    v30 = v3[v29++];
    if ( v30 != aEnd[v29 - 1] )
      goto LABEL_2;
  }
  while ( v29 != 4 );
  return v7;
}
// 18000B2D8: using guessed type __int64 __fastcall UF_MOM_ask_string(_QWORD, _QWORD, _QWORD);

//----- (0000000180006DF0) ----------------------------------------------------
__int64 __fastcall sub_180006DF0(__int64 a1, __int64 a2)
{
  int v2; // ebx
  const char *v3; // r8
  __int64 v4; // rdi
  __int64 v5; // r14
  __int64 v6; // rsi
  unsigned int v7; // ebp
  char *v8; // rcx
  char *v9; // rcx
  char *v10; // rcx
  __int64 v11; // rdx
  char v12; // al
  char *v13; // rcx
  __int64 v14; // rdx
  char v15; // al
  __int64 v16; // rcx
  char v17; // al
  const char *v19; // [rsp+28h] [rbp-40h]
  const char *v20; // [rsp+30h] [rbp-38h]
  const char *v21; // [rsp+38h] [rbp-30h]
  const char *v22; // [rsp+40h] [rbp-28h]
  char *Str; // [rsp+80h] [rbp+18h]

  v2 = 0;
  v19 = "mom_kin_arc_valid_plane";
  v3 = "mom_kin_arc_output_mode";
  v20 = "mom_kin_min_arc_radius";
  v22 = "END";
  v21 = "mom_kin_max_arc_radius";
  v4 = a2;
  v5 = a1;
  v6 = 0i64;
LABEL_2:
  v7 = UF_MOM_ask_string(v5, v3 + 4, &Str);
  if ( v2 )
  {
    switch ( v2 )
    {
      case 1:
        v10 = "XY";
        if ( Str )
          v10 = Str;
        Str = v10;
        v11 = v4 - (_QWORD)v10;
        do
        {
          v12 = *v10;
          v10[v11 + 397] = *v10;
          ++v10;
        }
        while ( v12 );
        break;
      case 2:
        v9 = "0.0001";
        if ( Str )
          v9 = Str;
        Str = v9;
        *(double *)(v4 + 800) = strtod(v9, 0i64);
        break;
      case 3:
        v8 = "9999.9999";
        if ( Str )
          v8 = Str;
        Str = v8;
        *(double *)(v4 + 808) = strtod(v8, 0i64);
        break;
    }
  }
  else
  {
    v13 = "FULL_CIRCLE";
    if ( Str )
      v13 = Str;
    Str = v13;
    v14 = v4 - (_QWORD)v13;
    do
    {
      v15 = *v13;
      v13[v14] = *v13;
      ++v13;
    }
    while ( v15 );
  }
  v3 = (&v19)[v6++];
  ++v2;
  v16 = 0i64;
  do
  {
    v17 = v3[v16++];
    if ( v17 != aEnd[v16 - 1] )
      goto LABEL_2;
  }
  while ( v16 != 4 );
  return v7;
}
// 18000B2D8: using guessed type __int64 __fastcall UF_MOM_ask_string(_QWORD, _QWORD, _QWORD);

//----- (0000000180006FB0) ----------------------------------------------------
__int64 __fastcall sub_180006FB0(__int64 a1, double *a2)
{
  int v2; // ebx
  const char *v3; // r8
  double *v4; // r14
  __int64 v5; // r15
  __int64 v6; // rdi
  unsigned int v7; // esi
  char *v8; // rcx
  char *v9; // rcx
  char *v10; // rcx
  char *v11; // rcx
  char *v12; // rcx
  char *v13; // rcx
  char *v14; // rcx
  char *v15; // rcx
  __int64 v16; // rcx
  char v17; // al
  const char *v19; // [rsp+28h] [rbp-48h]
  const char *v20; // [rsp+30h] [rbp-40h]
  const char *v21; // [rsp+38h] [rbp-38h]
  const char *v22; // [rsp+40h] [rbp-30h]
  const char *v23; // [rsp+48h] [rbp-28h]
  const char *v24; // [rsp+50h] [rbp-20h]
  const char *v25; // [rsp+58h] [rbp-18h]
  const char *v26; // [rsp+60h] [rbp-10h]
  char *Str; // [rsp+B0h] [rbp+40h]

  v2 = 0;
  v19 = "mom_kin_min_fpm";
  v3 = "mom_kin_max_fpm";
  v20 = "mom_kin_max_fpr";
  v26 = "END";
  v21 = "mom_kin_min_fpr";
  v4 = a2;
  v22 = "mom_kin_max_frn";
  v5 = a1;
  v6 = 0i64;
  v23 = "mom_kin_min_frn";
  v24 = "mom_kin_max_dpm";
  v25 = "mom_kin_min_dpm";
LABEL_2:
  v7 = UF_MOM_ask_string(v5, v3 + 4, &Str);
  switch ( v2 )
  {
    case 0:
      v8 = "999.999";
      if ( Str )
        v8 = Str;
      Str = v8;
      *v4 = strtod(v8, 0i64);
      break;
    case 1:
      v9 = "0.001";
      if ( Str )
        v9 = Str;
      Str = v9;
      v4[4] = strtod(v9, 0i64);
      break;
    case 2:
      v10 = "99.999";
      if ( Str )
        v10 = Str;
      Str = v10;
      v4[1] = strtod(v10, 0i64);
      break;
    case 3:
      v11 = "0.001";
      if ( Str )
        v11 = Str;
      Str = v11;
      v4[5] = strtod(v11, 0i64);
      break;
    case 4:
      v12 = "99999.999";
      if ( Str )
        v12 = Str;
      Str = v12;
      v4[2] = strtod(v12, 0i64);
      break;
    case 5:
      v13 = "0.001";
      if ( Str )
        v13 = Str;
      Str = v13;
      v4[6] = strtod(v13, 0i64);
      break;
    case 6:
      v14 = "99.999";
      if ( Str )
        v14 = Str;
      Str = v14;
      v4[3] = strtod(v14, 0i64);
      break;
    case 7:
      v15 = "0.0";
      if ( Str )
        v15 = Str;
      Str = v15;
      v4[7] = strtod(v15, 0i64);
      break;
    default:
      break;
  }
  v3 = (&v19)[v6++];
  ++v2;
  v16 = 0i64;
  do
  {
    v17 = v3[v16++];
    if ( v17 != aEnd[v16 - 1] )
      goto LABEL_2;
  }
  while ( v16 != 4 );
  return v7;
}
// 18000B2D8: using guessed type __int64 __fastcall UF_MOM_ask_string(_QWORD, _QWORD, _QWORD);

//----- (0000000180007220) ----------------------------------------------------
__int64 __fastcall sub_180007220(__int64 a1, __int64 a2)
{
  int v2; // ebx
  const char *v3; // r8
  __int64 v4; // rsi
  __int64 v5; // r14
  __int64 v6; // rdi
  unsigned int v7; // ebp
  char *v8; // rcx
  char *v9; // rcx
  char *v10; // rcx
  __int64 v11; // rdx
  char v12; // al
  __int64 v13; // rcx
  char v14; // al
  const char *v16; // [rsp+28h] [rbp-30h]
  const char *v17; // [rsp+30h] [rbp-28h]
  const char *v18; // [rsp+38h] [rbp-20h]
  char *Str; // [rsp+70h] [rbp+18h]

  v2 = 0;
  v16 = "mom_kin_ind_to_dependent_head_x";
  v3 = "mom_kin_independent_head";
  v17 = "mom_kin_ind_to_dependent_head_z";
  v4 = a2;
  v18 = "END";
  v5 = a1;
  v6 = 0i64;
LABEL_2:
  v7 = UF_MOM_ask_string(v5, v3 + 4, &Str);
  if ( v2 )
  {
    if ( v2 == 1 )
    {
      v9 = "0.0";
      if ( Str )
        v9 = Str;
      Str = v9;
      *(double *)(v4 + 400) = strtod(v9, 0i64);
    }
    else if ( v2 == 2 )
    {
      v8 = "0.0";
      if ( Str )
        v8 = Str;
      Str = v8;
      *(double *)(v4 + 408) = strtod(v8, 0i64);
    }
  }
  else
  {
    v10 = "FRONT";
    if ( Str )
      v10 = Str;
    Str = v10;
    v11 = v4 - (_QWORD)v10;
    do
    {
      v12 = *v10;
      v10[v11] = *v10;
      ++v10;
    }
    while ( v12 );
  }
  v3 = (&v16)[v6++];
  ++v2;
  v13 = 0i64;
  do
  {
    v14 = v3[v13++];
    if ( v14 != aEnd[v13 - 1] )
      goto LABEL_2;
  }
  while ( v13 != 4 );
  return v7;
}
// 18000B2D8: using guessed type __int64 __fastcall UF_MOM_ask_string(_QWORD, _QWORD, _QWORD);

//----- (0000000180007370) ----------------------------------------------------
__int64 __fastcall sub_180007370(__int64 a1, double *a2)
{
  int v2; // edi
  const char *v3; // r8
  double *v4; // rbx
  __int64 v5; // r15
  __int64 v6; // rsi
  unsigned int v7; // er14
  char *v8; // rdx
  signed __int64 v9; // rcx
  char v10; // al
  char *v11; // rcx
  signed __int64 v12; // rdx
  char v13; // al
  char *v14; // rcx
  signed __int64 v15; // rdx
  char v16; // al
  char *v17; // rcx
  signed __int64 v18; // rdx
  char v19; // al
  char *v20; // rcx
  signed __int64 v21; // rdx
  char v22; // al
  char *v23; // rcx
  signed __int64 v24; // rdx
  char v25; // al
  char *v26; // rcx
  char *v27; // rcx
  char *v28; // rcx
  char *v29; // rcx
  char *v30; // rcx
  char *v31; // rcx
  char *v32; // rcx
  char *v33; // rcx
  char *v34; // rcx
  char *v35; // rcx
  char *v36; // rcx
  char *v37; // rcx
  char *v38; // rcx
  char *v39; // rcx
  char *v40; // rcx
  char *v41; // rcx
  char *v42; // rcx
  char *v43; // rcx
  __int64 v44; // rcx
  char v45; // al
  const char *v47; // [rsp+28h] [rbp-91h]
  const char *v48; // [rsp+30h] [rbp-89h]
  const char *v49; // [rsp+38h] [rbp-81h]
  const char *v50; // [rsp+40h] [rbp-79h]
  const char *v51; // [rsp+48h] [rbp-71h]
  const char *v52; // [rsp+50h] [rbp-69h]
  const char *v53; // [rsp+58h] [rbp-61h]
  const char *v54; // [rsp+60h] [rbp-59h]
  const char *v55; // [rsp+68h] [rbp-51h]
  const char *v56; // [rsp+70h] [rbp-49h]
  const char *v57; // [rsp+78h] [rbp-41h]
  const char *v58; // [rsp+80h] [rbp-39h]
  const char *v59; // [rsp+88h] [rbp-31h]
  const char *v60; // [rsp+90h] [rbp-29h]
  const char *v61; // [rsp+98h] [rbp-21h]
  const char *v62; // [rsp+A0h] [rbp-19h]
  const char *v63; // [rsp+A8h] [rbp-11h]
  const char *v64; // [rsp+B0h] [rbp-9h]
  const char *v65; // [rsp+B8h] [rbp-1h]
  const char *v66; // [rsp+C0h] [rbp+7h]
  const char *v67; // [rsp+C8h] [rbp+Fh]
  const char *v68; // [rsp+D0h] [rbp+17h]
  const char *v69; // [rsp+D8h] [rbp+1Fh]
  const char *v70; // [rsp+E0h] [rbp+27h]
  char *Str; // [rsp+130h] [rbp+77h]

  v2 = 0;
  v47 = "mom_kin_holder2_orientation";
  v3 = "mom_kin_holder1_orientation";
  v48 = "mom_kin_holder3_orientation";
  v70 = "END";
  v49 = "mom_kin_holder4_orientation";
  v4 = a2;
  v50 = "mom_kin_holder5_orientation";
  v5 = a1;
  v6 = 0i64;
  v51 = "mom_kin_holder6_orientation";
  v52 = "mom_kin_holder1_offset_x";
  v53 = "mom_kin_holder1_offset_y";
  v54 = "mom_kin_holder1_offset_z";
  v55 = "mom_kin_holder2_offset_x";
  v56 = "mom_kin_holder2_offset_y";
  v57 = "mom_kin_holder2_offset_z";
  v58 = "mom_kin_holder3_offset_x";
  v59 = "mom_kin_holder3_offset_y";
  v60 = "mom_kin_holder3_offset_z";
  v61 = "mom_kin_holder4_offset_x";
  v62 = "mom_kin_holder4_offset_y";
  v63 = "mom_kin_holder4_offset_z";
  v64 = "mom_kin_holder5_offset_x";
  v65 = "mom_kin_holder5_offset_y";
  v66 = "mom_kin_holder5_offset_z";
  v67 = "mom_kin_holder6_offset_x";
  v68 = "mom_kin_holder6_offset_y";
  v69 = "mom_kin_holder6_offset_z";
LABEL_2:
  v7 = UF_MOM_ask_string(v5, v3 + 4, &Str);
  switch ( v2 )
  {
    case 0:
      v8 = "POSZ";
      if ( Str )
        v8 = Str;
      v9 = (char *)v4 - v8;
      Str = v8;
      do
      {
        v10 = *v8;
        v8[v9] = *v8;
        ++v8;
      }
      while ( v10 );
      break;
    case 1:
      v11 = "POSZ";
      if ( Str )
        v11 = Str;
      Str = v11;
      v12 = (char *)v4 - v11;
      do
      {
        v13 = *v11;
        v11[v12 + 397] = *v11;
        ++v11;
      }
      while ( v13 );
      break;
    case 2:
      v14 = "POSZ";
      if ( Str )
        v14 = Str;
      Str = v14;
      v15 = (char *)v4 - v14;
      do
      {
        v16 = *v14;
        v14[v15 + 794] = *v14;
        ++v14;
      }
      while ( v16 );
      break;
    case 3:
      v17 = "POSZ";
      if ( Str )
        v17 = Str;
      Str = v17;
      v18 = (char *)v4 - v17;
      do
      {
        v19 = *v17;
        v17[v18 + 1191] = *v17;
        ++v17;
      }
      while ( v19 );
      break;
    case 4:
      v20 = "POSZ";
      if ( Str )
        v20 = Str;
      Str = v20;
      v21 = (char *)v4 - v20;
      do
      {
        v22 = *v20;
        v20[v21 + 1588] = *v20;
        ++v20;
      }
      while ( v22 );
      break;
    case 5:
      v23 = "POSZ";
      if ( Str )
        v23 = Str;
      Str = v23;
      v24 = (char *)v4 - v23;
      do
      {
        v25 = *v23;
        v23[v24 + 1985] = *v23;
        ++v23;
      }
      while ( v25 );
      break;
    case 6:
      v26 = "0.0";
      if ( Str )
        v26 = Str;
      Str = v26;
      v4[298] = strtod(v26, 0i64);
      break;
    case 7:
      v27 = "0.0";
      if ( Str )
        v27 = Str;
      Str = v27;
      v4[299] = strtod(v27, 0i64);
      break;
    case 8:
      v28 = "0.0";
      if ( Str )
        v28 = Str;
      Str = v28;
      v4[300] = strtod(v28, 0i64);
      break;
    case 9:
      v29 = "0.0";
      if ( Str )
        v29 = Str;
      Str = v29;
      v4[301] = strtod(v29, 0i64);
      break;
    case 10:
      v30 = "0.0";
      if ( Str )
        v30 = Str;
      Str = v30;
      v4[302] = strtod(v30, 0i64);
      break;
    case 11:
      v31 = "0.0";
      if ( Str )
        v31 = Str;
      Str = v31;
      v4[303] = strtod(v31, 0i64);
      break;
    case 12:
      v32 = "0.0";
      if ( Str )
        v32 = Str;
      Str = v32;
      v4[304] = strtod(v32, 0i64);
      break;
    case 13:
      v33 = "0.0";
      if ( Str )
        v33 = Str;
      Str = v33;
      v4[305] = strtod(v33, 0i64);
      break;
    case 14:
      v34 = "0.0";
      if ( Str )
        v34 = Str;
      Str = v34;
      v4[306] = strtod(v34, 0i64);
      break;
    case 15:
      v35 = "0.0";
      if ( Str )
        v35 = Str;
      Str = v35;
      v4[307] = strtod(v35, 0i64);
      break;
    case 16:
      v36 = "0.0";
      if ( Str )
        v36 = Str;
      Str = v36;
      v4[308] = strtod(v36, 0i64);
      break;
    case 17:
      v37 = "0.0";
      if ( Str )
        v37 = Str;
      Str = v37;
      v4[309] = strtod(v37, 0i64);
      break;
    case 18:
      v38 = "0.0";
      if ( Str )
        v38 = Str;
      Str = v38;
      v4[310] = strtod(v38, 0i64);
      break;
    case 19:
      v39 = "0.0";
      if ( Str )
        v39 = Str;
      Str = v39;
      v4[311] = strtod(v39, 0i64);
      break;
    case 20:
      v40 = "0.0";
      if ( Str )
        v40 = Str;
      Str = v40;
      v4[312] = strtod(v40, 0i64);
      break;
    case 21:
      v41 = "0.0";
      if ( Str )
        v41 = Str;
      Str = v41;
      v4[313] = strtod(v41, 0i64);
      break;
    case 22:
      v42 = "0.0";
      if ( Str )
        v42 = Str;
      Str = v42;
      v4[314] = strtod(v42, 0i64);
      break;
    case 23:
      v43 = "0.0";
      if ( Str )
        v43 = Str;
      Str = v43;
      v4[315] = strtod(v43, 0i64);
      break;
    default:
      break;
  }
  v3 = (&v47)[v6++];
  ++v2;
  v44 = 0i64;
  do
  {
    v45 = v3[v44++];
    if ( v45 != aEnd[v44 - 1] )
      goto LABEL_2;
  }
  while ( v44 != 4 );
  return v7;
}
// 18000B2D8: using guessed type __int64 __fastcall UF_MOM_ask_string(_QWORD, _QWORD, _QWORD);

//----- (0000000180007A00) ----------------------------------------------------
__int64 __fastcall sub_180007A00(__int64 a1, double *a2)
{
  __int64 v2; // r15
  const char *v3; // r8
  int v4; // ebx
  double *v5; // rdi
  __int64 v6; // rsi
  unsigned int v7; // er14
  char *v8; // rdx
  signed __int64 v9; // rcx
  char v10; // al
  char *v11; // rcx
  signed __int64 v12; // rdx
  char v13; // al
  char *v14; // rcx
  signed __int64 v15; // rdx
  char v16; // al
  char *v17; // rcx
  signed __int64 v18; // rdx
  char v19; // al
  char *v20; // rcx
  signed __int64 v21; // rdx
  char v22; // al
  char *v23; // rcx
  signed __int64 v24; // rdx
  char v25; // al
  char *v26; // rcx
  char *v27; // rcx
  char *v28; // rcx
  char *v29; // rcx
  char *v30; // rcx
  int v31; // eax
  char *v32; // rcx
  int v33; // eax
  char *v34; // rcx
  int v35; // eax
  __int64 v36; // rcx
  char v37; // al
  __int128 v39; // [rsp+20h] [rbp-99h]
  __int64 v40; // [rsp+30h] [rbp-89h]
  int v41; // [rsp+38h] [rbp-81h]
  __int128 v42; // [rsp+40h] [rbp-79h]
  __int64 v43; // [rsp+50h] [rbp-69h]
  int v44; // [rsp+58h] [rbp-61h]
  __int128 v45; // [rsp+60h] [rbp-59h]
  __int64 v46; // [rsp+70h] [rbp-49h]
  int v47; // [rsp+78h] [rbp-41h]
  const char *v48; // [rsp+80h] [rbp-39h]
  const char *v49; // [rsp+88h] [rbp-31h]
  const char *v50; // [rsp+90h] [rbp-29h]
  const char *v51; // [rsp+98h] [rbp-21h]
  const char *v52; // [rsp+A0h] [rbp-19h]
  const char *v53; // [rsp+A8h] [rbp-11h]
  const char *v54; // [rsp+B0h] [rbp-9h]
  const char *v55; // [rsp+B8h] [rbp-1h]
  const char *v56; // [rsp+C0h] [rbp+7h]
  const char *v57; // [rsp+C8h] [rbp+Fh]
  const char *v58; // [rsp+D0h] [rbp+17h]
  const char *v59; // [rsp+D8h] [rbp+1Fh]
  const char *v60; // [rsp+E0h] [rbp+27h]
  const char *v61; // [rsp+E8h] [rbp+2Fh]
  char *Str; // [rsp+130h] [rbp+77h]

  v2 = a1;
  v49 = "mom_kin_track_center_of_ball";
  v58 = "mom_kin_gauge_to_pivot_x";
  v50 = "mom_kin_wire_tilt_output_type";
  v3 = "mom_kin_machine_type";
  v48 = "mom_kin_machine_type";
  v51 = "mom_kin_clsf_generation";
  v60 = "mom_kin_gauge_to_pivot_x";
  v52 = "mom_kin_coordinate_type";
  v61 = "END";
  v53 = "mom_kin_linearization_flag";
  v4 = 0;
  v5 = a2;
  v54 = "mom_kin_machine_resolution";
  v6 = 0i64;
  v55 = "mom_kin_tool_tracking_height";
  v56 = "mom_kin_5th_axis_inclination_to_4th";
  v57 = "mom_kin_linearization_tol";
  v59 = "mom_kin_gauge_to_pivot_y";
LABEL_2:
  v7 = UF_MOM_ask_string(v2, v3 + 4, &Str);
  switch ( v4 )
  {
    case 0:
      v8 = "3_axis_mill";
      if ( Str )
        v8 = Str;
      v9 = (char *)v5 - v8;
      Str = v8;
      do
      {
        v10 = *v8;
        v8[v9] = *v8;
        ++v8;
      }
      while ( v10 );
      break;
    case 1:
      v11 = "T";
      if ( Str )
        v11 = Str;
      Str = v11;
      v12 = (char *)v5 - v11;
      do
      {
        v13 = *v11;
        v11[v12 + 397] = *v11;
        ++v11;
      }
      while ( v13 );
      break;
    case 2:
      v14 = "NONE";
      if ( Str )
        v14 = Str;
      Str = v14;
      v15 = (char *)v5 - v14;
      do
      {
        v16 = *v14;
        v14[v15 + 794] = *v14;
        ++v14;
      }
      while ( v16 );
      break;
    case 3:
      v17 = "F";
      if ( Str )
        v17 = Str;
      Str = v17;
      v18 = (char *)v5 - v17;
      do
      {
        v19 = *v17;
        v17[v18 + 1191] = *v17;
        ++v17;
      }
      while ( v19 );
      break;
    case 4:
      v20 = "CARTESIAN";
      if ( Str )
        v20 = Str;
      Str = v20;
      v21 = (char *)v5 - v20;
      do
      {
        v22 = *v20;
        v20[v21 + 1588] = *v20;
        ++v20;
      }
      while ( v22 );
      break;
    case 5:
      v23 = "F";
      if ( Str )
        v23 = Str;
      Str = v23;
      v24 = (char *)v5 - v23;
      do
      {
        v25 = *v23;
        v23[v24 + 1985] = *v23;
        ++v23;
      }
      while ( v25 );
      break;
    case 6:
      v26 = "0.0001";
      if ( Str )
        v26 = Str;
      Str = v26;
      v5[298] = strtod(v26, 0i64);
      break;
    case 7:
      v27 = "0.0";
      if ( Str )
        v27 = Str;
      Str = v27;
      v5[299] = strtod(v27, 0i64);
      break;
    case 8:
      v28 = "90.0";
      if ( Str )
        v28 = Str;
      Str = v28;
      v5[300] = strtod(v28, 0i64);
      break;
    case 9:
      v29 = "0.0001";
      if ( Str )
        v29 = Str;
      Str = v29;
      v5[301] = strtod(v29, 0i64);
      break;
    case 10:
      v30 = Str;
      if ( !Str )
      {
        v40 = 7956012745154326121i64;
        v39 = xmmword_18000C368;
        v41 = 7888756;
        v31 = sub_180006550(v2, (__int64)&v39, 0i64);
        v30 = Str;
        if ( !Str || v31 )
        {
          v30 = "0.0";
          Str = "0.0";
        }
      }
      v5[302] = strtod(v30, 0i64);
      break;
    case 11:
      v32 = Str;
      if ( !Str )
      {
        v43 = 7956012745154326121i64;
        v42 = xmmword_18000C388;
        v44 = 7954292;
        v33 = sub_180006550(v2, (__int64)&v42, 0i64);
        v32 = Str;
        if ( !Str || v33 )
        {
          v32 = "0.0";
          Str = "0.0";
        }
      }
      v5[303] = strtod(v32, 0i64);
      break;
    case 12:
      v34 = Str;
      if ( !Str )
      {
        v46 = 7956012745154326121i64;
        v45 = xmmword_18000C3A8;
        v47 = 8019828;
        v35 = sub_180006550(v2, (__int64)&v45, 0i64);
        v34 = Str;
        if ( !Str || v35 )
        {
          v34 = "0.0";
          Str = "0.0";
        }
      }
      v5[304] = strtod(v34, 0i64);
      break;
    default:
      break;
  }
  v3 = (&v49)[v6++];
  ++v4;
  v36 = 0i64;
  do
  {
    v37 = v3[v36++];
    if ( v37 != aEnd[v36 - 1] )
      goto LABEL_2;
  }
  while ( v36 != 4 );
  return v7;
}
// 18000B2D8: using guessed type __int64 __fastcall UF_MOM_ask_string(_QWORD, _QWORD, _QWORD);
// 18000C368: using guessed type __int128 xmmword_18000C368;
// 18000C388: using guessed type __int128 xmmword_18000C388;
// 18000C3A8: using guessed type __int128 xmmword_18000C3A8;

//----- (0000000180007ED0) ----------------------------------------------------
__int64 __fastcall sub_180007ED0(__int64 a1, __int64 a2)
{
  int v2; // ebx
  const char *v3; // r8
  __int64 v4; // rbp
  __int64 v5; // r14
  __int64 v6; // rdi
  unsigned int v7; // esi
  char *v8; // rdx
  __int64 v9; // rcx
  char v10; // al
  char *v11; // rcx
  __int64 v12; // rdx
  char v13; // al
  char *v14; // rcx
  __int64 v15; // rdx
  char v16; // al
  char *v17; // rcx
  __int64 v18; // rdx
  char v19; // al
  char *v20; // rcx
  char *v21; // rcx
  __int64 v22; // rcx
  char v23; // al
  const char *v25; // [rsp+28h] [rbp-60h]
  const char *v26; // [rsp+30h] [rbp-58h]
  const char *v27; // [rsp+38h] [rbp-50h]
  const char *v28; // [rsp+40h] [rbp-48h]
  const char *v29; // [rsp+48h] [rbp-40h]
  const char *v30; // [rsp+50h] [rbp-38h]
  char *Str; // [rsp+A0h] [rbp+18h]

  v2 = 0;
  v25 = "mom_kin_output_unit";
  v3 = "mom_kin_nurbs_output_type";
  v26 = "mom_kin_polar_radius_side";
  v30 = "END";
  v27 = "mom_kin_read_ahead_next_motion";
  v4 = a2;
  v28 = "mom_kin_pivot_gauge_offset";
  v5 = a1;
  v6 = 0i64;
  v29 = "mom_kin_rapid_feed_rate";
LABEL_2:
  v7 = UF_MOM_ask_string(v5, v3 + 4, &Str);
  switch ( v2 )
  {
    case 0:
      v8 = "NONE";
      if ( Str )
        v8 = Str;
      v9 = v4 - (_QWORD)v8;
      Str = v8;
      do
      {
        v10 = *v8;
        v8[v9] = *v8;
        ++v8;
      }
      while ( v10 );
      break;
    case 1:
      v11 = "IN";
      if ( Str )
        v11 = Str;
      Str = v11;
      v12 = v4 - (_QWORD)v11;
      do
      {
        v13 = *v11;
        v11[v12 + 397] = *v11;
        ++v11;
      }
      while ( v13 );
      break;
    case 2:
      v14 = "NONE";
      if ( Str )
        v14 = Str;
      Str = v14;
      v15 = v4 - (_QWORD)v14;
      do
      {
        v16 = *v14;
        v14[v15 + 794] = *v14;
        ++v14;
      }
      while ( v16 );
      break;
    case 3:
      v17 = "F";
      if ( Str )
        v17 = Str;
      Str = v17;
      v18 = v4 - (_QWORD)v17;
      do
      {
        v19 = *v17;
        v17[v18 + 1191] = *v17;
        ++v17;
      }
      while ( v19 );
      break;
    case 4:
      v20 = "0.0";
      if ( Str )
        v20 = Str;
      Str = v20;
      *(double *)(v4 + 1592) = strtod(v20, 0i64);
      break;
    case 5:
      v21 = "400.00";
      if ( Str )
        v21 = Str;
      Str = v21;
      *(double *)(v4 + 1600) = strtod(v21, 0i64);
      break;
    default:
      break;
  }
  v3 = (&v25)[v6++];
  ++v2;
  v22 = 0i64;
  do
  {
    v23 = v3[v22++];
    if ( v23 != aEnd[v22 - 1] )
      goto LABEL_2;
  }
  while ( v22 != 4 );
  return v7;
}
// 18000B2D8: using guessed type __int64 __fastcall UF_MOM_ask_string(_QWORD, _QWORD, _QWORD);

//----- (0000000180008140) ----------------------------------------------------
__int64 __fastcall sub_180008140(__int64 a1, double *a2)
{
  int v2; // ebx
  const char *v3; // r8
  double *v4; // rsi
  __int64 v5; // r14
  __int64 v6; // rdi
  unsigned int v7; // ebp
  char *v8; // rcx
  char *v9; // rcx
  char *v10; // rcx
  __int64 v11; // rcx
  char v12; // al
  const char *v14; // [rsp+28h] [rbp-30h]
  const char *v15; // [rsp+30h] [rbp-28h]
  const char *v16; // [rsp+38h] [rbp-20h]
  char *Str; // [rsp+70h] [rbp+18h]

  v2 = 0;
  v14 = "mom_kin_clamp_time";
  v3 = "mom_kin_tool_change_time";
  v15 = "mom_kin_flush_time";
  v4 = a2;
  v16 = "END";
  v5 = a1;
  v6 = 0i64;
LABEL_2:
  v7 = UF_MOM_ask_string(v5, v3 + 4, &Str);
  if ( v2 )
  {
    if ( v2 == 1 )
    {
      v9 = "0.5";
      if ( Str )
        v9 = Str;
      Str = v9;
      v4[1] = strtod(v9, 0i64);
    }
    else if ( v2 == 2 )
    {
      v8 = "0.5";
      if ( Str )
        v8 = Str;
      Str = v8;
      v4[2] = strtod(v8, 0i64);
    }
  }
  else
  {
    v10 = "3.0";
    if ( Str )
      v10 = Str;
    Str = v10;
    *v4 = strtod(v10, 0i64);
  }
  v3 = (&v14)[v6++];
  ++v2;
  v11 = 0i64;
  do
  {
    v12 = v3[v11++];
    if ( v12 != aEnd[v11 - 1] )
      goto LABEL_2;
  }
  while ( v11 != 4 );
  return v7;
}
// 18000B2D8: using guessed type __int64 __fastcall UF_MOM_ask_string(_QWORD, _QWORD, _QWORD);

//----- (0000000180008270) ----------------------------------------------------
__int64 __fastcall sub_180008270(__int64 a1, double *a2)
{
  int v2; // ebx
  const char *v3; // r8
  double *v4; // rbp
  __int64 v5; // r14
  __int64 v6; // rdi
  unsigned int v7; // esi
  char *v8; // rcx
  char *v9; // rcx
  char *v10; // rcx
  char *v11; // rcx
  char *v12; // rcx
  char *v13; // rcx
  __int64 v14; // rcx
  char v15; // al
  const char *v17; // [rsp+28h] [rbp-60h]
  const char *v18; // [rsp+30h] [rbp-58h]
  const char *v19; // [rsp+38h] [rbp-50h]
  const char *v20; // [rsp+40h] [rbp-48h]
  const char *v21; // [rsp+48h] [rbp-40h]
  const char *v22; // [rsp+50h] [rbp-38h]
  char *Str; // [rsp+A0h] [rbp+18h]

  v2 = 0;
  v17 = "mom_mcs_goto_y";
  v3 = "mom_mcs_goto_x";
  v18 = "mom_mcs_goto_z";
  v22 = "END";
  v19 = "mom_tool_axis_i";
  v4 = a2;
  v20 = "mom_tool_axis_j";
  v5 = a1;
  v6 = 0i64;
  v21 = "mom_tool_axis_k";
LABEL_2:
  v7 = UF_MOM_ask_string(v5, v3 + 4, &Str);
  switch ( v2 )
  {
    case 0:
      v8 = "0.0";
      if ( Str )
        v8 = Str;
      Str = v8;
      *v4 = strtod(v8, 0i64);
      break;
    case 1:
      v9 = "0.0";
      if ( Str )
        v9 = Str;
      Str = v9;
      v4[1] = strtod(v9, 0i64);
      break;
    case 2:
      v10 = "0.0";
      if ( Str )
        v10 = Str;
      Str = v10;
      v4[2] = strtod(v10, 0i64);
      break;
    case 3:
      v11 = "0.0";
      if ( Str )
        v11 = Str;
      Str = v11;
      v4[3] = strtod(v11, 0i64);
      break;
    case 4:
      v12 = "0.0";
      if ( Str )
        v12 = Str;
      Str = v12;
      v4[4] = strtod(v12, 0i64);
      break;
    case 5:
      v13 = "0.0";
      if ( Str )
        v13 = Str;
      Str = v13;
      v4[5] = strtod(v13, 0i64);
      break;
    default:
      break;
  }
  v3 = (&v17)[v6++];
  ++v2;
  v14 = 0i64;
  do
  {
    v15 = v3[v14++];
    if ( v15 != aEnd[v14 - 1] )
      goto LABEL_2;
  }
  while ( v14 != 4 );
  return v7;
}
// 18000B2D8: using guessed type __int64 __fastcall UF_MOM_ask_string(_QWORD, _QWORD, _QWORD);

//----- (0000000180008490) ----------------------------------------------------
__int64 __fastcall sub_180008490(__int64 a1, double *a2)
{
  int v2; // ebx
  const char *v3; // r8
  double *v4; // rsi
  __int64 v5; // r15
  __int64 v6; // rdi
  unsigned int v7; // er14
  char *v8; // rcx
  char *v9; // rcx
  char *v10; // rcx
  char *v11; // rcx
  char *v12; // rcx
  char *v13; // rcx
  char *v14; // rcx
  char *v15; // rcx
  char *v16; // rcx
  char *v17; // rcx
  char *v18; // rcx
  char *v19; // rcx
  __int64 v20; // rcx
  char v21; // al
  const char *v23; // [rsp+28h] [rbp-31h]
  const char *v24; // [rsp+30h] [rbp-29h]
  const char *v25; // [rsp+38h] [rbp-21h]
  const char *v26; // [rsp+40h] [rbp-19h]
  const char *v27; // [rsp+48h] [rbp-11h]
  const char *v28; // [rsp+50h] [rbp-9h]
  const char *v29; // [rsp+58h] [rbp-1h]
  const char *v30; // [rsp+60h] [rbp+7h]
  const char *v31; // [rsp+68h] [rbp+Fh]
  const char *v32; // [rsp+70h] [rbp+17h]
  const char *v33; // [rsp+78h] [rbp+1Fh]
  const char *v34; // [rsp+80h] [rbp+27h]
  char *Str; // [rsp+D0h] [rbp+77h]

  v2 = 0;
  v23 = "mom_msys_origin_y";
  v3 = "mom_msys_origin_x";
  v24 = "mom_msys_origin_z";
  v34 = "END";
  v25 = "mom_msys_x_axis_i";
  v4 = a2;
  v26 = "mom_msys_x_axis_j";
  v5 = a1;
  v6 = 0i64;
  v27 = "mom_msys_x_axis_k";
  v28 = "mom_msys_y_axis_i";
  v29 = "mom_msys_y_axis_j";
  v30 = "mom_msys_y_axis_k";
  v31 = "mom_msys_z_axis_i";
  v32 = "mom_msys_z_axis_j";
  v33 = "mom_msys_z_axis_k";
LABEL_2:
  v7 = UF_MOM_ask_string(v5, v3 + 4, &Str);
  switch ( v2 )
  {
    case 0:
      v8 = "0.0";
      if ( Str )
        v8 = Str;
      Str = v8;
      *v4 = strtod(v8, 0i64);
      break;
    case 1:
      v9 = "0.0";
      if ( Str )
        v9 = Str;
      Str = v9;
      v4[1] = strtod(v9, 0i64);
      break;
    case 2:
      v10 = "0.0";
      if ( Str )
        v10 = Str;
      Str = v10;
      v4[2] = strtod(v10, 0i64);
      break;
    case 3:
      v11 = "1.0";
      if ( Str )
        v11 = Str;
      Str = v11;
      v4[3] = strtod(v11, 0i64);
      break;
    case 4:
      v12 = "0.0";
      if ( Str )
        v12 = Str;
      Str = v12;
      v4[4] = strtod(v12, 0i64);
      break;
    case 5:
      v13 = "0.0";
      if ( Str )
        v13 = Str;
      Str = v13;
      v4[5] = strtod(v13, 0i64);
      break;
    case 6:
      v14 = "0.0";
      if ( Str )
        v14 = Str;
      Str = v14;
      v4[6] = strtod(v14, 0i64);
      break;
    case 7:
      v15 = "1.0";
      if ( Str )
        v15 = Str;
      Str = v15;
      v4[7] = strtod(v15, 0i64);
      break;
    case 8:
      v16 = "0.0";
      if ( Str )
        v16 = Str;
      Str = v16;
      v4[8] = strtod(v16, 0i64);
      break;
    case 9:
      v17 = "0.0";
      if ( Str )
        v17 = Str;
      Str = v17;
      v4[9] = strtod(v17, 0i64);
      break;
    case 10:
      v18 = "0.0";
      if ( Str )
        v18 = Str;
      Str = v18;
      v4[10] = strtod(v18, 0i64);
      break;
    case 11:
      v19 = "1.0";
      if ( Str )
        v19 = Str;
      Str = v19;
      v4[11] = strtod(v19, 0i64);
      break;
    default:
      break;
  }
  v3 = (&v23)[v6++];
  ++v2;
  v20 = 0i64;
  do
  {
    v21 = v3[v20++];
    if ( v21 != aEnd[v20 - 1] )
      goto LABEL_2;
  }
  while ( v20 != 4 );
  return v7;
}
// 18000B2D8: using guessed type __int64 __fastcall UF_MOM_ask_string(_QWORD, _QWORD, _QWORD);

//----- (00000001800087D0) ----------------------------------------------------
__int64 __fastcall sub_1800087D0(__int64 a1, double *a2)
{
  int v2; // ebx
  const char *v3; // r8
  double *v4; // rsi
  __int64 v5; // r15
  __int64 v6; // rdi
  unsigned int v7; // er14
  char *v8; // rcx
  char *v9; // rcx
  char *v10; // rcx
  char *v11; // rcx
  char *v12; // rcx
  char *v13; // rcx
  char *v14; // rcx
  char *v15; // rcx
  char *v16; // rcx
  char *v17; // rcx
  char *v18; // rcx
  char *v19; // rcx
  __int64 v20; // rcx
  char v21; // al
  const char *v23; // [rsp+28h] [rbp-31h]
  const char *v24; // [rsp+30h] [rbp-29h]
  const char *v25; // [rsp+38h] [rbp-21h]
  const char *v26; // [rsp+40h] [rbp-19h]
  const char *v27; // [rsp+48h] [rbp-11h]
  const char *v28; // [rsp+50h] [rbp-9h]
  const char *v29; // [rsp+58h] [rbp-1h]
  const char *v30; // [rsp+60h] [rbp+7h]
  const char *v31; // [rsp+68h] [rbp+Fh]
  const char *v32; // [rsp+70h] [rbp+17h]
  const char *v33; // [rsp+78h] [rbp+1Fh]
  const char *v34; // [rsp+80h] [rbp+27h]
  char *Str; // [rsp+D0h] [rbp+77h]

  v2 = 0;
  v23 = "mom_mtsys_origin_y";
  v3 = "mom_mtsys_origin_x";
  v24 = "mom_mtsys_origin_z";
  v34 = "END";
  v25 = "mom_mtsys_x_axis_i";
  v4 = a2;
  v26 = "mom_mtsys_x_axis_j";
  v5 = a1;
  v6 = 0i64;
  v27 = "mom_mtsys_x_axis_k";
  v28 = "mom_mtsys_y_axis_i";
  v29 = "mom_mtsys_y_axis_j";
  v30 = "mom_mtsys_y_axis_k";
  v31 = "mom_mtsys_z_axis_i";
  v32 = "mom_mtsys_z_axis_j";
  v33 = "mom_mtsys_z_axis_k";
LABEL_2:
  v7 = UF_MOM_ask_string(v5, v3 + 4, &Str);
  switch ( v2 )
  {
    case 0:
      v8 = "0.0";
      if ( Str )
        v8 = Str;
      Str = v8;
      v4[12] = strtod(v8, 0i64);
      break;
    case 1:
      v9 = "0.0";
      if ( Str )
        v9 = Str;
      Str = v9;
      v4[13] = strtod(v9, 0i64);
      break;
    case 2:
      v10 = "0.0";
      if ( Str )
        v10 = Str;
      Str = v10;
      v4[14] = strtod(v10, 0i64);
      break;
    case 3:
      v11 = "1.0";
      if ( Str )
        v11 = Str;
      Str = v11;
      v4[15] = strtod(v11, 0i64);
      break;
    case 4:
      v12 = "0.0";
      if ( Str )
        v12 = Str;
      Str = v12;
      v4[16] = strtod(v12, 0i64);
      break;
    case 5:
      v13 = "0.0";
      if ( Str )
        v13 = Str;
      Str = v13;
      v4[17] = strtod(v13, 0i64);
      break;
    case 6:
      v14 = "0.0";
      if ( Str )
        v14 = Str;
      Str = v14;
      v4[18] = strtod(v14, 0i64);
      break;
    case 7:
      v15 = "1.0";
      if ( Str )
        v15 = Str;
      Str = v15;
      v4[19] = strtod(v15, 0i64);
      break;
    case 8:
      v16 = "0.0";
      if ( Str )
        v16 = Str;
      Str = v16;
      v4[20] = strtod(v16, 0i64);
      break;
    case 9:
      v17 = "0.0";
      if ( Str )
        v17 = Str;
      Str = v17;
      v4[21] = strtod(v17, 0i64);
      break;
    case 10:
      v18 = "0.0";
      if ( Str )
        v18 = Str;
      Str = v18;
      v4[22] = strtod(v18, 0i64);
      break;
    case 11:
      v19 = "1.0";
      if ( Str )
        v19 = Str;
      Str = v19;
      v4[23] = strtod(v19, 0i64);
      break;
    default:
      break;
  }
  v3 = (&v23)[v6++];
  ++v2;
  v20 = 0i64;
  do
  {
    v21 = v3[v20++];
    if ( v21 != aEnd[v20 - 1] )
      goto LABEL_2;
  }
  while ( v20 != 4 );
  return v7;
}
// 18000B2D8: using guessed type __int64 __fastcall UF_MOM_ask_string(_QWORD, _QWORD, _QWORD);

//----- (0000000180008B30) ----------------------------------------------------
__int64 __fastcall sub_180008B30(__int64 a1, double *a2)
{
  int v2; // ebx
  const char *v3; // r8
  double *v4; // rsi
  __int64 v5; // r14
  __int64 v6; // rdi
  char *v7; // rcx
  char *v8; // rcx
  char *v9; // rcx
  char *v10; // rcx
  char *v11; // rcx
  char *v12; // rcx
  char *v13; // rcx
  signed __int64 v14; // rdx
  char v15; // al
  char *v16; // rcx
  char *v17; // rcx
  __int64 v18; // rcx
  char v19; // al
  const char *v21; // [rsp+28h] [rbp-48h]
  const char *v22; // [rsp+30h] [rbp-40h]
  const char *v23; // [rsp+38h] [rbp-38h]
  const char *v24; // [rsp+40h] [rbp-30h]
  const char *v25; // [rsp+48h] [rbp-28h]
  const char *v26; // [rsp+50h] [rbp-20h]
  const char *v27; // [rsp+58h] [rbp-18h]
  const char *v28; // [rsp+60h] [rbp-10h]
  const char *v29; // [rsp+68h] [rbp-8h]
  char *Str; // [rsp+B0h] [rbp+40h]

  v2 = 0;
  v21 = "mom_origin_y";
  v3 = "mom_origin_x";
  v22 = "mom_origin_z";
  v29 = "END";
  v23 = "mom_translate_x";
  v4 = a2;
  v24 = "mom_translate_y";
  v5 = a1;
  v6 = 0i64;
  v25 = "mom_translate_z";
  v26 = "mom_tool_type";
  v27 = "mom_tool_z_offset";
  v28 = "mom_tool_corner1_radius";
LABEL_2:
  UF_MOM_ask_string(v5, v3 + 4, &Str);
  switch ( v2 )
  {
    case 0:
      v7 = "0.0";
      if ( Str )
        v7 = Str;
      Str = v7;
      v4[27] = strtod(v7, 0i64);
      break;
    case 1:
      v8 = "0.0";
      if ( Str )
        v8 = Str;
      Str = v8;
      v4[28] = strtod(v8, 0i64);
      break;
    case 2:
      v9 = "0.0";
      if ( Str )
        v9 = Str;
      Str = v9;
      v4[29] = strtod(v9, 0i64);
      break;
    case 3:
      v10 = "0.0";
      if ( Str )
        v10 = Str;
      Str = v10;
      v4[24] = strtod(v10, 0i64);
      break;
    case 4:
      v11 = "0.0";
      if ( Str )
        v11 = Str;
      Str = v11;
      v4[25] = strtod(v11, 0i64);
      break;
    case 5:
      v12 = "0.0";
      if ( Str )
        v12 = Str;
      Str = v12;
      v4[26] = strtod(v12, 0i64);
      break;
    case 6:
      v13 = "MILL";
      if ( Str )
        v13 = Str;
      Str = v13;
      v14 = (char *)v4 - v13;
      do
      {
        v15 = *v13;
        v13[v14 + 240] = *v13;
        ++v13;
      }
      while ( v15 );
      break;
    case 7:
      v16 = "0.0";
      if ( Str )
        v16 = Str;
      Str = v16;
      v4[80] = strtod(v16, 0i64);
      break;
    case 8:
      v17 = "0.0";
      if ( Str )
        v17 = Str;
      Str = v17;
      v4[81] = strtod(v17, 0i64);
      break;
    default:
      break;
  }
  v3 = (&v21)[v6++];
  ++v2;
  v18 = 0i64;
  do
  {
    v19 = v3[v18++];
    if ( v19 != aEnd[v18 - 1] )
      goto LABEL_2;
  }
  while ( v18 != 4 );
  return 0i64;
}
// 18000B2D8: using guessed type __int64 __fastcall UF_MOM_ask_string(_QWORD, _QWORD, _QWORD);

//----- (0000000180008DF0) ----------------------------------------------------
__int64 __fastcall sub_180008DF0(__int64 a1, _QWORD *a2, __int64 a3)
{
  __int64 v3; // rbx
  _QWORD *v4; // r14
  __int64 v5; // rdi
  double v6; // xmm7_8
  double *v7; // rbx
  signed __int64 v8; // rsi
  double v9; // xmm6_8
  __int64 v10; // rdx
  __int128 v11; // xmm6
  __int128 v12; // xmm6
  char *v13; // rbx
  __int64 v14; // xmm1_8
  __int64 result; // rax
  __int64 v16; // xmm0_8
  __int64 v17; // xmm1_8
  __int64 v18; // xmm0_8
  __int64 v19; // xmm1_8
  __int64 v20; // xmm0_8
  __int64 v21; // xmm1_8
  __int64 v22; // xmm0_8
  __int128 v23; // [rsp+20h] [rbp-D8h]
  __int128 v24; // [rsp+30h] [rbp-C8h]
  __int128 v25; // [rsp+40h] [rbp-B8h]
  __int128 v26; // [rsp+50h] [rbp-A8h]
  __int64 v27; // [rsp+60h] [rbp-98h]
  char v28; // [rsp+70h] [rbp-88h]
  char v29[232]; // [rsp+88h] [rbp-70h]

  v3 = a3;
  v23 = xmmword_18000D1C0;
  v4 = a2;
  v25 = xmmword_18000D1C0;
  v27 = 4607182418800017408i64;
  v24 = 0i64;
  v26 = 0i64;
  v5 = 0i64;
  v6 = asin(1.0) / 90.0;
  v7 = (double *)(v3 + 8);
  v8 = 3i64;
  do
  {
    switch ( (signed int)*(v7 - 1) )
    {
      case 1:
        v12 = *(unsigned __int64 *)v7;
        UF_MTX3_x_vec(&v23, &v28);
        break;
      case 2:
        v11 = *(unsigned __int64 *)v7;
        UF_MTX3_y_vec(&v23, &v28);
        break;
      case 3:
        v9 = *v7 * -1.0 * v6;
        UF_MTX3_z_vec(&v23, &v28);
        break;
      default:
        goto LABEL_9;
    }
    UF_MTX3_rotate_about_axis(&v28, v10, &v29[72 * (signed int)v5]);
    v5 = (unsigned int)(v5 + 1);
LABEL_9:
    v7 += 2;
    --v8;
  }
  while ( v8 );
  if ( (signed int)v5 > 0 )
  {
    v13 = v29;
    do
    {
      UF_MTX3_multiply(&v23, v13, &v23);
      v13 += 72;
      --v5;
    }
    while ( v5 );
  }
  v14 = *((_QWORD *)&v24 + 1);
  result = 0i64;
  v4[3] = v23;
  v16 = v26;
  v4[6] = v14;
  v17 = *((_QWORD *)&v23 + 1);
  v4[9] = v16;
  v18 = v25;
  v4[4] = v17;
  v19 = *((_QWORD *)&v26 + 1);
  v4[7] = v18;
  v20 = v24;
  v4[10] = v19;
  v21 = *((_QWORD *)&v25 + 1);
  v4[5] = v20;
  v22 = v27;
  v4[8] = v21;
  v4[11] = v22;
  dword_18000F6B0 = 0;
  return result;
}
// 18000B1D0: using guessed type __int64 __fastcall UF_MTX3_rotate_about_axis(_QWORD, _QWORD, _QWORD);
// 18000B1D8: using guessed type __int64 __fastcall UF_MTX3_multiply(_QWORD, _QWORD, _QWORD);
// 18000B220: using guessed type __int64 __fastcall UF_MTX3_z_vec(_QWORD, _QWORD);
// 18000B228: using guessed type __int64 __fastcall UF_MTX3_y_vec(_QWORD, _QWORD);
// 18000B230: using guessed type __int64 __fastcall UF_MTX3_x_vec(_QWORD, _QWORD);
// 18000D1C0: using guessed type __int128 xmmword_18000D1C0;
// 18000F6B0: using guessed type int dword_18000F6B0;
// 180008DF0: using guessed type char var_118[232];

//----- (0000000180009010) ----------------------------------------------------
__int64 __fastcall sub_180009010(__int64 a1, __int64 a2)
{
  int v2; // edi
  const char *v3; // r8
  __int64 v4; // rbx
  __int64 v5; // r15
  __int64 v6; // rsi
  unsigned int v7; // er14
  char *v8; // rcx
  char *v9; // rcx
  char *v10; // rcx
  char *v11; // rcx
  char *v12; // rcx
  char *v13; // rcx
  char *v14; // rcx
  char *v15; // rcx
  char *v16; // rcx
  __int64 v17; // rcx
  char v18; // al
  __int64 result; // rax
  const char *v20; // [rsp+28h] [rbp-48h]
  const char *v21; // [rsp+30h] [rbp-40h]
  const char *v22; // [rsp+38h] [rbp-38h]
  const char *v23; // [rsp+40h] [rbp-30h]
  const char *v24; // [rsp+48h] [rbp-28h]
  const char *v25; // [rsp+50h] [rbp-20h]
  const char *v26; // [rsp+58h] [rbp-18h]
  const char *v27; // [rsp+60h] [rbp-10h]
  const char *v28; // [rsp+68h] [rbp-8h]
  char *Str; // [rsp+A8h] [rbp+38h]

  v2 = 0;
  v20 = "mom_origin_y";
  v3 = "mom_origin_x";
  v21 = "mom_origin_z";
  v28 = "END";
  v22 = "mom_translate_x";
  v4 = a2;
  v23 = "mom_translate_y";
  v5 = a1;
  v6 = 0i64;
  v24 = "mom_translate_z";
  v25 = "mom_tool_z_offset";
  v26 = "mom_kin_track_center_of_ball";
  v27 = "mom_tool_corner1_radius";
LABEL_2:
  v7 = UF_MOM_ask_string(v5, v3 + 4, &Str);
  switch ( v2 )
  {
    case 0:
      v8 = "0.0";
      if ( Str )
        v8 = Str;
      Str = v8;
      *(double *)v4 = strtod(v8, 0i64);
      break;
    case 1:
      v9 = "0.0";
      if ( Str )
        v9 = Str;
      Str = v9;
      *(double *)(v4 + 8) = strtod(v9, 0i64);
      break;
    case 2:
      v10 = "0.0";
      if ( Str )
        v10 = Str;
      Str = v10;
      *(double *)(v4 + 16) = strtod(v10, 0i64);
      break;
    case 3:
      v11 = "0.0";
      if ( Str )
        v11 = Str;
      Str = v11;
      *(double *)(v4 + 96) = strtod(v11, 0i64);
      break;
    case 4:
      v12 = "0.0";
      if ( Str )
        v12 = Str;
      Str = v12;
      *(double *)(v4 + 104) = strtod(v12, 0i64);
      break;
    case 5:
      v13 = "0.0";
      if ( Str )
        v13 = Str;
      Str = v13;
      *(double *)(v4 + 112) = strtod(v13, 0i64);
      break;
    case 6:
      v14 = "0.0";
      if ( Str )
        v14 = Str;
      Str = v14;
      *(double *)(v4 + 120) = strtod(v14, 0i64);
      break;
    case 7:
      v15 = "0.0";
      if ( Str )
        v15 = Str;
      Str = v15;
      *(_DWORD *)(v4 + 128) = (signed int)strtod(v15, 0i64);
      break;
    case 8:
      v16 = "0.0";
      if ( Str )
        v16 = Str;
      Str = v16;
      *(double *)(v4 + 136) = strtod(v16, 0i64);
      break;
    default:
      break;
  }
  v3 = (&v20)[v6++];
  ++v2;
  v17 = 0i64;
  do
  {
    v18 = v3[v17++];
    if ( v18 != aEnd[v17 - 1] )
      goto LABEL_2;
  }
  while ( v17 != 4 );
  result = v7;
  xmmword_18000F620 = *(_OWORD *)v4;
  xmmword_18000F630 = *(_OWORD *)(v4 + 16);
  xmmword_18000F640 = *(_OWORD *)(v4 + 32);
  xmmword_18000F650 = *(_OWORD *)(v4 + 48);
  xmmword_18000F660 = *(_OWORD *)(v4 + 64);
  xmmword_18000F670 = *(_OWORD *)(v4 + 80);
  xmmword_18000F680 = *(_OWORD *)(v4 + 96);
  xmmword_18000F690 = *(_OWORD *)(v4 + 112);
  xmmword_18000F6A0 = *(_OWORD *)(v4 + 128);
  return result;
}
// 18000B2D8: using guessed type __int64 __fastcall UF_MOM_ask_string(_QWORD, _QWORD, _QWORD);
// 18000F620: using guessed type __int128 xmmword_18000F620;
// 18000F630: using guessed type __int128 xmmword_18000F630;
// 18000F640: using guessed type __int128 xmmword_18000F640;
// 18000F650: using guessed type __int128 xmmword_18000F650;
// 18000F660: using guessed type __int128 xmmword_18000F660;
// 18000F670: using guessed type __int128 xmmword_18000F670;
// 18000F680: using guessed type __int128 xmmword_18000F680;
// 18000F690: using guessed type __int128 xmmword_18000F690;
// 18000F6A0: using guessed type __int128 xmmword_18000F6A0;

//----- (0000000180009320) ----------------------------------------------------
__int64 __fastcall sub_180009320(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  __int64 v4; // rcx
  __int64 v5; // rcx
  char v7; // [rsp+20h] [rbp-28h]

  v2 = a2;
  v3 = a1;
  UF_VEC3_add(a1, &xmmword_18000F680, a2);
  UF_VEC3_sub(v3, &xmmword_18000F620, v2);
  UF_VEC3_copy(v3 + 24, v2 + 24);
  UF_VEC3_scale(v4, v2 + 24, &v7);
  UF_VEC3_add(v2, &v7, v2);
  if ( (_DWORD)xmmword_18000F6A0 == 1 )
  {
    UF_VEC3_scale(v5, v2 + 24, &v7);
    UF_VEC3_add(v2, &v7, v2);
  }
  return 0i64;
}
// 18000B1F8: using guessed type __int64 __fastcall UF_VEC3_copy(_QWORD, _QWORD);
// 18000B260: using guessed type __int64 __fastcall UF_VEC3_sub(_QWORD, _QWORD, _QWORD);
// 18000B268: using guessed type __int64 __fastcall UF_VEC3_scale(_QWORD, _QWORD, _QWORD);
// 18000B2A0: using guessed type __int64 __fastcall UF_VEC3_add(_QWORD, _QWORD, _QWORD);
// 18000F620: using guessed type __int128 xmmword_18000F620;
// 18000F680: using guessed type __int128 xmmword_18000F680;
// 18000F690: using guessed type __int128 xmmword_18000F690;
// 18000F6A0: using guessed type __int128 xmmword_18000F6A0;

//----- (00000001800093E0) ----------------------------------------------------
__int64 __fastcall sub_1800093E0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 v4; // rdi
  UGS::System *v5; // rax
  const char *v6; // r8
  __int64 v8; // [rsp+20h] [rbp-88h]
  __int128 v9; // [rsp+28h] [rbp-80h]
  __int128 v10; // [rsp+38h] [rbp-70h]
  __int128 v11; // [rsp+48h] [rbp-60h]
  __int128 v12; // [rsp+58h] [rbp-50h]
  char v13; // [rsp+70h] [rbp-38h]
  char v14; // [rsp+88h] [rbp-20h]
  int v15; // [rsp+B0h] [rbp+8h]

  v3 = a2;
  v4 = a1;
  v8 = *((_QWORD *)&xmmword_18000F630 + 1);
  v10 = xmmword_18000F650;
  v9 = xmmword_18000F640;
  v12 = xmmword_18000F670;
  v11 = xmmword_18000F660;
  if ( !dword_18000F6B0 )
  {
    UF_VEC3_is_equal(a1 + 24, (char *)&xmmword_18000F660 + 8, a3, &v15, v8, v9, *((_QWORD *)&v9 + 1));
    if ( !v15 )
    {
      v5 = (UGS::System *)_acrt_iob_func(1i64);
      UGS::System::SYSS_fprintf(
        v5,
        (struct _iobuf *)"WARNING  The tool axis is not matching with the                 rotated MCS-Z axis. The output "
                         "may be INCORRECT\n",
        v6);
      uc1601(
        "WARNING  The tool axis is not matching with the *                     rotated MCS-Z axis. The output may be INCORRECT\n",
        1i64);
    }
    dword_18000F6B0 = 1;
  }
  UF_VEC3_copy(v4, &v13);
  UF_VEC3_copy(v4 + 24, &v14);
  UF_MTX3_vec_multiply(v4, &v8, v3);
  UF_MTX3_vec_multiply(v4 + 24, &v8, v3 + 24);
  return 0i64;
}
// 18000B168: using guessed type __int64 __fastcall _acrt_iob_func(_QWORD);
// 18000B188: using guessed type _DWORD UGS::System::SYSS_fprintf(UGS::System *__hidden this, struct _iobuf *, const char *, ...);
// 18000B1F8: using guessed type __int64 __fastcall UF_VEC3_copy(_QWORD, _QWORD);
// 18000B240: using guessed type __int64 __fastcall UF_MTX3_vec_multiply(_QWORD, _QWORD, _QWORD);
// 18000B308: using guessed type __int64 __fastcall uc1601(_QWORD, _QWORD);
// 18000F630: using guessed type __int128 xmmword_18000F630;
// 18000F640: using guessed type __int128 xmmword_18000F640;
// 18000F650: using guessed type __int128 xmmword_18000F650;
// 18000F660: using guessed type __int128 xmmword_18000F660;
// 18000F670: using guessed type __int128 xmmword_18000F670;
// 18000F6B0: using guessed type int dword_18000F6B0;

//----- (0000000180009594) ----------------------------------------------------
signed __int64 __fastcall sub_180009594(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // r14
  char v4; // bl
  char v5; // di
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 *v9; // rax
  __int64 *v10; // rbx
  __int64 v11; // rax

  v2 = a2;
  v3 = a1;
  if ( !(unsigned __int8)_scrt_initialize_crt(0i64) )
    return 0i64;
  v4 = _scrt_acquire_startup_lock();
  v5 = 1;
  if ( dword_18000F6D8 )
  {
    _scrt_fastfail(7i64);
    JUMPOUT(*(_QWORD *)&byte_1800096A9);
  }
  dword_18000F6D8 = 1;
  if ( (unsigned __int8)_scrt_dllmain_before_initialize_c() )
  {
    sub_180009E60(v7, v6, v8);
    sub_180009974();
    _scrt_initialize_default_local_stdio_options();
    if ( !(unsigned int)initterm_e(&unk_18000B340, &unk_18000B348) )
    {
      if ( (unsigned __int8)_scrt_dllmain_after_initialize_c() )
      {
        initterm(&unk_18000B328, &unk_18000B338);
        dword_18000F6D8 = 2;
        v5 = 0;
      }
    }
  }
  LOBYTE(v7) = v4;
  _scrt_release_startup_lock(v7);
  if ( v5 )
    return 0i64;
  v9 = (__int64 *)sub_180009D04();
  v10 = v9;
  if ( *v9 )
  {
    if ( sub_180009C1C((__int64)v9) )
    {
      v11 = *v10;
      sub_18000A110(v3, 2i64, v2);
    }
  }
  ++dword_18000F6BC;
  return 1i64;
}
// 1800096A9: using guessed type char byte_1800096A9;
// 180009998: using guessed type __int64 _scrt_initialize_default_local_stdio_options(void);
// 1800099B4: using guessed type __int64 _scrt_acquire_startup_lock(void);
// 1800099F0: using guessed type __int64 _scrt_dllmain_after_initialize_c(void);
// 180009A24: using guessed type __int64 _scrt_dllmain_before_initialize_c(void);
// 180009B20: using guessed type __int64 __fastcall _scrt_initialize_crt(_QWORD);
// 180009CB4: using guessed type __int64 __fastcall _scrt_release_startup_lock(_QWORD);
// 180009D14: using guessed type __int64 __fastcall _scrt_fastfail(_QWORD);
// 18000A0B8: using guessed type __int64 __fastcall initterm(_QWORD, _QWORD);
// 18000A0BE: using guessed type __int64 __fastcall initterm_e(_QWORD, _QWORD);
// 18000A110: using guessed type __int64 __fastcall sub_18000A110(_QWORD, _QWORD, _QWORD);
// 18000F6BC: using guessed type int dword_18000F6BC;
// 18000F6D8: using guessed type int dword_18000F6D8;

//----- (00000001800096AC) ----------------------------------------------------
signed __int64 __fastcall sub_1800096AC(char a1)
{
  char v1; // di
  char v2; // bl
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // rcx
  __int64 v7; // rcx
  signed __int64 result; // rax

  v1 = a1;
  if ( dword_18000F6BC <= 0 )
    goto LABEL_11;
  --dword_18000F6BC;
  v2 = _scrt_acquire_startup_lock();
  if ( dword_18000F6D8 != 2 )
  {
    _scrt_fastfail(7i64);
    JUMPOUT(*(_QWORD *)&byte_18000972E);
  }
  sub_180009ADC();
  sub_180009984();
  sub_180009E9C(v4, v3, v5);
  dword_18000F6D8 = 0;
  _scrt_dllmain_uninitialize_critical();
  LOBYTE(v6) = v2;
  _scrt_release_startup_lock(v6);
  LOBYTE(v7) = v1;
  if ( sub_180009CD8(v7, 0) )
    result = 1i64;
  else
LABEL_11:
    result = 0i64;
  return result;
}
// 18000972E: using guessed type char byte_18000972E;
// 1800099B4: using guessed type __int64 _scrt_acquire_startup_lock(void);
// 180009ADC: using guessed type __int64 sub_180009ADC(void);
// 180009B0C: using guessed type __int64 _scrt_dllmain_uninitialize_critical(void);
// 180009CB4: using guessed type __int64 __fastcall _scrt_release_startup_lock(_QWORD);
// 180009D14: using guessed type __int64 __fastcall _scrt_fastfail(_QWORD);
// 18000F6BC: using guessed type int dword_18000F6BC;
// 18000F6D8: using guessed type int dword_18000F6D8;

//----- (0000000180009974) ----------------------------------------------------
void sub_180009974()
{
  InitializeSListHead((PSLIST_HEADER)&unk_18000F6C0);
}

//----- (0000000180009984) ----------------------------------------------------
__int64 sub_180009984()
{
  return _std_type_info_destroy_list(&unk_18000F6C0);
}
// 18000A07C: using guessed type __int64 __fastcall _std_type_info_destroy_list(_QWORD);

//----- (0000000180009990) ----------------------------------------------------
void *sub_180009990()
{
  return &unk_18000F6D0;
}

//----- (0000000180009B6C) ----------------------------------------------------
char __fastcall sub_180009B6C(unsigned int a1)
{
  unsigned int v1; // ebx
  int v2; // eax

  v1 = a1;
  if ( !byte_18000F6E9 )
  {
    if ( a1 > 1 )
    {
      _scrt_fastfail(5i64);
      __debugbreak();
      JUMPOUT(*(_QWORD *)sub_180009C1C);
    }
    LOBYTE(v2) = __uncaught_exception();
    if ( !v2 || v1 )
    {
      qword_18000F6F0 = _security_cookie ^ __ROR8__(-1i64, 64 - ((unsigned __int8)_security_cookie & 0x3Fu));
      qword_18000F6F8 = _security_cookie ^ __ROR8__(-1i64, 64 - ((unsigned __int8)_security_cookie & 0x3Fu));
      qword_18000F700 = _security_cookie ^ __ROR8__(-1i64, 64 - ((unsigned __int8)_security_cookie & 0x3Fu));
      qword_18000F708 = _security_cookie ^ __ROR8__(-1i64, 64 - ((unsigned __int8)_security_cookie & 0x3Fu));
      qword_18000F710 = _security_cookie ^ __ROR8__(-1i64, 64 - ((unsigned __int8)_security_cookie & 0x3Fu));
      qword_18000F718 = _security_cookie ^ __ROR8__(-1i64, 64 - ((unsigned __int8)_security_cookie & 0x3Fu));
    }
    else if ( (unsigned int)initialize_onexit_table(&qword_18000F6F0)
           || (unsigned int)initialize_onexit_table(&qword_18000F708) )
    {
      return 0;
    }
    byte_18000F6E9 = 1;
  }
  return 1;
}
// 180009D14: using guessed type __int64 __fastcall _scrt_fastfail(_QWORD);
// 18000A0D6: using guessed type __int64 __fastcall initialize_onexit_table(_QWORD);
// 18000F6E9: using guessed type char byte_18000F6E9;
// 18000F6F0: using guessed type __int64 qword_18000F6F0;
// 18000F6F8: using guessed type __int64 qword_18000F6F8;
// 18000F700: using guessed type __int64 qword_18000F700;
// 18000F708: using guessed type __int64 qword_18000F708;
// 18000F710: using guessed type __int64 qword_18000F710;
// 18000F718: using guessed type __int64 qword_18000F718;

//----- (0000000180009C1C) ----------------------------------------------------
char __fastcall sub_180009C1C(__int64 a1)
{
  unsigned __int64 v1; // r8
  _DWORD *v2; // rdx
  signed __int64 v3; // r9
  unsigned __int64 v4; // rcx

  if ( MEMORY[0x180000000] != 23117
    || *(_DWORD *)(MEMORY[0x18000003C] + 0x180000000i64) != 17744
    || *(_WORD *)(MEMORY[0x18000003C] + 0x180000018i64) != 523 )
  {
    return 0;
  }
  v1 = a1 - 6442450944i64;
  v2 = (_DWORD *)(*(unsigned __int16 *)(MEMORY[0x18000003C] + 0x180000014i64) + MEMORY[0x18000003C] + 6442450968i64);
  v3 = (signed __int64)&v2[10 * *(unsigned __int16 *)(MEMORY[0x18000003C] + 0x180000006i64)];
  while ( v2 != (_DWORD *)v3 )
  {
    v4 = (unsigned int)v2[3];
    if ( v1 >= v4 && v1 < (unsigned int)(v4 + v2[2]) )
      goto LABEL_10;
    v2 += 10;
  }
  v2 = 0i64;
LABEL_10:
  if ( !v2 )
    return 0;
  if ( v2[9] >= 0 )
    return 1;
  return 0;
}

//----- (0000000180009CD8) ----------------------------------------------------
char __fastcall sub_180009CD8(__int64 a1, char a2)
{
  if ( !byte_18000F6E8 || !a2 )
  {
    sub_18000A0F0();
    sub_18000A0F0();
  }
  return 1;
}
// 18000F6E8: using guessed type char byte_18000F6E8;

//----- (0000000180009D04) ----------------------------------------------------
void *sub_180009D04()
{
  return &unk_18000F728;
}

//----- (0000000180009D0C) ----------------------------------------------------
void sub_180009D0C()
{
  dword_18000F720 = 0;
}
// 18000F720: using guessed type int dword_18000F720;

//----- (0000000180009E60) ----------------------------------------------------
__int64 __fastcall sub_180009E60(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 *i; // rbx
  __int64 result; // rax

  for ( i = (__int64 *)&unk_18000D630; i < (__int64 *)&unk_18000D630; ++i )
  {
    result = *i;
    if ( *i )
      result = sub_18000A110(a1, a2, a3);
  }
  return result;
}
// 18000A110: using guessed type __int64 __fastcall sub_18000A110(_QWORD, _QWORD, _QWORD);

//----- (0000000180009E9C) ----------------------------------------------------
__int64 __fastcall sub_180009E9C(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 *i; // rbx
  __int64 result; // rax

  for ( i = (__int64 *)&unk_18000D640; i < (__int64 *)&unk_18000D640; ++i )
  {
    result = *i;
    if ( *i )
      result = sub_18000A110(a1, a2, a3);
  }
  return result;
}
// 18000A110: using guessed type __int64 __fastcall sub_18000A110(_QWORD, _QWORD, _QWORD);

//----- (0000000180009ED8) ----------------------------------------------------
__int64 sub_180009ED8()
{
  char v5; // di
  int v6; // er10
  signed int v7; // esi
  int v9; // er9
  int v14; // er11
  int v15; // eax
  unsigned __int64 v16; // rax
  signed __int64 v17; // rcx
  int v18; // er8
  int v23; // eax

  _RAX = 0i64;
  dword_18000F244 = 2;
  dword_18000F240 = 1;
  __asm { cpuid }
  v5 = 0;
  v6 = _RDX;
  v7 = _RAX;
  _RAX = 1i64;
  v9 = _RCX ^ 0x6C65746E | _RBX ^ 0x756E6547;
  __asm { cpuid }
  v14 = _RCX;
  if ( v6 ^ 0x49656E69 | v9
    || (qword_18000F248 = -1i64, v15 = _RAX & 0xFFF3FF0, v15 != 67264)
    && v15 != 132704
    && v15 != 132720
    && ((v16 = (unsigned int)(v15 - 198224), (unsigned int)v16 > 0x20) || (v17 = 4295032833i64, !_bittest64(&v17, v16))) )
  {
    v18 = dword_18000F724;
  }
  else
  {
    v18 = dword_18000F724 | 1;
    dword_18000F724 |= 1u;
  }
  _RAX = 7i64;
  if ( v7 >= 7 )
  {
    __asm { cpuid }
    v5 = _RBX;
    if ( _bittest((const signed int *)&_RBX, 9u) )
      dword_18000F724 = v18 | 2;
  }
  if ( _bittest(&v14, 0x14u) )
  {
    dword_18000F240 = 2;
    dword_18000F244 = 6;
    if ( _bittest(&v14, 0x1Bu) )
    {
      if ( _bittest(&v14, 0x1Cu) )
      {
        __asm { xgetbv }
        if ( (_RAX & 6) == 6 )
        {
          v23 = dword_18000F244 | 8;
          dword_18000F240 = 3;
          dword_18000F244 |= 8u;
          if ( v5 & 0x20 )
          {
            dword_18000F240 = 5;
            dword_18000F244 = v23 | 0x20;
          }
        }
      }
    }
  }
  return 0i64;
}
// 18000F240: using guessed type int dword_18000F240;
// 18000F244: using guessed type int dword_18000F244;
// 18000F248: using guessed type __int64 qword_18000F248;
// 18000F720: using guessed type int dword_18000F720;
// 18000F724: using guessed type int dword_18000F724;

//----- (000000018000A054) ----------------------------------------------------
signed __int64 sub_18000A054()
{
  return 1i64;
}

//----- (000000018000A0F0) ----------------------------------------------------
char sub_18000A0F0()
{
  return 1;
}

//----- (000000018000A0F4) ----------------------------------------------------
__int64 sub_18000A0F4()
{
  return 0i64;
}

// ALL OK, 71 function(s) have been successfully decompiled
