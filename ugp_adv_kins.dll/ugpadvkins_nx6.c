/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007 Hex-Rays sprl <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Data declarations

extern char aReturnedErrorD[]; // idb
extern char aReturnedAD[]; // idb
extern char aSLineDS[]; // idb
extern char aKinematics[11]; // weak
extern char aErrorAdvancedK[]; // idb
extern char aUgpkin[13]; // weak
extern char aNumberOfArgume[]; // idb
extern char aIncorrectNumbe[]; // idb
extern char aSet_rotd_opera[]; // idb
extern char aSet_rotd_mcs_m[]; // idb
extern char aCaxis[6]; // weak
extern char aBaxis[6]; // weak
extern char aAaxis[6]; // weak
extern char aInsufficientNu[]; // idb
extern char aPos_z[6]; // weak
extern char aPos_y[6]; // weak
extern char aPos_x[6]; // weak
extern char aMom_transfer_g[]; // idb
extern char aMom_process_in[]; // idb
extern char aSet_input_poin[]; // idb
extern char a5_axis_head_ta[]; // idb
extern char a5_axis_dual_he[]; // idb
extern char a5_axis_dual_ta[]; // idb
extern char aNegz[]; // idb
extern char aNegy[]; // idb
extern char aNegx[]; // idb
extern char aPosz[]; // idb
extern char aPosy[]; // idb
extern char aPosx[]; // idb
extern char aAlt_pos_a2[11]; // weak
extern char aAlt_pos_a1[11]; // weak
extern char aAlt_pos_z[10]; // weak
extern char aAlt_pos_y[10]; // weak
extern char aAlt_pos_x[10]; // weak
extern char aPos_a2[7]; // weak
extern char aPos_a1[7]; // weak
extern char aUf_attr_read_v[]; // idb
extern char aUf_obj_cycle_b[]; // idb
extern char aNoToolNameObta[34]; // weak
extern char aErrorS[]; // idb
extern char aInvalidNumberO[28]; // weak
extern int dword_100095D4; // weak
extern int dword_100095D8; // weak
extern __int16 word_100095DC; // weak
extern int dword_100095E0; // weak
extern int dword_100095E4; // weak
extern int dword_100095E8; // weak
extern int dword_100095EC; // weak
extern int dword_100095F0; // weak
extern char aUf_mom_exten_4[87]; // weak
extern char aMom_exit_kinem[27]; // weak
extern char aUf_mom_exten_3[81]; // weak
extern char aMom_map_to_rot[24]; // weak
extern char aUf_mom_exten_2[75]; // weak
extern char aMom_rotate_mac[21]; // weak
extern char aUf_mom_exten_1[80]; // weak
extern char aMom_get_tool_a[23]; // weak
extern char aUf_mom_exten_0[69]; // weak
extern char aMom_convert_po[18]; // weak
extern char aOUgnx60Ip24Src[63]; // weak
extern char aUf_mom_extend_[73]; // weak
extern char aMom_load_kinem[20]; // weak
extern char aErrorUgpostAdv[]; // idb
extern _UNKNOWN unk_100098E8; // weak
extern _UNKNOWN unk_10009930; // weak
extern _UNKNOWN unk_10009978; // weak
extern char aWarningSameVal[]; // idb
extern char aComputingT11FT[]; // idb
extern char aComputingT10FT[]; // idb
extern char aAboutAdjusting[]; // idb
extern char aWarningDegener[]; // idb
extern char aInputPoint_4f_[]; // idb
extern char aStartingOld_pc[]; // idb
extern char asc_10009BAC[]; // idb
extern char aInit_t11Init_t[]; // idb
extern char aInit_t10Init_t[]; // idb
extern char aA1FD1FAlpha1FA[]; // idb
extern char aWarningToolAxi[]; // idb
extern char aLocalSecondary[]; // idb
extern char aLocalPrimaryax[]; // idb
extern char aSulzerCase[]; // idb
extern char aMcsysFFFFFFFFF[]; // idb
extern char aTool_vectorFFF[]; // idb
extern char aTool_machine_c[]; // idb
extern char aSecondary_mach[]; // idb
extern char aSecondaryFFF[]; // idb
extern char aPrimary_machin[]; // idb
extern char aPrimaryFFF[]; // idb
extern char aIs_5_axis_head[]; // idb
extern char aIs_5_axis_du_0[21]; // weak
extern char aIs_5_axis_dual[22]; // weak
extern char aIs_orthogonal_[]; // idb
extern char asc_10009E60[]; // idb
extern char aFinalUfuncAlt_[]; // idb
extern char aFinalUfuncMcoo[]; // idb
extern char a400_00[7]; // weak
extern char a0_0[4]; // weak
extern wchar_t aF[2]; // weak
extern char aIn[3]; // weak
extern char aNone[5]; // weak
extern char aMom_kin_rapid_[24]; // weak
extern char aMom_kin_pivot_[27]; // weak
extern char aMom_kin_read_a[31]; // weak
extern char aMom_kin_polar_[26]; // weak
extern char aMom_kin_output[20]; // weak
extern char aEnd[4]; // weak
extern char aMom_kin_nurbs_[26]; // weak
extern char a9999_9999[10]; // weak
extern char a0_0001[7]; // weak
extern char aXy[3]; // weak
extern char aFull_circle[12]; // weak
extern char aMom_kin_max_ar[23]; // weak
extern char aMom_kin_min_ar[23]; // weak
extern char aMom_kin_arc_va[24]; // weak
extern char aMom_kin_arc_ou[24]; // weak
extern char a99999_999[10]; // weak
extern char a99_999[7]; // weak
extern char a0_001[6]; // weak
extern char a999_999[8]; // weak
extern char aMom_kin_min_dp[16]; // weak
extern char aMom_kin_max_dp[16]; // weak
extern char aMom_kin_min_fr[16]; // weak
extern char aMom_kin_max_fr[16]; // weak
extern char aMom_kin_min__0[16]; // weak
extern char aMom_kin_max__0[16]; // weak
extern char aMom_kin_min_fp[16]; // weak
extern char aMom_kin_max_fp[16]; // weak
extern char a360_0[6]; // weak
extern char aStandard[9]; // weak
extern char aMagnitude_dete[31]; // weak
extern char aYz[3]; // weak
extern char aMom_kin_4th_13[27]; // weak
extern char aMom_kin_4th_12[27]; // weak
extern char aMom_kin_4th_11[26]; // weak
extern char aMom_kin_4th_10[26]; // weak
extern char aMom_kin_4th__9[26]; // weak
extern char aMom_kin_4th__8[33]; // weak
extern char aMom_kin_4th__7[33]; // weak
extern char aMom_kin_4th__6[33]; // weak
extern char aMom_kin_4th__5[22]; // weak
extern char aMom_kin_4th__4[27]; // weak
extern char aMom_kin_4th__3[27]; // weak
extern char aMom_kin_4th__2[26]; // weak
extern char aMom_kin_4th__1[26]; // weak
extern char aMom_kin_4th__0[27]; // weak
extern char aMom_kin_4th_ax[23]; // weak
extern char aMom_kin_5th_13[27]; // weak
extern char aMom_kin_5th_12[27]; // weak
extern char aMom_kin_5th_11[26]; // weak
extern char aMom_kin_5th_10[26]; // weak
extern char aMom_kin_5th__9[26]; // weak
extern char aMom_kin_5th__8[33]; // weak
extern char aMom_kin_5th__7[33]; // weak
extern char aMom_kin_5th__6[33]; // weak
extern char aMom_kin_5th__5[22]; // weak
extern char aMom_kin_5th__4[27]; // weak
extern char aMom_kin_5th__3[27]; // weak
extern char aMom_kin_5th__2[26]; // weak
extern char aMom_kin_5th__1[26]; // weak
extern char aMom_kin_5th__0[27]; // weak
extern char aMom_kin_5th_ax[23]; // weak
extern char aFront[6]; // weak
extern char aMom_kin_ind__0[32]; // weak
extern char aMom_kin_ind_to[32]; // weak
extern char aMom_kin_indepe[25]; // weak
extern char a3_0[4]; // weak
extern char a0_5[4]; // weak
extern char aMom_kin_flush_[19]; // weak
extern char aMom_kin_clamp_[19]; // weak
extern char aMom_kin_tool_c[25]; // weak
extern char aMom_kin_hol_22[25]; // weak
extern char aMom_kin_hol_21[25]; // weak
extern char aMom_kin_hol_20[25]; // weak
extern char aMom_kin_hol_19[25]; // weak
extern char aMom_kin_hol_18[25]; // weak
extern char aMom_kin_hol_17[25]; // weak
extern char aMom_kin_hol_16[25]; // weak
extern char aMom_kin_hol_15[25]; // weak
extern char aMom_kin_hol_14[25]; // weak
extern char aMom_kin_hol_13[25]; // weak
extern char aMom_kin_hol_12[25]; // weak
extern char aMom_kin_hol_11[25]; // weak
extern char aMom_kin_hol_10[25]; // weak
extern char aMom_kin_hold_9[25]; // weak
extern char aMom_kin_hold_8[25]; // weak
extern char aMom_kin_hold_7[25]; // weak
extern char aMom_kin_hold_6[25]; // weak
extern char aMom_kin_hold_5[25]; // weak
extern char aMom_kin_hold_4[28]; // weak
extern char aMom_kin_hold_3[28]; // weak
extern char aMom_kin_hold_2[28]; // weak
extern char aMom_kin_hold_1[28]; // weak
extern char aMom_kin_hold_0[28]; // weak
extern char aMom_kin_holder[28]; // weak
extern char aKin_4th_to_t_1[28]; // weak
extern char aKin_4th_to_t_0[28]; // weak
extern char aKin_4th_to_tra[28]; // weak
extern char a90_0[5]; // weak
extern char aCartesian[10]; // weak
extern wchar_t aT[2]; // weak
extern char a3_axis_mill[12]; // weak
extern char aMom_kin_gaug_0[25]; // weak
extern char aMom_kin_line_0[26]; // weak
extern char aMom_kin_5th_14[36]; // weak
extern char aMom_kin_tool_t[29]; // weak
extern char aMom_kin_mach_0[27]; // weak
extern char aMom_kin_linear[27]; // weak
extern char aMom_kin_coordi[24]; // weak
extern char aMom_kin_clsf_g[24]; // weak
extern char aMom_kin_wire_t[30]; // weak
extern char aMom_kin_track_[29]; // weak
extern char aMom_kin_machin[21]; // weak
extern char aMom_kin_gauge_[25]; // weak
extern char a1_0[4]; // weak
extern char aMom_msys_z_a_1[18]; // weak
extern char aMom_msys_z_a_0[18]; // weak
extern char aMom_msys_z_axi[18]; // weak
extern char aMom_msys_y_a_1[18]; // weak
extern char aMom_msys_y_a_0[18]; // weak
extern char aMom_msys_y_axi[18]; // weak
extern char aMom_msys_x_a_1[18]; // weak
extern char aMom_msys_x_a_0[18]; // weak
extern char aMom_msys_x_axi[18]; // weak
extern char aMom_msys_ori_1[18]; // weak
extern char aMom_msys_ori_0[18]; // weak
extern char aMom_msys_origi[18]; // weak
extern char aMom_mtsys_z__1[19]; // weak
extern char aMom_mtsys_z__0[19]; // weak
extern char aMom_mtsys_z_ax[19]; // weak
extern char aMom_mtsys_y__1[19]; // weak
extern char aMom_mtsys_y__0[19]; // weak
extern char aMom_mtsys_y_ax[19]; // weak
extern char aMom_mtsys_x__1[19]; // weak
extern char aMom_mtsys_x__0[19]; // weak
extern char aMom_mtsys_x_ax[19]; // weak
extern char aMom_mtsys_or_1[19]; // weak
extern char aMom_mtsys_or_0[19]; // weak
extern char aMom_mtsys_orig[19]; // weak
extern char aMill[5]; // weak
extern char aMom_tool_corne[24]; // weak
extern char aMom_tool_z_off[18]; // weak
extern char aMom_tool_type[14]; // weak
extern char aMom_translat_1[16]; // weak
extern char aMom_translat_0[16]; // weak
extern char aMom_translate_[16]; // weak
extern char aMom_origin_z[13]; // weak
extern char aMom_origin_y[13]; // weak
extern char aMom_origin_x[13]; // weak
extern char aMom_tool_axi_1[16]; // weak
extern char aMom_tool_axi_0[16]; // weak
extern char aMom_tool_axis_[16]; // weak
extern char aMom_mcs_goto_z[15]; // weak
extern char aMom_mcs_goto_y[15]; // weak
extern char aMom_mcs_goto_x[15]; // weak
extern char aWarningTheTo_0[119]; // weak
extern char aWarningTheTool[]; // idb
extern int dword_1000ADB8; // weak
extern _UNKNOWN unk_1000AE78; // weak
extern _UNKNOWN unk_1000AE80; // weak
extern char byte_1000C008; // weak
extern char byte_1000C009; // weak
extern char byte_1000C00A; // weak
extern int dword_1000C240; // weak
extern double dbl_1000C248; // weak
extern int dword_1000C2C8; // weak
extern int dword_1000C2CC; // weak
extern int dword_1000C2D0; // weak
extern int dword_1000C2D4; // weak
extern int dword_1000C2D8; // weak
extern int dword_1000C2DC; // weak
extern double dbl_1000C2F0; // weak
extern double dbl_1000C328; // weak
extern _UNKNOWN unk_1000C340; // weak
extern int dword_1000C3D8; // weak
extern int dword_1000C3DC; // weak
extern _UNKNOWN unk_1000C3E0; // weak
extern double dbl_1000C470; // weak
extern int dword_1000C4E0; // weak
extern int dword_1000C4E4; // weak
extern int dword_1000C4E8; // weak
extern int dword_1000C4EC; // weak
extern int dword_1000C4F0; // weak
extern int dword_1000C4F4; // weak
extern int dword_1000C4F8; // weak
extern int dword_1000C4FC; // weak
extern int dword_1000C500; // weak
extern int dword_1000C504; // weak
extern int dword_1000C508; // weak
extern int dword_1000C50C; // weak
extern int dword_1000C510; // weak
extern int dword_1000C514; // weak
extern int dword_1000C518; // weak
extern int dword_1000C51C; // weak
extern int dword_1000C520; // weak
extern int dword_1000C524; // weak
extern int dword_1000C528; // weak
extern int dword_1000C52C; // weak
extern int dword_1000C540; // weak
extern int dword_1000C544; // weak
extern int dword_1000C548; // weak
extern int dword_1000C54C; // weak
extern int dword_1000C550; // weak
extern int dword_1000C554; // weak
extern double dbl_1000C558; // weak
extern double dbl_1000C560; // weak
extern double dbl_1000C568; // weak
extern double dbl_1000C570; // weak
extern char byte_1000C588; // weak
extern _UNKNOWN unk_1000C590; // weak
extern _UNKNOWN unk_1000C5B8; // weak
extern _UNKNOWN unk_1000C5E0; // weak
extern double dbl_1000C628; // weak
extern _UNKNOWN unk_1000C640; // weak
extern int dword_1000C660; // weak
extern int dword_1000C670; // weak
extern _UNKNOWN unk_1000C67C; // weak
extern int dword_1000C9AC; // weak

//-------------------------------------------------------------------------
// Function declarations

// int __usercall sub_10001010<eax>(int a1<eax>, int a2<edx>, int a3<ecx>, int a4<esi>);
signed int __cdecl sub_10001070(char *a1); // idb
// int UF_terminate(); weak
// signed int __usercall sub_100010D0<eax>(int a1<edi>, int a2, int a3, int a4, int a5);
int __cdecl sub_10001260(int a1);
int __cdecl sub_10001340(char *a1); // idb
int __cdecl sub_10001AB0(int a1);
signed int __cdecl sub_10001BB0(int a1, int a2, int a3, int a4);
int __cdecl ufusr(int a1, int a2);
// int __usercall sub_10001F20<eax>(int a1<eax>, int a2<ecx>, int a3<esi>, char a4);
// int __cdecl sub_10001F50(double); idb
// int __usercall sub_10001FA0<eax>(int result<eax>, int _ECX<ecx>, double a3); idb
// int __usercall sub_10002080<eax>(int a1<eax>, int a2<ecx>, int a3);
// int __usercall sub_10002150<eax>(int a1<eax>, int a2<esi>, double a3, double a4, int a5); idb
int __cdecl sub_100022D0(int a1, double a2, int a3); // idb
int __cdecl sub_10002350(int a1, double a2, int a3); // idb
int __fastcall sub_10002390(int a1, int a2, int a3);
// int __usercall sub_100023B0<eax>(int _EAX<eax>, int a2<ecx>, int a3);
signed int __cdecl sub_100023F0(const void *a1, const void *a2); // idb
__int16 __cdecl sub_10002430();
__int16 __cdecl sub_10002580(double a1); // idb
// __int16 __usercall sub_100025B0<ax>(int _EDX<edx>, const void *_EBX<ebx>);
int __cdecl sub_100026E0(int a1);
int __cdecl sub_10002770(int a1, int a2, int a3, int a4);
int __cdecl sub_10002830(int a1, int a2, int a3, int a4);
int __fastcall sub_10002CA0(int a1, int _EDX, int a3, int a4, int a5);
int __cdecl sub_10002EB0(int a2);
int __cdecl sub_10002FE0(int a2, int a3);
// signed int __usercall sub_10003210<eax>(int a1<ebx>, int a2<edi>, int a3<esi>, const void *a4, int a5, int a6);
int __cdecl sub_10003F80(int a1, int a2, int a3, int a4, int a5, int a6);
signed int __cdecl sub_100041A0(int a1, const void *a2, int a3, int a4, int a5, int a6, int a7, int a8, const void *a9);
const void *__cdecl sub_10004F70(const void *a1, void *a2, void *a3);
__int16 __cdecl sub_10005200(int a1, int a2);
// signed int __usercall sub_10005290<eax>(int a1<eax>);
signed int __cdecl sub_100053B0(int a1);
int __fastcall sub_100053F0(int a1, int a2, char a3);
int __cdecl sub_10005410(int a1, int a2);
int __cdecl sub_100055C0(int a1, int a2);
int __cdecl sub_10005700(int a1, int a2);
int __cdecl sub_100058D0(int a1, int a2);
int __cdecl sub_10005C10(int a1, int a2);
int __cdecl sub_10005F50(int a1, int a2);
int __cdecl sub_10006060(int a1, int a2);
int __cdecl sub_10006150(int a1, int a2);
int __cdecl sub_10006660(int a1, int a2);
int __cdecl sub_10006A10(int a1, int a2);
int __cdecl sub_10006C90(int a1, int a2);
int __cdecl sub_10006F30(int a1, int a2);
int __cdecl sub_10007150(int a1, int a2);
int __cdecl sub_100072D0(int a1, char *a2); // idb
int __cdecl sub_100074F0(int a1, int a2);
int __cdecl sub_100075F0(int a1, int a2);
// int __usercall sub_10007690<eax>(int a1<ebx>, int a2<edi>, int a3<esi>, int a4, int a5, int a6);
// int __stdcall CIasin(_DWORD, _DWORD, _DWORD); weak
// double __cdecl floor(double); idb
// _DWORD _ftol2_sse(); weak
int __cdecl sub_10007D6B();
int (*__cdecl sub_10007E2E())(void);
int (*__cdecl sub_10007E52())(void); // idb
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved); // idb
// _DWORD unknown_libname_1(); weak
int __cdecl sub_100081C4();
// int __cdecl _clean_type_info_names_internal(_DWORD); weak
// BOOL __stdcall DisableThreadLibraryCalls(HMODULE hLibModule); idb
// double __cdecl ceil(double); idb
// void __cdecl qsort(void *, size_t, size_t, int (__cdecl *)(const void *, const void *)); idb
// int __cdecl atoi(const char *); idb
// void *__cdecl malloc(size_t); idb
// double __cdecl strtod(const char *, char **); idb
// void __cdecl free(void *); idb
// int sprintf(char *, const char *, ...); idb
// int printf(const char *, ...); idb
// char *__cdecl strstr(const char *, const char *); idb
// int __cdecl UF_VEC3_cross(_DWORD, _DWORD); weak
// int __cdecl UF_get_fail_message(_DWORD, _DWORD); weak
// int __cdecl UF_MTX3_rotate_about_axis(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_edit_rotation(_DWORD, _DWORD); weak
// int __cdecl UF_VEC3_scale(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_is_parallel(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_z_vec(_DWORD, _DWORD); weak
// int __cdecl UF_VEC3_distance(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_vec_multiply_t(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall UF_VEC3_is_zero(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_affine_comb(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_is_equal(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_allocate_memory(_DWORD, _DWORD); weak
// int __cdecl UF_free(_DWORD); weak
// int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_dot(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_copy(_DWORD, _DWORD); weak
// int __cdecl UF_VEC3_angle_between(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_vec3_multiply_t(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_add(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_rotation(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_ask_rotation(_DWORD, _DWORD); weak
// int __cdecl UF_MTX3_vec_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_vec3_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_vec_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_copy(_DWORD, _DWORD); weak
// int __cdecl UF_MTX3_x_vec(_DWORD, _DWORD); weak
// int __cdecl UF_MTX3_y_vec(_DWORD, _DWORD); weak
// int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MOM_ask_interp_from_param(_DWORD, _DWORD); weak
// int __cdecl UF_MOM_ask_mom(_DWORD, _DWORD); weak
// int __cdecl UF_MOM_extend_xlator(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_OBJ_cycle_by_name(_DWORD, _DWORD); weak
// int __cdecl UF_ATTR_read_value(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MOM_set_string(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MOM_set_double(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int UF_terminate(void); weak
// int __cdecl UF_MISC_set_program_name(_DWORD); weak
// int UF_initialize(void); weak
// int __cdecl UF_MTX4_csys_to_csys(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl uc1601(_DWORD, _DWORD); weak


//----- (10001010) --------------------------------------------------------
int __usercall sub_10001010<eax>(int a1<eax>, int a2<edx>, int a3<ecx>, int a4<esi>)
{
  char v5; // [sp+0h] [bp-88h]@2

  if ( a4 )
  {
    printf("%s, line %d:  %s\n", a2, a3, a1);
    if ( UF_get_fail_message(a4, &v5) )
    {
      printf("    returned a %d\n", a4);
      return a4;
    }
    printf("    returned error %d:  %s\n", a4, &v5);
  }
  return a4;
}

//----- (10001070) --------------------------------------------------------
signed int __cdecl sub_10001070(char *a1)
{
  signed int result; // eax@2

  UF_MISC_set_program_name("<!<UGPKIN>!>");
  if ( UF_initialize() )
  {
    sprintf(a1, "ERROR!: Advanced Kinematics Module Unavailable");
    result = 1;
  }
  else
  {
    UF_MISC_set_program_name("Kinematics");
    result = 0;
  }
  return result;
}

//----- (100010D0) --------------------------------------------------------
signed int __usercall sub_100010D0<eax>(int a1<edi>, int a2, int a3, int a4, int a5)
{
  int v5; // esi@1
  signed int result; // eax@4
  int v7; // ebx@5
  char v8; // zf@7
  signed int v9; // ecx@7
  int v10; // esi@7
  char v11; // zf@13
  signed int v12; // ecx@13
  int v13; // esi@13
  char v14; // zf@19
  signed int v15; // ecx@19
  int v16; // esi@19
  int v17; // ebx@28
  int v18; // edi@28
  int v19; // edi@30
  void *v20; // eax@1
  int v23; // eax@28
  int v24; // eax@30
  __int64 v25; // [sp+0h] [bp-38h]@1
  int v31; // [sp+30h] [bp-8h]@1
  int v32; // [sp+34h] [bp-4h]@6

  __asm
  {
    fldz
    fst     [ebp+var_38]
    fst     [ebp+var_30]
    fst     [ebp+var_28]
    fst     [ebp+var_20]
    fst     [ebp+var_18]
    fstp    [ebp+var_10]
  }
  v20 = malloc(0x90u);
  v5 = (int)v20;
  v31 = (int)v20;
  if ( a4 > 7 || a4 == 1 )
  {
    printf(" Incorrect number of arguments\n");
    printf(" Number of arguments should be between 1 and 6\n ");
    result = 999;
  }
  else
  {
    if ( !(a4 % 2) )
    {
      printf(" Insufficient number of arguments, There should be               atleast 2 arguments\n ");
      return 999;
    }
    v7 = 1;
    if ( a4 > 1 )
    {
      v32 = (int)&v25;
      while ( 1 )
      {
        a1 = (int)"AAXIS";
        v10 = *(_DWORD *)(a5 + 4 * v7);
        v9 = 6;
        v8 = 1;
        do
        {
          if ( !v9 )
            break;
          v8 = *(_BYTE *)v10++ == *(_BYTE *)a1++;
          --v9;
        }
        while ( v8 );
        if ( v8 )
        {
          __asm { fld1 }
        }
        else
        {
          a1 = (int)"BAXIS";
          v13 = *(_DWORD *)(a5 + 4 * v7);
          v12 = 6;
          v11 = 1;
          do
          {
            if ( !v12 )
              break;
            v11 = *(_BYTE *)v13++ == *(_BYTE *)a1++;
            --v12;
          }
          while ( v11 );
          if ( v11 )
          {
            __asm { fld     ds:dbl_10009308 }
          }
          else
          {
            a1 = (int)"CAXIS";
            v16 = *(_DWORD *)(a5 + 4 * v7);
            v15 = 6;
            v14 = 1;
            do
            {
              if ( !v15 )
                break;
              v14 = *(_BYTE *)v16++ == *(_BYTE *)a1++;
              --v15;
            }
            while ( v14 );
            if ( !v14 )
              goto LABEL_26;
            __asm { fld     ds:dbl_100092F8 }
          }
        }
        _EAX = v32;
        __asm { fstp    qword ptr [eax] }
LABEL_26:
        strtod(*(const char **)(a5 + 4 * v7 + 4), 0);
        _EAX = v32;
        __asm { fstp    qword ptr [eax+8] }
        v7 += 2;
        v32 = _EAX + 16;
        if ( v7 >= a4 )
        {
          v5 = v31;
          break;
        }
      }
    }
    v17 = a2;
    v23 = sub_10007690(a2, a1, v5, a2, v5, (int)&v25);
    v18 = v23;
    if ( v23 )
    {
      printf(" SET_rotd_mcs_matrix failed in mom_rotate_mach_csys \n ");
      result = v18;
    }
    else
    {
      v24 = sub_100072D0(v17, (char *)v5);
      v19 = v24;
      if ( v24 )
      {
        printf(" SET_rotd_operation_data failed in mom_rotate_mach_csys \n ");
        result = v19;
      }
      else
      {
        if ( v5 )
          free((void *)v5);
        result = 0;
      }
    }
  }
  return result;
}

//----- (10001260) --------------------------------------------------------
int __cdecl sub_10001260(int a1)
{
  int v1; // edi@1
  int v2; // esi@1
  int result; // eax@2
  int v4; // edi@3
  int v5; // edi@5
  int v6; // eax@1
  int v7; // eax@3
  int v8; // eax@5
  __int64 v9; // ST08_8@7
  __int64 v10; // ST08_8@7
  __int64 v11; // ST08_8@7
  char v12; // [sp+40h] [bp-60h]@1
  char v13; // [sp+10h] [bp-90h]@3
  __int64 v14; // [sp+70h] [bp-30h]@5

  v2 = a1;
  v6 = sub_10007150(a1, (int)&v12);
  v1 = v6;
  if ( v6 )
  {
    printf(" SET_input_point failed in mom_map_to_rotated_csys\n ");
    result = v1;
  }
  else
  {
    v7 = sub_100075F0((int)&v12, (int)&v13);
    v4 = v7;
    if ( v7 )
    {
      printf(" mom_process_input_gotos failed in mom_map_to_rotated_csys\n ");
      result = v4;
    }
    else
    {
      v8 = sub_100074F0((int)&v13, (int)&v14);
      v5 = v8;
      if ( v8 )
      {
        printf(" mom_transfer_gotos_rotd_mcsys failed in mom_map_to_rotated_csys\n ");
        result = v5;
      }
      else
      {
        __asm
        {
          fld     [ebp+var_30]
          fstp    [esp+0A0h+var_A0]
        }
        UF_MOM_set_double(v2, "pos_x", v9, *((_DWORD *)&v9 + 1));
        __asm
        {
          fld     [ebp+var_28]
          fstp    [esp+0A0h+var_A0]
        }
        UF_MOM_set_double(v2, "pos_y", v10, *((_DWORD *)&v10 + 1));
        __asm
        {
          fld     [ebp+var_20]
          fstp    [esp+0A0h+var_A0]
        }
        UF_MOM_set_double(v2, "pos_z", v11, *((_DWORD *)&v11 + 1));
        result = 0;
      }
    }
  }
  return result;
}

//----- (10001340) --------------------------------------------------------
int __cdecl sub_10001340(char *a1)
{
  void *v1; // eax@1
  void *v3; // edi@1
  int v4; // esi@1
  void *v7; // eax@1
  void *v8; // eax@1
  void *v9; // eax@1
  void *v10; // eax@1
  int v11; // eax@1
  void *v12; // eax@1
  void *v13; // eax@1
  void *v14; // eax@1
  void *v15; // eax@1
  char *v16; // eax@3
  void *v17; // ecx@3
  void *v18; // edx@3
  void *v19; // eax@3
  void *v20; // ecx@3
  char *v21; // eax@3
  void *v22; // ecx@3
  int v24; // edx@21
  int v25; // edx@21
  int v26; // eax@21
  int v27; // ecx@21
  int v28; // eax@21
  int v29; // ecx@21
  char *v32; // [sp+344h] [bp-24h]@1
  void *v33; // [sp+360h] [bp-8h]@1
  void *v34; // [sp+334h] [bp-34h]@1
  void *v35; // [sp+33Ch] [bp-2Ch]@1
  void *v36; // [sp+364h] [bp-4h]@1
  void *v37; // [sp+338h] [bp-30h]@1
  void *v38; // [sp+340h] [bp-28h]@1
  __int64 v39; // [sp+ECh] [bp-27Ch]@3
  __int64 v40; // [sp+Ch] [bp-35Ch]@3
  __int64 v41; // [sp+274h] [bp-F4h]@3
  __int64 v42; // [sp+F4h] [bp-274h]@3
  __int64 v43; // [sp+27Ch] [bp-ECh]@3
  __int64 v44; // [sp+24h] [bp-344h]@3
  int v45; // [sp+100h] [bp-268h]@3
  int v46; // [sp+288h] [bp-E0h]@3
  __int64 v47; // [sp+104h] [bp-264h]@3
  __int64 v48; // [sp+28Ch] [bp-DCh]@3
  __int64 v49; // [sp+3Ch] [bp-32Ch]@3
  __int64 v50; // [sp+10Ch] [bp-25Ch]@3
  __int64 v51; // [sp+294h] [bp-D4h]@3
  __int64 v53; // [sp+11Ch] [bp-24Ch]@3
  __int64 v54; // [sp+2A4h] [bp-C4h]@3
  __int64 v57; // [sp+FCh] [bp-26Ch]@3
  int v59; // [sp+284h] [bp-E4h]@3
  __int64 v61; // [sp+114h] [bp-254h]@3
  __int64 v62; // [sp+29Ch] [bp-CCh]@3
  __int64 v64; // [sp+124h] [bp-244h]@3
  __int64 v65; // [sp+2ACh] [bp-BCh]@3
  __int64 v66; // [sp+134h] [bp-234h]@3
  __int64 v67; // [sp+2BCh] [bp-ACh]@3
  __int64 v68; // [sp+12Ch] [bp-23Ch]@3
  __int64 v69; // [sp+2B4h] [bp-B4h]@3
  __int64 v70; // [sp+13Ch] [bp-22Ch]@3
  __int64 v71; // [sp+2C4h] [bp-A4h]@3
  int v72; // [sp+14Ch] [bp-21Ch]@3
  int v73; // [sp+2D4h] [bp-94h]@3
  __int64 v74; // [sp+144h] [bp-224h]@3
  __int64 v75; // [sp+2CCh] [bp-9Ch]@3
  int v76; // [sp+158h] [bp-210h]@3
  int v77; // [sp+2E0h] [bp-88h]@3
  int v78; // [sp+150h] [bp-218h]@3
  int v79; // [sp+2D8h] [bp-90h]@3
  int v80; // [sp+154h] [bp-214h]@3
  int v81; // [sp+2DCh] [bp-8Ch]@3
  int v82; // [sp+164h] [bp-204h]@3
  int v83; // [sp+2ECh] [bp-7Ch]@3
  int v84; // [sp+15Ch] [bp-20Ch]@3
  int v85; // [sp+2E4h] [bp-84h]@3
  int v86; // [sp+160h] [bp-208h]@3
  int v87; // [sp+2E8h] [bp-80h]@3
  int v88; // [sp+170h] [bp-1F8h]@3
  int v89; // [sp+2F8h] [bp-70h]@3
  int v90; // [sp+168h] [bp-200h]@3
  int v91; // [sp+2F0h] [bp-78h]@3
  int v92; // [sp+16Ch] [bp-1FCh]@3
  int v93; // [sp+2F4h] [bp-74h]@3
  int v94; // [sp+17Ch] [bp-1ECh]@3
  int v95; // [sp+304h] [bp-64h]@3
  int v96; // [sp+174h] [bp-1F4h]@3
  int v97; // [sp+2FCh] [bp-6Ch]@3
  int v98; // [sp+178h] [bp-1F0h]@3
  int v99; // [sp+300h] [bp-68h]@3
  int v100; // [sp+188h] [bp-1E0h]@3
  int v101; // [sp+310h] [bp-58h]@3
  int v102; // [sp+180h] [bp-1E8h]@3
  int v103; // [sp+308h] [bp-60h]@3
  int v104; // [sp+184h] [bp-1E4h]@3
  int v105; // [sp+30Ch] [bp-5Ch]@3
  int v106; // [sp+194h] [bp-1D4h]@3
  int v107; // [sp+31Ch] [bp-4Ch]@3
  int v108; // [sp+18Ch] [bp-1DCh]@3
  int v109; // [sp+314h] [bp-54h]@3
  int v110; // [sp+190h] [bp-1D8h]@3
  int v111; // [sp+318h] [bp-50h]@3
  int v112; // [sp+1A0h] [bp-1C8h]@3
  int v113; // [sp+328h] [bp-40h]@3
  int v114; // [sp+198h] [bp-1D0h]@3
  int v115; // [sp+320h] [bp-48h]@3
  int v116; // [sp+19Ch] [bp-1CCh]@3
  int v117; // [sp+324h] [bp-44h]@3
  int v118; // [sp+1A4h] [bp-1C4h]@3
  int v119; // [sp+32Ch] [bp-3Ch]@3
  int v120; // [sp+1A8h] [bp-1C0h]@3
  int v121; // [sp+330h] [bp-38h]@3
  __int64 v122; // [sp+348h] [bp-20h]@4
  signed int v125; // [sp+54h] [bp-314h]@16
  int v127; // [sp+1ACh] [bp-1BCh]@21
  int v128; // [sp+64h] [bp-304h]@21
  int v129; // [sp+1B8h] [bp-1B0h]@21
  int v130; // [sp+70h] [bp-2F8h]@21
  int v131; // [sp+1B0h] [bp-1B8h]@21
  int v132; // [sp+68h] [bp-300h]@21
  int v133; // [sp+1B4h] [bp-1B4h]@21
  int v134; // [sp+6Ch] [bp-2FCh]@21
  int v135; // [sp+1C4h] [bp-1A4h]@21
  int v136; // [sp+7Ch] [bp-2ECh]@21
  int v137; // [sp+1BCh] [bp-1ACh]@21
  int v138; // [sp+74h] [bp-2F4h]@21
  int v139; // [sp+1C0h] [bp-1A8h]@21
  int v140; // [sp+78h] [bp-2F0h]@21
  int v141; // [sp+1D0h] [bp-198h]@21
  int v142; // [sp+88h] [bp-2E0h]@21
  int v143; // [sp+1C8h] [bp-1A0h]@21
  int v144; // [sp+80h] [bp-2E8h]@21
  int v145; // [sp+1CCh] [bp-19Ch]@21
  int v146; // [sp+84h] [bp-2E4h]@21
  int v147; // [sp+94h] [bp-2D4h]@21
  int v148; // [sp+1D4h] [bp-194h]@21
  int v149; // [sp+8Ch] [bp-2DCh]@21
  int v150; // [sp+1D8h] [bp-190h]@21
  int v151; // [sp+90h] [bp-2D8h]@21
  int v152; // [sp+A0h] [bp-2C8h]@21
  int v153; // [sp+98h] [bp-2D0h]@21
  int v154; // [sp+9Ch] [bp-2CCh]@21
  int v155; // [sp+A4h] [bp-2C4h]@21
  int v156; // [sp+A8h] [bp-2C0h]@21
  char v159; // [sp+ACh] [bp-2BCh]@21

  v7 = malloc(0x358u);
  v4 = (int)a1;
  v32 = (char *)v7;
  sub_10006660((int)a1, (int)v7);
  v8 = malloc(0x228u);
  v33 = v8;
  sub_10005410(v4, (int)v8);
  v9 = malloc(0x120u);
  v34 = v9;
  sub_100055C0(v4, (int)v9);
  v10 = malloc(0x40u);
  v35 = v10;
  sub_10005700(v4, (int)v10);
  v11 = (int)malloc(0x1F0u);
  _EBX = v11;
  sub_100058D0(v4, v11);
  v12 = malloc(0x1F0u);
  v36 = v12;
  sub_10005C10(v4, (int)v12);
  v13 = malloc(0x98u);
  v37 = v13;
  sub_10005F50(v4, (int)v13);
  v14 = malloc(0x3B0u);
  a1 = (char *)v14;
  sub_10006150(v4, (int)v14);
  v15 = malloc(0x18u);
  v38 = v15;
  sub_10006060(v4, (int)v15);
  v1 = malloc(0x24u);
  v3 = v1;
  if ( !v1 )
    return (int)((char *)v1 + 1);
  v16 = v32;
  v17 = v33;
  *((_DWORD *)v3 + 2) = v34;
  v18 = v37;
  *(_DWORD *)v3 = v16;
  v19 = v35;
  *((_DWORD *)v3 + 1) = v17;
  v20 = v36;
  *((_DWORD *)v3 + 6) = v18;
  *((_DWORD *)v3 + 3) = v19;
  v21 = a1;
  *((_DWORD *)v3 + 5) = v20;
  v22 = v38;
  *((_DWORD *)v3 + 4) = _EBX;
  *((_DWORD *)v3 + 7) = v21;
  *((_DWORD *)v3 + 8) = v22;
  sub_10006A10(v4, (int)&v39);
  sub_10006C90(v4, (int)&v39);
  sub_10006F30(v4, (int)&v39);
  __asm
  {
    fld     [ebp+var_27C]
    fadd    qword ptr [ebx+1B0h]
  }
  _EAX = v36;
  _ESI = v32;
  __asm
  {
    fst     [ebp+var_35C]
    fld     qword ptr [eax+1B0h]
  }
  v41 = v39;
  __asm { fadd    st, st(1) }
  v43 = v42;
  __asm
  {
    fstp    [ebp+var_344]
    fadd    qword ptr [esi+340h]
  }
  v46 = v45;
  v48 = v47;
  __asm
  {
    fstp    [ebp+var_32C]
    fld     qword ptr [ebx+1B8h]
  }
  v51 = v50;
  __asm
  {
    fadd    [ebp+var_274]
    fst     [ebp+var_354]
    fld     qword ptr [eax+1B8h]
  }
  v54 = v53;
  __asm
  {
    fadd    st, st(1)
    fstp    [ebp+var_33C]
    fadd    qword ptr [esi+348h]
    fstp    [ebp+var_324]
    fld     qword ptr [ebx+1C0h]
    fadd    qword ptr [ebp-26Ch]
    fst     [ebp+var_34C]
    fld     qword ptr [eax+1C0h]
    fadd    st, st(1)
  }
  v59 = v57;
  __asm
  {
    fstp    [ebp+var_334]
    fadd    qword ptr [esi+350h]
  }
  v62 = v61;
  __asm { fstp    [ebp+var_31C] }
  v65 = v64;
  v67 = v66;
  v69 = v68;
  v71 = v70;
  v73 = v72;
  v75 = v74;
  v77 = v76;
  v79 = v78;
  v81 = v80;
  v83 = v82;
  v85 = v84;
  v87 = v86;
  v89 = v88;
  v91 = v90;
  v93 = v92;
  v95 = v94;
  v97 = v96;
  v99 = v98;
  v101 = v100;
  v103 = v102;
  v105 = v104;
  v107 = v106;
  v109 = v108;
  v111 = v110;
  v113 = v112;
  v115 = v114;
  v117 = v116;
  v119 = v118;
  v121 = v120;
  if ( strstr(a1, "POSX") )
  {
    __asm
    {
      fld     [ebp+var_264]
      fstp    [ebp+var_20]
      fld     [ebp+var_25C]
      fstp    [ebp+var_18]
      fld     [ebp+var_254]
    }
  }
  else
  {
    if ( !strstr(a1, "POSY") )
    {
      if ( !strstr(a1, "POSZ") )
      {
        if ( strstr(a1, "NEGX") )
        {
          __asm
          {
            fld     [ebp+var_264]
            fchs
            fstp    [ebp+var_20]
            fld     [ebp+var_25C]
            fchs
            fstp    [ebp+var_18]
            fld     [ebp+var_254]
            fchs
          }
          goto LABEL_15;
        }
        if ( strstr(a1, "NEGY") )
        {
          __asm
          {
            fld     [ebp+var_24C]
            fchs
            fstp    [ebp+var_20]
            fld     [ebp+var_244]
            fchs
            fstp    [ebp+var_18]
            fld     [ebp+var_23C]
            fchs
          }
          goto LABEL_15;
        }
        if ( strstr(a1, "NEGZ") )
        {
          __asm
          {
            fld     [ebp+var_234]
            fchs
            fstp    [ebp+var_20]
            fld     [ebp+var_22C]
            fchs
            fstp    [ebp+var_18]
            fld     [ebp+var_224]
            fchs
          }
          goto LABEL_15;
        }
      }
      __asm
      {
        fld     [ebp+var_234]
        fstp    [ebp+var_20]
        fld     [ebp+var_22C]
        fstp    [ebp+var_18]
        fld     [ebp+var_224]
      }
      goto LABEL_15;
    }
    __asm
    {
      fld     [ebp+var_24C]
      fstp    [ebp+var_20]
      fld     [ebp+var_244]
      fstp    [ebp+var_18]
      fld     [ebp+var_23C]
    }
  }
LABEL_15:
  __asm { fstp    [ebp+var_10] }
  if ( strstr(_ESI, "5_axis_dual_table") )
  {
    v125 = 2;
  }
  else
  {
    if ( strstr(_ESI, "5_axis_dual_head") )
    {
      v125 = 1;
    }
    else
    {
      if ( strstr(_ESI, "5_axis_head_table") )
        v125 = 3;
    }
  }
  __asm
  {
    fld     qword ptr [esi+320h]
    fstp    [ebp+var_30C]
  }
  v128 = v127;
  v130 = v129;
  v132 = v131;
  v134 = v133;
  v136 = v135;
  v138 = v137;
  v140 = v139;
  v142 = v141;
  v24 = *(_DWORD *)(_EBX + 432);
  v144 = v143;
  v146 = v145;
  v147 = v24;
  v25 = *(_DWORD *)(_EBX + 444);
  v149 = v148;
  v26 = *(_DWORD *)(_EBX + 436);
  v151 = v150;
  v27 = *(_DWORD *)(_EBX + 440);
  v152 = v25;
  v153 = v26;
  v28 = *(_DWORD *)(_EBX + 448);
  v154 = v27;
  v29 = *(_DWORD *)(_EBX + 452);
  v155 = v28;
  v156 = v29;
  __asm
  {
    fld     [ebp+var_FC]
    fstp    [ebp+var_2B4]
  }
  v159 = atoi(_ESI + 133) == 1;
  __asm { fld     qword ptr [ebx+198h] }
  _EAX = v36;
  __asm
  {
    fstp    [ebp+var_2AC]
    fld     qword ptr [ebx+1A0h]
    fstp    [ebp+var_2A4]
    fld     qword ptr [eax+198h]
    fstp    [ebp+var_29C]
    fld     qword ptr [eax+1A0h]
    fstp    [ebp+var_294]
    fld     [ebp+var_104]
    fstp    [ebp+var_28C]
  }
  if ( strstr(_ESI, "5_axis_dual_table") )
  {
    __asm { fldz }
  }
  else
  {
    _ECX = v33;
    __asm { fld     qword ptr [ecx+218h] }
  }
  __asm { fstp    [ebp+var_284] }
  sub_100041A0(
    (int)&v73,
    &v41,
    (int)&v40,
    _EBX + 456,
    (int)&v44,
    (int)((char *)v36 + 456),
    (int)&v49,
    (int)&v122,
    &v125);
  free(v3);
  free(_ESI);
  if ( v33 )
    free(v33);
  if ( v34 )
    free(v34);
  if ( v35 )
    free(v35);
  free((void *)_EBX);
  free(v36);
  if ( v37 )
    free(v37);
  if ( a1 )
    free(a1);
  if ( v38 )
    free(v38);
  return 0;
}

//----- (10001AB0) --------------------------------------------------------
int __cdecl sub_10001AB0(int a1)
{
  int v2; // esi@1
  __int64 v3; // ST18_8@1
  __int64 v4; // ST18_8@1
  __int64 v5; // ST18_8@1
  __int64 v6; // ST18_8@1
  __int64 v7; // ST18_8@1
  __int64 v8; // ST18_8@1
  __int64 v9; // ST18_8@1
  __int64 v10; // ST18_8@1
  __int64 v11; // ST18_8@1
  __int64 v12; // ST18_8@1
  char v13; // [sp+10h] [bp-208h]@1
  char v14; // [sp+198h] [bp-80h]@1
  __int64 v15; // [sp+1C8h] [bp-50h]@1
  __int64 v16; // [sp+1F0h] [bp-28h]@1

  v2 = a1;
  sub_10006F30(a1, (int)&v13);
  sub_100026E0((int)&v13);
  sub_10007150(v2, (int)&v14);
  sub_10004F70(&v14, &v15, &v16);
  __asm
  {
    fld     [ebp+var_50]
    fstp    [esp+230h+var_218]
  }
  UF_MOM_set_double(v2, "pos_x", v3, *((_DWORD *)&v3 + 1));
  __asm
  {
    fld     [ebp+var_48]
    fstp    [esp+218h+var_218]
  }
  UF_MOM_set_double(v2, "pos_y", v4, *((_DWORD *)&v4 + 1));
  __asm
  {
    fld     [ebp+var_40]
    fstp    [esp+218h+var_218]
  }
  UF_MOM_set_double(v2, "pos_z", v5, *((_DWORD *)&v5 + 1));
  __asm
  {
    fld     [ebp+var_38]
    fstp    [esp+218h+var_218]
  }
  UF_MOM_set_double(v2, "pos_a1", v6, *((_DWORD *)&v6 + 1));
  __asm
  {
    fld     [ebp+var_30]
    fstp    [esp+218h+var_218]
  }
  UF_MOM_set_double(v2, "pos_a2", v7, *((_DWORD *)&v7 + 1));
  __asm
  {
    fld     [ebp+var_28]
    fstp    [esp+218h+var_218]
  }
  UF_MOM_set_double(v2, "alt_pos_x", v8, *((_DWORD *)&v8 + 1));
  __asm
  {
    fld     [ebp+var_20]
    fstp    [esp+218h+var_218]
  }
  UF_MOM_set_double(v2, "alt_pos_y", v9, *((_DWORD *)&v9 + 1));
  __asm
  {
    fld     [ebp+var_18]
    fstp    [esp+218h+var_218]
  }
  UF_MOM_set_double(v2, "alt_pos_z", v10, *((_DWORD *)&v10 + 1));
  __asm
  {
    fld     [ebp+var_10]
    fstp    [esp+218h+var_218]
  }
  UF_MOM_set_double(v2, "alt_pos_a1", v11, *((_DWORD *)&v11 + 1));
  __asm
  {
    fld     [ebp+var_8]
    fstp    [esp+218h+var_218]
  }
  UF_MOM_set_double(v2, "alt_pos_a2", v12, *((_DWORD *)&v12 + 1));
  return 0;
}

//----- (10001BB0) --------------------------------------------------------
signed int __cdecl sub_10001BB0(int a1, int a2, int a3, int a4)
{
  int v5; // esi@4
  int v6; // eax@6
  _BYTE *v7; // edx@6
  int v8; // eax@8
  _BYTE *v9; // edx@8
  int v10; // eax@16
  int v11; // eax@19
  char v12; // cl@7
  char v13; // cl@9
  char v14; // cl@17
  char v15; // cl@20
  int v16; // [sp+3D4h] [bp-BCh]@1
  int v17; // [sp+3D8h] [bp-B8h]@1
  int v18; // [sp+3DCh] [bp-B4h]@1
  int v19; // [sp+3E0h] [bp-B0h]@1
  int v20; // [sp+3E4h] [bp-ACh]@1
  int v21; // [sp+48Ch] [bp-4h]@1
  _BYTE v22[136]; // [sp+208h] [bp-288h]@1
  int v23; // [sp+290h] [bp-200h]@1
  int v24; // [sp+294h] [bp-1FCh]@1
  __int16 v25; // [sp+298h] [bp-1F8h]@1
  char v26; // [sp+8h] [bp-488h]@2
  __int16 v27; // [sp+28h] [bp-468h]@5
  _BYTE v28[32]; // [sp+45Ch] [bp-34h]@6
  _BYTE v29[52]; // [sp+3A0h] [bp-F0h]@8
  _BYTE v30[136]; // [sp+318h] [bp-178h]@13
  int v31; // [sp+484h] [bp-Ch]@13
  signed int v32; // [sp+47Ch] [bp-14h]@13

  v16 = dword_100095E0;
  v17 = dword_100095E4;
  v18 = dword_100095E8;
  v19 = dword_100095EC;
  v20 = dword_100095F0;
  v21 = 0;
  *(_DWORD *)&v22[0] = 2105376;
  v23 = dword_100095D4;
  v24 = dword_100095D8;
  v25 = word_100095DC;
  if ( a3 != 2 )
  {
    memcpy(&v26, "Invalid number of arguments", 0x1Cu);
LABEL_3:
    printf(" ERROR : %s \n ", &v26);
    return 1;
  }
  v5 = a1;
  if ( UF_MOM_ask_string(a1, &v23, &a3) )
  {
    memcpy(&v26, "No Tool Name obtained from UGPost", 0x20u);
    v27 = *(_WORD *)&aNoToolNameObta[32];
    goto LABEL_3;
  }
  v6 = a3;
  v7 = &v28[-a3];
  do
  {
    v12 = *(_BYTE *)v6;
    v7[v6] = *(_BYTE *)v6;
    ++v6;
  }
  while ( v12 );
  v8 = *(_DWORD *)(a4 + 4);
  v9 = &v29[-v8];
  do
  {
    v13 = *(_BYTE *)v8;
    v9[v8] = *(_BYTE *)v8;
    ++v8;
  }
  while ( v13 );
  if ( UF_OBJ_cycle_by_name(v28, &v21) )
  {
    printf(" UF_OBJ_cycle_by_name could not get the tool_object_tag \n");
    return 1;
  }
  if ( v21 )
  {
    v31 = (int)v30;
    if ( UF_ATTR_read_value(v21, v29, 5, &v32) )
    {
      printf(" UF_ATTR_read_value could not return tool string \n");
      return 1;
    }
    if ( v32 != 5 )
    {
      v10 = 0;
      do
      {
        v14 = v22[v10];
        v30[v10] = v22[v10];
        ++v10;
      }
      while ( v14 );
    }
  }
  else
  {
    v11 = 0;
    do
    {
      v15 = v22[v11];
      v30[v11] = v22[v11];
      ++v11;
    }
    while ( v15 );
  }
  UF_MOM_set_string(v5, &v16, v30);
  return 0;
}

//----- (10001DB0) --------------------------------------------------------
int __cdecl ufusr(int a1, int a2)
{
  int result; // eax@2
  int v3; // esi@3
  int v4; // eax@3
  int v5; // eax@3
  int v6; // eax@3
  int v7; // eax@3
  int v8; // eax@3
  int v9; // eax@3
  int v10; // [sp+84h] [bp-8h]@1
  char v11; // [sp+0h] [bp-8Ch]@1
  int v12; // [sp+88h] [bp-4h]@3

  v10 = 0;
  if ( sub_10001070(&v11) )
  {
    printf("ERROR : Ugpost Advanced Kinematics license not found \n");
    uc1601(&v11, 1);
    result = UF_terminate();
  }
  else
  {
    v3 = a1;
    UF_MOM_ask_interp_from_param(a1, &v10);
    UF_MOM_ask_mom(v3, &v12);
    v4 = UF_MOM_extend_xlator(v12, "MOM_load_kinematics", sub_10001340);
    sub_10001010(
      (int)"UF_MOM_extend_xlator ( mom, \"MOM_load_kinematics\", mom_load_kinematics )",
      (int)"O:\\ugnx60\\ip24\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      113,
      v4);
    v5 = UF_MOM_extend_xlator(v12, "MOM_convert_point", sub_10001AB0);
    sub_10001010(
      (int)"UF_MOM_extend_xlator ( mom, \"MOM_convert_point\", mom_convert_point )",
      (int)"O:\\ugnx60\\ip24\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      123,
      v5);
    v6 = UF_MOM_extend_xlator(v12, "MOM_get_tool_attribute", sub_10001BB0);
    sub_10001010(
      (int)"UF_MOM_extend_xlator ( mom , \"MOM_get_tool_attribute\", mom_get_tool_attribute )",
      (int)"O:\\ugnx60\\ip24\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      133,
      v6);
    v7 = UF_MOM_extend_xlator(v12, "MOM_rotate_mach_csys", sub_100010D0);
    sub_10001010(
      (int)"UF_MOM_extend_xlator ( mom, \"MOM_rotate_mach_csys\", mom_rotate_mach_csys )",
      (int)"O:\\ugnx60\\ip24\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      143,
      v7);
    v8 = UF_MOM_extend_xlator(v12, "MOM_map_to_rotated_csys", sub_10001260);
    sub_10001010(
      (int)"UF_MOM_extend_xlator ( mom, \"MOM_map_to_rotated_csys\", mom_map_to_rotated_csys )",
      (int)"O:\\ugnx60\\ip24\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      153,
      v8);
    v9 = UF_MOM_extend_xlator(v12, "MOM_exit_kinematics_module", UF_terminate);
    result = sub_10001010(
               (int)"UF_MOM_extend_xlator ( mom, \"MOM_exit_kinematics_module\", mom_exit_kinematics_module )",
               (int)"O:\\ugnx60\\ip24\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
               163,
               v9);
    dword_1000C240 = v12;
    *(_DWORD *)a2 = 0;
  }
  return result;
}

//----- (10001F20) --------------------------------------------------------
int __usercall sub_10001F20<eax>(int a1<eax>, int a2<ecx>, int a3<esi>, char a4)
{
  int v5; // ST10_4@1
  char *v6; // ST0C_4@1
  __int64 v7; // ST04_8@1

  UF_VEC3_cross(a2, a1);
  __asm { fld     ds:dbl_100099C0 }
  v5 = a3;
  v6 = &a4;
  __asm { fstp    [esp+10h+var_10] }
  return UF_VEC3_unitize(a3, v7, *((_DWORD *)&v7 + 1), v6, v5);
}

//----- (10001FA0) --------------------------------------------------------
int __usercall sub_10001FA0<eax>(int result<eax>, int _ECX<ecx>, double a3)
{
  __asm
  {
    fld     [ebp+arg_0]
    fld     st
    fcos
    fxch    st(1)
    fsin
    fld     qword ptr [eax]
    fmul    st, st
    fld     qword ptr [eax+8]
    fmul    st, st
    fld     qword ptr [eax+10h]
    fmul    st, st
    fstp    [ebp+var_8]
    fld1
    fld     st
    fsub    st, st(5)
    fld     st(1)
    fsub    st, st(4)
    fmul    st, st(6)
    faddp   st(4), st
    fxch    st(3)
    fstp    qword ptr [ecx]
    fld     qword ptr [eax+8]
    fmul    qword ptr [eax]
    fmul    st, st(3)
    fld     qword ptr [eax+10h]
    fmul    st, st(5)
    faddp   st(1), st
    fstp    qword ptr [ecx+8]
    fld     qword ptr [eax+10h]
    fmul    qword ptr [eax]
    fmul    st, st(3)
    fld     qword ptr [eax+8]
    fmul    st, st(5)
    fsubp   st(1), st
    fstp    qword ptr [ecx+10h]
    fldz
    fst     qword ptr [ecx+18h]
    fld     qword ptr [eax+8]
    fmul    qword ptr [eax]
    fmul    st, st(4)
    fld     qword ptr [eax+10h]
    fmul    st, st(6)
    fsubp   st(1), st
    fstp    qword ptr [ecx+20h]
    fld     st(1)
    fsub    st, st(3)
    fmul    st, st(6)
    faddp   st(3), st
    fxch    st(2)
    fstp    qword ptr [ecx+28h]
    fld     qword ptr [eax+10h]
    fmul    qword ptr [eax+8]
    fmul    st, st(3)
    fld     qword ptr [eax]
    fmul    st, st(5)
    faddp   st(1), st
    fstp    qword ptr [ecx+30h]
    fxch    st(1)
    fst     qword ptr [ecx+38h]
    fld     qword ptr [eax+10h]
    fmul    qword ptr [eax]
    fmul    st, st(3)
    fld     qword ptr [eax+8]
    fmul    st, st(5)
    faddp   st(1), st
    fstp    qword ptr [ecx+40h]
    fld     qword ptr [eax+10h]
    fmul    qword ptr [eax+8]
    fmulp   st(3), st
    fld     qword ptr [eax]
    fmulp   st(4), st
    fxch    st(2)
    fsubrp  st(3), st
    fxch    st(2)
    fstp    qword ptr [ecx+48h]
    fld     st(1)
    fld     [ebp+var_8]
    fsub    st(1), st
    fxch    st(1)
    fmulp   st(4), st
    faddp   st(3), st
    fxch    st(2)
    fstp    qword ptr [ecx+50h]
    fxch    st(1)
    fst     qword ptr [ecx+58h]
    fst     qword ptr [ecx+60h]
    fst     qword ptr [ecx+68h]
    fstp    qword ptr [ecx+70h]
    fstp    qword ptr [ecx+78h]
  }
  return result;
}

//----- (10002080) --------------------------------------------------------
int __usercall sub_10002080<eax>(int a1<eax>, int a2<ecx>, int a3)
{
  char v6; // [sp+54h] [bp-D8h]@1
  char v7; // [sp+Ch] [bp-120h]@1
  __int64 v8; // [sp+FCh] [bp-30h]@1
  __int64 v9; // [sp+114h] [bp-18h]@1
  char v14; // [sp+CCh] [bp-60h]@1
  char v15; // [sp+9Ch] [bp-90h]@1
  char v16; // [sp+E4h] [bp-48h]@1
  char v17; // [sp+B4h] [bp-78h]@1

  _ESI = a1;
  _EDI = a2;
  UF_MTX3_copy(a1 + 24, &v6);
  UF_MTX3_copy(_EDI + 24, &v7);
  __asm
  {
    fld     qword ptr [esi]
    fstp    [ebp+var_30]
    fld     qword ptr [edi]
    fstp    [ebp+var_18]
    fld     qword ptr [esi+8]
    fstp    [ebp+var_28]
    fld     qword ptr [edi+8]
    fstp    [ebp+var_10]
    fld     qword ptr [esi+10h]
    fstp    [ebp+var_20]
    fld     qword ptr [edi+10h]
    fstp    [ebp+var_8]
  }
  UF_MTX3_x_vec(&v6, &v14);
  UF_MTX3_y_vec(&v6, &v15);
  UF_MTX3_x_vec(&v7, &v16);
  UF_MTX3_y_vec(&v7, &v17);
  return UF_MTX4_csys_to_csys(&v8, &v14, &v15, &v9, &v16, &v17, a3);
}

//----- (10002150) --------------------------------------------------------
int __usercall sub_10002150<eax>(int a1<eax>, int a2<esi>, double a3, double a4, int a5)
{
  int result; // eax@1
  int v6; // edx@1
  int v7; // ecx@1
  int v8; // edx@1
  int v9; // ecx@1
  int v10; // edx@1
  char *v12; // ST30_4@1
  __int64 v13; // ST28_8@1
  char *v14; // ST30_4@1
  double *v15; // ST2C_4@1
  __int64 v16; // ST24_8@1
  char *v17; // ST30_4@1
  __int64 v18; // ST28_8@1
  int v19; // ecx@1
  int v20; // edx@1
  int v21; // ecx@1
  int v22; // edx@1
  int v23; // [sp+24Ch] [bp-20h]@1
  int v25; // [sp+250h] [bp-1Ch]@1
  int v26; // [sp+254h] [bp-18h]@1
  int v27; // [sp+258h] [bp-14h]@1
  int v29; // [sp+25Ch] [bp-10h]@1
  __int64 v30; // [sp+1F4h] [bp-78h]@1
  char v32; // [sp+15Ch] [bp-110h]@1
  int v34; // [sp+260h] [bp-Ch]@1
  char v35; // [sp+114h] [bp-158h]@1
  char v36; // [sp+20Ch] [bp-60h]@1
  char v37; // [sp+1DCh] [bp-90h]@1
  char v38; // [sp+94h] [bp-1D8h]@1
  char v39; // [sp+14h] [bp-258h]@1
  int v40; // [sp+224h] [bp-48h]@1
  int v41; // [sp+228h] [bp-44h]@1
  int v42; // [sp+22Ch] [bp-40h]@1
  int v43; // [sp+230h] [bp-3Ch]@1
  int v44; // [sp+234h] [bp-38h]@1
  int v45; // [sp+238h] [bp-34h]@1

  __asm { fild    [ebp+arg_10] }
  v6 = *(_DWORD *)(a1 + 4);
  v23 = *(_DWORD *)a1;
  v7 = *(_DWORD *)(a1 + 8);
  __asm { fstp    [ebp+var_8] }
  v25 = v6;
  v8 = *(_DWORD *)(a1 + 12);
  v26 = v7;
  v9 = *(_DWORD *)(a1 + 16);
  v27 = v8;
  v10 = *(_DWORD *)(a1 + 20);
  _EAX = dword_1000C3D8;
  __asm
  {
    fld     qword ptr [eax+8]
    fstp    [ebp+var_28]
    fldz
  }
  v29 = v9;
  __asm
  {
    fst     [ebp+var_78]
    fst     [ebp+var_70]
  }
  v12 = &v32;
  __asm
  {
    fstp    [ebp+var_68]
    fld     [ebp+arg_8]
  }
  v34 = v10;
  __asm
  {
    fmul    ds:dbl_100099D8
    fstp    [esp+268h+var_268]
  }
  UF_MTX4_rotation(&dword_1000C2C8, &dbl_1000C328, v13, *((_DWORD *)&v13 + 1), v12);
  sub_100053B0((int)&v32);
  UF_MTX4_ask_rotation(&v32, &v35);
  UF_MTX3_vec_multiply(&dbl_1000C2F0, &v35, &v36);
  __asm { fld     [ebp+var_28] }
  v14 = &v36;
  v15 = &a4;
  __asm { fstp    qword ptr [esp] }
  UF_VEC3_unitize(&v36, v16, *((_DWORD *)&v16 + 1), v15, v14);
  UF_MTX4_vec3_multiply(&v30, &v32, &v37);
  __asm
  {
    fld     [ebp+arg_0]
    fmul    ds:dbl_100099D8
  }
  v17 = &v38;
  __asm { fstp    [esp+268h+var_268] }
  UF_MTX4_rotation(&v37, &v36, v18, *((_DWORD *)&v18 + 1), v17);
  sub_100053B0((int)&v38);
  UF_MTX4_multiply(&v32, &v38, &v39);
  sub_100053B0((int)&v39);
  UF_MTX4_vec_multiply(&v23, &v39, &v40);
  v19 = v41;
  v20 = v42;
  *(_DWORD *)a2 = v40;
  result = v43;
  *(_DWORD *)(a2 + 4) = v19;
  v21 = v44;
  *(_DWORD *)(a2 + 8) = v20;
  v22 = v45;
  *(_DWORD *)(a2 + 12) = result;
  *(_DWORD *)(a2 + 16) = v21;
  *(_DWORD *)(a2 + 20) = v22;
  return result;
}

//----- (100022D0) --------------------------------------------------------
int __cdecl sub_100022D0(int a1, double a2, int a3)
{
  char *v4; // ST34_4@1
  __int64 v5; // ST2C_8@1
  char v6; // [sp+Ch] [bp-E0h]@1
  char v7; // [sp+8Ch] [bp-60h]@1
  char v8; // [sp+D4h] [bp-18h]@1

  __asm
  {
    fld     [ebp+arg_4]
    fmul    ds:dbl_100099E0
  }
  v4 = &v6;
  __asm { fstp    [esp+0ECh+var_EC] }
  UF_MTX4_rotation(&dword_1000C540, &dbl_1000C2F0, v5, *((_DWORD *)&v5 + 1), v4);
  sub_100053B0((int)&v6);
  UF_MTX4_ask_rotation(&v6, &v7);
  UF_MTX3_vec_multiply(&dword_1000C2C8, &v7, &v8);
  return UF_VEC3_add(a1, &v8, a3);
}

//----- (10002350) --------------------------------------------------------
int __cdecl sub_10002350(int a1, double a2, int a3)
{
  int v4; // ecx@1
  double v5; // ST10_8@1
  int v6; // ecx@1
  char v7; // [sp+8h] [bp-80h]@1

  __asm { fld     [ebp+arg_4] }
  v4 = (int)&v7;
  __asm { fstp    [esp+88h+var_88] }
  sub_10001FA0((int)&dbl_1000C328, v4, v5);
  sub_100053B0(v6);
  return UF_MTX4_vec3_multiply_t(a1, &v7, a3);
}

//----- (10002390) --------------------------------------------------------
int __fastcall sub_10002390(int a1, int a2, int a3)
{
  int result; // eax@1
  __int64 v4; // [sp+0h] [bp-8h]@1

  result = UF_VEC3_angle_between(a3, a2, a1, &v4);
  __asm { fld     [ebp+var_8] }
  return result;
}

//----- (100023B0) --------------------------------------------------------
int __usercall sub_100023B0<eax>(int _EAX<eax>, int a2<ecx>, int a3)
{
  __int64 v4; // [sp+0h] [bp-18h]@1

  __asm
  {
    fld     qword ptr [eax]
    fld     qword ptr [eax+8]
    fsin
    fld     st(1)
    fcos
    fmul    st, st(1)
    fstp    [ebp+var_18]
    fxch    st(1)
    fsin
    fmul    st, st(1)
    fstp    [ebp+var_10]
    fstp    [ebp+var_8]
  }
  return UF_MTX3_vec_multiply(&v4, a2 + 24, a3);
}

//----- (100023F0) --------------------------------------------------------
signed int __cdecl sub_100023F0(const void *a1, const void *a2)
{
  signed int result; // eax@2

  _ECX = a1;
  __asm { fld     qword ptr [ecx] }
  _EDX = a2;
  __asm
  {
    fsub    qword ptr [edx]
    fabs
    fld     dbl_1000C000
    fcom    st(1)
    fnstsw  ax
    fstp    st(1)
  }
  if ( HIBYTE(_AX) & 1 )
  {
    __asm
    {
      fadd    qword ptr [edx]
      fcomp   qword ptr [ecx]
      fnstsw  ax
      jp      short loc_10002428
    }
    result = 1;
  }
  else
  {
    __asm { fstp    st }
    result = 0;
  }
  return result;
}

//----- (10002430) --------------------------------------------------------
__int16 __cdecl sub_10002430()
{
  __int16 result; // ax@9

  __asm
  {
    fld     qword ptr [edx]
    fsub    qword ptr [edx+8]
    fabs
    fld     dbl_1000C000
    fcom    st(1)
    fnstsw  ax
    fstp    st(1)
    fld     ds:dbl_100099E8
  }
  if ( !(HIBYTE(_AX) & 1) )
  {
    __asm
    {
      fld     qword ptr [ecx]
      fsub    qword ptr [ecx+8]
      fabs
      fcomp   st(2)
      fnstsw  ax
      jp      loc_100024FA
      fld     qword ptr [edx]
      fsub    qword ptr [ecx]
      fabs
      fcomp   st(2)
      fnstsw  ax
      jnp     loc_100024FA
      fld     st(1)
      fchs
      fcom    qword ptr [edx]
      fnstsw  ax
    }
    if ( HIBYTE(_AX) & 0x41 )
    {
      __asm
      {
        fcom    qword ptr [ecx]
        fnstsw  ax
      }
      if ( HIBYTE(_AX) & 0x41 )
      {
        __asm
        {
          fstp    st
          fxch    st(1)
          fcom    qword ptr [ecx+8]
          fnstsw  ax
          jp      short loc_100024F8
          fld     qword ptr [ecx+8]
          fsub    st, st(2)
          fstp    qword ptr [ecx+8]
          fxch    st(1)
        }
      }
      else
      {
        __asm
        {
          fld     qword ptr [ecx]
          fadd    st, st(2)
          fld     st
          fsub    qword ptr [edx]
          fabs
          fcomp   st(4)
          fnstsw  ax
          jnp     short loc_100024CC
          fstp    st(1)
          fst     qword ptr [ecx]
          fld     st
          fsub    qword ptr [ecx+8]
          fabs
          fcomp   st(3)
          fnstsw  ax
          jp      short loc_10002531
          fsubr   st, st(1)
          fstp    qword ptr [ecx+8]
        }
      }
    }
    else
    {
      __asm
      {
        fstp    st
        fld     qword ptr [edx]
        fadd    st, st(1)
        fst     qword ptr [edx]
        fsubr   st, st(1)
        fstp    qword ptr [edx+8]
      }
    }
  }
  __asm
  {
    fld     qword ptr [edx]
    fsub    qword ptr [ecx]
    fabs
    fcomp   st(2)
    fnstsw  ax
    jp      short loc_10002568
    fld     qword ptr [edx+8]
    fsub    qword ptr [ecx+8]
    fabs
    fcomp   st(2)
    fnstsw  ax
    jp      short loc_10002568
    fld     st(1)
    fchs
    fcomp   qword ptr [ecx+8]
    fnstsw  ax
  }
  if ( HIBYTE(result) & 0x41 )
  {
    __asm
    {
      fxch    st(1)
      fcom    qword ptr [ecx+8]
      fnstsw  ax
      jp      short loc_1000254A
      fstp    st
      fsub    qword ptr [ecx+8]
      fstp    qword ptr [ecx+8]
    }
  }
  else
  {
    __asm
    {
      fstp    st(1)
      fadd    qword ptr [ecx+8]
      fstp    qword ptr [ecx+8]
    }
  }
  return result;
}

//----- (10002580) --------------------------------------------------------
__int16 __cdecl sub_10002580(double a1)
{
  __int16 result; // ax@1

  __asm
  {
    fldz
    fld     [ebp+arg_0]
    fcom    st(1)
    fnstsw  ax
  }
  if ( HIBYTE(result) & 0x41 )
  {
    __asm
    {
      fcom    st(1)
      fnstsw  ax
      fstp    st(1)
      jp      short loc_100025AC
      fadd    ds:dbl_100099F0
    }
  }
  else
  {
    __asm
    {
      fstp    st(1)
      fsub    ds:dbl_100099F0
    }
  }
  return result;
}

//----- (100025B0) --------------------------------------------------------
__int16 __usercall sub_100025B0<ax>(int _EDX<edx>, const void *_EBX<ebx>)
{
  __int16 result; // ax@5
  double v7; // ST00_8@1
  double v11; // ST00_8@3
  char v18; // [sp+8h] [bp-28h]@5

  __asm
  {
    fld     qword ptr [edx+18h]
    fstp    [esp+30h+var_30]
  }
  sub_10002580(v7);
  __asm
  {
    fld     qword ptr [ecx+18h]
    fsub    qword ptr [edx+18h]
    fld     qword ptr [ecx+18h]
    fsub    st, st(2)
    fxch    st(1)
    fabs
    fxch    st(1)
    fabs
    fcompp  st(1), st
    fnstsw  ax
    jp      short loc_100025E8
    fstp    qword ptr [edx+18h]
    fld     qword ptr [edx+20h]
    fstp    [esp+30h+var_30]
  }
  sub_10002580(v11);
  __asm
  {
    fld     qword ptr [ecx+20h]
    fsub    qword ptr [edx+20h]
    fld     qword ptr [ecx+20h]
    fsub    st, st(2)
    fxch    st(1)
    fabs
    fxch    st(1)
    fabs
    fcompp  st(1), st
    fnstsw  ax
    jp      short loc_1000261C
    fstp    qword ptr [edx+20h]
    fld     qword ptr [ecx+18h]
    fsub    qword ptr [edx+18h]
    fld     qword ptr [ecx+18h]
    fsub    qword ptr [ebx+18h]
    fxch    st(1)
    fabs
    fxch    st(1)
    fabs
    fcompp  st(1), st
    fnstsw  ax
    jp      short loc_10002660
  }
  memcpy(&v18, _EDX, 0x28u);
  memcpy((void *)_EDX, _EBX, 0x28u);
  memcpy((void *)_EBX, &v18, 0x28u);
  _ECX = dword_1000C3D8;
  __asm
  {
    fld     qword ptr [ecx+68h]
    fld     dbl_1000C000
    fsub    st(1), st
    fxch    st(1)
    fcomp   qword ptr [edx+18h]
    fnstsw  ax
    jp      short loc_1000268C
    fld     qword ptr [ecx+70h]
    fadd    st, st(1)
    fcomp   qword ptr [edx+18h]
    fnstsw  ax
  }
  if ( HIBYTE(result) & 0x41 )
  {
    __asm
    {
      fld     qword ptr [ecx+78h]
      fsub    st, st(1)
      fcomp   qword ptr [ebx+18h]
      fnstsw  ax
      jp      short loc_100026D4
      fadd    qword ptr [ecx+80h]
      fcomp   qword ptr [ebx+18h]
      fnstsw  ax
    }
    if ( !(HIBYTE(result) & 0x41) )
    {
      memcpy(&v18, _EDX, 0x28u);
      memcpy((void *)_EDX, _EBX, 0x28u);
      memcpy((void *)_EBX, &v18, 0x28u);
    }
  }
  else
  {
    __asm { fstp    st }
  }
  return result;
}

//----- (100026E0) --------------------------------------------------------
int __cdecl sub_100026E0(int a1)
{
  _EAX = a1;
  _ECX = dword_1000C3D8;
  *(_DWORD *)(dword_1000C3D8 + 16) = *(_DWORD *)(a1 + 192);
  *(_DWORD *)(dword_1000C3D8 + 20) = *(_DWORD *)(_EAX + 196);
  *(_DWORD *)(dword_1000C3D8 + 24) = *(_DWORD *)(_EAX + 200);
  *(_DWORD *)(dword_1000C3D8 + 28) = *(_DWORD *)(_EAX + 204);
  *(_DWORD *)(dword_1000C3D8 + 32) = *(_DWORD *)(_EAX + 208);
  *(_DWORD *)(dword_1000C3D8 + 36) = *(_DWORD *)(_EAX + 212);
  *(_DWORD *)(dword_1000C3D8 + 40) = *(_DWORD *)(_EAX + 216);
  *(_DWORD *)(dword_1000C3D8 + 44) = *(_DWORD *)(_EAX + 220);
  *(_DWORD *)(dword_1000C3D8 + 48) = *(_DWORD *)(_EAX + 224);
  *(_DWORD *)(dword_1000C3D8 + 52) = *(_DWORD *)(_EAX + 228);
  *(_DWORD *)(dword_1000C3D8 + 56) = *(_DWORD *)(_EAX + 232);
  *(_DWORD *)(dword_1000C3D8 + 60) = *(_DWORD *)(_EAX + 236);
  __asm
  {
    fld     qword ptr [eax+178h]
    fstp    qword ptr [ecx+88h]
  }
  return 0;
}

//----- (10002770) --------------------------------------------------------
int __cdecl sub_10002770(int a1, int a2, int a3, int a4)
{
  int result; // eax@1
  __int64 v14; // [sp+20h] [bp-28h]@1
  char v15; // [sp+8h] [bp-40h]@1
  __int64 v19; // [sp+40h] [bp-8h]@1

  _ESI = a2;
  UF_VEC3_sub(a2 + 24, a2, &v14);
  UF_VEC3_sub(a1, _ESI, &v15);
  __asm
  {
    fld     [ebp+var_18]
    fmul    st, st
    fld     [ebp+var_20]
    fmul    st, st
    faddp   st(1), st
    fld     [ebp+var_28]
    fmul    st, st
    faddp   st(1), st
    fst     [ebp+var_10]
    fldz
    fcom    st(1)
    fnstsw  ax
    fstp    st(1)
    jp      short loc_10002807
    fstp    st
  }
  UF_VEC3_dot(&v14, &v15, &v19);
  __asm
  {
    fld     [ebp+var_8]
    fdiv    [ebp+var_10]
  }
  _EAX = a4;
  _ECX = a3;
  __asm
  {
    fst     qword ptr [eax]
    fmul    [ebp+var_28]
    fadd    qword ptr [esi]
    fstp    qword ptr [ecx]
    fld     qword ptr [eax]
    fmul    [ebp+var_20]
    fadd    qword ptr [esi+8]
    fstp    qword ptr [ecx+8]
    fld     qword ptr [eax]
  }
  result = 0;
  __asm
  {
    fmul    [ebp+var_18]
    fadd    qword ptr [esi+10h]
    fstp    qword ptr [ecx+10h]
  }
  return result;
}

//----- (10002830) --------------------------------------------------------
int __cdecl sub_10002830(int a1, int a2, int a3, int a4)
{
  int v4; // edi@1
  int v5; // esi@1
  int v6; // ebx@2
  unsigned int v8; // ecx@3
  int v10; // ecx@18
  int v11; // edx@24
  signed int v13; // ebx@26
  int v15; // esi@27
  int v17; // edx@28
  unsigned int v18; // ebx@28
  int v22; // esi@38
  int v24; // edx@39
  unsigned int v25; // edi@39
  int v29; // eax@53
  unsigned int v33; // esi@54
  int v35; // edx@58
  int v37; // edx@62
  int v39; // edx@63
  int v40; // eax@64
  unsigned int v41; // ebx@64
  int v42; // eax@1
  unsigned __int8 v62; // of@23
  char v63; // sf@23
  int v81; // esi@54
  int v82; // ebx@54
  char v100; // [sp+Ch] [bp-24h]@1
  int v101; // [sp+20h] [bp-10h]@1
  int v102; // [sp+2Ch] [bp-4h]@1
  int v103; // [sp+28h] [bp-8h]@24
  int v104; // [sp+14h] [bp-1Ch]@25
  int v105; // [sp+24h] [bp-Ch]@25
  int v106; // [sp+10h] [bp-20h]@25
  int v107; // [sp+1Ch] [bp-14h]@27
  int v108; // [sp+18h] [bp-18h]@47

  v5 = a2;
  v4 = a1;
  v42 = UF_allocate_memory(8 * a2, &v100);
  __asm { fld1 }
  _EDX = a4;
  __asm
  {
    fst     qword ptr [edx]
    fldz
  }
  v101 = v42;
  v102 = 0;
  if ( v5 > 0 )
  {
    do
    {
      v6 = 0;
      __asm { fld     st }
      if ( v5 >= 4 )
      {
        _EDX = *(_DWORD *)(v4 + 4 * v102) + 16;
        v8 = ((unsigned int)(v5 - 4) >> 2) + 1;
        v6 = 4 * v8;
        do
        {
          __asm
          {
            fld     qword ptr [edx-10h]
            fabs
            fcom    st(1)
            fnstsw  ax
          }
          if ( HIBYTE(_AX) & 0x41 )
            __asm { fstp    st }
          else
            __asm { fstp    st(1) }
          __asm
          {
            fld     qword ptr [edx-8]
            fabs
            fcom    st(1)
            fnstsw  ax
          }
          if ( HIBYTE(_AX) & 0x41 )
            __asm { fstp    st }
          else
            __asm { fstp    st(1) }
          __asm
          {
            fld     qword ptr [edx]
            fabs
            fcom    st(1)
            fnstsw  ax
          }
          if ( HIBYTE(_AX) & 0x41 )
            __asm { fstp    st }
          else
            __asm { fstp    st(1) }
          __asm
          {
            fld     qword ptr [edx+8]
            fabs
            fcom    st(1)
            fnstsw  ax
          }
          if ( HIBYTE(_AX) & 0x41 )
            __asm { fstp    st }
          else
            __asm { fstp    st(1) }
          _EDX += 32;
          --v8;
        }
        while ( v8 );
      }
      if ( v6 < v5 )
      {
        _EDX = *(_DWORD *)(v4 + 4 * v102) + 8 * v6;
        v10 = v5 - v6;
        do
        {
          __asm
          {
            fld     qword ptr [edx]
            fabs
            fcom    st(1)
            fnstsw  ax
          }
          if ( HIBYTE(_AX) & 0x41 )
            __asm { fstp    st }
          else
            __asm { fstp    st(1) }
          _EDX += 8;
          --v10;
        }
        while ( v10 );
      }
      __asm
      {
        fld     st(1)
        fucomp  st(1)
        fnstsw  ax
        jnp     loc_10002AC5
        fdivr   st, st(2)
      }
      _ECX = v101;
      _EAX = v102 + 1;
      v62 = __SETO__(v102 + 1, v5);
      v63 = v102++ + 1 < v5;
      __asm { fstp    qword ptr [ecx+eax*8-8] }
    }
    while ( v63 ^ v62 );
  }
  v11 = 0;
  v103 = 0;
  if ( v5 > 0 )
  {
    __asm { fld     ds:dbl_100099F8 }
    v104 = v5 - 1;
    _ECX = 0;
    v105 = v4;
    v106 = a3 - v4;
    do
    {
      v13 = 0;
      v102 = 0;
      if ( v11 > 0 )
      {
        do
        {
          _EAX = *(_DWORD *)(v4 + 4 * v13);
          __asm { fld     qword ptr [ecx+eax] }
          v15 = 0;
          v107 = *(_DWORD *)(v4 + 4 * v13);
          if ( v13 >= 4 )
          {
            _EAX = _EAX + 16;
            v18 = ((unsigned int)(v13 - 4) >> 2) + 1;
            v17 = v4 + 8;
            v15 = 4 * v18;
            do
            {
              _EDI = *(_DWORD *)(v17 - 8);
              __asm { fld     qword ptr [edi+ecx] }
              _EDI = *(_DWORD *)(v17 - 4);
              __asm { fmul    qword ptr [eax-10h] }
              _EAX += 32;
              v17 += 16;
              --v18;
              __asm
              {
                fsubp   st(1), st
                fld     qword ptr [edi+ecx]
              }
              _EDI = *(_DWORD *)(v17 - 16);
              __asm
              {
                fmul    qword ptr [eax-28h]
                fsubp   st(1), st
                fld     qword ptr [edi+ecx]
              }
              _EDI = *(_DWORD *)(v17 - 12);
              __asm
              {
                fmul    qword ptr [eax-20h]
                fsubp   st(1), st
                fld     qword ptr [edi+ecx]
                fmul    qword ptr [eax-18h]
                fsubp   st(1), st
              }
            }
            while ( v18 );
            v4 = a1;
            v13 = v102;
            _EAX = v107;
            v11 = v103;
          }
          if ( v15 < v13 )
          {
            _EAX = _EAX + 8 * v15;
            do
            {
              _EDX = *(_DWORD *)(v4 + 4 * v15);
              __asm { fld     qword ptr [edx+ecx] }
              ++v15;
              __asm { fmul    qword ptr [eax] }
              _EAX += 8;
              __asm { fsubp   st(1), st }
            }
            while ( v15 < v13 );
            _EAX = v107;
            v11 = v103;
          }
          ++v13;
          __asm { fstp    qword ptr [ecx+eax] }
          v102 = v13;
        }
        while ( v13 < v11 );
        v5 = a2;
      }
      __asm { fld     st(1) }
      _EBX = v11;
      v102 = v11;
      if ( v11 < v5 )
      {
        do
        {
          _EAX = *(_DWORD *)(v4 + 4 * _EBX);
          __asm { fld     qword ptr [ecx+eax] }
          v22 = 0;
          v107 = *(_DWORD *)(v4 + 4 * _EBX);
          if ( _ECX >= 32 )
          {
            v24 = v4 + 8;
            _EAX = _EAX + 16;
            v25 = ((unsigned int)(v103 - 4) >> 2) + 1;
            v22 = 4 * v25;
            do
            {
              _EBX = *(_DWORD *)(v24 - 8);
              __asm { fld     qword ptr [ebx+ecx] }
              _EBX = *(_DWORD *)(v24 - 4);
              __asm { fmul    qword ptr [eax-10h] }
              _EAX += 32;
              v24 += 16;
              --v25;
              __asm
              {
                fsubp   st(1), st
                fld     qword ptr [ebx+ecx]
              }
              _EBX = *(_DWORD *)(v24 - 16);
              __asm
              {
                fmul    qword ptr [eax-28h]
                fsubp   st(1), st
                fld     qword ptr [ebx+ecx]
              }
              _EBX = *(_DWORD *)(v24 - 12);
              __asm
              {
                fmul    qword ptr [eax-20h]
                fsubp   st(1), st
                fld     qword ptr [ebx+ecx]
                fmul    qword ptr [eax-18h]
                fsubp   st(1), st
              }
            }
            while ( v25 );
            _EBX = v102;
            v4 = a1;
            _EAX = v107;
            v11 = v103;
          }
          if ( v22 < v11 )
          {
            _EBX = _EAX + 8 * v22;
            do
            {
              _EDX = *(_DWORD *)(v4 + 4 * v22);
              __asm { fld     qword ptr [edx+ecx] }
              v11 = v103;
              __asm { fmul    qword ptr [ebx] }
              ++v22;
              _EBX += 8;
              __asm { fsubp   st(1), st }
            }
            while ( v22 < v103 );
            _EBX = v102;
          }
          __asm { fst     qword ptr [ecx+eax] }
          _EAX = v101;
          __asm
          {
            fabs
            fmul    qword ptr [eax+ebx*8]
            fcom    st(1)
            fnstsw  ax
          }
          if ( BYTE1(_EAX) & 1 )
          {
            __asm { fstp    st }
          }
          else
          {
            __asm { fstp    st(1) }
            v108 = _EBX;
          }
          ++_EBX;
          v102 = _EBX;
        }
        while ( _EBX < a2 );
        v5 = a2;
      }
      _EBX = v108;
      __asm { fstp    st }
      if ( v11 != v108 )
      {
        v29 = 0;
        v107 = 0;
        if ( v5 >= 4 )
        {
          v81 = *(_DWORD *)(v4 + 4 * v108);
          v82 = *(_DWORD *)v105;
          _EDX = v81 + 24;
          v102 = v81 - *(_DWORD *)v105;
          _EAX = v82 + 8;
          v33 = ((unsigned int)(a2 - 4) >> 2) + 1;
          v107 = 4 * v33;
          _EBX = v102;
          do
          {
            __asm { fld     qword ptr [edx-18h] }
            _EAX += 32;
            __asm { fld     qword ptr [eax-28h] }
            _EDX += 32;
            --v33;
            __asm
            {
              fstp    qword ptr [edx-38h]
              fstp    qword ptr [eax-28h]
              fld     qword ptr [eax+ebx-20h]
              fld     qword ptr [eax-20h]
              fstp    qword ptr [eax+ebx-20h]
              fstp    qword ptr [eax-20h]
              fld     qword ptr [edx-28h]
              fld     qword ptr [eax-18h]
              fstp    qword ptr [edx-28h]
              fstp    qword ptr [eax-18h]
              fld     qword ptr [edx-20h]
              fld     qword ptr [eax-10h]
              fstp    qword ptr [edx-20h]
              fstp    qword ptr [eax-10h]
            }
          }
          while ( v33 );
          v5 = a2;
          _EBX = v108;
          v29 = v107;
        }
        if ( v29 < v5 )
        {
          _EBX = *(_DWORD *)(v4 + 4 * _EBX) - *(_DWORD *)v105;
          _EAX = *(_DWORD *)v105 + 8 * v29;
          v35 = v5 - v107;
          v102 = _EBX;
          do
          {
            __asm { fld     qword ptr [ebx+eax] }
            _EAX += 8;
            --v35;
            __asm
            {
              fld     qword ptr [eax-8]
              fstp    qword ptr [ebx+eax-8]
              fstp    qword ptr [eax-8]
            }
          }
          while ( v35 );
          _EBX = v108;
        }
        _EAX = a4;
        __asm
        {
          fld     qword ptr [eax]
          fchs
          fstp    qword ptr [eax]
        }
        _EAX = v101;
        __asm
        {
          fld     qword ptr [ecx+eax]
          fstp    qword ptr [eax+ebx*8]
        }
      }
      __asm { fld     st(1) }
      *(_DWORD *)(v106 + v105) = _EBX;
      _EAX = *(_DWORD *)v105;
      __asm { fcomp   qword ptr [ecx+eax] }
      _EBX = _ECX + *(_DWORD *)v105;
      __asm
      {
        fnstsw  ax
        jp      short loc_10002BE0
        fst     qword ptr [ebx]
      }
      v37 = v103;
      if ( v103 != v5 - 1 )
      {
        __asm { fld     st(2) }
        v39 = v103 + 1;
        __asm { fdiv    qword ptr [ebx] }
        if ( v104 >= 4 )
        {
          v40 = v105 + 12;
          v41 = ((unsigned int)(v5 - v39 - 4) >> 2) + 1;
          v39 += 4 * v41;
          do
          {
            _ESI = *(_DWORD *)(v40 - 8);
            __asm { fld     qword ptr [esi+ecx] }
            _ESI = _ECX + _ESI;
            __asm { fmul    st, st(1) }
            v40 += 16;
            __asm { fstp    qword ptr [esi] }
            _ESI = *(_DWORD *)(v40 - 20);
            __asm { fld     qword ptr [esi+ecx] }
            _ESI = _ECX + _ESI;
            __asm
            {
              fmul    st, st(1)
              fstp    qword ptr [esi]
            }
            _ESI = *(_DWORD *)(v40 - 16);
            __asm { fld     qword ptr [esi+ecx] }
            _ESI = _ECX + _ESI;
            __asm
            {
              fmul    st, st(1)
              fstp    qword ptr [esi]
            }
            _ESI = *(_DWORD *)(v40 - 12);
            __asm { fld     qword ptr [esi+ecx] }
            _ESI = _ECX + _ESI;
            --v41;
            __asm
            {
              fmul    st, st(1)
              fstp    qword ptr [esi]
            }
          }
          while ( v41 );
          v5 = a2;
        }
        while ( v39 < v5 )
        {
          _EAX = *(_DWORD *)(v4 + 4 * v39);
          __asm
          {
            fld     st
            fmul    qword ptr [eax+ecx]
          }
          _EAX = _ECX + _EAX;
          ++v39;
          __asm { fstp    qword ptr [eax] }
        }
        v37 = v103;
        __asm { fstp    st }
      }
      --v104;
      v105 += 4;
      v11 = v37 + 1;
      _ECX += 8;
      v103 = v11;
    }
    while ( v11 < v5 );
    __asm { fstp    st }
  }
  __asm
  {
    fstp    st
    fstp    st
  }
  UF_free(v101);
  return 0;
}

//----- (10002CA0) --------------------------------------------------------
int __fastcall sub_10002CA0(int a1, int _EDX, int a3, int a4, int a5)
{
  int result; // eax@1
  int v5; // ecx@1
  int v7; // eax@2
  int v8; // ebx@2
  int v9; // eax@5
  unsigned int v10; // eax@6
  int v15; // ecx@10
  int v19; // ebx@17
  int v20; // esi@17
  unsigned int v21; // eax@20
  int v26; // ecx@24
  char v28; // zf@4
  int v32; // eax@20
  int v33; // ecx@20
  int v35; // [sp+14h] [bp-10h]@1
  int v36; // [sp+18h] [bp-Ch]@2
  int v37; // [sp+1Ch] [bp-8h]@2
  int v38; // [sp+10h] [bp-14h]@2
  int v39; // [sp+20h] [bp-4h]@5
  int v40; // [sp+Ch] [bp-18h]@6

  result = a4;
  v5 = a3;
  _EDI = 0;
  v35 = 0;
  if ( a4 > 0 )
  {
    __asm { fldz }
    v8 = v36;
    v7 = a5 - a3;
    v37 = a3;
    v38 = a5 - a3;
    while ( 1 )
    {
      v28 = v35 == 0;
      _EAX = *(_DWORD *)(v5 + v7);
      __asm
      {
        fld     qword ptr [edx+eax*8]
        fld     qword ptr [edx+edi*8]
        fstp    qword ptr [edx+eax*8]
      }
      if ( v28 )
      {
        __asm
        {
          fld     st(1)
          fucomp  st(1)
          fnstsw  ax
          jnp     short loc_10002D8B
        }
        v8 = _EDI;
        v35 = 1;
        v36 = _EDI;
      }
      else
      {
        v9 = v8;
        v39 = v8;
        if ( _EDI - v8 >= 4 )
        {
          _ESI = *(_DWORD *)v5 + 8 * v8 + 24;
          v40 = *(_DWORD *)v5 - _EDX;
          _ECX = _EDX + 8 * v8 + 8;
          v10 = ((unsigned int)(_EDI - v8 - 4) >> 2) + 1;
          v39 = v8 + 4 * v10;
          _EBX = v40;
          do
          {
            __asm { fld     qword ptr [ecx-8] }
            _ECX += 32;
            __asm { fmul    qword ptr [esi-18h] }
            _ESI += 32;
            --v10;
            __asm
            {
              fsubp   st(1), st
              fld     qword ptr [ecx+ebx-20h]
              fmul    qword ptr [ecx-20h]
              fsubp   st(1), st
              fld     qword ptr [ecx-18h]
              fmul    qword ptr [esi-28h]
              fsubp   st(1), st
              fld     qword ptr [ecx-10h]
              fmul    qword ptr [esi-20h]
              fsubp   st(1), st
            }
          }
          while ( v10 );
          v5 = v37;
          v8 = v36;
          v9 = v39;
        }
        if ( v9 < _EDI )
        {
          _ESI = *(_DWORD *)v5 - _EDX;
          v15 = _EDI - v39;
          _EAX = _EDX + 8 * v9;
          do
          {
            __asm { fld     qword ptr [eax+esi] }
            _EAX += 8;
            --v15;
            __asm
            {
              fmul    qword ptr [eax-8]
              fsubp   st(1), st
            }
          }
          while ( v15 );
          v5 = v37;
        }
      }
      result = a4;
      __asm { fstp    qword ptr [edx+edi*8] }
      ++_EDI;
      v5 += 4;
      v37 = v5;
      if ( _EDI >= result )
        break;
      v7 = v38;
    }
    __asm { fstp    st }
  }
  _EDI = result - 1;
  if ( result - 1 >= 0 )
  {
    result = result - _EDI - 1;
    v19 = _EDI + 1;
    _ECX = _EDX + 8 * _EDI;
    v20 = 32 - _EDX;
    v38 = _EDI + 1;
    v35 = _EDX + 8 * _EDI;
    v36 = result;
    v40 = 32 - _EDX;
    while ( 1 )
    {
      __asm { fld     qword ptr [ecx] }
      v39 = v19;
      if ( result >= 4 )
      {
        v32 = *(_DWORD *)(a3 + 4 * _EDI);
        v33 = v20 + _ECX;
        _ESI = v33 + v32;
        v37 = v32 - _EDX;
        v21 = ((unsigned int)(a4 - v19 - 4) >> 2) + 1;
        v39 = v19 + 4 * v21;
        _EBX = v37;
        _ECX = v33 + _EDX - 16;
        do
        {
          __asm { fld     qword ptr [ecx-8] }
          _ECX += 32;
          __asm { fmul    qword ptr [esi-18h] }
          _ESI += 32;
          --v21;
          __asm
          {
            fsubp   st(1), st
            fld     qword ptr [ebx+ecx-20h]
            fmul    qword ptr [ecx-20h]
            fsubp   st(1), st
            fld     qword ptr [ecx-18h]
            fmul    qword ptr [esi-28h]
            fsubp   st(1), st
            fld     qword ptr [ecx-10h]
            fmul    qword ptr [esi-20h]
            fsubp   st(1), st
          }
        }
        while ( v21 );
        v19 = v38;
        _ECX = v35;
        result = v36;
      }
      if ( v39 < a4 )
      {
        v37 = *(_DWORD *)(a3 + 4 * _EDI) - _EDX;
        _EAX = _EDX + 8 * v39;
        v26 = a4 - v39;
        _ESI = v37;
        do
        {
          __asm { fld     qword ptr [esi+eax] }
          _EAX += 8;
          --v26;
          __asm
          {
            fmul    qword ptr [eax-8]
            fsubp   st(1), st
          }
        }
        while ( v26 );
        _ECX = v35;
        result = v36;
      }
      _ESI = *(_DWORD *)(a3 + 4 * _EDI);
      __asm { fdiv    qword ptr [esi+edi*8] }
      --_EDI;
      ++result;
      --v19;
      _ECX -= 8;
      v36 = result;
      v38 = v19;
      v35 = _ECX;
      __asm { fstp    qword ptr [ecx+8] }
      if ( _EDI < 0 )
        break;
      v20 = v40;
    }
  }
  return result;
}

//----- (10002EB0) --------------------------------------------------------
int __cdecl sub_10002EB0(int a2)
{
  int result; // eax@1
  __int64 v5; // [sp+78h] [bp-50h]@1
  __int64 v6; // [sp+58h] [bp-70h]@1
  __int64 *v7; // [sp+9Ch] [bp-2Ch]@1
  __int64 v8; // [sp+18h] [bp-B0h]@1
  __int64 *v9; // [sp+A0h] [bp-28h]@1
  __int64 v10; // [sp+38h] [bp-90h]@1
  __int64 *v22; // [sp+98h] [bp-30h]@1
  __int64 *v24; // [sp+A4h] [bp-24h]@1
  char v25; // [sp+0h] [bp-C8h]@1
  char v26; // [sp+10h] [bp-B8h]@1
  __int64 v27; // [sp+A8h] [bp-20h]@3
  __int64 v28; // [sp+B0h] [bp-18h]@3
  __int64 v29; // [sp+B8h] [bp-10h]@3
  __int64 v30; // [sp+C0h] [bp-8h]@3

  __asm
  {
    fld     qword ptr [eax]
    fstp    [ebp+var_50]
  }
  v7 = &v6;
  __asm
  {
    fld     qword ptr [eax+20h]
    fstp    [ebp+var_70]
    fld     qword ptr [eax+40h]
    fstp    [ebp+var_B0]
  }
  v9 = &v8;
  __asm
  {
    fld     qword ptr [eax+60h]
    fstp    [ebp+var_90]
    fld     qword ptr [eax+8]
    fstp    [ebp+var_48]
    fld     qword ptr [eax+28h]
    fstp    [ebp+var_68]
    fld     qword ptr [eax+48h]
    fstp    [ebp+var_A8]
    fld     qword ptr [eax+68h]
    fstp    [ebp+var_88]
    fld     qword ptr [eax+10h]
    fstp    [ebp+var_40]
    fld     qword ptr [eax+30h]
    fstp    [ebp+var_60]
    fld     qword ptr [eax+50h]
    fstp    [ebp+var_A0]
    fld     qword ptr [eax+70h]
    fstp    [ebp+var_80]
    fld     qword ptr [eax+18h]
    fstp    [ebp+var_38]
    fld     qword ptr [eax+38h]
    fstp    [ebp+var_58]
    fld     qword ptr [eax+58h]
    fstp    [ebp+var_98]
    fld     qword ptr [eax+78h]
  }
  v22 = &v5;
  __asm { fstp    [ebp+var_78] }
  v24 = &v10;
  result = sub_10002830((int)&v22, 4, (int)&v25, (int)&v26);
  if ( !result )
  {
    _EDI = 0;
    _ESI = a2 + 64;
    do
    {
      __asm { fld1 }
      v27 = 0i64;
      v28 = 0i64;
      v29 = 0i64;
      v30 = 0i64;
      __asm { fstp    [ebp+edi*8+var_20] }
      result = sub_10002CA0((int)&v25, (int)&v27, (int)&v22, 4, (int)&v25);
      __asm
      {
        fld     [ebp+var_20]
        fstp    qword ptr [esi-40h]
      }
      ++_EDI;
      __asm
      {
        fld     [ebp+var_18]
        fstp    qword ptr [esi-20h]
      }
      _ESI += 8;
      __asm
      {
        fld     [ebp+var_10]
        fstp    qword ptr [esi-8]
        fld     [ebp+var_8]
        fstp    qword ptr [esi+18h]
      }
    }
    while ( _EDI < 4 );
  }
  return result;
}

//----- (10002FE0) --------------------------------------------------------
int __cdecl sub_10002FE0(int a2, int a3)
{
  int result; // eax@11
  int v14; // eax@4
  int v15; // ST10_4@4
  double v16; // ST08_8@4
  int v17; // esi@4
  double v18; // ST00_8@4
  char *v19; // ST10_4@4
  char *v20; // ST0C_4@4
  __int64 v21; // ST04_8@4
  int *v22; // ST10_4@4
  __int64 v23; // ST08_8@4
  int v25; // eax@8
  int v26; // ST10_4@8
  double v27; // ST08_8@8
  int v28; // esi@8
  double v29; // ST00_8@8
  char *v30; // ST10_4@8
  char *v31; // ST0C_4@8
  __int64 v32; // ST04_8@8
  int *v33; // ST10_4@8
  __int64 v34; // ST08_8@8
  __int64 v35; // [sp+B0h] [bp-4Ch]@1
  char v54; // [sp+E0h] [bp-1Ch]@4
  char v55; // [sp+D8h] [bp-24h]@4
  int v56; // [sp+F8h] [bp-4h]@4
  __int64 v57; // [sp+20h] [bp-DCh]@7

  __asm { fldz }
  _EAX = a3;
  __asm
  {
    fst     [ebp+var_4C]
    fstp    [ebp+var_44]
    fld1
    fstp    [ebp+var_3C]
    fld     qword ptr [eax]
    fld     qword ptr [eax+8]
    fld     qword ptr [ecx]
    fst     [ebp+var_34]
    fld     qword ptr [ecx+8]
    fst     [ebp+var_2C]
    fxch    st(3)
    fst     [ebp+var_AC]
    fld     st
    fld     ds:dbl_100099D0
    fmul    st(1), st
    fxch    st(1)
    fst     [ebp+var_A4]
    fld     st(2)
    fld     ds:dbl_100099C8
    fadd    st(1), st
    fxch    st(1)
    fstp    [ebp+var_9C]
    fld     st
    fsubrp  st(4), st
    fxch    st(3)
    fstp    [ebp+var_94]
    fld     st(2)
    fsub    st, st(1)
    fstp    [ebp+var_8C]
    fadd    st, st(2)
    fstp    [ebp+var_84]
    fxch    st(3)
    fst     [ebp+var_7C]
    fld     st
    fmul    st, st(4)
    fst     [ebp+var_74]
    fld     st(1)
    fadd    st, st(3)
    fstp    [ebp+var_6C]
    fld     st(2)
    fsubrp  st(2), st
    fxch    st(1)
    fstp    [ebp+var_64]
    fld     st(1)
    fsub    st, st(1)
    fstp    [ebp+var_5C]
    faddp   st(1), st
    fstp    [ebp+var_54]
    fld     st
    fsub    st, st(3)
    fabs
    fcomp   dbl_1000C000
    fnstsw  ax
    jp      short loc_1000309E
    fxch    st(2)
    fmulp   st(1), st
  }
  _EBX = 0;
  __asm { fstp    qword ptr [ecx+8] }
  _EDI = 0;
  while ( 1 )
  {
    v14 = a2;
    v15 = 0;
    __asm { fstp    [esp+0FCh+var_F4] }
    v17 = (int)&v54;
    __asm
    {
      fld     [ebp+edi*8+var_AC]
      fstp    [esp+0FCh+var_FC]
    }
    sub_10002150(v14, v17, v18, v16, v15);
    __asm { fld     dbl_1000C000 }
    v19 = &v54;
    v20 = &v55;
    __asm { fstp    [esp+0F8h+var_FC+4] }
    UF_VEC3_unitize(&v54, v21, *((_DWORD *)&v21 + 1), v20, v19);
    __asm { fld     dbl_1000C000 }
    v22 = &v56;
    __asm { fstp    [esp+0F4h+var_F4] }
    UF_VEC3_is_equal(&v35, &v54, v23, *((_DWORD *)&v23 + 1), v22);
    if ( v56 )
    {
      __asm { fld     [ebp+edi*8+var_AC] }
      ++_EBX;
      __asm { fstp    [ebp+ebx*8+var_E4] }
    }
    ++_EDI;
    if ( _EDI >= 6 )
      break;
    __asm { fld     [ebp+var_34] }
  }
  qsort(&v57, _EBX - 1, 8u, sub_100023F0);
  __asm { fld     [ebp+var_DC] }
  _ECX = a3;
  __asm { fstp    qword ptr [ecx] }
  _EBX = 0;
  _EDI = 0;
  do
  {
    __asm { fld     [ebp+var_2C] }
    v25 = a2;
    v26 = 0;
    __asm { fstp    [esp+0FCh+var_F4] }
    v28 = (int)&v54;
    __asm
    {
      fld     [ebp+edi*8+var_7C]
      fstp    [esp+0FCh+var_FC]
    }
    sub_10002150(v25, v28, v29, v27, v26);
    __asm { fld     dbl_1000C000 }
    v30 = &v54;
    v31 = &v55;
    __asm { fstp    [esp+0F8h+var_FC+4] }
    UF_VEC3_unitize(&v54, v32, *((_DWORD *)&v32 + 1), v31, v30);
    __asm { fld     dbl_1000C000 }
    v33 = &v56;
    __asm { fstp    [esp+0F4h+var_F4] }
    UF_VEC3_is_equal(&v35, &v54, v34, *((_DWORD *)&v34 + 1), v33);
    if ( v56 )
    {
      __asm { fld     [ebp+edi*8+var_7C] }
      ++_EBX;
      __asm { fstp    [ebp+ebx*8+var_E4] }
    }
    ++_EDI;
  }
  while ( _EDI < 6 );
  qsort(&v57, _EBX - 1, 8u, sub_100023F0);
  __asm { fld     [ebp+var_DC] }
  result = a3;
  __asm { fstp    qword ptr [eax+8] }
  return result;
}

//----- (10003210) --------------------------------------------------------
signed int __usercall sub_10003210<eax>(int a1<ebx>, int a2<edi>, int a3<esi>, const void *a4, int a5, int a6)
{
  int ST40_4_0; // ST40_4@0
  int ST44_4_0; // ST44_4@0
  int ST48_4_0; // ST48_4@0
  int v11; // ST34_4@1
  int v12; // ST38_4@1
  int v13; // ST3C_4@1
  signed int result; // eax@7
  signed int v15; // ecx@8
  int v16; // esi@8
  signed int v19; // eax@58
  signed int v21; // esi@68
  int v22; // eax@69
  signed int v23; // eax@74
  int (__cdecl *v25)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // esi@77
  int *v26; // ST38_4@77
  int v27; // ST3C_4@77
  char v28; // zf@1
  __int64 v30; // ST2C_8@2
  __int64 v31; // ST24_8@2
  __int64 v32; // ST1C_8@2
  __int64 v33; // ST14_8@2
  __int64 v34; // ST0C_8@2
  __int64 v35; // ST04_8@2
  int v36; // ST28_4@4
  int v37; // ST2C_4@4
  int v38; // ST30_4@4
  __int64 v39; // ST28_8@6
  __int64 *v40; // ST3C_4@8
  char *v41; // ST38_4@8
  __int64 v42; // ST30_8@8
  double v45; // ST38_8@10
  double v49; // ST38_8@11
  double v65; // ST38_8@18
  __int64 v87; // ST38_8@38
  __int64 v88; // ST30_8@38
  __int64 v89; // ST28_8@38
  __int64 v90; // ST20_8@38
  __int64 v91; // ST18_8@38
  __int64 v92; // ST10_8@38
  __int64 v93; // ST38_8@38
  int v112; // eax@59
  int v113; // ecx@59
  int v114; // edx@59
  int v115; // esi@59
  int v116; // esi@59
  int v117; // eax@59
  __int64 v119; // ST38_8@63
  __int64 v120; // ST30_8@63
  __int64 v121; // ST28_8@63
  __int64 v122; // ST20_8@63
  __int64 v123; // ST38_8@63
  __int64 v124; // ST30_8@63
  __int64 v125; // ST28_8@63
  __int64 v126; // ST20_8@63
  int v127; // ST3C_4@65
  double v128; // ST34_8@65
  double v129; // ST2C_8@65
  int v130; // ST3C_4@65
  double v131; // ST34_8@65
  double v132; // ST2C_8@65
  int v133; // ST3C_4@67
  double v134; // ST34_8@67
  int v135; // ST3C_4@67
  double v136; // ST34_8@67
  int v138; // ST3C_4@75
  __int64 *v139; // ST38_4@75
  __int64 v140; // ST30_8@75
  int v141; // ST3C_4@75
  __int64 *v142; // ST38_4@75
  __int64 v143; // ST30_8@75
  int v144; // ST3C_4@75
  double v145; // ST34_8@75
  int v146; // ST3C_4@75
  double v147; // ST34_8@75
  int v149; // ST3C_4@77
  double v150; // ST34_8@77
  int *v151; // ST3C_4@77
  char *v152; // ST38_4@77
  __int64 v153; // ST30_8@77
  int v155; // ST3C_4@77
  int *v156; // ST38_4@77
  __int64 v157; // ST30_8@77
  int v160; // ST3C_4@79
  double v161; // ST34_8@79
  double v162; // ST2C_8@79
  int v163; // ST3C_4@79
  double v164; // ST34_8@79
  double v165; // ST2C_8@79
  int *v166; // ST3C_4@79
  char *v167; // ST38_4@79
  __int64 v168; // ST30_8@79
  char *v169; // ST3C_4@79
  char *v170; // ST38_4@79
  __int64 v171; // ST30_8@79
  int v173; // ST3C_4@79
  int *v174; // ST38_4@79
  __int64 v175; // ST30_8@79
  __int64 v177; // ST30_8@80
  char v178; // zf@82
  char v191; // [sp+103h] [bp-1h]@1
  signed int v192; // [sp+D4h] [bp-30h]@1
  int v193; // [sp+3Ch] [bp-C8h]@4
  char v194; // [sp+54h] [bp-B0h]@4
  __int64 v195; // [sp+9Ch] [bp-68h]@8
  char v196; // [sp+7Ch] [bp-88h]@8
  int v209; // [sp+40h] [bp-C4h]@59
  int v210; // [sp+44h] [bp-C0h]@59
  int v211; // [sp+48h] [bp-BCh]@59
  int v212; // [sp+4Ch] [bp-B8h]@59
  int v213; // [sp+50h] [bp-B4h]@59
  __int64 v214; // [sp+8Ch] [bp-78h]@65
  int v216; // [sp+BCh] [bp-48h]@77
  char v217; // [sp+84h] [bp-80h]@79

  v28 = byte_1000C588 == 0;
  __asm { fldz }
  _EAX = a5;
  v13 = a1;
  _EBX = a6;
  __asm { fst     qword ptr [ebx] }
  v12 = a3;
  __asm
  {
    fst     qword ptr [eax]
    fst     qword ptr [ebx+8]
  }
  v11 = a2;
  _EDI = a4;
  __asm
  {
    fst     qword ptr [eax+8]
    fst     qword ptr [ebx+10h]
  }
  v191 = 0;
  __asm { fst     qword ptr [eax+10h] }
  v192 = 0;
  __asm
  {
    fst     qword ptr [ebx+18h]
    fst     qword ptr [eax+18h]
    fst     qword ptr [ebx+20h]
    fstp    qword ptr [eax+20h]
  }
  if ( !v28 )
  {
    printf("\n------------------------------------------------------\n", v11, a3, v13);
    __asm
    {
      fld     qword ptr [edi+28h]
      fstp    [esp+104h+var_DC]
      fld     qword ptr [edi+20h]
      fstp    [esp+104h+var_E4]
      fld     qword ptr [edi+18h]
      fstp    [esp+104h+var_EC]
      fld     qword ptr [edi+10h]
      fstp    [esp+104h+var_F4]
      fld     qword ptr [edi+8]
      fstp    [esp+104h+var_FC]
      fld     qword ptr [edi]
      fstp    [esp+104h+var_104]
    }
    printf("Starting old_pcoord_t[] = (%f,%f,%f,%f,%f,%f)\n", v35, *((_DWORD *)&v35 + 1), v34, v33, v32, v31, v30);
  }
  if ( dword_1000C3DC == 3 )
  {
    UF_MTX3_vec_multiply_t(_EDI, &unk_10009978, &v193, v11, v12, v13);
    UF_MTX3_vec_multiply_t((char *)_EDI + 24, &unk_10009978, &v194, v36, v37, v38);
  }
  else
  {
    memcpy(&v193, _EDI, 0x30u);
    _EDI = a4;
  }
  __asm
  {
    fld     dbl_1000C000
    fstp    [esp+0E0h+var_E4+4]
  }
  UF_VEC3_is_zero(&v194, v39, *((_DWORD *)&v39 + 1));
  if ( a6 )
    return 4;
  __asm { fld     dbl_1000C000 }
  v40 = &v195;
  v41 = &v196;
  __asm { fstp    [esp+0D8h+var_DC+4] }
  UF_VEC3_unitize(&v194, v42, *((_DWORD *)&v42 + 1), v41, v40);
  __asm { fld     qword ptr [ebp+var_68] }
  v16 = dword_1000C3D8;
  __asm
  {
    fst     [ebp+var_70]
    fld     [ebp+var_60]
  }
  v15 = *(_DWORD *)v16;
  __asm
  {
    fst     [ebp+var_90]
    fld     [ebp+var_58]
    fst     [ebp+var_98]
  }
  if ( v15 != 3 )
  {
    __asm
    {
      fld     dbl_1000C298
      fmul    st, st(1)
      fld     dbl_1000C278
      fmul    st, st(3)
      faddp   st(1), st
      fld     dbl_1000C258
      fmul    st, st(4)
      faddp   st(1), st
      fld     dbl_1000C2A0
      fmul    st, st(2)
      fld     dbl_1000C280
      fmul    st, st(4)
      faddp   st(1), st
      fld     dbl_1000C260
      fmul    st, st(5)
      faddp   st(1), st
      fmul    dbl_1000C560
      fsubp   st(1), st
      fld     dbl_1000C4D8
      fmul    st(1), st
      fxch    st(1)
      fstp    [ebp+var_2C]
      fld     dbl_1000C288
      fmul    st, st(2)
      fld     dbl_1000C268
      fmul    st, st(4)
      faddp   st(1), st
      fld     dbl_1000C248
      fmul    st, st(5)
      faddp   st(1), st
      fld     dbl_1000C290
      fmulp   st(3), st
      fld     dbl_1000C270
      fmulp   st(4), st
      fxch    st(2)
      faddp   st(3), st
      fld     dbl_1000C250
      fmulp   st(4), st
      fxch    st(2)
      faddp   st(3), st
      fld     dbl_1000C310
      fld     st
      fabs
      fld     dbl_1000C000
      fcom    st(1)
      fnstsw  ax
      fstp    st(1)
    }
    if ( HIBYTE(_AX) & 1 )
    {
      if ( v15 == 1 )
      {
        __asm { fld     dbl_1000C308 }
      }
      else
      {
        if ( v15 == 2 )
          __asm { fld     dbl_1000C308 }
        else
          __asm { fld     [ebp+var_38] }
      }
      __asm
      {
        fsub    [ebp+var_2C]
        fdiv    st, st(2)
        fstp    [ebp+var_2C]
        fldz
      }
    }
    else
    {
      __asm { fldz }
      v191 = 1;
      __asm { fst     [ebp+var_2C] }
    }
    __asm
    {
      fld     st(5)
      fmul    st, st(6)
      fld     st(4)
      fmul    st, st(5)
      faddp   st(1), st
      fsqrt
      fld     st(4)
      fabs
      fcomp   st(3)
      fnstsw  ax
      jp      short loc_10003685
      fld     st(6)
      fabs
      fcomp   st(3)
      fnstsw  ax
      jp      short loc_10003685
      fstp    st(6)
      fstp    st(3)
      fxch    st(2)
      fst     [ebp+var_50]
      fld     st(4)
      fabs
      fcomp   st(3)
      fnstsw  ax
      jp      short loc_100036A9
      fstp    st(4)
      fld     st(3)
      fst     [ebp+var_2C]
      fld     st
      fabs
      fld     st(3)
      fld1
      fadd    st(1), st
      fxch    st(2)
      fcompp  st(1), st
      fnstsw  ax
    }
    if ( HIBYTE(_AX) & 0x41 )
    {
      __asm
      {
        fld     st(1)
        fmul    st, st(2)
        fsubr   st, st(1)
        fld     st
        fabs
        fcomp   st(5)
        fnstsw  ax
        jp      short loc_1000376D
        fstp    st
        fld     st(5)
        fld     st(2)
        fsubrp  st(2), st
        fxch    st(1)
        fabs
        fcomp   st(4)
        fnstsw  ax
        jp      short loc_10003784
        fstp    st
        fld     st(4)
        fld     st
      }
      _ECX = 0;
      __asm
      {
        fld     st(2)
        fxch    st(1)
        fpatan
        fadd    [ebp+var_50]
        fstp    [ebp+var_14]
        fchs
        fpatan
        fadd    [ebp+var_50]
        fstp    [ebp+var_C]
        fld     dbl_1000C4D0
        fabs
        fstp    [ebp+var_2C]
      }
    }
    else
    {
      __asm
      {
        fstp    st(1)
        fstp    st(4)
        fstp    st
        fstp    st(1)
        fstp    st
        fstp    st
        fld     qword ptr [edi+28h]
        fstp    [esp+0F8h+var_D0]
        fld     qword ptr [edi+20h]
        fstp    [esp+0F8h+var_DC+4]
        fld     qword ptr [edi+18h]
        fstp    [esp+0F8h+var_E4+4]
        fld     qword ptr [edi+10h]
        fstp    [esp+0F8h+var_EC+4]
        fld     qword ptr [edi+8]
        fstp    [esp+0F8h+var_F4+4]
        fld     qword ptr [edi]
        fstp    [esp+0F8h+var_FC+4]
      }
      printf("INPUT Point =%-.4f,%-.4f,%-.4f,%-.8f,%-.8f,%-.8f\n", v92, *((_DWORD *)&v92 + 1), v91, v90, v89, v88, v87);
      __asm
      {
        fld     [ebp+var_2C]
        fstp    [esp+0D0h+var_D0]
      }
      printf("WARNING: Degenerated G_lambda(%f) out of range (-1, 1)\n", v93, *((_DWORD *)&v93 + 1));
      __asm
      {
        fldz
        fst     [ebp+var_C]
        fst     [ebp+var_14]
        fld     dbl_1000C000
      }
      _ECX = 0;
      __asm
      {
        fld     dbl_1000C4D8
        fld     dbl_1000C310
        fxch    st(1)
        fxch    st(2)
        fxch    st(1)
        fld     dbl_1000C4D0
        fabs
        fstp    [ebp+var_2C]
      }
    }
    while ( 1 )
    {
      __asm
      {
        fld     [ebp+ecx+var_14]
        fsin
        fld     [ebp+ecx+var_14]
        fcos
        fxch    st(3)
        fcom    [ebp+var_2C]
        fnstsw  ax
      }
      if ( HIBYTE(_AX) & 1 )
      {
        __asm
        {
          fstp    st(5)
          fstp    st(4)
          fld     st(3)
          fmul    st, st(3)
          fchs
          fld     st(2)
          fmulp   st(4), st
          fxch    st(1)
          fmul    dbl_1000C560
          fchs
          fstp    [ebp+var_50]
          fld     st(3)
          fmul    dbl_1000C290
          fld     st(2)
          fmul    dbl_1000C288
          faddp   st(1), st
          fld     dbl_1000C558
          fmul    dbl_1000C2A0
          fsubp   st(1), st
          fmul    [ebp+var_98]
          fld     st(4)
          fmul    dbl_1000C270
          fld     st(3)
          fmul    dbl_1000C268
          faddp   st(1), st
          fld     dbl_1000C558
          fmul    dbl_1000C280
          fsubp   st(1), st
          fmul    [ebp+var_90]
          faddp   st(1), st
          fxch    st(4)
          fmul    dbl_1000C250
          fxch    st(2)
          fmul    dbl_1000C248
          faddp   st(2), st
          fld     dbl_1000C558
          fmul    dbl_1000C260
          fsubp   st(2), st
          fxch    st(1)
          fmul    [ebp+var_70]
          faddp   st(3), st
          fxch    st(2)
          fdiv    dbl_1000C4D0
          fstp    [ebp+var_38]
          fld     dbl_1000C310
          fld     dbl_1000C298
          fmul    st, st(1)
          fld     st(2)
          fmul    dbl_1000C290
          faddp   st(1), st
          fld     st(3)
          fmul    dbl_1000C288
          faddp   st(1), st
          fld     [ebp+var_50]
          fld     dbl_1000C2A0
          fmul    st, st(1)
          faddp   st(2), st
          fxch    st(1)
          fmul    [ebp+var_98]
          fld     st(2)
          fmul    dbl_1000C278
          fld     st(4)
          fmul    dbl_1000C270
          faddp   st(1), st
          fld     st(5)
          fmul    dbl_1000C268
          faddp   st(1), st
          fld     st(2)
          fmul    dbl_1000C280
          faddp   st(1), st
          fmul    [ebp+var_90]
          faddp   st(1), st
          fld     st(2)
          fmul    dbl_1000C258
          fxch    st(4)
          fmul    dbl_1000C250
          faddp   st(4), st
          fxch    st(4)
          fmul    dbl_1000C248
          faddp   st(3), st
          fmul    dbl_1000C260
          faddp   st(2), st
          fxch    st(1)
          fmul    [ebp+var_70]
          faddp   st(2), st
          fld     ds:dbl_100099D0
          fdiv    dbl_1000C4D0
          fmulp   st(2), st
          fldz
          fld     dbl_1000C000
          fld     dbl_1000C4D8
          fld     [ebp+var_38]
          fxch    st(3)
          fxch    st(5)
          fxch    st(1)
          fxch    st(4)
          fxch    st(2)
          fxch    st(3)
        }
      }
      else
      {
        __asm
        {
          fstp    st(3)
          fstp    st
          fld     st(3)
          fld     st(4)
        }
      }
      __asm
      {
        fld     st
        fabs
        fcomp   st(4)
        fnstsw  ax
        jp      short loc_10003954
        fld     st(1)
        fabs
        fcomp   st(4)
        fnstsw  ax
        jp      short loc_10003954
        fstp    st(1)
      }
      v191 = 1;
      __asm
      {
        fstp    st
        fxch    st(3)
        fst     [ebp+ecx+var_24]
      }
      _ECX += 8;
      if ( _ECX >= 16 )
        break;
      __asm { fxch    st(3) }
    }
    v16 = dword_1000C3D8;
    __asm { fstp    st }
    goto LABEL_50;
  }
  if ( dword_1000C3DC )
  {
    if ( dword_1000C3DC != 1 && dword_1000C3DC != 3 )
    {
      __asm
      {
        fstp    st
        fstp    st
        fstp    st
      }
      return 2;
    }
    __asm
    {
      fld     dbl_1000C300
      fld     st
      fld1
      fsub    st(1), st
      fxch    st(1)
      fabs
      fld     dbl_1000C000
      fcom    st(1)
      fnstsw  ax
      fstp    st(1)
    }
    if ( HIBYTE(_AX) & 1 )
    {
      __asm
      {
        fld     st(2)
        fmul    st, st(3)
        fsub    st(4), st
        fsubr   st, st(2)
        fdivp   st(4), st
        fld     st(3)
        fabs
        fld     st(1)
        fadd    st, st(3)
        fcompp  st(1), st
        fnstsw  ax
        jnp     short loc_100034CB
        fstp    st(4)
        fstp    st(4)
        fstp    st
        fstp    st(1)
        fstp    st(1)
        fstp    [esp+0D0h+var_D0]
      }
      sub_10001F50(v65);
      __asm
      {
        fst     [ebp+var_14]
        fchs
      }
      _ECX = 0;
      __asm
      {
        fstp    [ebp+var_C]
        fld     [ebp+var_60]
        fld     qword ptr [ebp+var_68]
        fld     dbl_1000C000
        fld     dbl_1000C300
        fld1
        fxch    st(3)
        fxch    st(4)
        fxch    st(3)
        fld     dbl_1000C2F8
      }
    }
    else
    {
      __asm
      {
        fstp    st(3)
        fld     dbl_1000C460
      }
      _ECX = 0;
      __asm
      {
        fstp    [ebp+var_14]
        fld     dbl_1000C468
        fstp    [ebp+var_C]
        fld     dbl_1000C2F8
      }
    }
    while ( 1 )
    {
      __asm
      {
        fld     [ebp+ecx+var_14]
        fsin
        fld     [ebp+ecx+var_14]
        fcos
        fsubp   st(3), st
        fxch    st(2)
        fmulp   st(3), st
        fld     st(2)
        fmul    dbl_1000C2F0
        fld     st(1)
        fmul    st, st(3)
        faddp   st(1), st
        fxch    st(3)
        fmul    st, st(1)
        fld     dbl_1000C2F0
        fmulp   st(3), st
        fsubrp  st(2), st
        fld     st(1)
        fmul    st, st(5)
        fld     st(3)
        fmul    st, st(7)
        faddp   st(1), st
        fxch    st(3)
        fmul    st, st(5)
        fxch    st(2)
        fmul    st, st(6)
        fsubp   st(2), st
        fld     st(1)
        fabs
        fcomp   st(4)
        fnstsw  ax
        jp      short loc_10003563
        fld     st(2)
        fabs
        fcomp   st(4)
        fnstsw  ax
        jp      short loc_10003563
        fstp    st(1)
      }
      v191 = 1;
      __asm
      {
        fstp    st(1)
        fld     dbl_1000C318[ecx]
        fstp    [ebp+ecx+var_24]
      }
      _ECX += 8;
      if ( _ECX >= 16 )
        break;
      __asm
      {
        fld1
        fld     dbl_1000C300
        fxch    st(2)
      }
    }
    __asm { fstp    st(2) }
LABEL_50:
    __asm
    {
      fstp    st(2)
      fstp    st
    }
    if ( !v191 )
      goto LABEL_54;
    goto LABEL_51;
  }
  __asm
  {
    fstp    st
    fstp    st(1)
    fchs
  }
  CIasin(ST40_4_0, ST44_4_0, ST48_4_0);
  __asm
  {
    fstp    [ebp+var_14]
    fld     [ebp+var_58]
    fmul    st, st
    fld     qword ptr [ebp+var_68]
    fmul    st, st
    faddp   st(1), st
    fsqrt
    fst     [ebp+var_70]
    fstp    [esp+0D0h+var_D0]
  }
  sub_10001F50(v45);
  __asm
  {
    fst     [ebp+var_C]
    fsubr   [ebp+var_14]
    fabs
    fld     dbl_1000C000
    fcom    st(1)
    fnstsw  ax
    fstp    st(1)
  }
  if ( !(HIBYTE(_AX) & 1) )
  {
    __asm
    {
      fstp    st
      fld     [ebp+var_70]
      fchs
      fstp    [esp+0D0h+var_D0]
    }
    sub_10001F50(v49);
    __asm
    {
      fstp    [ebp+var_C]
      fld     dbl_1000C000
    }
  }
  __asm
  {
    fld     qword ptr [ebp+var_68]
    fld     st
    fabs
    fcomp   st(2)
    fnstsw  ax
    fld     [ebp+var_58]
    jp      short loc_10003412
    fld     st
    fabs
    fcomp   st(3)
    fnstsw  ax
    jp      short loc_10003412
    fstp    st
  }
  v191 = 1;
  __asm
  {
    fstp    st
    fld     dbl_1000C318
    fstp    [ebp+var_24]
    fld     dbl_1000C320
    fstp    [ebp+var_1C]
  }
LABEL_51:
  if ( *(_DWORD *)v16 != 3 )
  {
    __asm
    {
      fld     dbl_1000C460
      fstp    [ebp+var_14]
      fld     dbl_1000C468
      fstp    [ebp+var_C]
      fld     dbl_1000C318
      fstp    [ebp+var_24]
      fld     dbl_1000C320
      fstp    [ebp+var_1C]
    }
  }
  v192 = 1;
LABEL_54:
  if ( byte_1000C009 && (*(_DWORD *)v16 == 2 || *(_DWORD *)v16 == 3) )
  {
    __asm { fstp    st }
    sub_10002430();
    __asm { fld     [ebp+var_14] }
    result = v192;
    __asm
    {
      fstp    dbl_1000C530
      fld     [ebp+var_C]
      fstp    dbl_1000C538
      fld     [ebp+var_24]
      fstp    dbl_1000C2E0
      fld     [ebp+var_1C]
      fstp    dbl_1000C2E8
    }
    return result;
  }
  v19 = *(_DWORD *)v16;
  if ( *(_DWORD *)v16 == 1 )
  {
    _EDI = a5;
    v112 = v193;
    v113 = v209;
    v114 = v210;
    v115 = v211;
    *(_DWORD *)a5 = v193;
    *(_DWORD *)(a5 + 4) = v113;
    *(_DWORD *)(a5 + 8) = v114;
    *(_DWORD *)(a5 + 12) = v115;
    *(_DWORD *)(a5 + 16) = v212;
    v116 = v213;
    *(_DWORD *)(a5 + 20) = v213;
    *(_DWORD *)_EBX = v112;
    v117 = v212;
    *(_DWORD *)(_EBX + 4) = v113;
    *(_DWORD *)(_EBX + 8) = v114;
    *(_DWORD *)(_EBX + 12) = v211;
    *(_DWORD *)(_EBX + 16) = v117;
    *(_DWORD *)(_EBX + 20) = v116;
    goto LABEL_74;
  }
  if ( v19 != 2 && v19 != 3 )
  {
    _EDI = a5;
  }
  else
  {
    __asm { fstp    st }
    if ( byte_1000C588 )
    {
      printf("About adjusting theta with initial angle...\n");
      __asm
      {
        fld     dbl_1000C2E0
        fld     ds:dbl_10009308
        fmul    st(1), st
        fld     [ebp+var_24]
        fsub    st(2), st
        fld     ds:dbl_100099E0
        fmul    st(3), st
        fxch    st(3)
        fstp    [esp+0E8h+var_D0]
        fld     dbl_1000C530
        fmulp   st(2), st
        fld     [ebp+var_14]
        fsub    st(2), st
        fxch    st(2)
        fmul    st, st(3)
        fstp    [esp+0E8h+var_DC+4]
        fmul    st, st(2)
        fstp    [esp+0E8h+var_E4+4]
        fmulp   st(1), st
        fstp    [esp+0E8h+var_EC+4]
      }
      printf(
        "computing t1[0]=%f, t2[0]=%f, (Init_T1[0]*2-t1[0])=%f,(Init_T2[0]*2-t2[0])=%f\n",
        v122,
        *((_DWORD *)&v122 + 1),
        v121,
        v120,
        v119);
      __asm
      {
        fld     dbl_1000C2E8
        fld     ds:dbl_10009308
        fmul    st(1), st
        fld     [ebp+var_1C]
        fsub    st(2), st
        fld     ds:dbl_100099E0
        fmul    st(3), st
        fxch    st(3)
        fstp    [esp+0E8h+var_D0]
        fld     dbl_1000C538
        fmulp   st(2), st
        fld     [ebp+var_C]
        fsub    st(2), st
        fxch    st(2)
        fmul    st, st(3)
        fstp    [esp+0E8h+var_DC+4]
        fmul    st, st(2)
        fstp    [esp+0E8h+var_E4+4]
        fmulp   st(1), st
        fstp    [esp+0E8h+var_EC+4]
      }
      printf(
        "computing t1[1]=%f, t2[1]=%f, (Init_T1[1]*2-t1[1])=%f,(Init_T2[1]*2-t2[1])=%f\n",
        v126,
        *((_DWORD *)&v126 + 1),
        v125,
        v124,
        v123);
    }
    sub_10002430();
    if ( *(_DWORD *)dword_1000C3D8 == 2 )
    {
      __asm
      {
        fld     [ebp+var_14]
        fstp    [ebp+var_78]
        fld     [ebp+var_C]
        fstp    [ebp+var_70]
        fld     [ebp+var_24]
        fstp    [ebp+var_40]
        fld     [ebp+var_1C]
        fstp    [ebp+var_38]
      }
      sub_10002FE0((int)&v195, (int)&v214);
      __asm { fld     [ebp+var_78] }
      _EDI = a5;
      __asm
      {
        fst     [ebp+var_14]
        fld     [ebp+var_70]
      }
      v127 = 1;
      __asm
      {
        fstp    [ebp+var_C]
        fld     [ebp+var_40]
        fst     [ebp+var_24]
        fld     [ebp+var_38]
        fstp    [ebp+var_1C]
        fstp    qword ptr [esp+8]
        fstp    [esp+0DCh+var_DC]
      }
      sub_10002150((int)&v193, a5, v129, v128, v127);
      __asm { fld     [ebp+var_38] }
      v130 = 1;
      __asm
      {
        fstp    qword ptr [esp+8]
        fld     [ebp+var_70]
        fstp    [esp+0DCh+var_DC]
      }
      sub_10002150((int)&v193, _EBX, v132, v131, v130);
LABEL_66:
      __asm { fld     dbl_1000C000 }
      goto LABEL_74;
    }
    _EDI = a5;
    __asm { fld     [ebp+var_24] }
    v133 = a5;
    __asm
    {
      fchs
      fstp    qword ptr [esp]
    }
    sub_10002350((int)&v193, v134, v133);
    __asm
    {
      fld     [ebp+var_1C]
      fchs
    }
    v135 = _EBX;
    __asm { fstp    qword ptr [esp] }
    sub_10002350((int)&v193, v136, v135);
    if ( dword_1000C3DC != 3 )
      goto LABEL_66;
    v21 = 0;
    do
    {
      v22 = _EDI;
      if ( v21 )
        v22 = _EBX;
      UF_MTX3_vec_multiply_t(v22, &unk_10009930, v22, ST40_4_0, ST44_4_0, ST48_4_0);
      ++v21;
    }
    while ( v21 < 2 );
    __asm { fld     dbl_1000C000 }
  }
LABEL_74:
  _ECX = dword_1000C3D8;
  v23 = *(_DWORD *)dword_1000C3D8;
  if ( *(_DWORD *)dword_1000C3D8 == 1 )
  {
    __asm
    {
      fstp    st
      fld     qword ptr [ecx+90h]
    }
    v138 = _EDI;
    __asm { fadd    qword ptr [ecx+88h] }
    v139 = &v195;
    __asm
    {
      fst     [ebp+var_38]
      fstp    [esp+0D8h+var_DC+4]
    }
    UF_VEC3_affine_comb(_EDI, v140, *((_DWORD *)&v140 + 1), v139, v138);
    __asm { fld     [ebp+var_38] }
    v141 = _EBX;
    v142 = &v195;
    __asm { fstp    [esp+0D8h+var_DC+4] }
    UF_VEC3_affine_comb(_EBX, v143, *((_DWORD *)&v143 + 1), v142, v141);
    __asm { fld     [ebp+var_14] }
    v144 = _EDI;
    __asm { fstp    qword ptr [esp] }
    sub_100022D0(_EDI, v145, v144);
    __asm { fld     [ebp+var_C] }
    v146 = _EBX;
    __asm { fstp    qword ptr [esp] }
    sub_100022D0(_EBX, v147, v146);
LABEL_81:
    __asm { fld     dbl_1000C000 }
    goto LABEL_82;
  }
  if ( v23 == 3 )
  {
    __asm
    {
      fstp    st
      fld     [ebp+var_24]
    }
    v149 = (int)&v216;
    __asm
    {
      fchs
      fstp    qword ptr [esp]
    }
    sub_10002350((int)&v195, v150, v149);
    __asm { fld     dbl_1000C000 }
    v151 = &v216;
    v152 = &v196;
    __asm { fstp    [esp+0D8h+var_DC+4] }
    UF_VEC3_unitize(&v216, v153, *((_DWORD *)&v153 + 1), v152, v151);
    _EDX = dword_1000C3D8;
    __asm { fld     qword ptr [edx+88h] }
    v25 = UF_VEC3_affine_comb;
    v155 = _EDI;
    v156 = &v216;
    __asm { fstp    [esp+0D8h+var_DC+4] }
    UF_VEC3_affine_comb(_EDI, v157, *((_DWORD *)&v157 + 1), v156, v155);
    _ECX = dword_1000C3D8;
    __asm { fld     qword ptr [ecx+88h] }
    v27 = _EBX;
    v26 = &v216;
LABEL_80:
    __asm { fstp    [esp+0D8h+var_DC+4] }
    v25(_EBX, v177, *((_DWORD *)&v177 + 1), v26, v27);
    goto LABEL_81;
  }
  if ( v23 == 2 )
  {
    __asm { fstp    st }
    v160 = 0;
    __asm
    {
      fld     [ebp+var_24]
      fstp    qword ptr [esp+8]
      fld     [ebp+var_14]
      fstp    [esp+0DCh+var_DC]
    }
    sub_10002150((int)&v195, (int)&v216, v162, v161, v160);
    __asm { fld     [ebp+var_1C] }
    v163 = 0;
    __asm
    {
      fstp    qword ptr [esp+8]
      fld     [ebp+var_C]
      fstp    [esp+0DCh+var_DC]
    }
    sub_10002150((int)&v195, (int)&v217, v165, v164, v163);
    __asm { fld     dbl_1000C000 }
    v166 = &v216;
    v167 = &v196;
    __asm { fstp    [esp+0D8h+var_DC+4] }
    UF_VEC3_unitize(&v216, v168, *((_DWORD *)&v168 + 1), v167, v166);
    __asm { fld     dbl_1000C000 }
    v169 = &v217;
    v170 = &v196;
    __asm { fstp    [esp+0D8h+var_DC+4] }
    UF_VEC3_unitize(&v217, v171, *((_DWORD *)&v171 + 1), v170, v169);
    _EAX = dword_1000C3D8;
    __asm { fld     qword ptr [eax+88h] }
    v25 = UF_VEC3_affine_comb;
    v173 = _EDI;
    v174 = &v216;
    __asm { fstp    [esp+0D8h+var_DC+4] }
    UF_VEC3_affine_comb(_EDI, v175, *((_DWORD *)&v175 + 1), v174, v173);
    _EDX = dword_1000C3D8;
    __asm { fld     qword ptr [edx+88h] }
    v27 = _EBX;
    v26 = (int *)&v217;
    goto LABEL_80;
  }
LABEL_82:
  v178 = byte_1000C008 == 0;
  __asm
  {
    fld     [ebp+var_14]
    fld     st
    fld     ds:dbl_100099E0
    fmul    st(1), st
    fxch    st(1)
    fstp    qword ptr [edi+18h]
    fld     [ebp+var_C]
    fld     st
    fmul    st, st(2)
    fstp    qword ptr [ebx+18h]
    fld     [ebp+var_24]
    fld     st
    fmul    st, st(3)
    fstp    qword ptr [edi+20h]
    fld     [ebp+var_1C]
    fmulp   st(3), st
    fxch    st(2)
    fstp    qword ptr [ebx+20h]
  }
  if ( !v178 )
  {
    if ( *(_DWORD *)dword_1000C3D8 != 3 )
    {
      __asm
      {
        fld     qword ptr [edi+20h]
        fld     ds:dbl_10009A38
        fsub    st(1), st
        fxch    st(1)
        fst     qword ptr [edi+20h]
        fld     ds:dbl_10009A30
        fcom    st(1)
        fnstsw  ax
        fld     ds:dbl_100099F0
      }
      if ( HIBYTE(_AX) & 0x41 )
      {
        __asm { fstp    st(2) }
      }
      else
      {
        __asm
        {
          fadd    st(2), st
          fxch    st(2)
          fstp    qword ptr [edi+20h]
        }
      }
      __asm
      {
        fld     qword ptr [ebx+20h]
        fsubrp  st(3), st
        fxch    st(2)
        fst     qword ptr [ebx+20h]
        fcom    st(2)
        fnstsw  ax
        fstp    st(2)
        jp      short loc_10003E90
        faddp   st(1), st
        fstp    qword ptr [ebx+20h]
      }
    }
  }
  if ( v191 )
  {
    if ( *(_DWORD *)dword_1000C3D8 != 3 )
    {
      *(_DWORD *)(_EDI + 24) = dword_1000C4F8;
      *(_DWORD *)(_EDI + 28) = dword_1000C4FC;
      *(_DWORD *)(_EDI + 32) = dword_1000C500;
      *(_DWORD *)(_EDI + 36) = dword_1000C504;
      *(_DWORD *)(_EBX + 24) = dword_1000C520;
      *(_DWORD *)(_EBX + 28) = dword_1000C524;
      *(_DWORD *)(_EBX + 32) = dword_1000C528;
      *(_DWORD *)(_EBX + 36) = dword_1000C52C;
    }
  }
  if ( byte_1000C588 )
  {
    __asm
    {
      fsubp   st(2), st
      fxch    st(1)
      fabs
      fcomp   st(2)
      fnstsw  ax
      jp      short loc_10003F24
      fsub    [ebp+var_1C]
      fabs
      fcompp  st(1), st
      fnstsw  ax
      jp      short loc_10003F28
    }
    printf("WARNING: same value of rotary produced:\n");
  }
  else
  {
    __asm
    {
      fstp    st
      fstp    st(1)
      fstp    st(1)
      fstp    st
    }
  }
  __asm { fld     [ebp+var_14] }
  result = v192;
  memcpy(&dword_1000C4E0, (const void *)a5, 0x28u);
  memcpy(&dword_1000C508, (const void *)_EBX, 0x28u);
  __asm
  {
    fstp    dbl_1000C460
    fld     [ebp+var_C]
    fstp    dbl_1000C468
    fld     [ebp+var_24]
    fstp    dbl_1000C318
    fld     [ebp+var_1C]
    fstp    dbl_1000C320
  }
  return result;
}

//----- (10003F80) --------------------------------------------------------
int __cdecl sub_10003F80(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // esi@1
  int v8; // edi@1
  __int64 v48; // [sp+3Ch] [bp-40h]@1
  char v49; // [sp+Ch] [bp-70h]@1
  __int64 v50; // [sp+24h] [bp-58h]@1
  __int64 v51; // [sp+5Ch] [bp-20h]@1
  __int64 v52; // [sp+64h] [bp-18h]@1
  __int64 v53; // [sp+54h] [bp-28h]@1
  __int64 v54; // [sp+6Ch] [bp-10h]@1
  __int64 v55; // [sp+74h] [bp-8h]@1

  v7 = a1;
  UF_VEC3_sub(a1 + 24, a1, &v48);
  v8 = a2;
  UF_VEC3_sub(v7, a2, &v49);
  UF_VEC3_sub(v8 + 24, v8, &v50);
  UF_VEC3_dot(&v48, &v49, &v51);
  UF_VEC3_dot(&v50, &v48, &v52);
  UF_VEC3_dot(&v50, &v49, &v53);
  UF_VEC3_dot(&v50, &v50, &v54);
  UF_VEC3_dot(&v48, &v48, &v55);
  __asm
  {
    fldz
    fld     st
    fld     [ebp+var_10]
    fucom   st(1)
    fnstsw  ax
    fstp    st(1)
    jp      short loc_10004072
    fstp    st(1)
    fstp    st
  }
  UF_VEC3_copy(v8, a4);
  __asm { fldz }
  _EDX = a6;
  __asm
  {
    fst     qword ptr [edx]
    fcomp   [ebp+var_8]
    fnstsw  ax
    jp      short loc_10004054
  }
  UF_VEC3_copy(v7, a3);
  __asm { fldz }
  _ECX = a5;
  __asm { fstp    qword ptr [ecx] }
  return 0;
}

//----- (100041A0) --------------------------------------------------------
signed int __cdecl sub_100041A0(int a1, const void *a2, int a3, int a4, int a5, int a6, int a7, int a8, const void *a9)
{
  int ST64_4_0; // ST64_4@0
  int ST68_4_0; // ST68_4@0
  int ST6C_4_0; // ST6C_4@0
  signed int v12; // eax@1
  signed int result; // eax@4
  char *v15; // ST60_4@9
  int v17; // edx@1
  double *v18; // ST60_4@1
  __int64 *v19; // ST5C_4@1
  __int64 v20; // ST54_8@1
  double *v21; // ST60_4@1
  __int64 *v22; // ST5C_4@1
  __int64 v23; // ST54_8@1
  char v24; // zf@1
  int *v25; // ST60_4@5
  __int64 v26; // ST58_8@5
  int *v27; // ST60_4@5
  __int64 v28; // ST58_8@5
  int *v29; // ST60_4@5
  __int64 v30; // ST58_8@5
  __int64 v31; // ST5C_8@6
  int *v32; // ST60_4@7
  __int64 v33; // ST58_8@7
  __int64 v35; // ST5C_8@13
  __int64 v36; // ST54_8@13
  __int64 v37; // ST4C_8@13
  __int64 v38; // ST5C_8@13
  __int64 v39; // ST54_8@13
  __int64 v40; // ST4C_8@13
  __int64 v42; // ST5C_8@13
  __int64 v43; // ST54_8@13
  __int64 v44; // ST4C_8@13
  __int64 v45; // ST5C_8@13
  __int64 v46; // ST54_8@13
  __int64 v47; // ST4C_8@13
  __int64 v49; // ST5C_8@13
  __int64 v50; // ST54_8@13
  __int64 v51; // ST4C_8@13
  __int64 v53; // ST5C_8@13
  __int64 v54; // ST54_8@13
  __int64 v55; // ST4C_8@13
  __int64 v56; // ST5C_8@13
  __int64 v57; // ST54_8@13
  __int64 v58; // ST4C_8@13
  __int64 v59; // ST44_8@13
  __int64 v60; // ST3C_8@13
  __int64 v61; // ST34_8@13
  __int64 v62; // ST2C_8@13
  __int64 v63; // ST24_8@13
  __int64 v64; // ST1C_8@13
  __int64 v65; // ST14_8@13
  __int64 v66; // ST0C_8@13
  __int64 v67; // ST04_8@13
  char v68; // zf@15
  const void **v69; // ST60_4@16
  __int64 v70; // ST58_8@16
  signed int *v71; // ST60_4@17
  __int64 v72; // ST58_8@17
  char *v73; // ST60_4@17
  __int64 v74; // ST58_8@17
  int v75; // ST58_4@21
  int v76; // ST5C_4@21
  int v77; // ST60_4@21
  __int64 v78; // ST5C_8@22
  __int64 v79; // ST54_8@22
  __int64 v80; // ST4C_8@22
  __int64 v81; // ST5C_8@22
  __int64 v82; // ST54_8@22
  __int64 v83; // ST4C_8@22
  int *v84; // ST60_4@25
  __int64 v85; // ST58_8@25
  int v86; // edi@25
  int *v87; // ST60_4@25
  __int64 v88; // ST58_8@25
  const void **v89; // ST60_4@25
  __int64 v90; // ST58_8@25
  __int64 v91; // ST5C_8@31
  __int64 v94; // ST5C_8@34
  int v104; // esi@53
  int v107; // eax@57
  int v108; // edx@57
  int v109; // ecx@57
  int v110; // eax@57
  int v111; // edx@57
  __int64 v112; // ST5C_8@57
  __int64 v113; // ST5C_8@57
  __int64 v114; // ST5C_8@58
  __int64 v115; // ST54_8@58
  __int64 v116; // ST4C_8@58
  __int64 v117; // ST44_8@58
  __int64 v118; // ST3C_8@58
  __int64 v119; // ST34_8@58
  int v123; // ecx@61
  int v124; // edx@61
  int v125; // ecx@61
  int v126; // edx@61
  int v127; // eax@61
  int v128; // edx@61
  int v129; // ecx@61
  int v130; // edx@61
  int v131; // ecx@61
  int v132; // edx@61
  __int64 v133; // ST5C_8@62
  __int64 v134; // ST54_8@62
  __int64 v135; // ST5C_8@62
  __int64 v136; // ST54_8@62
  signed int v137; // [sp+268h] [bp-10h]@1
  __int64 v138; // [sp+224h] [bp-54h]@1
  __int64 v139; // [sp+244h] [bp-34h]@1
  __int64 v140; // [sp+20Ch] [bp-6Ch]@1
  __int64 v141; // [sp+26Ch] [bp-Ch]@1
  int v142; // [sp+274h] [bp-4h]@5
  char v143; // [sp+194h] [bp-E4h]@6
  char v144; // [sp+1DCh] [bp-9Ch]@7
  char v145; // [sp+A4h] [bp-1D4h]@16
  char v146; // [sp+7Ch] [bp-1FCh]@16
  int v147; // [sp+1C4h] [bp-B4h]@16
  __int64 v148; // [sp+23Ch] [bp-3Ch]@17
  __int64 v149; // [sp+134h] [bp-144h]@38
  __int64 v150; // [sp+164h] [bp-114h]@38
  char v165; // [sp+11Ch] [bp-15Ch]@38
  char v166; // [sp+1F4h] [bp-84h]@38
  __int64 v167; // [sp+25Ch] [bp-1Ch]@38
  char v168; // [sp+264h] [bp-14h]@38
  int v171; // [sp+BCh] [bp-1BCh]@57
  int v172; // [sp+C4h] [bp-1B4h]@57
  int v173; // [sp+C0h] [bp-1B8h]@57
  int v174; // [sp+C8h] [bp-1B0h]@57
  int v175; // [sp+D0h] [bp-1A8h]@57
  int v176; // [sp+CCh] [bp-1ACh]@57
  char v177; // [sp+D4h] [bp-1A4h]@57
  char v181; // [sp+ECh] [bp-18Ch]@57
  int v182; // [sp+1ACh] [bp-CCh]@61
  int v183; // [sp+1B0h] [bp-C8h]@61
  int v184; // [sp+1B4h] [bp-C4h]@61
  int v185; // [sp+1B8h] [bp-C0h]@61
  int v186; // [sp+1BCh] [bp-BCh]@61
  int v187; // [sp+1C0h] [bp-B8h]@61
  int v188; // [sp+1C8h] [bp-B0h]@61
  int v189; // [sp+1CCh] [bp-ACh]@61
  int v190; // [sp+1D0h] [bp-A8h]@61
  int v191; // [sp+1D4h] [bp-A4h]@61
  int v192; // [sp+1D8h] [bp-A0h]@61
  char v193; // [sp+6Ch] [bp-20Ch]@61
  char v194; // [sp+94h] [bp-1E4h]@61

  _EBX = a3;
  dword_1000C540 = *(_DWORD *)a3;
  dword_1000C544 = *(_DWORD *)(a3 + 4);
  dword_1000C548 = *(_DWORD *)(a3 + 8);
  dword_1000C54C = *(_DWORD *)(a3 + 12);
  dword_1000C550 = *(_DWORD *)(a3 + 16);
  dword_1000C554 = *(_DWORD *)(a3 + 20);
  dword_1000C2C8 = *(_DWORD *)a5;
  dword_1000C2CC = *(_DWORD *)(a5 + 4);
  dword_1000C2D0 = *(_DWORD *)(a5 + 8);
  dword_1000C2D4 = *(_DWORD *)(a5 + 12);
  dword_1000C2D8 = *(_DWORD *)(a5 + 16);
  v17 = *(_DWORD *)(a5 + 20);
  v137 = 0;
  dword_1000C2DC = v17;
  UF_VEC3_copy(a4, &v138);
  UF_VEC3_copy(a6, &v139);
  UF_VEC3_copy(a8, &v140);
  __asm
  {
    fldz
    fst     dbl_1000C558
    fst     dbl_1000C560
    fst     dbl_1000C568
    fst     dbl_1000C570
  }
  memcpy(&unk_1000C340, a9, 0x98u);
  __asm
  {
    fst     dbl_1000C578
    fst     dbl_1000C580
    fld     dbl_1000C348
    fst     dbl_1000C000
    fxch    st(1)
  }
  memcpy(&dbl_1000C470, a2, 0x60u);
  __asm
  {
    fst     dbl_1000C538
    fst     dbl_1000C530
    fst     dbl_1000C2E8
    fst     dbl_1000C2E0
    fst     dbl_1000C468
    fst     dbl_1000C460
    fst     dbl_1000C320
    fstp    dbl_1000C318
  }
  v18 = &dbl_1000C2F0;
  v19 = &v141;
  byte_1000C588 = 0;
  dword_1000C3D8 = (int)&unk_1000C340;
  __asm { fstp    [esp+228h+var_228] }
  UF_VEC3_unitize(a4, v20, *((_DWORD *)&v20 + 1), v19, v18);
  __asm { fld     dbl_1000C000 }
  v21 = &dbl_1000C328;
  v22 = &v141;
  __asm { fstp    [esp+228h+var_228] }
  UF_VEC3_unitize(a6, v23, *((_DWORD *)&v23 + 1), v22, v21);
  dword_1000C4E0 = 0;
  dword_1000C4E4 = 0;
  dword_1000C4E8 = 0;
  dword_1000C4EC = 0;
  dword_1000C4F0 = 0;
  dword_1000C4F4 = 0;
  dword_1000C4F8 = 0;
  dword_1000C4FC = 0;
  dword_1000C500 = 0;
  dword_1000C504 = 0;
  dword_1000C508 = 0;
  dword_1000C50C = 0;
  dword_1000C510 = 0;
  dword_1000C514 = 0;
  dword_1000C518 = 0;
  dword_1000C51C = 0;
  dword_1000C520 = 0;
  dword_1000C524 = 0;
  dword_1000C528 = 0;
  dword_1000C52C = 0;
  v12 = *(_DWORD *)dword_1000C3D8;
  v24 = *(_DWORD *)dword_1000C3D8 == 1;
  byte_1000C009 = 1;
  byte_1000C00A = 1;
  if ( !v24 && v12 != 2 && v12 != 3 )
    return 2;
  __asm { fld     dbl_1000C000 }
  v25 = &v142;
  __asm { fstp    [esp+224h+var_228+4] }
  UF_VEC3_is_parallel(&v138, &v139, v26, *((_DWORD *)&v26 + 1), v25);
  __asm { fld     dbl_1000C000 }
  v27 = &v142;
  BYTE3(a2) = v142 != 0;
  __asm { fstp    [esp+224h+var_228+4] }
  UF_VEC3_is_parallel(&v138, &v140, v28, *((_DWORD *)&v28 + 1), v27);
  __asm { fld     dbl_1000C000 }
  v29 = &v142;
  BYTE3(a9) = v142 != 0;
  __asm { fstp    [esp+224h+var_228+4] }
  UF_VEC3_is_parallel(&v139, &v140, v30, *((_DWORD *)&v30 + 1), v29);
  BYTE3(a3) = v142 != 0;
  if ( !BYTE3(a9) )
  {
    __asm
    {
      fld     [ebp+var_C]
      fstp    [esp+220h+var_220]
    }
    sub_10001F20((int)&v140, (int)&v138, (int)&v143, v31);
  }
  UF_VEC3_cross(&v138, &v139);
  __asm { fld     dbl_1000C000 }
  v32 = &v142;
  __asm { fstp    [esp+224h+var_228+4] }
  UF_VEC3_is_parallel(&v144, &v140, v33, *((_DWORD *)&v33 + 1), v32);
  byte_1000C008 = v142 != 0;
  if ( byte_1000C588 )
  {
    printf("\n\n======================================================================\n");
    printf("Is_orthogonal_case = %d, ", (unsigned __int8)byte_1000C008);
    if ( *(_DWORD *)dword_1000C3D8 == 2 )
    {
      v15 = "is_5_axis_dual_table\n";
    }
    else
    {
      if ( *(_DWORD *)dword_1000C3D8 == 1 )
        v15 = "is_5_axis_dual_head\n";
      else
        v15 = "is_5_axis_head_table\n";
    }
    printf(v15);
    _EAX = a4;
    __asm
    {
      fld     qword ptr [eax+10h]
      fstp    [esp+230h+var_220]
      fld     qword ptr [eax+8]
      fstp    [esp+230h+var_228]
      fld     qword ptr [eax]
      fstp    [esp+230h+var_230]
    }
    printf("primary=(%f,%f,%f)\n", v37, *((_DWORD *)&v37 + 1), v36, v35);
    __asm
    {
      fld     qword ptr [ebx+10h]
      fstp    [esp+230h+var_220]
      fld     qword ptr [ebx+8]
      fstp    [esp+230h+var_228]
      fld     qword ptr [ebx]
      fstp    [esp+230h+var_230]
    }
    printf("primary_machine_center=(%f,%f,%f)\n", v40, *((_DWORD *)&v40 + 1), v39, v38);
    _EAX = a6;
    __asm
    {
      fld     qword ptr [eax+10h]
      fstp    [esp+230h+var_220]
      fld     qword ptr [eax+8]
      fstp    [esp+230h+var_228]
      fld     qword ptr [eax]
      fstp    [esp+230h+var_230]
    }
    printf("secondary=(%f,%f,%f)\n", v44, *((_DWORD *)&v44 + 1), v43, v42);
    _ESI = a5;
    __asm
    {
      fld     qword ptr [esi+10h]
      fstp    [esp+230h+var_220]
      fld     qword ptr [esi+8]
      fstp    [esp+230h+var_228]
      fld     qword ptr [esi]
      fstp    [esp+230h+var_230]
    }
    printf("secondary_machine_center=(%f,%f,%f)\n", v47, *((_DWORD *)&v47 + 1), v46, v45);
    _EAX = a7;
    __asm
    {
      fld     qword ptr [eax+10h]
      fstp    [esp+230h+var_220]
      fld     qword ptr [eax+8]
      fstp    [esp+230h+var_228]
      fld     qword ptr [eax]
      fstp    [esp+230h+var_230]
    }
    printf("tool_machine_center=(%f,%f,%f)\n", v51, *((_DWORD *)&v51 + 1), v50, v49);
    _EAX = a8;
    __asm
    {
      fld     qword ptr [eax+10h]
      fstp    [esp+230h+var_220]
      fld     qword ptr [eax+8]
      fstp    [esp+230h+var_228]
      fld     qword ptr [eax]
      fstp    [esp+230h+var_230]
    }
    printf("tool_vector=(%f,%f,%f)\n", v55, *((_DWORD *)&v55 + 1), v54, v53);
    __asm
    {
      fld     dbl_1000C4C8
      fstp    [esp+278h+var_220]
      fld     dbl_1000C4C0
      fstp    [esp+278h+var_228]
      fld     dbl_1000C4B8
      fstp    [esp+278h+var_230]
      fld     dbl_1000C4B0
      fstp    [esp+278h+var_238]
      fld     dbl_1000C4A8
      fstp    [esp+278h+var_240]
      fld     dbl_1000C4A0
      fstp    [esp+278h+var_248]
      fld     dbl_1000C498
      fstp    [esp+278h+var_250]
      fld     dbl_1000C490
      fstp    [esp+278h+var_258]
      fld     dbl_1000C488
      fstp    [esp+278h+var_260]
      fld     dbl_1000C480
      fstp    [esp+278h+var_268]
      fld     dbl_1000C478
      fstp    [esp+278h+var_270]
      fld     dbl_1000C470
      fstp    [esp+278h+var_278]
    }
    printf(
      "Mcsys= (%f,%f,%f) (%f,%f,%f) (%f,%f,%f)  (%f,%f,%f)\n",
      v67,
      *((_DWORD *)&v67 + 1),
      v66,
      v65,
      v64,
      v63,
      v62,
      v61,
      v60,
      v59,
      v58,
      v57,
      v56);
  }
  else
  {
    _ESI = a5;
  }
  v68 = *(_DWORD *)dword_1000C3D8 == 3;
  dword_1000C3DC = -1;
  if ( !v68 )
    goto LABEL_23;
  UF_MTX3_x_vec(&unk_100098E8, &v145);
  UF_MTX3_y_vec(&unk_100098E8, &v146);
  UF_MTX3_z_vec(&unk_100098E8, &v147);
  __asm { fld     dbl_1000C000 }
  v69 = &a9;
  __asm { fstp    [esp+224h+var_228+4] }
  UF_VEC3_is_equal(a8, &v147, v70, *((_DWORD *)&v70 + 1), v69);
  __asm { fld     dbl_1000C000 }
  if ( !a9 )
  {
    v71 = &v137;
    __asm { fstp    [esp+224h+var_228+4] }
    UF_VEC3_is_equal(a8, &v146, v72, *((_DWORD *)&v72 + 1), v71);
    __asm { fld     dbl_1000C000 }
    v73 = (char *)&v148 + 4;
    __asm { fstp    [esp+224h+var_228+4] }
    UF_VEC3_is_equal(&v138, &v147, v74, *((_DWORD *)&v74 + 1), v73);
    if ( byte_1000C008 || !BYTE3(a3) || !v137 || !*((_DWORD *)&v148 + 1) )
      return 2;
    dword_1000C3DC = 3;
    UF_MTX3_vec_multiply_t(&dbl_1000C2F0, &unk_10009978, &dbl_1000C2F0, ST64_4_0, ST68_4_0, ST6C_4_0);
    UF_MTX3_vec_multiply_t(&dbl_1000C328, &unk_10009978, &dbl_1000C328, v75, v76, v77);
    if ( byte_1000C588 )
    {
      printf("Sulzer case:\n");
      __asm
      {
        fld     dbl_1000C300
        fstp    [esp+230h+var_220]
        fld     dbl_1000C2F8
        fstp    [esp+230h+var_228]
        fld     dbl_1000C2F0
        fstp    [esp+230h+var_230]
      }
      printf("local PrimaryAxis=(%f,%f,%f)\n", v80, *((_DWORD *)&v80 + 1), v79, v78);
      __asm
      {
        fld     dbl_1000C338
        fstp    [esp+230h+var_220]
        fld     dbl_1000C330
        fstp    [esp+230h+var_228]
        fld     dbl_1000C328
        fstp    [esp+230h+var_230]
      }
      printf("local SecondaryAxis=(%f,%f,%f)\n", v83, *((_DWORD *)&v83 + 1), v82, v81);
    }
LABEL_23:
    if ( BYTE3(a2) )
    {
      __asm { fldz }
    }
    else
    {
      __asm
      {
        fld     [ebp+var_C]
        fstp    [esp+220h+var_220]
      }
      sub_10001F20((int)&v139, (int)&v138, (int)&v143, v91);
      sub_10002390((int)&v143, (int)&v139, (int)&v138);
      _ESI = a5;
    }
    __asm { fst     dbl_1000C578 }
    if ( BYTE3(a3) )
    {
      __asm { fstp    st }
      printf("WARNING: Tool axis is parallelled with secondary axis that may cause unresolved rotaries");
      __asm
      {
        fldz
        fstp    dbl_1000C580
        fld     [ebp+var_54]
        fld     ds:dbl_10009C60
        fmul    st(1), st
        fld     qword ptr [ebx]
        fadd    st, st(2)
        fld     qword ptr [ebx]
        fsubrp  st(3), st
        fld     [ebp+var_34]
        fmul    st, st(2)
        fld     qword ptr [esi]
        fadd    st, st(1)
        fld     qword ptr [esi]
        fsubrp  st(2), st
        fxch    st(2)
        fstp    [ebp+var_144]
        fxch    st(1)
        fstp    [ebp+var_114]
        fxch    st(2)
        fstp    [ebp+var_12C]
        fxch    st(1)
        fstp    [ebp+var_FC]
        fld     [ebp+var_4C]
        fmul    st, st(1)
        fld     qword ptr [ebx+8]
        fadd    st, st(1)
        fld     qword ptr [ebx+8]
        fsubrp  st(2), st
        fld     [ebp+var_2C]
        fmul    st, st(3)
        fld     qword ptr [esi+8]
        fadd    st, st(1)
        fld     qword ptr [esi+8]
        fsubrp  st(2), st
        fxch    st(2)
        fstp    [ebp+var_13C]
        fxch    st(1)
        fstp    [ebp+var_10C]
        fxch    st(1)
        fstp    [ebp+var_124]
        fstp    [ebp+var_F4]
        fld     [ebp+var_44]
        fmul    st, st(1)
        fld     qword ptr [ebx+10h]
        fadd    st, st(1)
        fld     qword ptr [ebx+10h]
        fsubrp  st(2), st
        fld     [ebp+var_24]
        fmulp   st(3), st
        fld     qword ptr [esi+10h]
        fadd    st, st(3)
        fld     qword ptr [esi+10h]
        fsubrp  st(4), st
        fxch    st(1)
        fstp    [ebp+var_134]
        fstp    [ebp+var_104]
        fstp    [ebp+var_11C]
        fstp    [ebp+var_EC]
      }
      if ( sub_10003F80((int)&v149, (int)&v150, (int)&v165, (int)&v166, (int)&v167, (int)&v168) )
        goto LABEL_66;
      UF_VEC3_distance(&v165, &v166, &dbl_1000C558);
      __asm
      {
        fld     dbl_1000C000
        fcomp   dbl_1000C558
        fnstsw  ax
        jp      short loc_10004AD3
      }
      UF_VEC3_sub(&v166, &v165, &v144);
      UF_VEC3_dot(&v144, &v143, &v148);
      __asm
      {
        fldz
        fcomp   [ebp+var_3C]
        fnstsw  ax
      }
      if ( !(HIBYTE(_AX) & 0x41) )
      {
        __asm
        {
          fld     dbl_1000C558
          fchs
          fstp    dbl_1000C558
        }
      }
      UF_VEC3_distance(&v166, _EBX, &dbl_1000C560);
      __asm
      {
        fld     dbl_1000C000
        fcomp   dbl_1000C560
        fnstsw  ax
        jp      short loc_10004B47
      }
      UF_VEC3_sub(&v166, _EBX, &v144);
      UF_VEC3_dot(&v144, &v138, &v148);
      __asm
      {
        fldz
        fcomp   [ebp+var_3C]
        fnstsw  ax
      }
      if ( !(HIBYTE(_AX) & 0x41) )
      {
        __asm
        {
          fld     dbl_1000C560
          fchs
          fstp    dbl_1000C560
        }
      }
      __asm { fld     [ebp+var_34] }
      _EAX = a7;
      __asm
      {
        fld     ds:dbl_10009C60
        fmul    st(1), st
        fld     qword ptr [esi]
        fadd    st, st(2)
        fld     qword ptr [esi]
        fsubrp  st(3), st
        fld     [ebp+var_6C]
        fmul    st, st(2)
        fld     qword ptr [eax]
        fadd    st, st(1)
        fld     qword ptr [eax]
        fsubrp  st(2), st
        fxch    st(2)
        fstp    [ebp+var_144]
        fxch    st(1)
        fstp    [ebp+var_114]
        fxch    st(2)
        fstp    [ebp+var_12C]
        fxch    st(1)
        fstp    [ebp+var_FC]
        fld     [ebp+var_2C]
        fmul    st, st(1)
        fld     qword ptr [esi+8]
        fadd    st, st(1)
        fld     qword ptr [esi+8]
        fsubrp  st(2), st
        fld     [ebp+var_64]
        fmul    st, st(3)
        fld     qword ptr [eax+8]
        fadd    st, st(1)
        fld     qword ptr [eax+8]
        fsubrp  st(2), st
        fxch    st(2)
        fstp    [ebp+var_13C]
        fxch    st(1)
        fstp    [ebp+var_10C]
        fxch    st(1)
        fstp    [ebp+var_124]
        fstp    [ebp+var_F4]
        fld     [ebp+var_24]
        fmul    st, st(1)
        fld     qword ptr [esi+10h]
        fadd    st, st(1)
        fld     qword ptr [esi+10h]
        fsubrp  st(2), st
        fld     [ebp+var_5C]
        fmulp   st(3), st
        fld     qword ptr [eax+10h]
        fadd    st, st(3)
        fld     qword ptr [eax+10h]
        fsubrp  st(4), st
        fxch    st(1)
        fstp    [ebp+var_134]
        fstp    [ebp+var_104]
        fstp    [ebp+var_11C]
        fstp    [ebp+var_EC]
      }
      if ( sub_10003F80((int)&v149, (int)&v150, (int)&v165, (int)&v166, (int)&v167, (int)&v168) )
      {
LABEL_66:
        result = 5;
      }
      else
      {
        UF_VEC3_distance(&v165, &v166, &dbl_1000C568);
        __asm
        {
          fld     dbl_1000C000
          fcomp   dbl_1000C568
          fnstsw  ax
          jp      short loc_10004CB5
        }
        UF_VEC3_sub(&v166, &v165, &v144);
        UF_VEC3_dot(&v144, &v143, &v167);
        __asm
        {
          fldz
          fcomp   [ebp+var_1C]
          fnstsw  ax
        }
        if ( !(HIBYTE(_AX) & 0x41) )
        {
          __asm
          {
            fld     dbl_1000C568
            fchs
            fstp    dbl_1000C568
          }
        }
        v104 = a7;
        UF_VEC3_distance(&v166, a7, &dbl_1000C570);
        __asm
        {
          fld     dbl_1000C000
          fcomp   dbl_1000C570
          fnstsw  ax
          jp      short loc_10004D2C
        }
        UF_VEC3_sub(&v166, v104, &v144);
        UF_VEC3_dot(&v144, &v139, &v167);
        __asm
        {
          fldz
          fcomp   [ebp+var_1C]
          fnstsw  ax
        }
        if ( !(HIBYTE(_AX) & 0x41) )
        {
          __asm
          {
            fld     dbl_1000C570
            fchs
            fstp    dbl_1000C570
          }
        }
        __asm { fld     [ebp+var_C] }
        v107 = *(_DWORD *)(_EBX + 8);
        v108 = *(_DWORD *)(_EBX + 4);
        v171 = *(_DWORD *)_EBX;
        v109 = *(_DWORD *)(_EBX + 12);
        v172 = v107;
        v110 = *(_DWORD *)(_EBX + 20);
        v173 = v108;
        v111 = *(_DWORD *)(_EBX + 16);
        v174 = v109;
        v175 = v110;
        __asm { fstp    [esp+220h+var_220] }
        v176 = v111;
        sub_10001F20((int)&v139, (int)&v138, (int)&v177, v112);
        __asm
        {
          fld     [ebp+var_54]
          fstp    [ebp+var_174]
          fld     [ebp+var_4C]
          fstp    [ebp+var_16C]
          fld     [ebp+var_44]
          fstp    [ebp+var_164]
          fld     [ebp+var_C]
          fstp    [esp+220h+var_220]
        }
        sub_10001F20((int)&v177, (int)&v138, (int)&v181, v113);
        sub_10002080((int)&v171, a1, (int)&unk_1000C3E0);
        sub_10002EB0((int)&dbl_1000C248);
        __asm
        {
          fld     dbl_1000C578
          fld     st
          fsin
          fstp    dbl_1000C310
          fld     dbl_1000C580
          fld     st
          fsin
          fstp    dbl_1000C4D0
          fld     st(1)
          fcos
          fstp    dbl_1000C4D8
          fld     st
          fcos
          fstp    dbl_1000C308
          fld     ds:dbl_100099E0
        }
        if ( byte_1000C588 )
        {
          __asm
          {
            fmul    st(1), st
            fxch    st(1)
            fstp    [esp+248h+var_220]
            fld     dbl_1000C570
            fstp    [esp+248h+var_228]
            fld     dbl_1000C568
            fstp    [esp+248h+var_230]
            fmulp   st(1), st
            fstp    [esp+248h+var_238]
            fld     dbl_1000C560
            fstp    [esp+248h+var_240]
            fld     dbl_1000C558
            fstp    [esp+248h+var_248]
          }
          printf(
            "A1=%f,D1=%f,Alpha1=%f,A2=%f,D2=%f,Alpha2=%f\n",
            v119,
            *((_DWORD *)&v119 + 1),
            v118,
            v117,
            v116,
            v115,
            v114);
        }
        else
        {
          __asm
          {
            fstp    st
            fstp    st(1)
            fstp    st
          }
        }
        if ( *(_DWORD *)dword_1000C3D8 == 2 )
        {
          v123 = *(_DWORD *)(a7 + 4);
          v182 = *(_DWORD *)a7;
          v124 = *(_DWORD *)(a7 + 8);
          v183 = v123;
          v125 = *(_DWORD *)(a7 + 12);
          v184 = v124;
          v126 = *(_DWORD *)(a7 + 16);
          v127 = *(_DWORD *)(a7 + 20);
          v185 = v125;
          v186 = v126;
          v187 = v127;
          v128 = *(_DWORD *)(a8 + 4);
          v147 = *(_DWORD *)a8;
          v129 = *(_DWORD *)(a8 + 8);
          v188 = v128;
          v130 = *(_DWORD *)(a8 + 12);
          v189 = v129;
          v131 = *(_DWORD *)(a8 + 16);
          v190 = v130;
          v132 = *(_DWORD *)(a8 + 20);
          v191 = v131;
          v192 = v132;
          sub_10003210(_EBX, (int)printf, (int)&v181, &v182, (int)&v193, (int)&v194);
          if ( byte_1000C588 )
          {
            __asm
            {
              fld     dbl_1000C2E0
              fld     ds:dbl_100099E0
              fmul    st(1), st
              fxch    st(1)
              fstp    [esp+228h+var_220]
              fmul    dbl_1000C530
              fstp    [esp+228h+var_228]
            }
            printf("Init_T1[0], Init_T2[0] = (%f,%f)\n", v134, *((_DWORD *)&v134 + 1), v133);
            __asm
            {
              fld     dbl_1000C2E8
              fld     ds:dbl_100099E0
              fmul    st(1), st
              fxch    st(1)
              fstp    [esp+228h+var_220]
              fmul    dbl_1000C538
              fstp    [esp+228h+var_228]
            }
            printf("Init_T1[1], Init_T2[1] = (%f,%f)\n", v136, *((_DWORD *)&v136 + 1), v135);
          }
        }
        result = 0;
        byte_1000C009 = 0;
      }
    }
    else
    {
      __asm
      {
        fabs
        fcomp   dbl_1000C000
        fnstsw  ax
        jp      short loc_10004914
        fld     [ebp+var_C]
        fstp    [esp+220h+var_220]
      }
      sub_10001F20((int)&v140, (int)&v139, (int)&v143, v94);
      __asm
      {
        fld     [ebp+var_C]
        fabs
        fcomp   dbl_1000C000
        fnstsw  ax
        jp      short loc_10004911
      }
      result = 3;
    }
    return result;
  }
  v84 = &a5;
  __asm { fstp    [esp+224h+var_228+4] }
  UF_VEC3_is_equal(a4, &v145, v85, *((_DWORD *)&v85 + 1), v84);
  __asm { fld     dbl_1000C000 }
  v86 = a6;
  v87 = &a3;
  __asm { fstp    [esp+224h+var_228+4] }
  UF_VEC3_is_equal(a6, &v146, v88, *((_DWORD *)&v88 + 1), v87);
  __asm { fld     dbl_1000C000 }
  v89 = &a2;
  __asm { fstp    [esp+224h+var_228+4] }
  UF_VEC3_is_equal(v86, &v147, v90, *((_DWORD *)&v90 + 1), v89);
  if ( a5 && a3 )
  {
    result = v137;
    dword_1000C3DC = 0;
    byte_1000C009 = 0;
  }
  else
  {
    if ( a2 )
    {
      result = v137;
      dword_1000C3DC = 1;
      byte_1000C009 = 0;
    }
    else
    {
      result = 2;
      byte_1000C009 = 0;
    }
  }
  return result;
}

//----- (10004F70) --------------------------------------------------------
const void *__cdecl sub_10004F70(const void *a1, void *a2, void *a3)
{
  signed int v5; // esi@3
  __int64 *v9; // ST38_4@2
  __int64 *v10; // ST34_4@2
  __int64 v11; // ST2C_8@2
  char v14; // zf@8
  __int64 v15; // ST34_8@9
  __int64 v16; // ST2C_8@9
  __int64 v17; // ST24_8@9
  __int64 v18; // ST1C_8@9
  __int64 v19; // ST14_8@9
  __int64 v20; // ST34_8@9
  __int64 v21; // ST2C_8@9
  __int64 v22; // ST24_8@9
  __int64 v23; // ST1C_8@9
  __int64 v24; // ST14_8@9
  char v25; // [sp+34h] [bp-98h]@1
  _BYTE v26[40]; // [sp+64h] [bp-68h]@1
  _BYTE v27[40]; // [sp+8Ch] [bp-40h]@1
  __int64 v28; // [sp+B4h] [bp-18h]@2

  _EBX = (int)a1;
  memcpy(&v25, a1, 0x30u);
  UF_VEC3_add(&v25, dword_1000C3D8 + 16, &v25);
  UF_VEC3_sub(&v25, dword_1000C3D8 + 40, &v25);
  a1 = (const void *)sub_10003210(_EBX, (int)v26, (int)UF_VEC3_add, &v25, (int)v27, (int)v26);
  UF_VEC3_add(v27, dword_1000C3D8 + 64, v27);
  UF_VEC3_add(v26, dword_1000C3D8 + 64, v26);
  _EAX = dword_1000C3D8;
  if ( *(_BYTE *)(dword_1000C3D8 + 88) )
  {
    __asm
    {
      fld     qword ptr [ebx+18h]
      fstp    [ebp+var_18]
    }
    v9 = &v28;
    __asm
    {
      fld     qword ptr [ebx+20h]
      fstp    [ebp+var_10]
    }
    v10 = &v28;
    __asm
    {
      fld     qword ptr [ebx+28h]
      fstp    [ebp+var_8]
      fld     qword ptr [eax+60h]
      fstp    [esp+0B4h+var_B4]
    }
    UF_VEC3_scale(v11, *((_DWORD *)&v11 + 1), v10, v9);
    UF_VEC3_add(v27, &v28, v27);
    UF_VEC3_add(v26, &v28, v26);
  }
  v5 = 0;
  do
  {
    _EDI = &v27[v5];
    sub_10005200((int)&v27[v5], dword_1000C3D8 + 8);
    __asm { fstp    qword ptr [edi] }
    _EDI = &v26[v5];
    sub_10005200((int)&v26[v5], dword_1000C3D8 + 8);
    __asm { fstp    qword ptr [edi] }
    v5 += 8;
  }
  while ( v5 <= 16 );
  if ( byte_1000C00A )
    byte_1000C00A = 0;
  else
    sub_100025B0((int)v27, v26);
  v14 = byte_1000C588 == 0;
  _EAX = a2;
  _EBX = a3;
  memcpy(a2, v27, 0x28u);
  memcpy(_EBX, v26, 0x28u);
  memcpy(&unk_1000C5B8, _EAX, 0x28u);
  memcpy(&unk_1000C590, _EBX, 0x28u);
  if ( !v14 )
  {
    __asm
    {
      fld     qword ptr [eax+20h]
      fstp    [esp+0CCh+var_AC]
      fld     qword ptr [eax+18h]
      fstp    [esp+0CCh+var_B4]
      fld     qword ptr [eax+10h]
      fstp    [esp+0CCh+var_BC]
      fld     qword ptr [eax+8]
      fstp    [esp+0CCh+var_C4]
      fld     qword ptr [eax]
      fstp    [esp+0CCh+var_CC]
    }
    printf("final ufunc mcoord[] = (%f,%f,%f), (%f,%f)\n", v19, *((_DWORD *)&v19 + 1), v18, v17, v16, v15);
    __asm
    {
      fld     qword ptr [ebx+20h]
      fstp    [esp+0D0h+var_AC]
      fld     qword ptr [ebx+18h]
      fstp    [esp+0CCh+var_B4]
      fld     qword ptr [ebx+10h]
      fstp    [esp+0CCh+var_BC]
      fld     qword ptr [ebx+8]
      fstp    [esp+0CCh+var_C4]
      fld     qword ptr [ebx]
      fstp    [esp+0CCh+var_CC]
    }
    printf("final ufunc alt_mcoord[] = (%f,%f,%f), (%f,%f)\n", v24, *((_DWORD *)&v24 + 1), v23, v22, v21, v20);
  }
  return a1;
}

//----- (10005200) --------------------------------------------------------
__int16 __cdecl sub_10005200(int a1, int a2)
{
  __int16 result; // ax@1

  _ECX = a2;
  __asm
  {
    fld     qword ptr [ecx]
    fabs
    fabs
    fcomp   ds:dbl_100099C0
    fnstsw  ax
    jp      short loc_10005222
    fldz
  }
  return result;
}

//----- (10005290) --------------------------------------------------------
signed int __usercall sub_10005290<eax>(int a1<eax>)
{
  signed int result; // eax@10
  char *v14; // ST1C_4@8
  char *v16; // ST18_4@8
  __int64 v17; // ST10_8@8
  char *v18; // ST1C_4@9
  char *v19; // ST18_4@9
  __int64 v20; // ST10_8@9
  char v21; // [sp+94h] [bp-20h]@1
  char v22; // [sp+7Ch] [bp-38h]@1
  char v23; // [sp+64h] [bp-50h]@1
  char v24; // [sp+1Ch] [bp-98h]@1
  char v25; // [sp+ACh] [bp-8h]@8

  _ESI = a1;
  UF_VEC3_copy(a1, &v21);
  UF_VEC3_copy(_ESI + 24, &v22);
  UF_VEC3_copy(_ESI + 48, &v23);
  UF_MTX3_copy(_ESI, &v24);
  __asm
  {
    fld     ds:dbl_100099C0
    fldz
    fld1
  }
  _ECX = 0;
  __asm { fld     ds:dbl_100099D0 }
  while ( 1 )
  {
    __asm
    {
      fld     qword ptr [esi+ecx*8]
      fabs
      fcom    st(4)
      fnstsw  ax
      jp      short loc_10005302
      fstp    st
      fxch    st(2)
      fst     qword ptr [esi+ecx*8]
    }
    ++_ECX;
    if ( _ECX >= 9 )
      break;
    __asm { fxch    st(2) }
  }
  __asm
  {
    fstp    st(1)
    fstp    st
  }
  v14 = &v21;
  __asm { fstp    st }
  v16 = &v25;
  __asm { fstp    [esp+0B4h+var_B4] }
  if ( !UF_VEC3_unitize(&v21, v17, *((_DWORD *)&v17 + 1), v16, v14) )
    goto LABEL_14;
  __asm { fld     ds:dbl_100099C0 }
  v18 = &v22;
  v19 = &v25;
  __asm { fstp    [esp+0B4h+var_B4] }
  if ( UF_VEC3_unitize(&v22, v20, *((_DWORD *)&v20 + 1), v19, v18) )
  {
    UF_VEC3_cross(&v21, &v22);
    UF_VEC3_cross(&v23, &v21);
    result = 1;
  }
  else
  {
LABEL_14:
    result = 0;
  }
  return result;
}

//----- (100053B0) --------------------------------------------------------
signed int __cdecl sub_100053B0(int a1)
{
  int v2; // esi@1
  signed int v3; // edi@1
  char v4; // [sp+8h] [bp-48h]@1

  v2 = a1;
  UF_MTX4_ask_rotation(a1, &v4);
  v3 = sub_10005290((int)&v4);
  UF_MTX4_edit_rotation(v2, &v4);
  return v3;
}

//----- (100053F0) --------------------------------------------------------
int __fastcall sub_100053F0(int a1, int a2, char a3)
{
  return UF_MOM_ask_string(a2, a1, &a3);
}

//----- (10005410) --------------------------------------------------------
int __cdecl sub_10005410(int a1, int a2)
{
  char v2; // zf@1
  char *v3; // eax@1
  signed int v4; // ecx@1
  char *v5; // edi@1
  char *v6; // esi@1
  int v8; // esi@7
  char *v9; // eax@8
  int v10; // edx@10
  char *v11; // eax@13
  int v12; // edx@15
  char *v13; // eax@18
  int v14; // edx@20
  void *v15; // eax@23
  int v16; // edx@25
  char *v17; // eax@28
  char *v18; // eax@31
  char v19; // zf@34
  signed int v20; // ecx@34
  char *v21; // edi@34
  char *v22; // esi@34
  char v24; // cl@11
  char v25; // cl@16
  char v26; // cl@21
  char v27; // cl@26
  char *v28; // [sp+20h] [bp-10h]@1
  char *v29; // [sp+8h] [bp-28h]@5
  char *v30; // [sp+Ch] [bp-24h]@5
  char *v31; // [sp+10h] [bp-20h]@5
  char *v32; // [sp+14h] [bp-1Ch]@5
  char *v33; // [sp+18h] [bp-18h]@5
  char *v34; // [sp+1Ch] [bp-14h]@5
  int v35; // [sp+28h] [bp-8h]@5
  char *v36; // [sp+2Ch] [bp-4h]@7
  int v37; // [sp+24h] [bp-Ch]@7

  v3 = "mom_kin_nurbs_output_type";
  v5 = "END";
  v6 = "mom_kin_nurbs_output_type";
  v4 = 26;
  v2 = 1;
  v28 = "END";
  do
  {
    if ( !v4 )
      break;
    v2 = *v6++ == *v5++;
    --v4;
  }
  while ( v2 );
  v29 = "mom_kin_nurbs_output_type";
  v30 = "mom_kin_output_unit";
  v31 = "mom_kin_polar_radius_side";
  v32 = "mom_kin_read_ahead_next_motion";
  v33 = "mom_kin_pivot_gauge_offset";
  v34 = "mom_kin_rapid_feed_rate";
  v35 = 0;
  if ( !v2 )
  {
    _EBX = a2;
    do
    {
      v8 = v35;
      v37 = UF_MOM_ask_string(a1, v3 + 4, &v36);
      switch ( v35 )
      {
        case 0:
          v9 = v36;
          if ( !v36 )
          {
            v9 = "NONE";
            v36 = "NONE";
          }
          v10 = _EBX - (_DWORD)v9;
          do
          {
            v24 = *v9;
            v9[v10] = *v9;
            ++v9;
          }
          while ( v24 );
          break;
        case 1:
          v11 = v36;
          if ( !v36 )
          {
            v11 = "IN";
            v36 = "IN";
          }
          v12 = _EBX - (_DWORD)v11 + 133;
          do
          {
            v25 = *v11;
            v11[v12] = *v11;
            ++v11;
          }
          while ( v25 );
          break;
        case 2:
          v13 = v36;
          if ( !v36 )
          {
            v13 = "NONE";
            v36 = "NONE";
          }
          v14 = _EBX - (_DWORD)v13 + 266;
          do
          {
            v26 = *v13;
            v13[v14] = *v13;
            ++v13;
          }
          while ( v26 );
          break;
        case 3:
          v15 = v36;
          if ( !v36 )
          {
            v15 = L"F";
            v36 = (char *)L"F";
          }
          v16 = _EBX - (_DWORD)v15 + 399;
          do
          {
            v27 = *(_BYTE *)v15;
            *((_BYTE *)v15 + v16) = *(_BYTE *)v15;
            v15 = (char *)v15 + 1;
          }
          while ( v27 );
          break;
        case 4:
          v17 = v36;
          if ( !v36 )
          {
            v17 = "0.0";
            v36 = "0.0";
          }
          strtod(v17, 0);
          __asm { fstp    qword ptr [ebx+218h] }
          break;
        case 5:
          v18 = v36;
          if ( !v36 )
          {
            v18 = "400.00";
            v36 = "400.00";
          }
          strtod(v18, 0);
          __asm { fstp    qword ptr [ebx+220h] }
          break;
        default:
          break;
      }
      v3 = (&v30)[4 * v8];
      v35 = v8 + 1;
      v21 = "END";
      v22 = v3;
      v20 = 4;
      v19 = 1;
      do
      {
        if ( !v20 )
          break;
        v19 = *v22++ == *v21++;
        --v20;
      }
      while ( v19 );
    }
    while ( !v19 );
  }
  return v37;
}

//----- (100055C0) --------------------------------------------------------
int __cdecl sub_100055C0(int a1, int a2)
{
  char v2; // zf@1
  char *v3; // eax@1
  signed int v4; // ecx@1
  int v5; // ebx@1
  char *v6; // edi@1
  char *v7; // esi@1
  char *v8; // eax@7
  int v9; // edx@9
  char *v10; // eax@12
  int v11; // edx@14
  char *v12; // eax@17
  char *v13; // eax@20
  char v14; // zf@23
  signed int v15; // ecx@23
  char *v16; // edi@23
  char *v17; // esi@23
  char v19; // cl@10
  char v20; // cl@15
  char *v23; // [sp+1Ch] [bp-Ch]@1
  char *v24; // [sp+Ch] [bp-1Ch]@5
  char *v25; // [sp+10h] [bp-18h]@5
  char *v26; // [sp+14h] [bp-14h]@5
  char *v27; // [sp+18h] [bp-10h]@5
  char *v28; // [sp+24h] [bp-4h]@6
  int v29; // [sp+20h] [bp-8h]@6

  v3 = "mom_kin_arc_output_mode";
  v6 = "END";
  v5 = 0;
  v7 = "mom_kin_arc_output_mode";
  v4 = 24;
  v2 = 1;
  v23 = "END";
  do
  {
    if ( !v4 )
      break;
    v2 = *v7++ == *v6++;
    --v4;
  }
  while ( v2 );
  v24 = "mom_kin_arc_output_mode";
  v25 = "mom_kin_arc_valid_plane";
  v26 = "mom_kin_min_arc_radius";
  v27 = "mom_kin_max_arc_radius";
  if ( !v2 )
  {
    do
    {
      v29 = UF_MOM_ask_string(a1, v3 + 4, &v28);
      switch ( v5 )
      {
        case 0:
          v8 = v28;
          if ( !v28 )
          {
            v8 = "FULL_CIRCLE";
            v28 = "FULL_CIRCLE";
          }
          v9 = a2 - (_DWORD)v8;
          do
          {
            v19 = *v8;
            v8[v9] = *v8;
            ++v8;
          }
          while ( v19 );
          break;
        case 1:
          v10 = v28;
          if ( !v28 )
          {
            v10 = "XY";
            v28 = "XY";
          }
          v11 = a2 - (_DWORD)v10 + 133;
          do
          {
            v20 = *v10;
            v10[v11] = *v10;
            ++v10;
          }
          while ( v20 );
          break;
        case 2:
          v12 = v28;
          if ( !v28 )
          {
            v12 = "0.0001";
            v28 = "0.0001";
          }
          strtod(v12, 0);
          _EAX = a2;
          __asm { fstp    qword ptr [eax+110h] }
          break;
        case 3:
          v13 = v28;
          if ( !v28 )
          {
            v13 = "9999.9999";
            v28 = "9999.9999";
          }
          strtod(v13, 0);
          _ECX = a2;
          __asm { fstp    qword ptr [ecx+118h] }
          break;
        default:
          break;
      }
      v3 = (&v25)[4 * v5++];
      v16 = "END";
      v17 = v3;
      v15 = 4;
      v14 = 1;
      do
      {
        if ( !v15 )
          break;
        v14 = *v17++ == *v16++;
        --v15;
      }
      while ( v14 );
    }
    while ( !v14 );
  }
  return v29;
}

//----- (10005700) --------------------------------------------------------
int __cdecl sub_10005700(int a1, int a2)
{
  char v2; // zf@1
  char *v3; // eax@1
  signed int v4; // ecx@1
  char *v5; // edi@1
  char *v6; // esi@1
  int v8; // esi@7
  char *v9; // eax@8
  char *v10; // eax@11
  char *v11; // eax@14
  char *v12; // eax@17
  char *v13; // eax@20
  char *v14; // eax@23
  char *v15; // eax@26
  char *v16; // eax@29
  char v17; // zf@32
  signed int v18; // ecx@32
  char *v19; // edi@32
  char *v20; // esi@32
  char *v22; // [sp+28h] [bp-10h]@1
  char *v23; // [sp+8h] [bp-30h]@5
  char *v24; // [sp+Ch] [bp-2Ch]@5
  char *v25; // [sp+10h] [bp-28h]@5
  char *v26; // [sp+14h] [bp-24h]@5
  char *v27; // [sp+18h] [bp-20h]@5
  char *v28; // [sp+1Ch] [bp-1Ch]@5
  char *v29; // [sp+20h] [bp-18h]@5
  char *v30; // [sp+24h] [bp-14h]@5
  int v31; // [sp+30h] [bp-8h]@5
  char *v32; // [sp+34h] [bp-4h]@7
  int v33; // [sp+2Ch] [bp-Ch]@7

  v3 = "mom_kin_max_fpm";
  v5 = "END";
  v6 = "mom_kin_max_fpm";
  v4 = 16;
  v2 = 1;
  v22 = "END";
  do
  {
    if ( !v4 )
      break;
    v2 = *v6++ == *v5++;
    --v4;
  }
  while ( v2 );
  v23 = "mom_kin_max_fpm";
  v24 = "mom_kin_min_fpm";
  v25 = "mom_kin_max_fpr";
  v26 = "mom_kin_min_fpr";
  v27 = "mom_kin_max_frn";
  v28 = "mom_kin_min_frn";
  v29 = "mom_kin_max_dpm";
  v30 = "mom_kin_min_dpm";
  v31 = 0;
  if ( !v2 )
  {
    _EBX = a2;
    do
    {
      v8 = v31;
      v33 = UF_MOM_ask_string(a1, v3 + 4, &v32);
      switch ( v31 )
      {
        case 0:
          v9 = v32;
          if ( !v32 )
          {
            v9 = "999.999";
            v32 = "999.999";
          }
          strtod(v9, 0);
          __asm { fstp    qword ptr [ebx] }
          break;
        case 1:
          v10 = v32;
          if ( !v32 )
          {
            v10 = "0.001";
            v32 = "0.001";
          }
          strtod(v10, 0);
          __asm { fstp    qword ptr [ebx+20h] }
          break;
        case 2:
          v11 = v32;
          if ( !v32 )
          {
            v11 = "99.999";
            v32 = "99.999";
          }
          strtod(v11, 0);
          __asm { fstp    qword ptr [ebx+8] }
          break;
        case 3:
          v12 = v32;
          if ( !v32 )
          {
            v12 = "0.001";
            v32 = "0.001";
          }
          strtod(v12, 0);
          __asm { fstp    qword ptr [ebx+28h] }
          break;
        case 4:
          v13 = v32;
          if ( !v32 )
          {
            v13 = "99999.999";
            v32 = "99999.999";
          }
          strtod(v13, 0);
          __asm { fstp    qword ptr [ebx+10h] }
          break;
        case 5:
          v14 = v32;
          if ( !v32 )
          {
            v14 = "0.001";
            v32 = "0.001";
          }
          strtod(v14, 0);
          __asm { fstp    qword ptr [ebx+30h] }
          break;
        case 6:
          v15 = v32;
          if ( !v32 )
          {
            v15 = "99.999";
            v32 = "99.999";
          }
          strtod(v15, 0);
          __asm { fstp    qword ptr [ebx+18h] }
          break;
        case 7:
          v16 = v32;
          if ( !v32 )
          {
            v16 = "0.0";
            v32 = "0.0";
          }
          strtod(v16, 0);
          __asm { fstp    qword ptr [ebx+38h] }
          break;
        default:
          break;
      }
      v3 = (&v24)[4 * v8];
      v31 = v8 + 1;
      v19 = "END";
      v20 = v3;
      v18 = 4;
      v17 = 1;
      do
      {
        if ( !v18 )
          break;
        v17 = *v20++ == *v19++;
        --v18;
      }
      while ( v17 );
    }
    while ( !v17 );
  }
  return v33;
}

//----- (100058D0) --------------------------------------------------------
int __cdecl sub_100058D0(int a1, int a2)
{
  char v2; // zf@1
  char *v3; // eax@1
  signed int v4; // ecx@1
  char *v5; // edi@1
  char *v6; // esi@1
  int v8; // esi@7
  char *v9; // eax@8
  int v10; // edx@10
  char *v11; // eax@13
  int v12; // edx@15
  char *v13; // eax@18
  int v14; // edx@20
  char *v15; // eax@23
  char *v16; // eax@26
  char *v17; // eax@29
  char *v18; // eax@32
  char *v19; // eax@35
  char *v20; // eax@38
  char *v21; // eax@41
  char *v22; // eax@44
  char *v23; // eax@47
  char *v24; // eax@50
  char *v25; // eax@53
  char *v26; // eax@56
  char v27; // zf@59
  signed int v28; // ecx@59
  char *v29; // edi@59
  char *v30; // esi@59
  char v32; // cl@11
  char v33; // cl@16
  char v34; // cl@21
  char *v35; // [sp+44h] [bp-10h]@1
  char *v36; // [sp+8h] [bp-4Ch]@5
  char *v37; // [sp+Ch] [bp-48h]@5
  char *v38; // [sp+10h] [bp-44h]@5
  char *v39; // [sp+14h] [bp-40h]@5
  char *v40; // [sp+18h] [bp-3Ch]@5
  char *v41; // [sp+1Ch] [bp-38h]@5
  char *v42; // [sp+20h] [bp-34h]@5
  char *v43; // [sp+24h] [bp-30h]@5
  char *v44; // [sp+28h] [bp-2Ch]@5
  char *v45; // [sp+2Ch] [bp-28h]@5
  char *v46; // [sp+30h] [bp-24h]@5
  char *v47; // [sp+34h] [bp-20h]@5
  char *v48; // [sp+38h] [bp-1Ch]@5
  char *v49; // [sp+3Ch] [bp-18h]@5
  char *v50; // [sp+40h] [bp-14h]@5
  int v51; // [sp+4Ch] [bp-8h]@5
  char *v52; // [sp+50h] [bp-4h]@7
  int v53; // [sp+48h] [bp-Ch]@7

  v3 = "mom_kin_4th_axis_plane";
  v5 = "END";
  v6 = "mom_kin_4th_axis_plane";
  v4 = 23;
  v2 = 1;
  v35 = "END";
  do
  {
    if ( !v4 )
      break;
    v2 = *v6++ == *v5++;
    --v4;
  }
  while ( v2 );
  v36 = "mom_kin_4th_axis_plane";
  v37 = "mom_kin_4th_axis_direction";
  v38 = "mom_kin_4th_axis_rotation";
  v39 = "mom_kin_4th_axis_min_incr";
  v40 = "mom_kin_4th_axis_min_limit";
  v41 = "mom_kin_4th_axis_max_limit";
  v42 = "mom_kin_4th_axis_zero";
  v43 = "mom_kin_4th_axis_center_offset_x";
  v44 = "mom_kin_4th_axis_center_offset_y";
  v45 = "mom_kin_4th_axis_center_offset_z";
  v46 = "mom_kin_4th_axis_vector_i";
  v47 = "mom_kin_4th_axis_vector_j";
  v48 = "mom_kin_4th_axis_vector_k";
  v49 = "mom_kin_4th_axis_angles_a1";
  v50 = "mom_kin_4th_axis_angles_a2";
  v51 = 0;
  if ( !v2 )
  {
    _EBX = a2;
    do
    {
      v8 = v51;
      v53 = UF_MOM_ask_string(a1, v3 + 4, &v52);
      switch ( v51 )
      {
        case 0:
          v9 = v52;
          if ( !v52 )
          {
            v9 = "YZ";
            v52 = "YZ";
          }
          v10 = _EBX - (_DWORD)v9;
          do
          {
            v32 = *v9;
            v9[v10] = *v9;
            ++v9;
          }
          while ( v32 );
          break;
        case 1:
          v11 = v52;
          if ( !v52 )
          {
            v11 = "MAGNITUDE_DETERMINES_DIRECTION";
            v52 = "MAGNITUDE_DETERMINES_DIRECTION";
          }
          v12 = _EBX - (_DWORD)v11 + 133;
          do
          {
            v33 = *v11;
            v11[v12] = *v11;
            ++v11;
          }
          while ( v33 );
          break;
        case 2:
          v13 = v52;
          if ( !v52 )
          {
            v13 = "STANDARD";
            v52 = "STANDARD";
          }
          v14 = _EBX - (_DWORD)v13 + 266;
          do
          {
            v34 = *v13;
            v13[v14] = *v13;
            ++v13;
          }
          while ( v34 );
          break;
        case 3:
          v15 = v52;
          if ( !v52 )
          {
            v15 = "0.001";
            v52 = "0.001";
          }
          strtod(v15, 0);
          __asm { fstp    qword ptr [ebx+190h] }
          break;
        case 4:
          v16 = v52;
          if ( !v52 )
          {
            v16 = "0.0";
            v52 = "0.0";
          }
          strtod(v16, 0);
          __asm { fstp    qword ptr [ebx+198h] }
          break;
        case 5:
          v17 = v52;
          if ( !v52 )
          {
            v17 = "360.0";
            v52 = "360.0";
          }
          strtod(v17, 0);
          __asm { fstp    qword ptr [ebx+1A0h] }
          break;
        case 6:
          v18 = v52;
          if ( !v52 )
          {
            v18 = "0.0";
            v52 = "0.0";
          }
          strtod(v18, 0);
          __asm { fstp    qword ptr [ebx+1A8h] }
          break;
        case 7:
          v19 = v52;
          if ( !v52 )
          {
            v19 = "0.0";
            v52 = "0.0";
          }
          strtod(v19, 0);
          __asm { fstp    qword ptr [ebx+1B0h] }
          break;
        case 8:
          v20 = v52;
          if ( !v52 )
          {
            v20 = "0.0";
            v52 = "0.0";
          }
          strtod(v20, 0);
          __asm { fstp    qword ptr [ebx+1B8h] }
          break;
        case 9:
          v21 = v52;
          if ( !v52 )
          {
            v21 = "0.0";
            v52 = "0.0";
          }
          strtod(v21, 0);
          __asm { fstp    qword ptr [ebx+1C0h] }
          break;
        case 10:
          v22 = v52;
          if ( !v52 )
          {
            v22 = "0.0";
            v52 = "0.0";
          }
          strtod(v22, 0);
          __asm { fstp    qword ptr [ebx+1C8h] }
          break;
        case 11:
          v23 = v52;
          if ( !v52 )
          {
            v23 = "0.0";
            v52 = "0.0";
          }
          strtod(v23, 0);
          __asm { fstp    qword ptr [ebx+1D0h] }
          break;
        case 12:
          v24 = v52;
          if ( !v52 )
          {
            v24 = "0.0";
            v52 = "0.0";
          }
          strtod(v24, 0);
          __asm { fstp    qword ptr [ebx+1D8h] }
          break;
        case 13:
          v25 = v52;
          if ( !v52 )
          {
            v25 = "0.0";
            v52 = "0.0";
          }
          strtod(v25, 0);
          __asm { fstp    qword ptr [ebx+1E0h] }
          break;
        case 14:
          v26 = v52;
          if ( !v52 )
          {
            v26 = "0.0";
            v52 = "0.0";
          }
          strtod(v26, 0);
          __asm { fstp    qword ptr [ebx+1E8h] }
          break;
        default:
          break;
      }
      v3 = (&v37)[4 * v8];
      v51 = v8 + 1;
      v29 = "END";
      v30 = v3;
      v28 = 4;
      v27 = 1;
      do
      {
        if ( !v28 )
          break;
        v27 = *v30++ == *v29++;
        --v28;
      }
      while ( v27 );
    }
    while ( !v27 );
  }
  return v53;
}

//----- (10005C10) --------------------------------------------------------
int __cdecl sub_10005C10(int a1, int a2)
{
  char v2; // zf@1
  char *v3; // eax@1
  signed int v4; // ecx@1
  char *v5; // edi@1
  char *v6; // esi@1
  int v8; // esi@7
  char *v9; // eax@8
  int v10; // edx@10
  char *v11; // eax@13
  int v12; // edx@15
  char *v13; // eax@18
  int v14; // edx@20
  char *v15; // eax@23
  char *v16; // eax@26
  char *v17; // eax@29
  char *v18; // eax@32
  char *v19; // eax@35
  char *v20; // eax@38
  char *v21; // eax@41
  char *v22; // eax@44
  char *v23; // eax@47
  char *v24; // eax@50
  char *v25; // eax@53
  char *v26; // eax@56
  char v27; // zf@59
  signed int v28; // ecx@59
  char *v29; // edi@59
  char *v30; // esi@59
  char v32; // cl@11
  char v33; // cl@16
  char v34; // cl@21
  char *v35; // [sp+44h] [bp-10h]@1
  char *v36; // [sp+8h] [bp-4Ch]@5
  char *v37; // [sp+Ch] [bp-48h]@5
  char *v38; // [sp+10h] [bp-44h]@5
  char *v39; // [sp+14h] [bp-40h]@5
  char *v40; // [sp+18h] [bp-3Ch]@5
  char *v41; // [sp+1Ch] [bp-38h]@5
  char *v42; // [sp+20h] [bp-34h]@5
  char *v43; // [sp+24h] [bp-30h]@5
  char *v44; // [sp+28h] [bp-2Ch]@5
  char *v45; // [sp+2Ch] [bp-28h]@5
  char *v46; // [sp+30h] [bp-24h]@5
  char *v47; // [sp+34h] [bp-20h]@5
  char *v48; // [sp+38h] [bp-1Ch]@5
  char *v49; // [sp+3Ch] [bp-18h]@5
  char *v50; // [sp+40h] [bp-14h]@5
  int v51; // [sp+4Ch] [bp-8h]@5
  char *v52; // [sp+50h] [bp-4h]@7
  int v53; // [sp+48h] [bp-Ch]@7

  v3 = "mom_kin_5th_axis_plane";
  v5 = "END";
  v6 = "mom_kin_5th_axis_plane";
  v4 = 23;
  v2 = 1;
  v35 = "END";
  do
  {
    if ( !v4 )
      break;
    v2 = *v6++ == *v5++;
    --v4;
  }
  while ( v2 );
  v36 = "mom_kin_5th_axis_plane";
  v37 = "mom_kin_5th_axis_direction";
  v38 = "mom_kin_5th_axis_rotation";
  v39 = "mom_kin_5th_axis_min_incr";
  v40 = "mom_kin_5th_axis_min_limit";
  v41 = "mom_kin_5th_axis_max_limit";
  v42 = "mom_kin_5th_axis_zero";
  v43 = "mom_kin_5th_axis_center_offset_x";
  v44 = "mom_kin_5th_axis_center_offset_y";
  v45 = "mom_kin_5th_axis_center_offset_z";
  v46 = "mom_kin_5th_axis_vector_i";
  v47 = "mom_kin_5th_axis_vector_j";
  v48 = "mom_kin_5th_axis_vector_k";
  v49 = "mom_kin_5th_axis_angles_a1";
  v50 = "mom_kin_5th_axis_angles_a2";
  v51 = 0;
  if ( !v2 )
  {
    _EBX = a2;
    do
    {
      v8 = v51;
      v53 = UF_MOM_ask_string(a1, v3 + 4, &v52);
      switch ( v51 )
      {
        case 0:
          v9 = v52;
          if ( !v52 )
          {
            v9 = "YZ";
            v52 = "YZ";
          }
          v10 = _EBX - (_DWORD)v9;
          do
          {
            v32 = *v9;
            v9[v10] = *v9;
            ++v9;
          }
          while ( v32 );
          break;
        case 1:
          v11 = v52;
          if ( !v52 )
          {
            v11 = "MAGNITUDE_DETERMINES_DIRECTION";
            v52 = "MAGNITUDE_DETERMINES_DIRECTION";
          }
          v12 = _EBX - (_DWORD)v11 + 133;
          do
          {
            v33 = *v11;
            v11[v12] = *v11;
            ++v11;
          }
          while ( v33 );
          break;
        case 2:
          v13 = v52;
          if ( !v52 )
          {
            v13 = "STANDARD";
            v52 = "STANDARD";
          }
          v14 = _EBX - (_DWORD)v13 + 266;
          do
          {
            v34 = *v13;
            v13[v14] = *v13;
            ++v13;
          }
          while ( v34 );
          break;
        case 3:
          v15 = v52;
          if ( !v52 )
          {
            v15 = "0.001";
            v52 = "0.001";
          }
          strtod(v15, 0);
          __asm { fstp    qword ptr [ebx+190h] }
          break;
        case 4:
          v16 = v52;
          if ( !v52 )
          {
            v16 = "0.0";
            v52 = "0.0";
          }
          strtod(v16, 0);
          __asm { fstp    qword ptr [ebx+198h] }
          break;
        case 5:
          v17 = v52;
          if ( !v52 )
          {
            v17 = "360.0";
            v52 = "360.0";
          }
          strtod(v17, 0);
          __asm { fstp    qword ptr [ebx+1A0h] }
          break;
        case 6:
          v18 = v52;
          if ( !v52 )
          {
            v18 = "0.0";
            v52 = "0.0";
          }
          strtod(v18, 0);
          __asm { fstp    qword ptr [ebx+1A8h] }
          break;
        case 7:
          v19 = v52;
          if ( !v52 )
          {
            v19 = "0.0";
            v52 = "0.0";
          }
          strtod(v19, 0);
          __asm { fstp    qword ptr [ebx+1B0h] }
          break;
        case 8:
          v20 = v52;
          if ( !v52 )
          {
            v20 = "0.0";
            v52 = "0.0";
          }
          strtod(v20, 0);
          __asm { fstp    qword ptr [ebx+1B8h] }
          break;
        case 9:
          v21 = v52;
          if ( !v52 )
          {
            v21 = "0.0";
            v52 = "0.0";
          }
          strtod(v21, 0);
          __asm { fstp    qword ptr [ebx+1C0h] }
          break;
        case 10:
          v22 = v52;
          if ( !v52 )
          {
            v22 = "0.0";
            v52 = "0.0";
          }
          strtod(v22, 0);
          __asm { fstp    qword ptr [ebx+1C8h] }
          break;
        case 11:
          v23 = v52;
          if ( !v52 )
          {
            v23 = "0.0";
            v52 = "0.0";
          }
          strtod(v23, 0);
          __asm { fstp    qword ptr [ebx+1D0h] }
          break;
        case 12:
          v24 = v52;
          if ( !v52 )
          {
            v24 = "0.0";
            v52 = "0.0";
          }
          strtod(v24, 0);
          __asm { fstp    qword ptr [ebx+1D8h] }
          break;
        case 13:
          v25 = v52;
          if ( !v52 )
          {
            v25 = "0.0";
            v52 = "0.0";
          }
          strtod(v25, 0);
          __asm { fstp    qword ptr [ebx+1E0h] }
          break;
        case 14:
          v26 = v52;
          if ( !v52 )
          {
            v26 = "0.0";
            v52 = "0.0";
          }
          strtod(v26, 0);
          __asm { fstp    qword ptr [ebx+1E8h] }
          break;
        default:
          break;
      }
      v3 = (&v37)[4 * v8];
      v51 = v8 + 1;
      v29 = "END";
      v30 = v3;
      v28 = 4;
      v27 = 1;
      do
      {
        if ( !v28 )
          break;
        v27 = *v30++ == *v29++;
        --v28;
      }
      while ( v27 );
    }
    while ( !v27 );
  }
  return v53;
}

//----- (10005F50) --------------------------------------------------------
int __cdecl sub_10005F50(int a1, int a2)
{
  char v2; // zf@1
  char *v3; // eax@1
  signed int v4; // ecx@1
  signed int v5; // ebx@1
  char *v6; // edi@1
  char *v7; // esi@1
  char *v8; // eax@9
  char *v9; // eax@12
  char *v10; // eax@15
  int v11; // edx@17
  char v12; // zf@19
  signed int v13; // ecx@19
  char *v14; // edi@19
  char *v15; // esi@19
  char v19; // cl@18
  char *v20; // [sp+18h] [bp-Ch]@1
  char *v21; // [sp+Ch] [bp-18h]@5
  char *v22; // [sp+10h] [bp-14h]@5
  char *v23; // [sp+14h] [bp-10h]@5
  char *v24; // [sp+20h] [bp-4h]@6
  int v25; // [sp+1Ch] [bp-8h]@6

  v3 = "mom_kin_independent_head";
  v6 = "END";
  v5 = 0;
  v7 = "mom_kin_independent_head";
  v4 = 25;
  v2 = 1;
  v20 = "END";
  do
  {
    if ( !v4 )
      break;
    v2 = *v7++ == *v6++;
    --v4;
  }
  while ( v2 );
  v21 = "mom_kin_independent_head";
  v22 = "mom_kin_ind_to_dependent_head_x";
  v23 = "mom_kin_ind_to_dependent_head_z";
  if ( !v2 )
  {
    do
    {
      v25 = UF_MOM_ask_string(a1, v3 + 4, &v24);
      if ( v5 )
      {
        if ( v5 == 1 )
        {
          v9 = v24;
          if ( !v24 )
          {
            v9 = "0.0";
            v24 = "0.0";
          }
          strtod(v9, 0);
          _ECX = a2;
          __asm { fstp    qword ptr [ecx+88h] }
        }
        else
        {
          if ( v5 == 2 )
          {
            v8 = v24;
            if ( !v24 )
            {
              v8 = "0.0";
              v24 = "0.0";
            }
            strtod(v8, 0);
            _EAX = a2;
            __asm { fstp    qword ptr [eax+90h] }
          }
        }
      }
      else
      {
        v10 = v24;
        if ( !v24 )
        {
          v10 = "FRONT";
          v24 = "FRONT";
        }
        v11 = a2 - (_DWORD)v10;
        do
        {
          v19 = *v10;
          v10[v11] = *v10;
          ++v10;
        }
        while ( v19 );
      }
      v3 = (&v22)[4 * v5++];
      v14 = "END";
      v15 = v3;
      v13 = 4;
      v12 = 1;
      do
      {
        if ( !v13 )
          break;
        v12 = *v15++ == *v14++;
        --v13;
      }
      while ( v12 );
    }
    while ( !v12 );
  }
  return v25;
}

//----- (10006060) --------------------------------------------------------
int __cdecl sub_10006060(int a1, int a2)
{
  char v2; // zf@1
  char *v3; // eax@1
  signed int v4; // ecx@1
  signed int v5; // ebx@1
  char *v6; // edi@1
  char *v7; // esi@1
  char *v8; // eax@9
  char *v9; // eax@12
  char *v10; // eax@15
  char v11; // zf@18
  signed int v12; // ecx@18
  char *v13; // edi@18
  char *v14; // esi@18
  char *v19; // [sp+18h] [bp-Ch]@1
  char *v20; // [sp+Ch] [bp-18h]@5
  char *v21; // [sp+10h] [bp-14h]@5
  char *v22; // [sp+14h] [bp-10h]@5
  char *v23; // [sp+20h] [bp-4h]@6
  int v24; // [sp+1Ch] [bp-8h]@6

  v3 = "mom_kin_tool_change_time";
  v6 = "END";
  v5 = 0;
  v7 = "mom_kin_tool_change_time";
  v4 = 25;
  v2 = 1;
  v19 = "END";
  do
  {
    if ( !v4 )
      break;
    v2 = *v7++ == *v6++;
    --v4;
  }
  while ( v2 );
  v20 = "mom_kin_tool_change_time";
  v21 = "mom_kin_clamp_time";
  v22 = "mom_kin_flush_time";
  if ( !v2 )
  {
    do
    {
      v24 = UF_MOM_ask_string(a1, v3 + 4, &v23);
      if ( v5 )
      {
        if ( v5 == 1 )
        {
          v9 = v23;
          if ( !v23 )
          {
            v9 = "0.5";
            v23 = "0.5";
          }
          strtod(v9, 0);
          _ECX = a2;
          __asm { fstp    qword ptr [ecx+8] }
        }
        else
        {
          if ( v5 == 2 )
          {
            v8 = v23;
            if ( !v23 )
            {
              v8 = "0.5";
              v23 = "0.5";
            }
            strtod(v8, 0);
            _EAX = a2;
            __asm { fstp    qword ptr [eax+10h] }
          }
        }
      }
      else
      {
        v10 = v23;
        if ( !v23 )
        {
          v10 = "3.0";
          v23 = "3.0";
        }
        strtod(v10, 0);
        _EDX = a2;
        __asm { fstp    qword ptr [edx] }
      }
      v3 = (&v21)[4 * v5++];
      v13 = "END";
      v14 = v3;
      v12 = 4;
      v11 = 1;
      do
      {
        if ( !v12 )
          break;
        v11 = *v14++ == *v13++;
        --v12;
      }
      while ( v11 );
    }
    while ( !v11 );
  }
  return v24;
}

//----- (10006150) --------------------------------------------------------
int __cdecl sub_10006150(int a1, int a2)
{
  char v2; // zf@1
  char *v3; // eax@1
  signed int v4; // ecx@1
  char *v5; // edi@1
  char *v6; // esi@1
  char *v8; // eax@8
  int v9; // edx@10
  char *v10; // eax@13
  int v11; // edx@15
  char *v12; // eax@18
  int v13; // edx@20
  char *v14; // eax@23
  int v15; // edx@25
  char *v16; // eax@28
  int v17; // edx@30
  char *v18; // eax@33
  int v19; // edx@35
  char *v20; // eax@38
  char *v21; // eax@41
  char *v22; // eax@44
  char *v23; // eax@47
  char *v24; // eax@50
  char *v25; // eax@53
  char *v26; // eax@56
  char *v27; // eax@59
  char *v28; // eax@62
  char *v29; // eax@65
  char *v30; // eax@68
  char *v31; // eax@71
  char *v32; // eax@74
  char *v33; // eax@77
  char *v34; // eax@80
  char *v35; // eax@83
  char *v36; // eax@86
  char *v37; // eax@89
  char v38; // zf@92
  signed int v39; // ecx@92
  char *v40; // edi@92
  char *v41; // esi@92
  char v43; // cl@11
  char v44; // cl@16
  char v45; // cl@21
  char v46; // cl@26
  char v47; // cl@31
  char v48; // cl@36
  int v49; // eax@92
  char *v50; // [sp+68h] [bp-10h]@1
  char *v51; // [sp+8h] [bp-70h]@5
  char *v52; // [sp+Ch] [bp-6Ch]@5
  char *v53; // [sp+10h] [bp-68h]@5
  char *v54; // [sp+14h] [bp-64h]@5
  char *v55; // [sp+18h] [bp-60h]@5
  char *v56; // [sp+1Ch] [bp-5Ch]@5
  char *v57; // [sp+20h] [bp-58h]@5
  char *v58; // [sp+24h] [bp-54h]@5
  char *v59; // [sp+28h] [bp-50h]@5
  char *v60; // [sp+2Ch] [bp-4Ch]@5
  char *v61; // [sp+30h] [bp-48h]@5
  char *v62; // [sp+34h] [bp-44h]@5
  char *v63; // [sp+38h] [bp-40h]@5
  char *v64; // [sp+3Ch] [bp-3Ch]@5
  char *v65; // [sp+40h] [bp-38h]@5
  char *v66; // [sp+44h] [bp-34h]@5
  char *v67; // [sp+48h] [bp-30h]@5
  char *v68; // [sp+4Ch] [bp-2Ch]@5
  char *v69; // [sp+50h] [bp-28h]@5
  char *v70; // [sp+54h] [bp-24h]@5
  char *v71; // [sp+58h] [bp-20h]@5
  char *v72; // [sp+5Ch] [bp-1Ch]@5
  char *v73; // [sp+60h] [bp-18h]@5
  char *v74; // [sp+64h] [bp-14h]@5
  int v75; // [sp+70h] [bp-8h]@5
  char *v76; // [sp+74h] [bp-4h]@7
  int v77; // [sp+6Ch] [bp-Ch]@7

  v3 = "mom_kin_holder1_orientation";
  v5 = "END";
  v6 = "mom_kin_holder1_orientation";
  v4 = 28;
  v2 = 1;
  v50 = "END";
  do
  {
    if ( !v4 )
      break;
    v2 = *v6++ == *v5++;
    --v4;
  }
  while ( v2 );
  v51 = "mom_kin_holder1_orientation";
  v52 = "mom_kin_holder2_orientation";
  v53 = "mom_kin_holder3_orientation";
  v54 = "mom_kin_holder4_orientation";
  v55 = "mom_kin_holder5_orientation";
  v56 = "mom_kin_holder6_orientation";
  v57 = "mom_kin_holder1_offset_x";
  v58 = "mom_kin_holder1_offset_y";
  v59 = "mom_kin_holder1_offset_z";
  v60 = "mom_kin_holder2_offset_x";
  v61 = "mom_kin_holder2_offset_y";
  v62 = "mom_kin_holder2_offset_z";
  v63 = "mom_kin_holder3_offset_x";
  v64 = "mom_kin_holder3_offset_y";
  v65 = "mom_kin_holder3_offset_z";
  v66 = "mom_kin_holder4_offset_x";
  v67 = "mom_kin_holder4_offset_y";
  v68 = "mom_kin_holder4_offset_z";
  v69 = "mom_kin_holder5_offset_x";
  v70 = "mom_kin_holder5_offset_y";
  v71 = "mom_kin_holder5_offset_z";
  v72 = "mom_kin_holder6_offset_x";
  v73 = "mom_kin_holder6_offset_y";
  v74 = "mom_kin_holder6_offset_z";
  v75 = 0;
  if ( !v2 )
  {
    _EBX = a2;
    do
    {
      v77 = UF_MOM_ask_string(a1, v3 + 4, &v76);
      switch ( v75 )
      {
        case 0:
          v8 = v76;
          if ( !v76 )
          {
            v8 = "POSZ";
            v76 = "POSZ";
          }
          v9 = _EBX - (_DWORD)v8;
          do
          {
            v43 = *v8;
            v8[v9] = *v8;
            ++v8;
          }
          while ( v43 );
          break;
        case 1:
          v10 = v76;
          if ( !v76 )
          {
            v10 = "POSZ";
            v76 = "POSZ";
          }
          v11 = _EBX - (_DWORD)v10 + 133;
          do
          {
            v44 = *v10;
            v10[v11] = *v10;
            ++v10;
          }
          while ( v44 );
          break;
        case 2:
          v12 = v76;
          if ( !v76 )
          {
            v12 = "POSZ";
            v76 = "POSZ";
          }
          v13 = _EBX - (_DWORD)v12 + 266;
          do
          {
            v45 = *v12;
            v12[v13] = *v12;
            ++v12;
          }
          while ( v45 );
          break;
        case 3:
          v14 = v76;
          if ( !v76 )
          {
            v14 = "POSZ";
            v76 = "POSZ";
          }
          v15 = _EBX - (_DWORD)v14 + 399;
          do
          {
            v46 = *v14;
            v14[v15] = *v14;
            ++v14;
          }
          while ( v46 );
          break;
        case 4:
          v16 = v76;
          if ( !v76 )
          {
            v16 = "POSZ";
            v76 = "POSZ";
          }
          v17 = _EBX - (_DWORD)v16 + 532;
          do
          {
            v47 = *v16;
            v16[v17] = *v16;
            ++v16;
          }
          while ( v47 );
          break;
        case 5:
          v18 = v76;
          if ( !v76 )
          {
            v18 = "POSZ";
            v76 = "POSZ";
          }
          v19 = _EBX - (_DWORD)v18 + 665;
          do
          {
            v48 = *v18;
            v18[v19] = *v18;
            ++v18;
          }
          while ( v48 );
          break;
        case 6:
          v20 = v76;
          if ( !v76 )
          {
            v20 = "0.0";
            v76 = "0.0";
          }
          strtod(v20, 0);
          __asm { fstp    qword ptr [ebx+320h] }
          break;
        case 7:
          v21 = v76;
          if ( !v76 )
          {
            v21 = "0.0";
            v76 = "0.0";
          }
          strtod(v21, 0);
          __asm { fstp    qword ptr [ebx+328h] }
          break;
        case 8:
          v22 = v76;
          if ( !v76 )
          {
            v22 = "0.0";
            v76 = "0.0";
          }
          strtod(v22, 0);
          __asm { fstp    qword ptr [ebx+330h] }
          break;
        case 9:
          v23 = v76;
          if ( !v76 )
          {
            v23 = "0.0";
            v76 = "0.0";
          }
          strtod(v23, 0);
          __asm { fstp    qword ptr [ebx+338h] }
          break;
        case 10:
          v24 = v76;
          if ( !v76 )
          {
            v24 = "0.0";
            v76 = "0.0";
          }
          strtod(v24, 0);
          __asm { fstp    qword ptr [ebx+340h] }
          break;
        case 11:
          v25 = v76;
          if ( !v76 )
          {
            v25 = "0.0";
            v76 = "0.0";
          }
          strtod(v25, 0);
          __asm { fstp    qword ptr [ebx+348h] }
          break;
        case 12:
          v26 = v76;
          if ( !v76 )
          {
            v26 = "0.0";
            v76 = "0.0";
          }
          strtod(v26, 0);
          __asm { fstp    qword ptr [ebx+350h] }
          break;
        case 13:
          v27 = v76;
          if ( !v76 )
          {
            v27 = "0.0";
            v76 = "0.0";
          }
          strtod(v27, 0);
          __asm { fstp    qword ptr [ebx+358h] }
          break;
        case 14:
          v28 = v76;
          if ( !v76 )
          {
            v28 = "0.0";
            v76 = "0.0";
          }
          strtod(v28, 0);
          __asm { fstp    qword ptr [ebx+360h] }
          break;
        case 15:
          v29 = v76;
          if ( !v76 )
          {
            v29 = "0.0";
            v76 = "0.0";
          }
          strtod(v29, 0);
          __asm { fstp    qword ptr [ebx+368h] }
          break;
        case 16:
          v30 = v76;
          if ( !v76 )
          {
            v30 = "0.0";
            v76 = "0.0";
          }
          strtod(v30, 0);
          __asm { fstp    qword ptr [ebx+370h] }
          break;
        case 17:
          v31 = v76;
          if ( !v76 )
          {
            v31 = "0.0";
            v76 = "0.0";
          }
          strtod(v31, 0);
          __asm { fstp    qword ptr [ebx+378h] }
          break;
        case 18:
          v32 = v76;
          if ( !v76 )
          {
            v32 = "0.0";
            v76 = "0.0";
          }
          strtod(v32, 0);
          __asm { fstp    qword ptr [ebx+380h] }
          break;
        case 19:
          v33 = v76;
          if ( !v76 )
          {
            v33 = "0.0";
            v76 = "0.0";
          }
          strtod(v33, 0);
          __asm { fstp    qword ptr [ebx+388h] }
          break;
        case 20:
          v34 = v76;
          if ( !v76 )
          {
            v34 = "0.0";
            v76 = "0.0";
          }
          strtod(v34, 0);
          __asm { fstp    qword ptr [ebx+390h] }
          break;
        case 21:
          v35 = v76;
          if ( !v76 )
          {
            v35 = "0.0";
            v76 = "0.0";
          }
          strtod(v35, 0);
          __asm { fstp    qword ptr [ebx+398h] }
          break;
        case 22:
          v36 = v76;
          if ( !v76 )
          {
            v36 = "0.0";
            v76 = "0.0";
          }
          strtod(v36, 0);
          __asm { fstp    qword ptr [ebx+3A0h] }
          break;
        case 23:
          v37 = v76;
          if ( !v76 )
          {
            v37 = "0.0";
            v76 = "0.0";
          }
          strtod(v37, 0);
          __asm { fstp    qword ptr [ebx+3A8h] }
          break;
        default:
          break;
      }
      v49 = v75++ + 1;
      v3 = (&v51)[4 * v49];
      v40 = "END";
      v41 = v3;
      v39 = 4;
      v38 = 1;
      do
      {
        if ( !v39 )
          break;
        v38 = *v41++ == *v40++;
        --v39;
      }
      while ( v38 );
    }
    while ( !v38 );
  }
  return v77;
}

//----- (10006660) --------------------------------------------------------
int __cdecl sub_10006660(int a1, int a2)
{
  char v2; // zf@1
  signed int v3; // ecx@1
  char *v4; // edi@1
  char *v5; // esi@1
  char *v6; // eax@6
  char *v8; // eax@8
  int v9; // edx@10
  void *v10; // eax@13
  int v11; // edx@15
  char *v12; // eax@18
  int v13; // edx@20
  void *v14; // eax@23
  int v15; // edx@25
  char *v16; // eax@28
  int v17; // edx@30
  void *v18; // eax@33
  int v19; // edx@35
  char *v20; // eax@38
  char *v21; // eax@41
  char *v22; // eax@44
  char *v23; // eax@47
  char *v24; // ecx@50
  int v25; // eax@51
  char *v26; // ecx@55
  int v27; // eax@56
  char *v28; // ecx@60
  int v29; // eax@61
  char v30; // zf@65
  signed int v31; // ecx@65
  char *v32; // edi@65
  char *v33; // esi@65
  char v35; // cl@11
  char v36; // cl@16
  char v37; // cl@21
  char v38; // cl@26
  char v39; // cl@31
  char v40; // cl@36
  int v41; // eax@65
  char *v42; // [sp+84h] [bp-1Ch]@1
  char *v43; // [sp+8Ch] [bp-14h]@1
  char *v44; // [sp+90h] [bp-10h]@1
  char *v45; // [sp+5Ch] [bp-44h]@5
  char *v46; // [sp+60h] [bp-40h]@5
  char *v47; // [sp+64h] [bp-3Ch]@5
  char *v48; // [sp+68h] [bp-38h]@5
  char *v49; // [sp+6Ch] [bp-34h]@5
  char *v50; // [sp+70h] [bp-30h]@5
  char *v51; // [sp+74h] [bp-2Ch]@5
  char *v52; // [sp+78h] [bp-28h]@5
  char *v53; // [sp+7Ch] [bp-24h]@5
  char *v54; // [sp+80h] [bp-20h]@5
  char *v55; // [sp+88h] [bp-18h]@5
  int v56; // [sp+98h] [bp-8h]@5
  char *v57; // [sp+9Ch] [bp-4h]@7
  int v58; // [sp+94h] [bp-Ch]@7
  char v59; // [sp+40h] [bp-60h]@51
  char v60; // [sp+8h] [bp-98h]@56
  char v61; // [sp+24h] [bp-7Ch]@61

  v4 = "END";
  v42 = "mom_kin_gauge_to_pivot_x";
  v43 = "mom_kin_gauge_to_pivot_x";
  v5 = "mom_kin_machine_type";
  v3 = 21;
  v2 = 1;
  v44 = "END";
  do
  {
    if ( !v3 )
      break;
    v2 = *v5++ == *v4++;
    --v3;
  }
  while ( v2 );
  v45 = "mom_kin_machine_type";
  v46 = "mom_kin_track_center_of_ball";
  v47 = "mom_kin_wire_tilt_output_type";
  v48 = "mom_kin_clsf_generation";
  v49 = "mom_kin_coordinate_type";
  v50 = "mom_kin_linearization_flag";
  v51 = "mom_kin_machine_resolution";
  v52 = "mom_kin_tool_tracking_height";
  v53 = "mom_kin_5th_axis_inclination_to_4th";
  v54 = "mom_kin_linearization_tol";
  v55 = "mom_kin_gauge_to_pivot_y";
  v56 = 0;
  if ( !v2 )
  {
    _EBX = a2;
    v6 = "mom_kin_machine_type";
    do
    {
      v58 = UF_MOM_ask_string(a1, v6 + 4, &v57);
      switch ( v56 )
      {
        case 0:
          v8 = v57;
          if ( !v57 )
          {
            v8 = "3_axis_mill";
            v57 = "3_axis_mill";
          }
          v9 = _EBX - (_DWORD)v8;
          do
          {
            v35 = *v8;
            v8[v9] = *v8;
            ++v8;
          }
          while ( v35 );
          break;
        case 1:
          v10 = v57;
          if ( !v57 )
          {
            v10 = L"T";
            v57 = (char *)L"T";
          }
          v11 = _EBX - (_DWORD)v10 + 133;
          do
          {
            v36 = *(_BYTE *)v10;
            *((_BYTE *)v10 + v11) = *(_BYTE *)v10;
            v10 = (char *)v10 + 1;
          }
          while ( v36 );
          break;
        case 2:
          v12 = v57;
          if ( !v57 )
          {
            v12 = "NONE";
            v57 = "NONE";
          }
          v13 = _EBX - (_DWORD)v12 + 266;
          do
          {
            v37 = *v12;
            v12[v13] = *v12;
            ++v12;
          }
          while ( v37 );
          break;
        case 3:
          v14 = v57;
          if ( !v57 )
          {
            v14 = L"F";
            v57 = (char *)L"F";
          }
          v15 = _EBX - (_DWORD)v14 + 399;
          do
          {
            v38 = *(_BYTE *)v14;
            *((_BYTE *)v14 + v15) = *(_BYTE *)v14;
            v14 = (char *)v14 + 1;
          }
          while ( v38 );
          break;
        case 4:
          v16 = v57;
          if ( !v57 )
          {
            v16 = "CARTESIAN";
            v57 = "CARTESIAN";
          }
          v17 = _EBX - (_DWORD)v16 + 532;
          do
          {
            v39 = *v16;
            v16[v17] = *v16;
            ++v16;
          }
          while ( v39 );
          break;
        case 5:
          v18 = v57;
          if ( !v57 )
          {
            v18 = L"F";
            v57 = (char *)L"F";
          }
          v19 = _EBX - (_DWORD)v18 + 665;
          do
          {
            v40 = *(_BYTE *)v18;
            *((_BYTE *)v18 + v19) = *(_BYTE *)v18;
            v18 = (char *)v18 + 1;
          }
          while ( v40 );
          break;
        case 6:
          v20 = v57;
          if ( !v57 )
          {
            v20 = "0.0001";
            v57 = "0.0001";
          }
          strtod(v20, 0);
          __asm { fstp    qword ptr [ebx+320h] }
          break;
        case 7:
          v21 = v57;
          if ( !v57 )
          {
            v21 = "0.0";
            v57 = "0.0";
          }
          strtod(v21, 0);
          __asm { fstp    qword ptr [ebx+328h] }
          break;
        case 8:
          v22 = v57;
          if ( !v57 )
          {
            v22 = "90.0";
            v57 = "90.0";
          }
          strtod(v22, 0);
          __asm { fstp    qword ptr [ebx+330h] }
          break;
        case 9:
          v23 = v57;
          if ( !v57 )
          {
            v23 = "0.0001";
            v57 = "0.0001";
          }
          strtod(v23, 0);
          __asm { fstp    qword ptr [ebx+338h] }
          break;
        case 10:
          v24 = v57;
          if ( !v57 )
          {
            memcpy(&v59, "kin_4th_to_tracking_point_x", 0x1Cu);
            v25 = sub_100053F0((int)&v59, a1, 0);
            v24 = v57;
            if ( !v57 || v25 )
            {
              v24 = "0.0";
              v57 = "0.0";
            }
          }
          strtod(v24, 0);
          __asm { fstp    qword ptr [ebx+340h] }
          break;
        case 11:
          v26 = v57;
          if ( !v57 )
          {
            memcpy(&v60, "kin_4th_to_tracking_point_y", 0x1Cu);
            v27 = sub_100053F0((int)&v60, a1, 0);
            v26 = v57;
            if ( !v57 || v27 )
            {
              v26 = "0.0";
              v57 = "0.0";
            }
          }
          strtod(v26, 0);
          __asm { fstp    qword ptr [ebx+348h] }
          break;
        case 12:
          v28 = v57;
          if ( !v57 )
          {
            memcpy(&v61, "kin_4th_to_tracking_point_z", 0x1Cu);
            v29 = sub_100053F0((int)&v61, a1, 0);
            v28 = v57;
            if ( !v57 || v29 )
            {
              v28 = "0.0";
              v57 = "0.0";
            }
          }
          strtod(v28, 0);
          __asm { fstp    qword ptr [ebx+350h] }
          break;
        default:
          break;
      }
      v41 = v56++ + 1;
      v6 = (&v45)[4 * v41];
      v32 = "END";
      v33 = v6;
      v31 = 4;
      v30 = 1;
      do
      {
        if ( !v31 )
          break;
        v30 = *v33++ == *v32++;
        --v31;
      }
      while ( v30 );
    }
    while ( !v30 );
  }
  return v58;
}

//----- (10006A10) --------------------------------------------------------
int __cdecl sub_10006A10(int a1, int a2)
{
  char v2; // zf@1
  char *v3; // eax@1
  signed int v4; // ecx@1
  char *v5; // edi@1
  char *v6; // esi@1
  int v8; // esi@7
  char *v9; // eax@8
  char *v10; // eax@11
  char *v11; // eax@14
  char *v12; // eax@17
  char *v13; // eax@20
  char *v14; // eax@23
  char *v15; // eax@26
  char *v16; // eax@29
  char *v17; // eax@32
  char *v18; // eax@35
  char *v19; // eax@38
  char *v20; // eax@41
  char v21; // zf@44
  signed int v22; // ecx@44
  char *v23; // edi@44
  char *v24; // esi@44
  char *v26; // [sp+38h] [bp-10h]@1
  char *v27; // [sp+8h] [bp-40h]@5
  char *v28; // [sp+Ch] [bp-3Ch]@5
  char *v29; // [sp+10h] [bp-38h]@5
  char *v30; // [sp+14h] [bp-34h]@5
  char *v31; // [sp+18h] [bp-30h]@5
  char *v32; // [sp+1Ch] [bp-2Ch]@5
  char *v33; // [sp+20h] [bp-28h]@5
  char *v34; // [sp+24h] [bp-24h]@5
  char *v35; // [sp+28h] [bp-20h]@5
  char *v36; // [sp+2Ch] [bp-1Ch]@5
  char *v37; // [sp+30h] [bp-18h]@5
  char *v38; // [sp+34h] [bp-14h]@5
  int v39; // [sp+40h] [bp-8h]@5
  char *v40; // [sp+44h] [bp-4h]@7
  int v41; // [sp+3Ch] [bp-Ch]@7

  v3 = "mom_msys_origin_x";
  v5 = "END";
  v6 = "mom_msys_origin_x";
  v4 = 18;
  v2 = 1;
  v26 = "END";
  do
  {
    if ( !v4 )
      break;
    v2 = *v6++ == *v5++;
    --v4;
  }
  while ( v2 );
  v27 = "mom_msys_origin_x";
  v28 = "mom_msys_origin_y";
  v29 = "mom_msys_origin_z";
  v30 = "mom_msys_x_axis_i";
  v31 = "mom_msys_x_axis_j";
  v32 = "mom_msys_x_axis_k";
  v33 = "mom_msys_y_axis_i";
  v34 = "mom_msys_y_axis_j";
  v35 = "mom_msys_y_axis_k";
  v36 = "mom_msys_z_axis_i";
  v37 = "mom_msys_z_axis_j";
  v38 = "mom_msys_z_axis_k";
  v39 = 0;
  if ( !v2 )
  {
    _EBX = a2;
    do
    {
      v8 = v39;
      v41 = UF_MOM_ask_string(a1, v3 + 4, &v40);
      switch ( v39 )
      {
        case 0:
          v9 = v40;
          if ( !v40 )
          {
            v9 = "0.0";
            v40 = "0.0";
          }
          strtod(v9, 0);
          __asm { fstp    qword ptr [ebx] }
          break;
        case 1:
          v10 = v40;
          if ( !v40 )
          {
            v10 = "0.0";
            v40 = "0.0";
          }
          strtod(v10, 0);
          __asm { fstp    qword ptr [ebx+8] }
          break;
        case 2:
          v11 = v40;
          if ( !v40 )
          {
            v11 = "0.0";
            v40 = "0.0";
          }
          strtod(v11, 0);
          __asm { fstp    qword ptr [ebx+10h] }
          break;
        case 3:
          v12 = v40;
          if ( !v40 )
          {
            v12 = "1.0";
            v40 = "1.0";
          }
          strtod(v12, 0);
          __asm { fstp    qword ptr [ebx+18h] }
          break;
        case 4:
          v13 = v40;
          if ( !v40 )
          {
            v13 = "0.0";
            v40 = "0.0";
          }
          strtod(v13, 0);
          __asm { fstp    qword ptr [ebx+20h] }
          break;
        case 5:
          v14 = v40;
          if ( !v40 )
          {
            v14 = "0.0";
            v40 = "0.0";
          }
          strtod(v14, 0);
          __asm { fstp    qword ptr [ebx+28h] }
          break;
        case 6:
          v15 = v40;
          if ( !v40 )
          {
            v15 = "0.0";
            v40 = "0.0";
          }
          strtod(v15, 0);
          __asm { fstp    qword ptr [ebx+30h] }
          break;
        case 7:
          v16 = v40;
          if ( !v40 )
          {
            v16 = "1.0";
            v40 = "1.0";
          }
          strtod(v16, 0);
          __asm { fstp    qword ptr [ebx+38h] }
          break;
        case 8:
          v17 = v40;
          if ( !v40 )
          {
            v17 = "0.0";
            v40 = "0.0";
          }
          strtod(v17, 0);
          __asm { fstp    qword ptr [ebx+40h] }
          break;
        case 9:
          v18 = v40;
          if ( !v40 )
          {
            v18 = "0.0";
            v40 = "0.0";
          }
          strtod(v18, 0);
          __asm { fstp    qword ptr [ebx+48h] }
          break;
        case 10:
          v19 = v40;
          if ( !v40 )
          {
            v19 = "0.0";
            v40 = "0.0";
          }
          strtod(v19, 0);
          __asm { fstp    qword ptr [ebx+50h] }
          break;
        case 11:
          v20 = v40;
          if ( !v40 )
          {
            v20 = "1.0";
            v40 = "1.0";
          }
          strtod(v20, 0);
          __asm { fstp    qword ptr [ebx+58h] }
          break;
        default:
          break;
      }
      v3 = (&v28)[4 * v8];
      v39 = v8 + 1;
      v23 = "END";
      v24 = v3;
      v22 = 4;
      v21 = 1;
      do
      {
        if ( !v22 )
          break;
        v21 = *v24++ == *v23++;
        --v22;
      }
      while ( v21 );
    }
    while ( !v21 );
  }
  return v41;
}

//----- (10006C90) --------------------------------------------------------
int __cdecl sub_10006C90(int a1, int a2)
{
  char v2; // zf@1
  char *v3; // eax@1
  signed int v4; // ecx@1
  char *v5; // edi@1
  char *v6; // esi@1
  int v8; // esi@7
  char *v9; // eax@8
  char *v10; // eax@11
  char *v11; // eax@14
  char *v12; // eax@17
  char *v13; // eax@20
  char *v14; // eax@23
  char *v15; // eax@26
  char *v16; // eax@29
  char *v17; // eax@32
  char *v18; // eax@35
  char *v19; // eax@38
  char *v20; // eax@41
  char v21; // zf@44
  signed int v22; // ecx@44
  char *v23; // edi@44
  char *v24; // esi@44
  char *v26; // [sp+38h] [bp-10h]@1
  char *v27; // [sp+8h] [bp-40h]@5
  char *v28; // [sp+Ch] [bp-3Ch]@5
  char *v29; // [sp+10h] [bp-38h]@5
  char *v30; // [sp+14h] [bp-34h]@5
  char *v31; // [sp+18h] [bp-30h]@5
  char *v32; // [sp+1Ch] [bp-2Ch]@5
  char *v33; // [sp+20h] [bp-28h]@5
  char *v34; // [sp+24h] [bp-24h]@5
  char *v35; // [sp+28h] [bp-20h]@5
  char *v36; // [sp+2Ch] [bp-1Ch]@5
  char *v37; // [sp+30h] [bp-18h]@5
  char *v38; // [sp+34h] [bp-14h]@5
  int v39; // [sp+40h] [bp-8h]@5
  char *v40; // [sp+44h] [bp-4h]@7
  int v41; // [sp+3Ch] [bp-Ch]@7

  v3 = "mom_mtsys_origin_x";
  v5 = "END";
  v6 = "mom_mtsys_origin_x";
  v4 = 19;
  v2 = 1;
  v26 = "END";
  do
  {
    if ( !v4 )
      break;
    v2 = *v6++ == *v5++;
    --v4;
  }
  while ( v2 );
  v27 = "mom_mtsys_origin_x";
  v28 = "mom_mtsys_origin_y";
  v29 = "mom_mtsys_origin_z";
  v30 = "mom_mtsys_x_axis_i";
  v31 = "mom_mtsys_x_axis_j";
  v32 = "mom_mtsys_x_axis_k";
  v33 = "mom_mtsys_y_axis_i";
  v34 = "mom_mtsys_y_axis_j";
  v35 = "mom_mtsys_y_axis_k";
  v36 = "mom_mtsys_z_axis_i";
  v37 = "mom_mtsys_z_axis_j";
  v38 = "mom_mtsys_z_axis_k";
  v39 = 0;
  if ( !v2 )
  {
    _EBX = a2;
    do
    {
      v8 = v39;
      v41 = UF_MOM_ask_string(a1, v3 + 4, &v40);
      switch ( v39 )
      {
        case 0:
          v9 = v40;
          if ( !v40 )
          {
            v9 = "0.0";
            v40 = "0.0";
          }
          strtod(v9, 0);
          __asm { fstp    qword ptr [ebx+60h] }
          break;
        case 1:
          v10 = v40;
          if ( !v40 )
          {
            v10 = "0.0";
            v40 = "0.0";
          }
          strtod(v10, 0);
          __asm { fstp    qword ptr [ebx+68h] }
          break;
        case 2:
          v11 = v40;
          if ( !v40 )
          {
            v11 = "0.0";
            v40 = "0.0";
          }
          strtod(v11, 0);
          __asm { fstp    qword ptr [ebx+70h] }
          break;
        case 3:
          v12 = v40;
          if ( !v40 )
          {
            v12 = "1.0";
            v40 = "1.0";
          }
          strtod(v12, 0);
          __asm { fstp    qword ptr [ebx+78h] }
          break;
        case 4:
          v13 = v40;
          if ( !v40 )
          {
            v13 = "0.0";
            v40 = "0.0";
          }
          strtod(v13, 0);
          __asm { fstp    qword ptr [ebx+80h] }
          break;
        case 5:
          v14 = v40;
          if ( !v40 )
          {
            v14 = "0.0";
            v40 = "0.0";
          }
          strtod(v14, 0);
          __asm { fstp    qword ptr [ebx+88h] }
          break;
        case 6:
          v15 = v40;
          if ( !v40 )
          {
            v15 = "0.0";
            v40 = "0.0";
          }
          strtod(v15, 0);
          __asm { fstp    qword ptr [ebx+90h] }
          break;
        case 7:
          v16 = v40;
          if ( !v40 )
          {
            v16 = "1.0";
            v40 = "1.0";
          }
          strtod(v16, 0);
          __asm { fstp    qword ptr [ebx+98h] }
          break;
        case 8:
          v17 = v40;
          if ( !v40 )
          {
            v17 = "0.0";
            v40 = "0.0";
          }
          strtod(v17, 0);
          __asm { fstp    qword ptr [ebx+0A0h] }
          break;
        case 9:
          v18 = v40;
          if ( !v40 )
          {
            v18 = "0.0";
            v40 = "0.0";
          }
          strtod(v18, 0);
          __asm { fstp    qword ptr [ebx+0A8h] }
          break;
        case 10:
          v19 = v40;
          if ( !v40 )
          {
            v19 = "0.0";
            v40 = "0.0";
          }
          strtod(v19, 0);
          __asm { fstp    qword ptr [ebx+0B0h] }
          break;
        case 11:
          v20 = v40;
          if ( !v40 )
          {
            v20 = "1.0";
            v40 = "1.0";
          }
          strtod(v20, 0);
          __asm { fstp    qword ptr [ebx+0B8h] }
          break;
        default:
          break;
      }
      v3 = (&v28)[4 * v8];
      v39 = v8 + 1;
      v23 = "END";
      v24 = v3;
      v22 = 4;
      v21 = 1;
      do
      {
        if ( !v22 )
          break;
        v21 = *v24++ == *v23++;
        --v22;
      }
      while ( v21 );
    }
    while ( !v21 );
  }
  return v41;
}

//----- (10006F30) --------------------------------------------------------
int __cdecl sub_10006F30(int a1, int a2)
{
  char v2; // zf@1
  char *v3; // eax@1
  signed int v4; // ecx@1
  char *v5; // edi@1
  char *v6; // esi@1
  int v8; // esi@7
  char *v9; // eax@8
  char *v10; // eax@11
  char *v11; // eax@14
  char *v12; // eax@17
  char *v13; // eax@20
  char *v14; // eax@23
  char *v15; // eax@26
  int v16; // edx@28
  char *v17; // eax@31
  char *v18; // eax@34
  char v19; // zf@37
  signed int v20; // ecx@37
  char *v21; // edi@37
  char *v22; // esi@37
  char v24; // cl@29
  char *v25; // [sp+2Ch] [bp-Ch]@1
  char *v26; // [sp+8h] [bp-30h]@5
  char *v27; // [sp+Ch] [bp-2Ch]@5
  char *v28; // [sp+10h] [bp-28h]@5
  char *v29; // [sp+14h] [bp-24h]@5
  char *v30; // [sp+18h] [bp-20h]@5
  char *v31; // [sp+1Ch] [bp-1Ch]@5
  char *v32; // [sp+20h] [bp-18h]@5
  char *v33; // [sp+24h] [bp-14h]@5
  char *v34; // [sp+28h] [bp-10h]@5
  int v35; // [sp+30h] [bp-8h]@5
  char *v36; // [sp+34h] [bp-4h]@7

  v3 = "mom_origin_x";
  v5 = "END";
  v6 = "mom_origin_x";
  v4 = 13;
  v2 = 1;
  v25 = "END";
  do
  {
    if ( !v4 )
      break;
    v2 = *v6++ == *v5++;
    --v4;
  }
  while ( v2 );
  v26 = "mom_origin_x";
  v27 = "mom_origin_y";
  v28 = "mom_origin_z";
  v29 = "mom_translate_x";
  v30 = "mom_translate_y";
  v31 = "mom_translate_z";
  v32 = "mom_tool_type";
  v33 = "mom_tool_z_offset";
  v34 = "mom_tool_corner1_radius";
  v35 = 0;
  if ( !v2 )
  {
    _EBX = a2;
    do
    {
      UF_MOM_ask_string(a1, v3 + 4, &v36);
      v8 = v35;
      switch ( v35 )
      {
        case 0:
          v9 = v36;
          if ( !v36 )
          {
            v9 = "0.0";
            v36 = "0.0";
          }
          strtod(v9, 0);
          __asm { fstp    qword ptr [ebx+0D8h] }
          break;
        case 1:
          v10 = v36;
          if ( !v36 )
          {
            v10 = "0.0";
            v36 = "0.0";
          }
          strtod(v10, 0);
          __asm { fstp    qword ptr [ebx+0E0h] }
          break;
        case 2:
          v11 = v36;
          if ( !v36 )
          {
            v11 = "0.0";
            v36 = "0.0";
          }
          strtod(v11, 0);
          __asm { fstp    qword ptr [ebx+0E8h] }
          break;
        case 3:
          v12 = v36;
          if ( !v36 )
          {
            v12 = "0.0";
            v36 = "0.0";
          }
          strtod(v12, 0);
          __asm { fstp    qword ptr [ebx+0C0h] }
          break;
        case 4:
          v13 = v36;
          if ( !v36 )
          {
            v13 = "0.0";
            v36 = "0.0";
          }
          strtod(v13, 0);
          __asm { fstp    qword ptr [ebx+0C8h] }
          break;
        case 5:
          v14 = v36;
          if ( !v36 )
          {
            v14 = "0.0";
            v36 = "0.0";
          }
          strtod(v14, 0);
          __asm { fstp    qword ptr [ebx+0D0h] }
          break;
        case 6:
          v15 = v36;
          if ( !v36 )
          {
            v15 = "MILL";
            v36 = "MILL";
          }
          v16 = _EBX - (_DWORD)v15 + 240;
          do
          {
            v24 = *v15;
            v15[v16] = *v15;
            ++v15;
          }
          while ( v24 );
          break;
        case 7:
          v17 = v36;
          if ( !v36 )
          {
            v17 = "0.0";
            v36 = "0.0";
          }
          strtod(v17, 0);
          __asm { fstp    qword ptr [ebx+178h] }
          break;
        case 8:
          v18 = v36;
          if ( !v36 )
          {
            v18 = "0.0";
            v36 = "0.0";
          }
          strtod(v18, 0);
          __asm { fstp    qword ptr [ebx+180h] }
          break;
        default:
          break;
      }
      v3 = (&v27)[4 * v8];
      v35 = v8 + 1;
      v21 = "END";
      v22 = v3;
      v20 = 4;
      v19 = 1;
      do
      {
        if ( !v20 )
          break;
        v19 = *v22++ == *v21++;
        --v20;
      }
      while ( v19 );
    }
    while ( !v19 );
  }
  return 0;
}

//----- (10007150) --------------------------------------------------------
int __cdecl sub_10007150(int a1, int a2)
{
  char v2; // zf@1
  char *v3; // eax@1
  signed int v4; // ecx@1
  char *v5; // edi@1
  char *v6; // esi@1
  int v8; // esi@7
  char *v9; // eax@8
  char *v10; // eax@11
  char *v11; // eax@14
  char *v12; // eax@17
  char *v13; // eax@20
  char *v14; // eax@23
  char v15; // zf@26
  signed int v16; // ecx@26
  char *v17; // edi@26
  char *v18; // esi@26
  char *v20; // [sp+20h] [bp-10h]@1
  char *v21; // [sp+8h] [bp-28h]@5
  char *v22; // [sp+Ch] [bp-24h]@5
  char *v23; // [sp+10h] [bp-20h]@5
  char *v24; // [sp+14h] [bp-1Ch]@5
  char *v25; // [sp+18h] [bp-18h]@5
  char *v26; // [sp+1Ch] [bp-14h]@5
  int v27; // [sp+28h] [bp-8h]@5
  char *v28; // [sp+2Ch] [bp-4h]@7
  int v29; // [sp+24h] [bp-Ch]@7

  v3 = "mom_mcs_goto_x";
  v5 = "END";
  v6 = "mom_mcs_goto_x";
  v4 = 15;
  v2 = 1;
  v20 = "END";
  do
  {
    if ( !v4 )
      break;
    v2 = *v6++ == *v5++;
    --v4;
  }
  while ( v2 );
  v21 = "mom_mcs_goto_x";
  v22 = "mom_mcs_goto_y";
  v23 = "mom_mcs_goto_z";
  v24 = "mom_tool_axis_i";
  v25 = "mom_tool_axis_j";
  v26 = "mom_tool_axis_k";
  v27 = 0;
  if ( !v2 )
  {
    _EBX = a2;
    do
    {
      v8 = v27;
      v29 = UF_MOM_ask_string(a1, v3 + 4, &v28);
      switch ( v27 )
      {
        case 0:
          v9 = v28;
          if ( !v28 )
          {
            v9 = "0.0";
            v28 = "0.0";
          }
          strtod(v9, 0);
          __asm { fstp    qword ptr [ebx] }
          break;
        case 1:
          v10 = v28;
          if ( !v28 )
          {
            v10 = "0.0";
            v28 = "0.0";
          }
          strtod(v10, 0);
          __asm { fstp    qword ptr [ebx+8] }
          break;
        case 2:
          v11 = v28;
          if ( !v28 )
          {
            v11 = "0.0";
            v28 = "0.0";
          }
          strtod(v11, 0);
          __asm { fstp    qword ptr [ebx+10h] }
          break;
        case 3:
          v12 = v28;
          if ( !v28 )
          {
            v12 = "0.0";
            v28 = "0.0";
          }
          strtod(v12, 0);
          __asm { fstp    qword ptr [ebx+18h] }
          break;
        case 4:
          v13 = v28;
          if ( !v28 )
          {
            v13 = "0.0";
            v28 = "0.0";
          }
          strtod(v13, 0);
          __asm { fstp    qword ptr [ebx+20h] }
          break;
        case 5:
          v14 = v28;
          if ( !v28 )
          {
            v14 = "0.0";
            v28 = "0.0";
          }
          strtod(v14, 0);
          __asm { fstp    qword ptr [ebx+28h] }
          break;
        default:
          break;
      }
      v3 = (&v22)[4 * v8];
      v27 = v8 + 1;
      v17 = "END";
      v18 = v3;
      v16 = 4;
      v15 = 1;
      do
      {
        if ( !v16 )
          break;
        v15 = *v18++ == *v17++;
        --v16;
      }
      while ( v15 );
    }
    while ( !v15 );
  }
  return v29;
}

//----- (100072D0) --------------------------------------------------------
int __cdecl sub_100072D0(int a1, char *a2)
{
  char v2; // zf@1
  char *v3; // eax@1
  signed int v4; // ecx@1
  char *v6; // edi@1
  char *v7; // esi@1
  int v8; // esi@6
  char *v9; // eax@7
  char *v10; // eax@10
  char *v11; // eax@13
  char *v12; // eax@16
  char *v13; // eax@19
  char *v14; // eax@22
  char *v15; // eax@25
  char *v16; // eax@28
  char *v17; // eax@31
  char v18; // zf@34
  signed int v19; // ecx@34
  char *v20; // edi@34
  char *v21; // esi@34
  int result; // eax@39
  char *v23; // [sp+30h] [bp-Ch]@1
  char *v24; // [sp+Ch] [bp-30h]@5
  char *v25; // [sp+10h] [bp-2Ch]@5
  char *v26; // [sp+14h] [bp-28h]@5
  char *v27; // [sp+18h] [bp-24h]@5
  char *v28; // [sp+1Ch] [bp-20h]@5
  char *v29; // [sp+20h] [bp-1Ch]@5
  char *v30; // [sp+24h] [bp-18h]@5
  char *v31; // [sp+28h] [bp-14h]@5
  char *v32; // [sp+2Ch] [bp-10h]@5
  int v33; // [sp+38h] [bp-4h]@5
  int v34; // [sp+34h] [bp-8h]@6

  _EBX = a2;
  v3 = "mom_origin_x";
  v6 = "END";
  v7 = "mom_origin_x";
  v4 = 13;
  v2 = 1;
  v23 = "END";
  do
  {
    if ( !v4 )
      break;
    v2 = *v7++ == *v6++;
    --v4;
  }
  while ( v2 );
  v24 = "mom_origin_x";
  v25 = "mom_origin_y";
  v26 = "mom_origin_z";
  v27 = "mom_translate_x";
  v28 = "mom_translate_y";
  v29 = "mom_translate_z";
  v30 = "mom_tool_z_offset";
  v31 = "mom_kin_track_center_of_ball";
  v32 = "mom_tool_corner1_radius";
  v33 = 0;
  if ( !v2 )
  {
    do
    {
      v8 = v33;
      v34 = UF_MOM_ask_string(a1, v3 + 4, &a2);
      switch ( v33 )
      {
        case 0:
          v9 = a2;
          if ( !a2 )
          {
            v9 = "0.0";
            a2 = "0.0";
          }
          strtod(v9, 0);
          __asm { fstp    qword ptr [ebx] }
          break;
        case 1:
          v10 = a2;
          if ( !a2 )
          {
            v10 = "0.0";
            a2 = "0.0";
          }
          strtod(v10, 0);
          __asm { fstp    qword ptr [ebx+8] }
          break;
        case 2:
          v11 = a2;
          if ( !a2 )
          {
            v11 = "0.0";
            a2 = "0.0";
          }
          strtod(v11, 0);
          __asm { fstp    qword ptr [ebx+10h] }
          break;
        case 3:
          v12 = a2;
          if ( !a2 )
          {
            v12 = "0.0";
            a2 = "0.0";
          }
          strtod(v12, 0);
          __asm { fstp    qword ptr [ebx+60h] }
          break;
        case 4:
          v13 = a2;
          if ( !a2 )
          {
            v13 = "0.0";
            a2 = "0.0";
          }
          strtod(v13, 0);
          __asm { fstp    qword ptr [ebx+68h] }
          break;
        case 5:
          v14 = a2;
          if ( !a2 )
          {
            v14 = "0.0";
            a2 = "0.0";
          }
          strtod(v14, 0);
          __asm { fstp    qword ptr [ebx+70h] }
          break;
        case 6:
          v15 = a2;
          if ( !a2 )
          {
            v15 = "0.0";
            a2 = "0.0";
          }
          strtod(v15, 0);
          __asm { fstp    qword ptr [ebx+78h] }
          break;
        case 7:
          v16 = a2;
          if ( !a2 )
          {
            v16 = "0.0";
            a2 = "0.0";
          }
          strtod(v16, 0);
          *((_DWORD *)_EBX + 32) = _ftol2_sse();
          break;
        case 8:
          v17 = a2;
          if ( !a2 )
          {
            v17 = "0.0";
            a2 = "0.0";
          }
          strtod(v17, 0);
          __asm { fstp    qword ptr [ebx+88h] }
          break;
        default:
          break;
      }
      v3 = (&v25)[4 * v8];
      v33 = v8 + 1;
      v20 = "END";
      v21 = v3;
      v19 = 4;
      v18 = 1;
      do
      {
        if ( !v19 )
          break;
        v18 = *v21++ == *v20++;
        --v19;
      }
      while ( v18 );
    }
    while ( !v18 );
  }
  result = v34;
  memcpy(&unk_1000C5E0, _EBX, 0x90u);
  return result;
}

//----- (100074F0) --------------------------------------------------------
int __cdecl sub_100074F0(int a1, int a2)
{
  int v2; // esi@1
  int *v4; // ST24_4@2
  __int64 v5; // ST1C_8@2
  int v6; // ebx@5
  __int64 v7; // [sp+18h] [bp-78h]@1
  char v16; // [sp+78h] [bp-18h]@5
  char v17; // [sp+60h] [bp-30h]@5

  __asm
  {
    fld     dbl_1000C5F8
    fstp    [ebp+var_78]
    fld     dbl_1000C610
    fstp    [ebp+var_60]
  }
  v2 = a1;
  __asm
  {
    fld     dbl_1000C628
    fstp    [ebp+var_48]
    fld     dbl_1000C600
    fstp    [ebp+var_70]
    fld     dbl_1000C618
    fstp    [ebp+var_58]
    fld     dbl_1000C630
    fstp    [ebp+var_40]
    fld     dbl_1000C608
    fstp    [ebp+var_68]
    fld     dbl_1000C620
    fstp    [ebp+var_50]
    fld     dbl_1000C638
    fstp    [ebp+var_38]
  }
  if ( !dword_1000C670 )
  {
    __asm { fld     ds:dbl_1000ADA8 }
    v4 = &a1;
    __asm { fstp    [esp+90h+var_90] }
    UF_VEC3_is_equal(a1 + 24, &dbl_1000C628, v5, *((_DWORD *)&v5 + 1), v4);
    if ( !a1 )
    {
      printf("WARNING  The tool axis is not matching with the                 rotated MCS-Z axis. The output may be INCORRECT\n");
      uc1601(
        "WARNING  The tool axis is not matching with the *                     rotated MCS-Z axis. The output may be INCORRECT\n",
        1);
    }
    dword_1000C670 = 1;
  }
  UF_VEC3_copy(v2, &v16);
  UF_VEC3_copy(v2 + 24, &v17);
  v6 = a2;
  UF_MTX3_vec_multiply(v2, &v7, a2);
  UF_MTX3_vec_multiply(v2 + 24, &v7, v6 + 24);
  return 0;
}

//----- (100075F0) --------------------------------------------------------
int __cdecl sub_100075F0(int a1, int a2)
{
  int v2; // esi@1
  int v4; // ebx@1
  char *v5; // ST1C_4@1
  int v6; // ST18_4@1
  __int64 v7; // ST10_8@1
  char *v8; // ST1C_4@2
  int v9; // ST18_4@2
  __int64 v10; // ST10_8@2
  char v11; // [sp+1Ch] [bp-18h]@1

  v4 = a1;
  v2 = a2;
  UF_VEC3_add(a1, &unk_1000C640, a2);
  UF_VEC3_sub(v4, &unk_1000C5E0, v2);
  UF_VEC3_copy(v4 + 24, v2 + 24);
  __asm { fld     dbl_1000C658 }
  v5 = &v11;
  v6 = v2 + 24;
  __asm { fstp    [esp+34h+var_34] }
  UF_VEC3_scale(v7, *((_DWORD *)&v7 + 1), v6, v5);
  UF_VEC3_add(v2, &v11, v2);
  if ( dword_1000C660 == 1 )
  {
    __asm { fld     dbl_1000C668 }
    v8 = &v11;
    v9 = v2 + 24;
    __asm { fstp    [esp+34h+var_34] }
    UF_VEC3_scale(v10, *((_DWORD *)&v10 + 1), v9, v8);
    UF_VEC3_add(v2, &v11, v2);
  }
  return 0;
}

//----- (10007690) --------------------------------------------------------
int __usercall sub_10007690<eax>(int a1<ebx>, int a2<edi>, int a3<esi>, int a4, int a5, int a6)
{
  char *v6; // edi@1
  int v8; // eax@2
  int v9; // eax@3
  int v10; // edi@10
  char *v11; // esi@11
  char *v13; // ST14_4@8
  __int64 v14; // ST0C_8@8
  __int64 v19; // [sp+110h] [bp-58h]@1
  int v28; // [sp+164h] [bp-4h]@1
  char v30; // [sp+18h] [bp-150h]@1
  signed int v31; // [sp+160h] [bp-8h]@1
  char v33; // [sp+F0h] [bp-78h]@5

  __asm
  {
    fld1
    fst     [ebp+var_58]
    fldz
    fst     [ebp+var_50]
    fst     [ebp+var_48]
    fst     [ebp+var_40]
    fst     [ebp+var_30]
    fst     [ebp+var_28]
    fstp    [ebp+var_20]
    fst     [ebp+var_38]
    fst     [ebp+var_18]
  }
  CIasin(a2, a3, a1);
  __asm { fmul    ds:dbl_1000ADB0 }
  v28 = 0;
  __asm { fst     [ebp+var_60] }
  v6 = &v30;
  __asm { fld     ds:dbl_100099D0 }
  _ESI = a6 + 8;
  v31 = 3;
  do
  {
    __asm { fld     qword ptr [esi-8] }
    v8 = _ftol2_sse() - 1;
    if ( v8 )
    {
      v9 = v8 - 1;
      if ( v9 )
      {
        if ( v9 != 1 )
          goto LABEL_9;
        __asm
        {
          fld     qword ptr [esi]
          fmulp   st(2), st
          fmulp   st(1), st
          fstp    [ebp+var_10]
        }
        UF_MTX3_z_vec(&v19, &v33);
      }
      else
      {
        __asm
        {
          fld     qword ptr [esi]
          fmulp   st(2), st
          fmulp   st(1), st
          fstp    [ebp+var_10]
        }
        UF_MTX3_y_vec(&v19, &v33);
      }
    }
    else
    {
      __asm
      {
        fld     qword ptr [esi]
        fmulp   st(2), st
        fmulp   st(1), st
        fstp    [ebp+var_10]
      }
      UF_MTX3_x_vec(&v19, &v33);
    }
    __asm { fld     [ebp+var_10] }
    v13 = v6;
    __asm { fstp    [esp+15Ch+var_15C] }
    UF_MTX3_rotate_about_axis(&v33, v14, *((_DWORD *)&v14 + 1), v13);
    __asm { fld     [ebp+var_60] }
    ++v28;
    __asm { fld     ds:dbl_100099D0 }
    v6 += 72;
LABEL_9:
    _ESI += 16;
  }
  while ( v31-- != 1 );
  v10 = v28;
  __asm
  {
    fstp    st(1)
    fstp    st
  }
  if ( v28 > 0 )
  {
    v11 = &v30;
    do
    {
      UF_MTX3_multiply(&v19, v11, &v19);
      v11 += 72;
      --v10;
    }
    while ( v10 );
  }
  _EAX = a5;
  __asm
  {
    fld     [ebp+var_58]
    fstp    qword ptr [eax+18h]
    fld     [ebp+var_40]
    fstp    qword ptr [eax+30h]
  }
  dword_1000C670 = 0;
  __asm
  {
    fld     [ebp+var_28]
    fstp    qword ptr [eax+48h]
    fld     [ebp+var_50]
    fstp    qword ptr [eax+20h]
    fld     [ebp+var_38]
    fstp    qword ptr [eax+38h]
    fld     [ebp+var_20]
    fstp    qword ptr [eax+50h]
    fld     [ebp+var_48]
    fstp    qword ptr [eax+28h]
    fld     [ebp+var_30]
    fstp    qword ptr [eax+40h]
    fld     [ebp+var_18]
    fstp    qword ptr [eax+58h]
  }
  return 0;
}

//----- (10007D6B) --------------------------------------------------------
int __cdecl sub_10007D6B()
{
  return _clean_type_info_names_internal(&unk_1000C67C);
}

//----- (10007E2E) --------------------------------------------------------
int (*__cdecl sub_10007E2E())(void)
{
  int (*result)(void); // eax@1
  unsigned int v1; // esi@1

  result = (int (*)(void))&unk_1000AE78;
  v1 = (unsigned int)&unk_1000AE78;
  if ( &unk_1000AE78 < &unk_1000AE78 )
  {
    do
    {
      result = *(int (**)(void))v1;
      if ( *(_DWORD *)v1 )
        result = (int (*)(void))result();
      v1 += 4;
    }
    while ( v1 < (unsigned int)&unk_1000AE78 );
  }
  return result;
}

//----- (10007E52) --------------------------------------------------------
int (*__cdecl sub_10007E52())(void)
{
  int (*result)(void); // eax@1
  unsigned int v1; // esi@1

  result = (int (*)(void))&unk_1000AE80;
  v1 = (unsigned int)&unk_1000AE80;
  if ( &unk_1000AE80 < &unk_1000AE80 )
  {
    do
    {
      result = *(int (**)(void))v1;
      if ( *(_DWORD *)v1 )
        result = (int (*)(void))result();
      v1 += 4;
    }
    while ( v1 < (unsigned int)&unk_1000AE80 );
  }
  return result;
}

//----- (10007FE4) --------------------------------------------------------
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
  if ( fdwReason == 1 )
  {
    if ( !dword_1000ADB8 )
      DisableThreadLibraryCalls(hinstDLL);
  }
  return 1;
}

//----- (100081C4) --------------------------------------------------------
int __cdecl sub_100081C4()
{
  dword_1000C9AC = unknown_libname_1();
  return 0;
}

// ALL OK, 56 function(s) have been successfully decompiled
