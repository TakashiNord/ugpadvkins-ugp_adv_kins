/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007 Hex-Rays sprl <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Data declarations

// extern void *adjust_fdiv; weak
extern _UNKNOWN unk_10009168; // weak
extern _UNKNOWN unk_10009170; // weak
extern _UNKNOWN unk_1000917C; // weak
extern char aReturnedErrorD[]; // idb
extern char aReturnedAD[]; // idb
extern char aSLineDS[]; // idb
extern char aKinematics[11]; // weak
extern char aErrorAdvancedK[]; // idb
extern char aUgpkin[13]; // weak
extern char aNumberOfArgume[]; // idb
extern char aIncorrectNumbe[]; // idb
extern char aSet_rotd_opera[]; // idb
extern char aSet_rotd_mcs_m[]; // idb
extern char aCaxis[6]; // weak
extern char aBaxis[6]; // weak
extern char aAaxis[6]; // weak
extern char aInsufficientNu[]; // idb
extern char aPos_z[6]; // weak
extern char aPos_y[6]; // weak
extern char aPos_x[6]; // weak
extern char aMom_transfer_g[]; // idb
extern char aMom_process_in[]; // idb
extern char aSet_input_poin[]; // idb
extern char a5_axis_head_ta[]; // idb
extern char a5_axis_dual_he[]; // idb
extern char a5_axis_dual_ta[]; // idb
extern char aNegz[]; // idb
extern char aNegy[]; // idb
extern char aNegx[]; // idb
extern char aPosz[]; // idb
extern char aPosy[]; // idb
extern char aPosx[]; // idb
extern char aAlt_pos_a2[11]; // weak
extern char aAlt_pos_a1[11]; // weak
extern char aAlt_pos_z[10]; // weak
extern char aAlt_pos_y[10]; // weak
extern char aAlt_pos_x[10]; // weak
extern char aPos_a2[7]; // weak
extern char aPos_a1[7]; // weak
extern char aUf_attr_read_v[]; // idb
extern char aUf_obj_cycle_b[]; // idb
extern char aNoToolNameObta[34]; // weak
extern char aErrorS[]; // idb
extern char aInvalidNumberO[28]; // weak
extern int dword_100095CC; // weak
extern int dword_100095D0; // weak
extern __int16 word_100095D4; // weak
extern int dword_100095D8; // weak
extern int dword_100095DC; // weak
extern int dword_100095E0; // weak
extern int dword_100095E4; // weak
extern int dword_100095E8; // weak
extern char aUf_mom_exten_4[87]; // weak
extern char aMom_exit_kinem[27]; // weak
extern char aUf_mom_exten_3[81]; // weak
extern char aMom_map_to_rot[24]; // weak
extern char aUf_mom_exten_2[75]; // weak
extern char aMom_rotate_mac[21]; // weak
extern char aUf_mom_exten_1[80]; // weak
extern char aMom_get_tool_a[23]; // weak
extern char aUf_mom_exten_0[69]; // weak
extern char aMom_convert_po[18]; // weak
extern char aOUgnx75Ip32Src[63]; // weak
extern char aUf_mom_extend_[73]; // weak
extern char aMom_load_kinem[20]; // weak
extern char aErrorUgpostAdv[]; // idb
extern _UNKNOWN unk_100098E0; // weak
extern _UNKNOWN unk_10009928; // weak
extern _UNKNOWN unk_10009970; // weak
extern char aWarningSameVal[]; // idb
extern char aComputingT11FT[]; // idb
extern char aComputingT10FT[]; // idb
extern char aAboutAdjusting[]; // idb
extern char aWarningDegener[]; // idb
extern char aInputPoint_4f_[]; // idb
extern char aStartingOld_pc[]; // idb
extern char asc_10009BA4[]; // idb
extern char aInit_t11Init_t[]; // idb
extern char aInit_t10Init_t[]; // idb
extern char aA1FD1FAlpha1FA[]; // idb
extern char aWarningToolAxi[]; // idb
extern char aLocalSecondary[]; // idb
extern char aLocalPrimaryax[]; // idb
extern char aSulzerCase[]; // idb
extern char aMcsysFFFFFFFFF[]; // idb
extern char aTool_vectorFFF[]; // idb
extern char aTool_machine_c[]; // idb
extern char aSecondary_mach[]; // idb
extern char aSecondaryFFF[]; // idb
extern char aPrimary_machin[]; // idb
extern char aPrimaryFFF[]; // idb
extern char aIs_5_axis_head[]; // idb
extern char aIs_5_axis_du_0[21]; // weak
extern char aIs_5_axis_dual[22]; // weak
extern char aIs_orthogonal_[]; // idb
extern char asc_10009E58[]; // idb
extern char aFinalUfuncAlt_[]; // idb
extern char aFinalUfuncMcoo[]; // idb
extern char a400_00[7]; // weak
extern char a0_0[4]; // weak
extern wchar_t aF[2]; // weak
extern char aIn[3]; // weak
extern char aNone[5]; // weak
extern char aMom_kin_rapid_[24]; // weak
extern char aMom_kin_pivot_[27]; // weak
extern char aMom_kin_read_a[31]; // weak
extern char aMom_kin_polar_[26]; // weak
extern char aMom_kin_output[20]; // weak
extern char aEnd[4]; // weak
extern char aMom_kin_nurbs_[26]; // weak
extern char a9999_9999[10]; // weak
extern char a0_0001[7]; // weak
extern char aXy[3]; // weak
extern char aFull_circle[12]; // weak
extern char aMom_kin_max_ar[23]; // weak
extern char aMom_kin_min_ar[23]; // weak
extern char aMom_kin_arc_va[24]; // weak
extern char aMom_kin_arc_ou[24]; // weak
extern char a99999_999[10]; // weak
extern char a99_999[7]; // weak
extern char a0_001[6]; // weak
extern char a999_999[8]; // weak
extern char aMom_kin_min_dp[16]; // weak
extern char aMom_kin_max_dp[16]; // weak
extern char aMom_kin_min_fr[16]; // weak
extern char aMom_kin_max_fr[16]; // weak
extern char aMom_kin_min__0[16]; // weak
extern char aMom_kin_max__0[16]; // weak
extern char aMom_kin_min_fp[16]; // weak
extern char aMom_kin_max_fp[16]; // weak
extern char a360_0[6]; // weak
extern char aStandard[9]; // weak
extern char aMagnitude_dete[31]; // weak
extern char aYz[3]; // weak
extern char aMom_kin_4th_13[27]; // weak
extern char aMom_kin_4th_12[27]; // weak
extern char aMom_kin_4th_11[26]; // weak
extern char aMom_kin_4th_10[26]; // weak
extern char aMom_kin_4th__9[26]; // weak
extern char aMom_kin_4th__8[33]; // weak
extern char aMom_kin_4th__7[33]; // weak
extern char aMom_kin_4th__6[33]; // weak
extern char aMom_kin_4th__5[22]; // weak
extern char aMom_kin_4th__4[27]; // weak
extern char aMom_kin_4th__3[27]; // weak
extern char aMom_kin_4th__2[26]; // weak
extern char aMom_kin_4th__1[26]; // weak
extern char aMom_kin_4th__0[27]; // weak
extern char aMom_kin_4th_ax[23]; // weak
extern char aMom_kin_5th_13[27]; // weak
extern char aMom_kin_5th_12[27]; // weak
extern char aMom_kin_5th_11[26]; // weak
extern char aMom_kin_5th_10[26]; // weak
extern char aMom_kin_5th__9[26]; // weak
extern char aMom_kin_5th__8[33]; // weak
extern char aMom_kin_5th__7[33]; // weak
extern char aMom_kin_5th__6[33]; // weak
extern char aMom_kin_5th__5[22]; // weak
extern char aMom_kin_5th__4[27]; // weak
extern char aMom_kin_5th__3[27]; // weak
extern char aMom_kin_5th__2[26]; // weak
extern char aMom_kin_5th__1[26]; // weak
extern char aMom_kin_5th__0[27]; // weak
extern char aMom_kin_5th_ax[23]; // weak
extern char aFront[6]; // weak
extern char aMom_kin_ind__0[32]; // weak
extern char aMom_kin_ind_to[32]; // weak
extern char aMom_kin_indepe[25]; // weak
extern char a3_0[4]; // weak
extern char a0_5[4]; // weak
extern char aMom_kin_flush_[19]; // weak
extern char aMom_kin_clamp_[19]; // weak
extern char aMom_kin_tool_c[25]; // weak
extern char aMom_kin_hol_22[25]; // weak
extern char aMom_kin_hol_21[25]; // weak
extern char aMom_kin_hol_20[25]; // weak
extern char aMom_kin_hol_19[25]; // weak
extern char aMom_kin_hol_18[25]; // weak
extern char aMom_kin_hol_17[25]; // weak
extern char aMom_kin_hol_16[25]; // weak
extern char aMom_kin_hol_15[25]; // weak
extern char aMom_kin_hol_14[25]; // weak
extern char aMom_kin_hol_13[25]; // weak
extern char aMom_kin_hol_12[25]; // weak
extern char aMom_kin_hol_11[25]; // weak
extern char aMom_kin_hol_10[25]; // weak
extern char aMom_kin_hold_9[25]; // weak
extern char aMom_kin_hold_8[25]; // weak
extern char aMom_kin_hold_7[25]; // weak
extern char aMom_kin_hold_6[25]; // weak
extern char aMom_kin_hold_5[25]; // weak
extern char aMom_kin_hold_4[28]; // weak
extern char aMom_kin_hold_3[28]; // weak
extern char aMom_kin_hold_2[28]; // weak
extern char aMom_kin_hold_1[28]; // weak
extern char aMom_kin_hold_0[28]; // weak
extern char aMom_kin_holder[28]; // weak
extern char aKin_4th_to_t_1[28]; // weak
extern char aKin_4th_to_t_0[28]; // weak
extern char aKin_4th_to_tra[28]; // weak
extern char a90_0[5]; // weak
extern char aCartesian[10]; // weak
extern wchar_t aT[2]; // weak
extern char a3_axis_mill[12]; // weak
extern char aMom_kin_gaug_0[25]; // weak
extern char aMom_kin_line_0[26]; // weak
extern char aMom_kin_5th_14[36]; // weak
extern char aMom_kin_tool_t[29]; // weak
extern char aMom_kin_mach_0[27]; // weak
extern char aMom_kin_linear[27]; // weak
extern char aMom_kin_coordi[24]; // weak
extern char aMom_kin_clsf_g[24]; // weak
extern char aMom_kin_wire_t[30]; // weak
extern char aMom_kin_track_[29]; // weak
extern char aMom_kin_machin[21]; // weak
extern char aMom_kin_gauge_[25]; // weak
extern char a1_0[4]; // weak
extern char aMom_msys_z_a_1[18]; // weak
extern char aMom_msys_z_a_0[18]; // weak
extern char aMom_msys_z_axi[18]; // weak
extern char aMom_msys_y_a_1[18]; // weak
extern char aMom_msys_y_a_0[18]; // weak
extern char aMom_msys_y_axi[18]; // weak
extern char aMom_msys_x_a_1[18]; // weak
extern char aMom_msys_x_a_0[18]; // weak
extern char aMom_msys_x_axi[18]; // weak
extern char aMom_msys_ori_1[18]; // weak
extern char aMom_msys_ori_0[18]; // weak
extern char aMom_msys_origi[18]; // weak
extern char aMom_mtsys_z__1[19]; // weak
extern char aMom_mtsys_z__0[19]; // weak
extern char aMom_mtsys_z_ax[19]; // weak
extern char aMom_mtsys_y__1[19]; // weak
extern char aMom_mtsys_y__0[19]; // weak
extern char aMom_mtsys_y_ax[19]; // weak
extern char aMom_mtsys_x__1[19]; // weak
extern char aMom_mtsys_x__0[19]; // weak
extern char aMom_mtsys_x_ax[19]; // weak
extern char aMom_mtsys_or_1[19]; // weak
extern char aMom_mtsys_or_0[19]; // weak
extern char aMom_mtsys_orig[19]; // weak
extern char aMill[5]; // weak
extern char aMom_tool_corne[24]; // weak
extern char aMom_tool_z_off[18]; // weak
extern char aMom_tool_type[14]; // weak
extern char aMom_translat_1[16]; // weak
extern char aMom_translat_0[16]; // weak
extern char aMom_translate_[16]; // weak
extern char aMom_origin_z[13]; // weak
extern char aMom_origin_y[13]; // weak
extern char aMom_origin_x[13]; // weak
extern char aMom_tool_axi_1[16]; // weak
extern char aMom_tool_axi_0[16]; // weak
extern char aMom_tool_axis_[16]; // weak
extern char aMom_mcs_goto_z[15]; // weak
extern char aMom_mcs_goto_y[15]; // weak
extern char aMom_mcs_goto_x[15]; // weak
extern char aWarningTheTo_0[119]; // weak
extern char aWarningTheTool[]; // idb
extern int (__stdcall *dword_1000ADA8)(_DWORD, _DWORD, _DWORD); // idb
extern struct _EXCEPTION_POINTERS ExceptionInfo; // idb
extern _UNKNOWN unk_1000AE58; // weak
extern _UNKNOWN unk_1000AEB0; // weak
extern char byte_1000C008; // weak
extern char byte_1000C009; // weak
extern char byte_1000C00A; // weak
extern int dword_1000C230; // weak
extern int dword_1000C238; // weak
extern int dword_1000C23C; // weak
extern int dword_1000C240; // weak
extern double dbl_1000C248; // weak
extern int dword_1000C2C8; // weak
extern int dword_1000C2CC; // weak
extern int dword_1000C2D0; // weak
extern int dword_1000C2D4; // weak
extern int dword_1000C2D8; // weak
extern int dword_1000C2DC; // weak
extern double dbl_1000C2F0; // weak
extern double dbl_1000C328; // weak
extern _UNKNOWN unk_1000C340; // weak
extern int dword_1000C3D8; // weak
extern int dword_1000C3DC; // weak
extern _UNKNOWN unk_1000C3E0; // weak
extern double dbl_1000C470; // weak
extern int dword_1000C4E0; // weak
extern int dword_1000C4E4; // weak
extern int dword_1000C4E8; // weak
extern int dword_1000C4EC; // weak
extern int dword_1000C4F0; // weak
extern int dword_1000C4F4; // weak
extern int dword_1000C4F8; // weak
extern int dword_1000C4FC; // weak
extern int dword_1000C500; // weak
extern int dword_1000C504; // weak
extern int dword_1000C508; // weak
extern int dword_1000C50C; // weak
extern int dword_1000C510; // weak
extern int dword_1000C514; // weak
extern int dword_1000C518; // weak
extern int dword_1000C51C; // weak
extern int dword_1000C520; // weak
extern int dword_1000C524; // weak
extern int dword_1000C528; // weak
extern int dword_1000C52C; // weak
extern int dword_1000C540; // weak
extern int dword_1000C544; // weak
extern int dword_1000C548; // weak
extern int dword_1000C54C; // weak
extern int dword_1000C550; // weak
extern int dword_1000C554; // weak
extern double dbl_1000C558; // weak
extern double dbl_1000C560; // weak
extern double dbl_1000C568; // weak
extern double dbl_1000C570; // weak
extern char byte_1000C588; // weak
extern _UNKNOWN unk_1000C590; // weak
extern _UNKNOWN unk_1000C5B8; // weak
extern _UNKNOWN unk_1000C5E0; // weak
extern double dbl_1000C628; // weak
extern _UNKNOWN unk_1000C640; // weak
extern int dword_1000C660; // weak
extern int dword_1000C670; // weak
extern int dword_1000C674; // weak
extern _UNKNOWN unk_1000C67C; // weak
extern int dword_1000C688; // weak
extern int dword_1000C68C; // weak
extern int dword_1000C694; // weak
extern int dword_1000C6D8; // weak
extern int dword_1000C6E0; // weak
extern __int16 word_1000C76C; // weak
extern __int16 word_1000C770; // weak
extern __int16 word_1000C774; // weak
extern __int16 word_1000C778; // weak
extern int dword_1000C77C; // weak
extern int dword_1000C780; // weak
extern int dword_1000C784; // weak
extern int dword_1000C788; // weak
extern int dword_1000C78C; // weak
extern int dword_1000C790; // weak
extern int dword_1000C794; // weak
extern int dword_1000C798; // weak
extern __int16 word_1000C79C; // weak
extern int dword_1000C7A0; // weak
extern int dword_1000C7A4; // weak
extern __int16 word_1000C7A8; // weak
extern int dword_1000C9AC; // weak
extern int dword_1000C9B0; // weak
extern int dword_1000C9B4; // weak
extern PVOID Destination; // idb
extern int dword_1000C9BC; // weak
extern int dword_1000C9C0; // weak
extern int (__thiscall *dword_1000C9C4)(_DWORD, _DWORD, _DWORD, _DWORD); // idb

//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

// int __usercall sub_10001000<eax>(int a1<eax>, int a2<edx>, int a3<ecx>, int a4<esi>);
signed int __cdecl sub_10001060(char *a1); // idb
// int __cdecl UF_terminate();
// signed int __usercall sub_100010C0<eax>(int _EBX<ebx>, int a2<esi>, int a3, int a4, int a5, int a6);
int __cdecl sub_100012B0(int a1);
int __cdecl sub_10001390(char *a1); // idb
int __cdecl sub_10001B00(int a1);
signed int __cdecl sub_10001C00(int a1, int a2, int a3, int a4);
int __cdecl ufusr(int a1, int a2);
// int __usercall sub_10001F60<eax>(int a1<eax>, int a2<ecx>, int a3<esi>, char a4);
void __cdecl sub_10001F90(double a1); // idb
// int __usercall sub_10001FE0<eax>(int result<eax>, int _ECX<ecx>, double a3); idb
// int __usercall sub_100020C0<eax>(int a1<eax>, int a2<ecx>, int a3);
// int __usercall sub_10002190<eax>(int a1<eax>, int a2<esi>, double a3, double a4, int a5); idb
int __cdecl sub_10002310(int a1, double a2, int a3); // idb
int __cdecl sub_10002390(int a1, double a2, int a3); // idb
int __fastcall sub_100023D0(int a1, int a2, int a3);
signed int __cdecl sub_100023F0(const void *a1, const void *a2); // idb
__int16 __cdecl sub_10002430();
__int16 __cdecl sub_10002580(double a1); // idb
// __int16 __usercall sub_100025B0<ax>(int _EDX<edx>, const void *_EBX<ebx>);
int __cdecl sub_100026E0(int a1);
int __cdecl sub_10002770(int a1, int a2, int a3, int a4);
// int __usercall sub_10002830<eax>(int a1<esi>, int a2, int a3, int a4);
// __int16 __usercall sub_10002C00<ax>(int _EAX<eax>, int _ECX<ecx>, int a3, int a4);
__int16 __cdecl sub_10002DC0(int a2);
int __cdecl sub_10002EE0(int a2, int a3);
// signed int __usercall sub_10003100<eax>(int a1<ebx>, int a2<edi>, int a3<esi>, const void *a4, int a5, int a6);
int __cdecl sub_10003E70(int a1, int a2, int a3, int a4, int a5, int a6);
signed int __cdecl sub_10004090(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __cdecl sub_10004E60(int a1, int a2, int a3);
__int16 __cdecl sub_10005050(int a1, int a2);
// signed int __usercall sub_100050E0<eax>(int a1<eax>);
signed int __cdecl sub_10005200(int a1);
int __fastcall sub_10005240(int a1, int a2, char a3);
int __cdecl sub_10005260(int a1, int a2);
int __cdecl sub_10005430(int a1, int a2);
int __cdecl sub_100055A0(int a1, int a2);
int __cdecl sub_100057A0(int a1, int a2);
int __cdecl sub_10005B10(int a1, int a2);
int __cdecl sub_10005E80(int a1, int a2);
int __cdecl sub_10005FC0(int a1, int a2);
int __cdecl sub_100060F0(int a1, int a2);
int __cdecl sub_10006610(int a1, int a2);
int __cdecl sub_100069C0(int a1, int a2);
int __cdecl sub_10006C70(int a1, int a2);
int __cdecl sub_10006F40(int a1, int a2);
int __cdecl sub_10007190(int a1, int a2);
int __cdecl sub_10007340(int a1, char *a2); // idb
int __cdecl sub_10007590(int a1, int a2);
int __cdecl sub_10007690(int a1, int a2);
// int __usercall sub_10007730<eax>(int a1<ebx>, int a2<edi>, int a3<esi>, int a4, int a5, int a6);
void __cdecl NXSigningResource(); // idb
signed int __stdcall sub_100078F0(int a1, void *a2, int a3); // idb
int __fastcall sub_10007B16(int a1, int a2, HMODULE hLibModule); // idb
void __cdecl sub_10007C21();
BOOL __stdcall DllEntryPoint(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved); // idb
// int __stdcall CIasin(_DWORD, _DWORD, _DWORD); weak
// double __cdecl floor(double); idb
int __cdecl sub_10007C70();
int __cdecl sub_10007D1B();
_onexit_t __cdecl sub_10007D27(_onexit_t a1); // idb
int __cdecl sub_10007DC3();
int __cdecl sub_10007DCC(_onexit_t a1); // idb
int (*__cdecl sub_10007DE3())(void);
bool __cdecl sub_10007E30(int a1);
int __cdecl sub_10007E70(int a1, unsigned int a2);
// unsigned int __usercall sub_10007EC0<eax>(int a1<eax>, int a2);
// int __cdecl initterm(_DWORD); weak
// int __cdecl initterm_e(_DWORD, _DWORD); weak
// int __cdecl amsg_exit(_DWORD); weak
signed int __stdcall sub_10007F96(HMODULE hLibModule, int a2, int a3); // idb
int __cdecl sub_10008015(int a1, int a2, int a3, int a4);
unsigned __int32 __cdecl sub_1000803A();
signed int __cdecl sub_100080D0();
// bool __usercall sub_10008120<eax>(int a1<ebx>);
// int __usercall sub_10008182<eax>(int a1<ebx>);
// int __cdecl _clean_type_info_names_internal(_DWORD); weak
// int __cdecl unlock(_DWORD); weak
// int __cdecl _dllonexit(_DWORD, _DWORD, _DWORD); weak
// int __cdecl lock(_DWORD); weak
// BOOL __usercall sub_100081A8<eax>(int a1<eax>, int a2<edx>, int a3<ecx>, int a4<ebx>, int a5<edi>, int a6<esi>, char a7);
// int __cdecl except_handler4_common(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// BOOL __usercall sub_100081BE<eax>(int a1<eax>, int a2<edx>, int a3<ecx>, int a4<ebx>, int a5<edi>, int a6<esi>, char a7);
// int __cdecl crt_debugger_hook(_DWORD); weak
// LONG __stdcall UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo); idb
// HANDLE __stdcall GetCurrentProcess(); idb
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode); idb
// void __stdcall GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime); idb
// DWORD __stdcall GetCurrentProcessId(); idb
// DWORD __stdcall GetCurrentThreadId(); idb
// DWORD __stdcall GetTickCount(); idb
// BOOL __stdcall QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount); idb
// BOOL __stdcall DisableThreadLibraryCalls(HMODULE hLibModule); idb
// PVOID __stdcall InterlockedCompareExchange(PVOID *Destination, PVOID Exchange, PVOID Comperand); idb
// void __stdcall Sleep(DWORD dwMilliseconds); idb
// LONG __stdcall InterlockedExchange(LPLONG Target, LONG Value); idb
// BOOL __stdcall IsDebuggerPresent(); idb
// LPTOP_LEVEL_EXCEPTION_FILTER __stdcall SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter); idb
// _onexit_t __cdecl onexit(_onexit_t); idb
// int __cdecl decode_pointer(_DWORD); weak
// int __thiscall encoded_null(_DWORD); weak
// int __cdecl encode_pointer(_DWORD); weak
// double __cdecl ceil(double); idb
// void __cdecl qsort(void *, size_t, size_t, int (__cdecl *)(const void *, const void *)); idb
// void __cdecl CIacos(); weak
// int __cdecl atoi(const char *); idb
// void *__cdecl malloc(size_t); idb
// double __cdecl strtod(const char *, char **); idb
// void __cdecl free(void *); idb
// int sprintf(char *, const char *, ...); idb
// int printf(const char *, ...); idb
// char *__cdecl strstr(const char *, const char *); idb
// int __cdecl UF_VEC3_cross(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_get_fail_message(_DWORD, _DWORD); weak
// int __cdecl UF_MTX3_rotate_about_axis(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_edit_rotation(_DWORD, _DWORD); weak
// int __cdecl UF_VEC3_scale(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_is_parallel(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_z_vec(_DWORD, _DWORD); weak
// int __cdecl UF_VEC3_distance(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_vec_multiply_t(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall UF_VEC3_is_zero(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_affine_comb(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_is_equal(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_allocate_memory(_DWORD, _DWORD); weak
// int __cdecl UF_free(_DWORD); weak
// int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_dot(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_copy(_DWORD, _DWORD); weak
// int __cdecl UF_VEC3_angle_between(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_vec3_multiply_t(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_add(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_rotation(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_ask_rotation(_DWORD, _DWORD); weak
// int __cdecl UF_MTX3_vec_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_vec3_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_vec_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_copy(_DWORD, _DWORD); weak
// int __cdecl UF_MTX3_x_vec(_DWORD, _DWORD); weak
// int __cdecl UF_MTX3_y_vec(_DWORD, _DWORD); weak
// int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MOM_ask_interp_from_param(_DWORD, _DWORD); weak
// int __cdecl UF_MOM_ask_mom(_DWORD, _DWORD); weak
// int __cdecl UF_MOM_extend_xlator(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_OBJ_cycle_by_name(_DWORD, _DWORD); weak
// int __cdecl UF_ATTR_read_value(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MOM_set_string(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MOM_set_double(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int UF_terminate(void); weak
// int __cdecl UF_MISC_set_program_name(_DWORD); weak
// int UF_initialize(void); weak
// int __cdecl UF_MTX4_csys_to_csys(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl uc1601(_DWORD, _DWORD); weak


//----- (10001000) --------------------------------------------------------
int __usercall sub_10001000<eax>(int a1<eax>, int a2<edx>, int a3<ecx>, int a4<esi>)
{
  char v5; // [sp+0h] [bp-88h]@2

  if ( a4 )
  {
    printf("%s, line %d:  %s\n", a2, a3, a1);
    if ( UF_get_fail_message(a4, &v5) )
    {
      printf("    returned a %d\n", a4);
      return a4;
    }
    printf("    returned error %d:  %s\n", a4, &v5);
  }
  return a4;
}

//----- (10001060) --------------------------------------------------------
signed int __cdecl sub_10001060(char *a1)
{
  signed int result; // eax@2

  UF_MISC_set_program_name("<!<UGPKIN>!>");
  if ( UF_initialize() )
  {
    sprintf(a1, "ERROR!: Advanced Kinematics Module Unavailable");
    result = 1;
  }
  else
  {
    UF_MISC_set_program_name("Kinematics");
    result = 0;
  }
  return result;
}

//----- (100010C0) --------------------------------------------------------
signed int __usercall sub_100010C0<eax>(int _EBX<ebx>, int a2<esi>, int a3, int a4, int a5, int a6)
{
  signed int result; // eax@4
  int v7; // edi@5
  int v8; // edi@15
  int v9; // esi@15
  void *v10; // ebx@17
  int v11; // esi@17
  int v12; // eax@15
  int v13; // eax@17
  __int64 v14; // [sp+0h] [bp-34h]@1
  void *v20; // [sp+30h] [bp-4h]@1

  __asm
  {
    fldz
    fst     [ebp+var_34]
    fst     [ebp+var_2C]
    fst     [ebp+var_24]
    fst     [ebp+var_1C]
    fst     [ebp+var_14]
    fstp    [ebp+var_C]
  }
  v20 = malloc(0x90u);
  if ( a5 > 7 || a5 == 1 )
  {
    printf(" Incorrect number of arguments\n");
    printf(" Number of arguments should be between 1 and 6\n ");
    result = 999;
  }
  else
  {
    if ( !(a5 % 2) )
    {
      printf(" Insufficient number of arguments, There should be               atleast 2 arguments\n ");
      return 999;
    }
    v7 = 1;
    if ( a5 > 1 )
    {
      _EBX = (int)&v14;
      while ( 1 )
      {
        a2 = *(_DWORD *)(a6 + 4 * v7);
        if ( !strcmp(*(const char **)(a6 + 4 * v7), "AAXIS") )
          break;
        if ( !strcmp(*(const char **)(a6 + 4 * v7), "BAXIS") )
        {
          __asm { fld     ds:dbl_10009308 }
          goto LABEL_13;
        }
        if ( !strcmp(*(const char **)(a6 + 4 * v7), "CAXIS") )
        {
          __asm { fld     ds:dbl_100092F8 }
          goto LABEL_13;
        }
LABEL_14:
        strtod(*(const char **)(a6 + 4 * v7 + 4), 0);
        __asm { fstp    qword ptr [ebx+8] }
        v7 += 2;
        _EBX += 16;
        if ( v7 >= a5 )
          goto LABEL_15;
      }
      __asm { fld1 }
LABEL_13:
      __asm { fstp    qword ptr [ebx] }
      goto LABEL_14;
    }
LABEL_15:
    v8 = a3;
    v12 = sub_10007730(_EBX, a3, a2, a3, (int)v20, (int)&v14);
    v9 = v12;
    if ( v12 )
    {
      printf(" SET_rotd_mcs_matrix failed in mom_rotate_mach_csys \n ");
      result = v9;
    }
    else
    {
      v10 = v20;
      v13 = sub_10007340(v8, (char *)v20);
      v11 = v13;
      if ( v13 )
      {
        printf(" SET_rotd_operation_data failed in mom_rotate_mach_csys \n ");
        result = v11;
      }
      else
      {
        if ( v10 )
          free(v10);
        result = 0;
      }
    }
  }
  return result;
}

//----- (100012B0) --------------------------------------------------------
int __cdecl sub_100012B0(int a1)
{
  int v1; // edi@1
  int v2; // esi@1
  int result; // eax@2
  int v4; // edi@3
  int v5; // edi@5
  int v6; // eax@1
  int v7; // eax@3
  int v8; // eax@5
  __int64 v9; // ST08_8@7
  __int64 v10; // ST08_8@7
  __int64 v11; // ST08_8@7
  char v12; // [sp+40h] [bp-60h]@1
  char v13; // [sp+10h] [bp-90h]@3
  __int64 v14; // [sp+70h] [bp-30h]@5

  v2 = a1;
  v6 = sub_10007190(a1, (int)&v12);
  v1 = v6;
  if ( v6 )
  {
    printf(" SET_input_point failed in mom_map_to_rotated_csys\n ");
    result = v1;
  }
  else
  {
    v7 = sub_10007690((int)&v12, (int)&v13);
    v4 = v7;
    if ( v7 )
    {
      printf(" mom_process_input_gotos failed in mom_map_to_rotated_csys\n ");
      result = v4;
    }
    else
    {
      v8 = sub_10007590((int)&v13, (int)&v14);
      v5 = v8;
      if ( v8 )
      {
        printf(" mom_transfer_gotos_rotd_mcsys failed in mom_map_to_rotated_csys\n ");
        result = v5;
      }
      else
      {
        __asm
        {
          fld     [ebp+var_30]
          fstp    [esp+0A0h+var_A0]
        }
        UF_MOM_set_double(v2, "pos_x", v9, *((_DWORD *)&v9 + 1));
        __asm
        {
          fld     [ebp+var_28]
          fstp    [esp+0A0h+var_A0]
        }
        UF_MOM_set_double(v2, "pos_y", v10, *((_DWORD *)&v10 + 1));
        __asm
        {
          fld     [ebp+var_20]
          fstp    [esp+0A0h+var_A0]
        }
        UF_MOM_set_double(v2, "pos_z", v11, *((_DWORD *)&v11 + 1));
        result = 0;
      }
    }
  }
  return result;
}

//----- (10001390) --------------------------------------------------------
int __cdecl sub_10001390(char *a1)
{
  void *v1; // eax@1
  void *v3; // edi@1
  int v4; // esi@1
  void *v7; // eax@1
  void *v8; // eax@1
  void *v9; // eax@1
  void *v10; // eax@1
  int v11; // eax@1
  void *v12; // eax@1
  void *v13; // eax@1
  void *v14; // eax@1
  void *v15; // eax@1
  char *v16; // eax@3
  void *v17; // ecx@3
  void *v18; // edx@3
  void *v19; // eax@3
  void *v20; // ecx@3
  char *v21; // eax@3
  void *v22; // ecx@3
  int v24; // edx@21
  int v25; // edx@21
  int v26; // eax@21
  int v27; // ecx@21
  int v28; // eax@21
  int v29; // ecx@21
  char *v32; // [sp+344h] [bp-24h]@1
  void *v33; // [sp+360h] [bp-8h]@1
  void *v34; // [sp+334h] [bp-34h]@1
  void *v35; // [sp+33Ch] [bp-2Ch]@1
  void *v36; // [sp+364h] [bp-4h]@1
  void *v37; // [sp+338h] [bp-30h]@1
  void *v38; // [sp+340h] [bp-28h]@1
  __int64 v39; // [sp+ECh] [bp-27Ch]@3
  __int64 v40; // [sp+Ch] [bp-35Ch]@3
  __int64 v41; // [sp+274h] [bp-F4h]@3
  __int64 v42; // [sp+F4h] [bp-274h]@3
  __int64 v43; // [sp+27Ch] [bp-ECh]@3
  __int64 v44; // [sp+24h] [bp-344h]@3
  int v45; // [sp+100h] [bp-268h]@3
  int v46; // [sp+288h] [bp-E0h]@3
  __int64 v47; // [sp+104h] [bp-264h]@3
  __int64 v48; // [sp+28Ch] [bp-DCh]@3
  __int64 v49; // [sp+3Ch] [bp-32Ch]@3
  __int64 v50; // [sp+10Ch] [bp-25Ch]@3
  __int64 v51; // [sp+294h] [bp-D4h]@3
  __int64 v53; // [sp+11Ch] [bp-24Ch]@3
  __int64 v54; // [sp+2A4h] [bp-C4h]@3
  __int64 v57; // [sp+FCh] [bp-26Ch]@3
  int v59; // [sp+284h] [bp-E4h]@3
  __int64 v61; // [sp+114h] [bp-254h]@3
  __int64 v62; // [sp+29Ch] [bp-CCh]@3
  __int64 v64; // [sp+124h] [bp-244h]@3
  __int64 v65; // [sp+2ACh] [bp-BCh]@3
  __int64 v66; // [sp+134h] [bp-234h]@3
  __int64 v67; // [sp+2BCh] [bp-ACh]@3
  __int64 v68; // [sp+12Ch] [bp-23Ch]@3
  __int64 v69; // [sp+2B4h] [bp-B4h]@3
  __int64 v70; // [sp+13Ch] [bp-22Ch]@3
  __int64 v71; // [sp+2C4h] [bp-A4h]@3
  int v72; // [sp+14Ch] [bp-21Ch]@3
  int v73; // [sp+2D4h] [bp-94h]@3
  __int64 v74; // [sp+144h] [bp-224h]@3
  __int64 v75; // [sp+2CCh] [bp-9Ch]@3
  int v76; // [sp+158h] [bp-210h]@3
  int v77; // [sp+2E0h] [bp-88h]@3
  int v78; // [sp+150h] [bp-218h]@3
  int v79; // [sp+2D8h] [bp-90h]@3
  int v80; // [sp+154h] [bp-214h]@3
  int v81; // [sp+2DCh] [bp-8Ch]@3
  int v82; // [sp+164h] [bp-204h]@3
  int v83; // [sp+2ECh] [bp-7Ch]@3
  int v84; // [sp+15Ch] [bp-20Ch]@3
  int v85; // [sp+2E4h] [bp-84h]@3
  int v86; // [sp+160h] [bp-208h]@3
  int v87; // [sp+2E8h] [bp-80h]@3
  int v88; // [sp+170h] [bp-1F8h]@3
  int v89; // [sp+2F8h] [bp-70h]@3
  int v90; // [sp+168h] [bp-200h]@3
  int v91; // [sp+2F0h] [bp-78h]@3
  int v92; // [sp+16Ch] [bp-1FCh]@3
  int v93; // [sp+2F4h] [bp-74h]@3
  int v94; // [sp+17Ch] [bp-1ECh]@3
  int v95; // [sp+304h] [bp-64h]@3
  int v96; // [sp+174h] [bp-1F4h]@3
  int v97; // [sp+2FCh] [bp-6Ch]@3
  int v98; // [sp+178h] [bp-1F0h]@3
  int v99; // [sp+300h] [bp-68h]@3
  int v100; // [sp+188h] [bp-1E0h]@3
  int v101; // [sp+310h] [bp-58h]@3
  int v102; // [sp+180h] [bp-1E8h]@3
  int v103; // [sp+308h] [bp-60h]@3
  int v104; // [sp+184h] [bp-1E4h]@3
  int v105; // [sp+30Ch] [bp-5Ch]@3
  int v106; // [sp+194h] [bp-1D4h]@3
  int v107; // [sp+31Ch] [bp-4Ch]@3
  int v108; // [sp+18Ch] [bp-1DCh]@3
  int v109; // [sp+314h] [bp-54h]@3
  int v110; // [sp+190h] [bp-1D8h]@3
  int v111; // [sp+318h] [bp-50h]@3
  int v112; // [sp+1A0h] [bp-1C8h]@3
  int v113; // [sp+328h] [bp-40h]@3
  int v114; // [sp+198h] [bp-1D0h]@3
  int v115; // [sp+320h] [bp-48h]@3
  int v116; // [sp+19Ch] [bp-1CCh]@3
  int v117; // [sp+324h] [bp-44h]@3
  int v118; // [sp+1A4h] [bp-1C4h]@3
  int v119; // [sp+32Ch] [bp-3Ch]@3
  int v120; // [sp+1A8h] [bp-1C0h]@3
  int v121; // [sp+330h] [bp-38h]@3
  __int64 v122; // [sp+348h] [bp-20h]@4
  signed int v125; // [sp+54h] [bp-314h]@16
  int v127; // [sp+1ACh] [bp-1BCh]@21
  int v128; // [sp+64h] [bp-304h]@21
  int v129; // [sp+1B8h] [bp-1B0h]@21
  int v130; // [sp+70h] [bp-2F8h]@21
  int v131; // [sp+1B0h] [bp-1B8h]@21
  int v132; // [sp+68h] [bp-300h]@21
  int v133; // [sp+1B4h] [bp-1B4h]@21
  int v134; // [sp+6Ch] [bp-2FCh]@21
  int v135; // [sp+1C4h] [bp-1A4h]@21
  int v136; // [sp+7Ch] [bp-2ECh]@21
  int v137; // [sp+1BCh] [bp-1ACh]@21
  int v138; // [sp+74h] [bp-2F4h]@21
  int v139; // [sp+1C0h] [bp-1A8h]@21
  int v140; // [sp+78h] [bp-2F0h]@21
  int v141; // [sp+1D0h] [bp-198h]@21
  int v142; // [sp+88h] [bp-2E0h]@21
  int v143; // [sp+1C8h] [bp-1A0h]@21
  int v144; // [sp+80h] [bp-2E8h]@21
  int v145; // [sp+1CCh] [bp-19Ch]@21
  int v146; // [sp+84h] [bp-2E4h]@21
  int v147; // [sp+94h] [bp-2D4h]@21
  int v148; // [sp+1D4h] [bp-194h]@21
  int v149; // [sp+8Ch] [bp-2DCh]@21
  int v150; // [sp+1D8h] [bp-190h]@21
  int v151; // [sp+90h] [bp-2D8h]@21
  int v152; // [sp+A0h] [bp-2C8h]@21
  int v153; // [sp+98h] [bp-2D0h]@21
  int v154; // [sp+9Ch] [bp-2CCh]@21
  int v155; // [sp+A4h] [bp-2C4h]@21
  int v156; // [sp+A8h] [bp-2C0h]@21
  char v159; // [sp+ACh] [bp-2BCh]@21

  v7 = malloc(0x358u);
  v4 = (int)a1;
  v32 = (char *)v7;
  sub_10006610((int)a1, (int)v7);
  v8 = malloc(0x228u);
  v33 = v8;
  sub_10005260(v4, (int)v8);
  v9 = malloc(0x120u);
  v34 = v9;
  sub_10005430(v4, (int)v9);
  v10 = malloc(0x40u);
  v35 = v10;
  sub_100055A0(v4, (int)v10);
  v11 = (int)malloc(0x1F0u);
  _EBX = v11;
  sub_100057A0(v4, v11);
  v12 = malloc(0x1F0u);
  v36 = v12;
  sub_10005B10(v4, (int)v12);
  v13 = malloc(0x98u);
  v37 = v13;
  sub_10005E80(v4, (int)v13);
  v14 = malloc(0x3B0u);
  a1 = (char *)v14;
  sub_100060F0(v4, (int)v14);
  v15 = malloc(0x18u);
  v38 = v15;
  sub_10005FC0(v4, (int)v15);
  v1 = malloc(0x24u);
  v3 = v1;
  if ( !v1 )
    return (int)((char *)v1 + 1);
  v16 = v32;
  v17 = v33;
  *((_DWORD *)v3 + 2) = v34;
  v18 = v37;
  *(_DWORD *)v3 = v16;
  v19 = v35;
  *((_DWORD *)v3 + 1) = v17;
  v20 = v36;
  *((_DWORD *)v3 + 6) = v18;
  *((_DWORD *)v3 + 3) = v19;
  v21 = a1;
  *((_DWORD *)v3 + 5) = v20;
  v22 = v38;
  *((_DWORD *)v3 + 4) = _EBX;
  *((_DWORD *)v3 + 7) = v21;
  *((_DWORD *)v3 + 8) = v22;
  sub_100069C0(v4, (int)&v39);
  sub_10006C70(v4, (int)&v39);
  sub_10006F40(v4, (int)&v39);
  __asm
  {
    fld     [ebp+var_27C]
    fadd    qword ptr [ebx+1B0h]
  }
  _EAX = v36;
  _ESI = v32;
  __asm
  {
    fst     [ebp+var_35C]
    fld     qword ptr [eax+1B0h]
  }
  v41 = v39;
  __asm { fadd    st, st(1) }
  v43 = v42;
  __asm
  {
    fstp    [ebp+var_344]
    fadd    qword ptr [esi+340h]
  }
  v46 = v45;
  v48 = v47;
  __asm
  {
    fstp    [ebp+var_32C]
    fld     qword ptr [ebx+1B8h]
  }
  v51 = v50;
  __asm
  {
    fadd    [ebp+var_274]
    fst     [ebp+var_354]
    fld     qword ptr [eax+1B8h]
  }
  v54 = v53;
  __asm
  {
    fadd    st, st(1)
    fstp    [ebp+var_33C]
    fadd    qword ptr [esi+348h]
    fstp    [ebp+var_324]
    fld     qword ptr [ebx+1C0h]
    fadd    qword ptr [ebp-26Ch]
    fst     [ebp+var_34C]
    fld     qword ptr [eax+1C0h]
    fadd    st, st(1)
  }
  v59 = v57;
  __asm
  {
    fstp    [ebp+var_334]
    fadd    qword ptr [esi+350h]
  }
  v62 = v61;
  __asm { fstp    [ebp+var_31C] }
  v65 = v64;
  v67 = v66;
  v69 = v68;
  v71 = v70;
  v73 = v72;
  v75 = v74;
  v77 = v76;
  v79 = v78;
  v81 = v80;
  v83 = v82;
  v85 = v84;
  v87 = v86;
  v89 = v88;
  v91 = v90;
  v93 = v92;
  v95 = v94;
  v97 = v96;
  v99 = v98;
  v101 = v100;
  v103 = v102;
  v105 = v104;
  v107 = v106;
  v109 = v108;
  v111 = v110;
  v113 = v112;
  v115 = v114;
  v117 = v116;
  v119 = v118;
  v121 = v120;
  if ( strstr(a1, "POSX") )
  {
    __asm
    {
      fld     [ebp+var_264]
      fstp    [ebp+var_20]
      fld     [ebp+var_25C]
      fstp    [ebp+var_18]
      fld     [ebp+var_254]
    }
  }
  else
  {
    if ( !strstr(a1, "POSY") )
    {
      if ( !strstr(a1, "POSZ") )
      {
        if ( strstr(a1, "NEGX") )
        {
          __asm
          {
            fld     [ebp+var_264]
            fchs
            fstp    [ebp+var_20]
            fld     [ebp+var_25C]
            fchs
            fstp    [ebp+var_18]
            fld     [ebp+var_254]
            fchs
          }
          goto LABEL_15;
        }
        if ( strstr(a1, "NEGY") )
        {
          __asm
          {
            fld     [ebp+var_24C]
            fchs
            fstp    [ebp+var_20]
            fld     [ebp+var_244]
            fchs
            fstp    [ebp+var_18]
            fld     [ebp+var_23C]
            fchs
          }
          goto LABEL_15;
        }
        if ( strstr(a1, "NEGZ") )
        {
          __asm
          {
            fld     [ebp+var_234]
            fchs
            fstp    [ebp+var_20]
            fld     [ebp+var_22C]
            fchs
            fstp    [ebp+var_18]
            fld     [ebp+var_224]
            fchs
          }
          goto LABEL_15;
        }
      }
      __asm
      {
        fld     [ebp+var_234]
        fstp    [ebp+var_20]
        fld     [ebp+var_22C]
        fstp    [ebp+var_18]
        fld     [ebp+var_224]
      }
      goto LABEL_15;
    }
    __asm
    {
      fld     [ebp+var_24C]
      fstp    [ebp+var_20]
      fld     [ebp+var_244]
      fstp    [ebp+var_18]
      fld     [ebp+var_23C]
    }
  }
LABEL_15:
  __asm { fstp    [ebp+var_10] }
  if ( strstr(_ESI, "5_axis_dual_table") )
  {
    v125 = 2;
  }
  else
  {
    if ( strstr(_ESI, "5_axis_dual_head") )
    {
      v125 = 1;
    }
    else
    {
      if ( strstr(_ESI, "5_axis_head_table") )
        v125 = 3;
    }
  }
  __asm
  {
    fld     qword ptr [esi+320h]
    fstp    [ebp+var_30C]
  }
  v128 = v127;
  v130 = v129;
  v132 = v131;
  v134 = v133;
  v136 = v135;
  v138 = v137;
  v140 = v139;
  v142 = v141;
  v24 = *(_DWORD *)(_EBX + 432);
  v144 = v143;
  v146 = v145;
  v147 = v24;
  v25 = *(_DWORD *)(_EBX + 444);
  v149 = v148;
  v26 = *(_DWORD *)(_EBX + 436);
  v151 = v150;
  v27 = *(_DWORD *)(_EBX + 440);
  v152 = v25;
  v153 = v26;
  v28 = *(_DWORD *)(_EBX + 448);
  v154 = v27;
  v29 = *(_DWORD *)(_EBX + 452);
  v155 = v28;
  v156 = v29;
  __asm
  {
    fld     [ebp+var_FC]
    fstp    [ebp+var_2B4]
  }
  v159 = atoi(_ESI + 133) == 1;
  __asm { fld     qword ptr [ebx+198h] }
  _EAX = v36;
  __asm
  {
    fstp    [ebp+var_2AC]
    fld     qword ptr [ebx+1A0h]
    fstp    [ebp+var_2A4]
    fld     qword ptr [eax+198h]
    fstp    [ebp+var_29C]
    fld     qword ptr [eax+1A0h]
    fstp    [ebp+var_294]
    fld     [ebp+var_104]
    fstp    [ebp+var_28C]
  }
  if ( strstr(_ESI, "5_axis_dual_table") )
  {
    __asm { fldz }
  }
  else
  {
    _ECX = v33;
    __asm { fld     qword ptr [ecx+218h] }
  }
  __asm { fstp    [ebp+var_284] }
  sub_10004090(
    (int)&v73,
    (int)&v41,
    (int)&v40,
    _EBX + 456,
    (int)&v44,
    (int)((char *)v36 + 456),
    (int)&v49,
    (int)&v122,
    (int)&v125);
  free(v3);
  free(_ESI);
  if ( v33 )
    free(v33);
  if ( v34 )
    free(v34);
  if ( v35 )
    free(v35);
  free((void *)_EBX);
  free(v36);
  if ( v37 )
    free(v37);
  if ( a1 )
    free(a1);
  if ( v38 )
    free(v38);
  return 0;
}

//----- (10001B00) --------------------------------------------------------
int __cdecl sub_10001B00(int a1)
{
  int v2; // esi@1
  __int64 v3; // ST18_8@1
  __int64 v4; // ST18_8@1
  __int64 v5; // ST18_8@1
  __int64 v6; // ST18_8@1
  __int64 v7; // ST18_8@1
  __int64 v8; // ST18_8@1
  __int64 v9; // ST18_8@1
  __int64 v10; // ST18_8@1
  __int64 v11; // ST18_8@1
  __int64 v12; // ST18_8@1
  char v13; // [sp+10h] [bp-208h]@1
  char v14; // [sp+198h] [bp-80h]@1
  __int64 v15; // [sp+1C8h] [bp-50h]@1
  __int64 v16; // [sp+1F0h] [bp-28h]@1

  v2 = a1;
  sub_10006F40(a1, (int)&v13);
  sub_100026E0((int)&v13);
  sub_10007190(v2, (int)&v14);
  sub_10004E60((int)&v14, (int)&v15, (int)&v16);
  __asm
  {
    fld     [ebp+var_50]
    fstp    [esp+230h+var_218]
  }
  UF_MOM_set_double(v2, "pos_x", v3, *((_DWORD *)&v3 + 1));
  __asm
  {
    fld     [ebp+var_48]
    fstp    [esp+218h+var_218]
  }
  UF_MOM_set_double(v2, "pos_y", v4, *((_DWORD *)&v4 + 1));
  __asm
  {
    fld     [ebp+var_40]
    fstp    [esp+218h+var_218]
  }
  UF_MOM_set_double(v2, "pos_z", v5, *((_DWORD *)&v5 + 1));
  __asm
  {
    fld     [ebp+var_38]
    fstp    [esp+218h+var_218]
  }
  UF_MOM_set_double(v2, "pos_a1", v6, *((_DWORD *)&v6 + 1));
  __asm
  {
    fld     [ebp+var_30]
    fstp    [esp+218h+var_218]
  }
  UF_MOM_set_double(v2, "pos_a2", v7, *((_DWORD *)&v7 + 1));
  __asm
  {
    fld     [ebp+var_28]
    fstp    [esp+218h+var_218]
  }
  UF_MOM_set_double(v2, "alt_pos_x", v8, *((_DWORD *)&v8 + 1));
  __asm
  {
    fld     [ebp+var_20]
    fstp    [esp+218h+var_218]
  }
  UF_MOM_set_double(v2, "alt_pos_y", v9, *((_DWORD *)&v9 + 1));
  __asm
  {
    fld     [ebp+var_18]
    fstp    [esp+218h+var_218]
  }
  UF_MOM_set_double(v2, "alt_pos_z", v10, *((_DWORD *)&v10 + 1));
  __asm
  {
    fld     [ebp+var_10]
    fstp    [esp+218h+var_218]
  }
  UF_MOM_set_double(v2, "alt_pos_a1", v11, *((_DWORD *)&v11 + 1));
  __asm
  {
    fld     [ebp+var_8]
    fstp    [esp+218h+var_218]
  }
  UF_MOM_set_double(v2, "alt_pos_a2", v12, *((_DWORD *)&v12 + 1));
  return 0;
}

//----- (10001C00) --------------------------------------------------------
signed int __cdecl sub_10001C00(int a1, int a2, int a3, int a4)
{
  int v5; // esi@4
  int v6; // eax@6
  _BYTE *v7; // edx@6
  int v8; // eax@8
  _BYTE *v9; // edx@8
  int v10; // eax@16
  int v11; // eax@19
  char v12; // cl@7
  char v13; // cl@9
  char v14; // cl@17
  char v15; // cl@20
  int v16; // [sp+3D4h] [bp-BCh]@1
  int v17; // [sp+3D8h] [bp-B8h]@1
  int v18; // [sp+3DCh] [bp-B4h]@1
  int v19; // [sp+3E0h] [bp-B0h]@1
  int v20; // [sp+3E4h] [bp-ACh]@1
  int v21; // [sp+48Ch] [bp-4h]@1
  _BYTE v22[136]; // [sp+208h] [bp-288h]@1
  int v23; // [sp+290h] [bp-200h]@1
  int v24; // [sp+294h] [bp-1FCh]@1
  __int16 v25; // [sp+298h] [bp-1F8h]@1
  char v26; // [sp+8h] [bp-488h]@2
  __int16 v27; // [sp+28h] [bp-468h]@5
  _BYTE v28[32]; // [sp+45Ch] [bp-34h]@6
  _BYTE v29[52]; // [sp+3A0h] [bp-F0h]@8
  _BYTE v30[136]; // [sp+318h] [bp-178h]@13
  _BYTE *v31; // [sp+484h] [bp-Ch]@13
  signed int v32; // [sp+47Ch] [bp-14h]@13

  v16 = dword_100095D8;
  v17 = dword_100095DC;
  v18 = dword_100095E0;
  v19 = dword_100095E4;
  v20 = dword_100095E8;
  v21 = 0;
  *(_DWORD *)&v22[0] = 2105376;
  v23 = dword_100095CC;
  v24 = dword_100095D0;
  v25 = word_100095D4;
  if ( a3 != 2 )
  {
    memcpy(&v26, "Invalid number of arguments", 0x1Cu);
LABEL_3:
    printf(" ERROR : %s \n ", &v26);
    return 1;
  }
  v5 = a1;
  if ( UF_MOM_ask_string(a1, &v23, &a3) )
  {
    memcpy(&v26, "No Tool Name obtained from UGPost", 0x20u);
    v27 = *(_WORD *)&aNoToolNameObta[32];
    goto LABEL_3;
  }
  v6 = a3;
  v7 = &v28[-a3];
  do
  {
    v12 = *(_BYTE *)v6;
    v7[v6] = *(_BYTE *)v6;
    ++v6;
  }
  while ( v12 );
  v8 = *(_DWORD *)(a4 + 4);
  v9 = &v29[-v8];
  do
  {
    v13 = *(_BYTE *)v8;
    v9[v8] = *(_BYTE *)v8;
    ++v8;
  }
  while ( v13 );
  if ( UF_OBJ_cycle_by_name(v28, &v21) )
  {
    printf(" UF_OBJ_cycle_by_name could not get the tool_object_tag \n");
    return 1;
  }
  if ( v21 )
  {
    v31 = v30;
    if ( UF_ATTR_read_value(v21, v29, 5, &v32) )
    {
      printf(" UF_ATTR_read_value could not return tool string \n");
      return 1;
    }
    if ( v32 != 5 )
    {
      v10 = 0;
      do
      {
        v14 = v22[v10];
        v30[v10] = v22[v10];
        ++v10;
      }
      while ( v14 );
    }
  }
  else
  {
    v11 = 0;
    do
    {
      v15 = v22[v11];
      v30[v11] = v22[v11];
      ++v11;
    }
    while ( v15 );
  }
  UF_MOM_set_string(v5, &v16, v30);
  return 0;
}

//----- (10001DF0) --------------------------------------------------------
int __cdecl ufusr(int a1, int a2)
{
  int result; // eax@2
  int v3; // esi@3
  int v4; // eax@3
  int v5; // eax@3
  int v6; // eax@3
  int v7; // eax@3
  int v8; // eax@3
  int v9; // eax@3
  int v10; // [sp+84h] [bp-8h]@1
  char v11; // [sp+0h] [bp-8Ch]@1
  int v12; // [sp+88h] [bp-4h]@3

  v10 = 0;
  if ( sub_10001060(&v11) )
  {
    printf("ERROR : Ugpost Advanced Kinematics license not found \n");
    uc1601(&v11, 1);
    result = UF_terminate();
  }
  else
  {
    v3 = a1;
    UF_MOM_ask_interp_from_param(a1, &v10);
    UF_MOM_ask_mom(v3, &v12);
    v4 = UF_MOM_extend_xlator(v12, "MOM_load_kinematics", sub_10001390);
    sub_10001000(
      (int)"UF_MOM_extend_xlator ( mom, \"MOM_load_kinematics\", mom_load_kinematics )",
      (int)"o:\\ugnx75\\ip32\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      113,
      v4);
    v5 = UF_MOM_extend_xlator(v12, "MOM_convert_point", sub_10001B00);
    sub_10001000(
      (int)"UF_MOM_extend_xlator ( mom, \"MOM_convert_point\", mom_convert_point )",
      (int)"o:\\ugnx75\\ip32\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      123,
      v5);
    v6 = UF_MOM_extend_xlator(v12, "MOM_get_tool_attribute", sub_10001C00);
    sub_10001000(
      (int)"UF_MOM_extend_xlator ( mom , \"MOM_get_tool_attribute\", mom_get_tool_attribute )",
      (int)"o:\\ugnx75\\ip32\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      133,
      v6);
    v7 = UF_MOM_extend_xlator(v12, "MOM_rotate_mach_csys", sub_100010C0);
    sub_10001000(
      (int)"UF_MOM_extend_xlator ( mom, \"MOM_rotate_mach_csys\", mom_rotate_mach_csys )",
      (int)"o:\\ugnx75\\ip32\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      143,
      v7);
    v8 = UF_MOM_extend_xlator(v12, "MOM_map_to_rotated_csys", sub_100012B0);
    sub_10001000(
      (int)"UF_MOM_extend_xlator ( mom, \"MOM_map_to_rotated_csys\", mom_map_to_rotated_csys )",
      (int)"o:\\ugnx75\\ip32\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      153,
      v8);
    v9 = UF_MOM_extend_xlator(v12, "MOM_exit_kinematics_module", UF_terminate);
    result = sub_10001000(
               (int)"UF_MOM_extend_xlator ( mom, \"MOM_exit_kinematics_module\", mom_exit_kinematics_module )",
               (int)"o:\\ugnx75\\ip32\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
               163,
               v9);
    dword_1000C240 = v12;
    *(_DWORD *)a2 = 0;
  }
  return result;
}

//----- (10001F60) --------------------------------------------------------
int __usercall sub_10001F60<eax>(int a1<eax>, int a2<ecx>, int a3<esi>, char a4)
{
  int ST10_4_0; // ST10_4@0
  int v6; // ST10_4@1
  char *v7; // ST0C_4@1
  __int64 v8; // ST04_8@1

  UF_VEC3_cross(a2, a1, ST10_4_0);
  __asm { fld     ds:dbl_100099B8 }
  v6 = a3;
  v7 = &a4;
  __asm { fstp    [esp+10h+var_10] }
  return UF_VEC3_unitize(a3, v8, *((_DWORD *)&v8 + 1), v7, v6);
}

//----- (10001F90) --------------------------------------------------------
void __cdecl sub_10001F90(double a1)
{
  __asm
  {
    fld     [ebp+arg_0]
    fld     ds:dbl_10009318
    fsubr   st, st(1)
    fabs
    fld     dbl_1000C000
    fcom    st(1)
    fnstsw  ax
    fstp    st(1)
  }
  if ( HIBYTE(_AX) & 1 )
  {
    __asm
    {
      fld     st(1)
      fsub    ds:dbl_100099C8
      fabs
      fcompp  st(1), st
      fnstsw  ax
      jp      short loc_10001FD6
      fstp    st
      fld     ds:dbl_100099C0
    }
  }
  else
  {
    __asm
    {
      fstp    st(1)
      fstp    st
      fldz
    }
  }
}

//----- (10001FE0) --------------------------------------------------------
int __usercall sub_10001FE0<eax>(int result<eax>, int _ECX<ecx>, double a3)
{
  __asm
  {
    fld     [ebp+arg_0]
    fld     st
    fcos
    fxch    st(1)
    fsin
    fld     qword ptr [eax]
    fmul    st, st
    fld     qword ptr [eax+8]
    fmul    st, st
    fld     qword ptr [eax+10h]
    fmul    st, st
    fstp    [ebp+var_8]
    fld1
    fld     st
    fsub    st, st(5)
    fld     st(1)
    fsub    st, st(4)
    fmul    st, st(6)
    faddp   st(4), st
    fxch    st(3)
    fstp    qword ptr [ecx]
    fld     qword ptr [eax+8]
    fmul    qword ptr [eax]
    fmul    st, st(3)
    fld     qword ptr [eax+10h]
    fmul    st, st(5)
    faddp   st(1), st
    fstp    qword ptr [ecx+8]
    fld     qword ptr [eax+10h]
    fmul    qword ptr [eax]
    fmul    st, st(3)
    fld     qword ptr [eax+8]
    fmul    st, st(5)
    fsubp   st(1), st
    fstp    qword ptr [ecx+10h]
    fldz
    fst     qword ptr [ecx+18h]
    fld     qword ptr [eax+8]
    fmul    qword ptr [eax]
    fmul    st, st(4)
    fld     qword ptr [eax+10h]
    fmul    st, st(6)
    fsubp   st(1), st
    fstp    qword ptr [ecx+20h]
    fld     st(1)
    fsub    st, st(3)
    fmul    st, st(6)
    faddp   st(3), st
    fxch    st(2)
    fstp    qword ptr [ecx+28h]
    fld     qword ptr [eax+10h]
    fmul    qword ptr [eax+8]
    fmul    st, st(3)
    fld     qword ptr [eax]
    fmul    st, st(5)
    faddp   st(1), st
    fstp    qword ptr [ecx+30h]
    fxch    st(1)
    fst     qword ptr [ecx+38h]
    fld     qword ptr [eax+10h]
    fmul    qword ptr [eax]
    fmul    st, st(3)
    fld     qword ptr [eax+8]
    fmul    st, st(5)
    faddp   st(1), st
    fstp    qword ptr [ecx+40h]
    fld     qword ptr [eax+10h]
    fmul    qword ptr [eax+8]
    fmulp   st(3), st
    fld     qword ptr [eax]
    fmulp   st(4), st
    fxch    st(2)
    fsubrp  st(3), st
    fxch    st(2)
    fstp    qword ptr [ecx+48h]
    fld     st(1)
    fld     [ebp+var_8]
    fsub    st(1), st
    fxch    st(1)
    fmulp   st(4), st
    faddp   st(3), st
    fxch    st(2)
    fstp    qword ptr [ecx+50h]
    fxch    st(1)
    fst     qword ptr [ecx+58h]
    fst     qword ptr [ecx+60h]
    fst     qword ptr [ecx+68h]
    fstp    qword ptr [ecx+70h]
    fstp    qword ptr [ecx+78h]
  }
  return result;
}

//----- (100020C0) --------------------------------------------------------
int __usercall sub_100020C0<eax>(int a1<eax>, int a2<ecx>, int a3)
{
  char v6; // [sp+54h] [bp-D8h]@1
  char v7; // [sp+Ch] [bp-120h]@1
  __int64 v8; // [sp+FCh] [bp-30h]@1
  __int64 v9; // [sp+114h] [bp-18h]@1
  char v14; // [sp+CCh] [bp-60h]@1
  char v15; // [sp+9Ch] [bp-90h]@1
  char v16; // [sp+E4h] [bp-48h]@1
  char v17; // [sp+B4h] [bp-78h]@1

  _ESI = a1;
  _EDI = a2;
  UF_MTX3_copy(a1 + 24, &v6);
  UF_MTX3_copy(_EDI + 24, &v7);
  __asm
  {
    fld     qword ptr [esi]
    fstp    [ebp+var_30]
    fld     qword ptr [edi]
    fstp    [ebp+var_18]
    fld     qword ptr [esi+8]
    fstp    [ebp+var_28]
    fld     qword ptr [edi+8]
    fstp    [ebp+var_10]
    fld     qword ptr [esi+10h]
    fstp    [ebp+var_20]
    fld     qword ptr [edi+10h]
    fstp    [ebp+var_8]
  }
  UF_MTX3_x_vec(&v6, &v14);
  UF_MTX3_y_vec(&v6, &v15);
  UF_MTX3_x_vec(&v7, &v16);
  UF_MTX3_y_vec(&v7, &v17);
  return UF_MTX4_csys_to_csys(&v8, &v14, &v15, &v9, &v16, &v17, a3);
}

//----- (10002190) --------------------------------------------------------
int __usercall sub_10002190<eax>(int a1<eax>, int a2<esi>, double a3, double a4, int a5)
{
  int result; // eax@1
  int v6; // edx@1
  int v7; // ecx@1
  int v8; // edx@1
  int v9; // ecx@1
  int v10; // edx@1
  char *v12; // ST30_4@1
  __int64 v13; // ST28_8@1
  char *v14; // ST30_4@1
  double *v15; // ST2C_4@1
  __int64 v16; // ST24_8@1
  char *v17; // ST30_4@1
  __int64 v18; // ST28_8@1
  int v19; // ecx@1
  int v20; // edx@1
  int v21; // ecx@1
  int v22; // edx@1
  int v23; // [sp+24Ch] [bp-20h]@1
  int v25; // [sp+250h] [bp-1Ch]@1
  int v26; // [sp+254h] [bp-18h]@1
  int v27; // [sp+258h] [bp-14h]@1
  int v29; // [sp+25Ch] [bp-10h]@1
  __int64 v30; // [sp+1F4h] [bp-78h]@1
  char v32; // [sp+15Ch] [bp-110h]@1
  int v34; // [sp+260h] [bp-Ch]@1
  char v35; // [sp+114h] [bp-158h]@1
  char v36; // [sp+20Ch] [bp-60h]@1
  char v37; // [sp+1DCh] [bp-90h]@1
  char v38; // [sp+94h] [bp-1D8h]@1
  char v39; // [sp+14h] [bp-258h]@1
  int v40; // [sp+224h] [bp-48h]@1
  int v41; // [sp+228h] [bp-44h]@1
  int v42; // [sp+22Ch] [bp-40h]@1
  int v43; // [sp+230h] [bp-3Ch]@1
  int v44; // [sp+234h] [bp-38h]@1
  int v45; // [sp+238h] [bp-34h]@1

  __asm { fild    [ebp+arg_10] }
  v6 = *(_DWORD *)(a1 + 4);
  v23 = *(_DWORD *)a1;
  v7 = *(_DWORD *)(a1 + 8);
  __asm { fstp    [ebp+var_8] }
  v25 = v6;
  v8 = *(_DWORD *)(a1 + 12);
  v26 = v7;
  v9 = *(_DWORD *)(a1 + 16);
  v27 = v8;
  v10 = *(_DWORD *)(a1 + 20);
  _EAX = dword_1000C3D8;
  __asm
  {
    fld     qword ptr [eax+8]
    fstp    [ebp+var_28]
    fldz
  }
  v29 = v9;
  __asm
  {
    fst     [ebp+var_78]
    fst     [ebp+var_70]
  }
  v12 = &v32;
  __asm
  {
    fstp    [ebp+var_68]
    fld     [ebp+arg_8]
  }
  v34 = v10;
  __asm
  {
    fmul    ds:dbl_100099D0
    fstp    [esp+268h+var_268]
  }
  UF_MTX4_rotation(&dword_1000C2C8, &dbl_1000C328, v13, *((_DWORD *)&v13 + 1), v12);
  sub_10005200((int)&v32);
  UF_MTX4_ask_rotation(&v32, &v35);
  UF_MTX3_vec_multiply(&dbl_1000C2F0, &v35, &v36);
  __asm { fld     [ebp+var_28] }
  v14 = &v36;
  v15 = &a4;
  __asm { fstp    qword ptr [esp] }
  UF_VEC3_unitize(&v36, v16, *((_DWORD *)&v16 + 1), v15, v14);
  UF_MTX4_vec3_multiply(&v30, &v32, &v37);
  __asm
  {
    fld     [ebp+arg_0]
    fmul    ds:dbl_100099D0
  }
  v17 = &v38;
  __asm { fstp    [esp+268h+var_268] }
  UF_MTX4_rotation(&v37, &v36, v18, *((_DWORD *)&v18 + 1), v17);
  sub_10005200((int)&v38);
  UF_MTX4_multiply(&v32, &v38, &v39);
  sub_10005200((int)&v39);
  UF_MTX4_vec_multiply(&v23, &v39, &v40);
  v19 = v41;
  v20 = v42;
  *(_DWORD *)a2 = v40;
  result = v43;
  *(_DWORD *)(a2 + 4) = v19;
  v21 = v44;
  *(_DWORD *)(a2 + 8) = v20;
  v22 = v45;
  *(_DWORD *)(a2 + 12) = result;
  *(_DWORD *)(a2 + 16) = v21;
  *(_DWORD *)(a2 + 20) = v22;
  return result;
}

//----- (10002310) --------------------------------------------------------
int __cdecl sub_10002310(int a1, double a2, int a3)
{
  char *v4; // ST34_4@1
  __int64 v5; // ST2C_8@1
  char v6; // [sp+Ch] [bp-E0h]@1
  char v7; // [sp+8Ch] [bp-60h]@1
  char v8; // [sp+D4h] [bp-18h]@1

  __asm
  {
    fld     [ebp+arg_4]
    fmul    ds:dbl_100099D8
  }
  v4 = &v6;
  __asm { fstp    [esp+0ECh+var_EC] }
  UF_MTX4_rotation(&dword_1000C540, &dbl_1000C2F0, v5, *((_DWORD *)&v5 + 1), v4);
  sub_10005200((int)&v6);
  UF_MTX4_ask_rotation(&v6, &v7);
  UF_MTX3_vec_multiply(&dword_1000C2C8, &v7, &v8);
  return UF_VEC3_add(a1, &v8, a3);
}

//----- (10002390) --------------------------------------------------------
int __cdecl sub_10002390(int a1, double a2, int a3)
{
  int v4; // ecx@1
  double v5; // ST10_8@1
  int v6; // ecx@1
  char v7; // [sp+8h] [bp-80h]@1

  __asm { fld     [ebp+arg_4] }
  v4 = (int)&v7;
  __asm { fstp    [esp+88h+var_88] }
  sub_10001FE0((int)&dbl_1000C328, v4, v5);
  sub_10005200(v6);
  return UF_MTX4_vec3_multiply_t(a1, &v7, a3);
}

//----- (100023D0) --------------------------------------------------------
int __fastcall sub_100023D0(int a1, int a2, int a3)
{
  int result; // eax@1
  __int64 v4; // [sp+0h] [bp-8h]@1

  result = UF_VEC3_angle_between(a3, a2, a1, &v4);
  __asm { fld     [ebp+var_8] }
  return result;
}

//----- (100023F0) --------------------------------------------------------
signed int __cdecl sub_100023F0(const void *a1, const void *a2)
{
  signed int result; // eax@2

  _ECX = a1;
  __asm { fld     qword ptr [ecx] }
  _EDX = a2;
  __asm
  {
    fsub    qword ptr [edx]
    fabs
    fld     dbl_1000C000
    fcom    st(1)
    fnstsw  ax
    fstp    st(1)
  }
  if ( HIBYTE(_AX) & 1 )
  {
    __asm
    {
      fadd    qword ptr [edx]
      fcomp   qword ptr [ecx]
      fnstsw  ax
      jp      short loc_10002428
    }
    result = 1;
  }
  else
  {
    __asm { fstp    st }
    result = 0;
  }
  return result;
}

//----- (10002430) --------------------------------------------------------
__int16 __cdecl sub_10002430()
{
  __int16 result; // ax@9

  __asm
  {
    fld     qword ptr [edx]
    fsub    qword ptr [edx+8]
    fabs
    fld     dbl_1000C000
    fcom    st(1)
    fnstsw  ax
    fstp    st(1)
    fld     ds:dbl_100099E0
  }
  if ( !(HIBYTE(_AX) & 1) )
  {
    __asm
    {
      fld     qword ptr [ecx]
      fsub    qword ptr [ecx+8]
      fabs
      fcomp   st(2)
      fnstsw  ax
      jp      loc_100024FA
      fld     qword ptr [edx]
      fsub    qword ptr [ecx]
      fabs
      fcomp   st(2)
      fnstsw  ax
      jnp     loc_100024FA
      fld     st(1)
      fchs
      fcom    qword ptr [edx]
      fnstsw  ax
    }
    if ( HIBYTE(_AX) & 0x41 )
    {
      __asm
      {
        fcom    qword ptr [ecx]
        fnstsw  ax
      }
      if ( HIBYTE(_AX) & 0x41 )
      {
        __asm
        {
          fstp    st
          fxch    st(1)
          fcom    qword ptr [ecx+8]
          fnstsw  ax
          jp      short loc_100024F8
          fld     qword ptr [ecx+8]
          fsub    st, st(2)
          fstp    qword ptr [ecx+8]
          fxch    st(1)
        }
      }
      else
      {
        __asm
        {
          fld     qword ptr [ecx]
          fadd    st, st(2)
          fld     st
          fsub    qword ptr [edx]
          fabs
          fcomp   st(4)
          fnstsw  ax
          jnp     short loc_100024CC
          fstp    st(1)
          fst     qword ptr [ecx]
          fld     st
          fsub    qword ptr [ecx+8]
          fabs
          fcomp   st(3)
          fnstsw  ax
          jp      short loc_10002531
          fsubr   st, st(1)
          fstp    qword ptr [ecx+8]
        }
      }
    }
    else
    {
      __asm
      {
        fstp    st
        fld     qword ptr [edx]
        fadd    st, st(1)
        fst     qword ptr [edx]
        fsubr   st, st(1)
        fstp    qword ptr [edx+8]
      }
    }
  }
  __asm
  {
    fld     qword ptr [edx]
    fsub    qword ptr [ecx]
    fabs
    fcomp   st(2)
    fnstsw  ax
    jp      short loc_10002568
    fld     qword ptr [edx+8]
    fsub    qword ptr [ecx+8]
    fabs
    fcomp   st(2)
    fnstsw  ax
    jp      short loc_10002568
    fld     st(1)
    fchs
    fcomp   qword ptr [ecx+8]
    fnstsw  ax
  }
  if ( HIBYTE(result) & 0x41 )
  {
    __asm
    {
      fxch    st(1)
      fcom    qword ptr [ecx+8]
      fnstsw  ax
      jp      short loc_1000254A
      fstp    st
      fsub    qword ptr [ecx+8]
      fstp    qword ptr [ecx+8]
    }
  }
  else
  {
    __asm
    {
      fstp    st(1)
      fadd    qword ptr [ecx+8]
      fstp    qword ptr [ecx+8]
    }
  }
  return result;
}

//----- (10002580) --------------------------------------------------------
__int16 __cdecl sub_10002580(double a1)
{
  __int16 result; // ax@1

  __asm
  {
    fldz
    fld     [ebp+arg_0]
    fcom    st(1)
    fnstsw  ax
  }
  if ( HIBYTE(result) & 0x41 )
  {
    __asm
    {
      fcom    st(1)
      fnstsw  ax
      fstp    st(1)
      jp      short loc_100025AC
      fadd    ds:dbl_100099E8
    }
  }
  else
  {
    __asm
    {
      fstp    st(1)
      fsub    ds:dbl_100099E8
    }
  }
  return result;
}

//----- (100025B0) --------------------------------------------------------
__int16 __usercall sub_100025B0<ax>(int _EDX<edx>, const void *_EBX<ebx>)
{
  __int16 result; // ax@5
  double v7; // ST00_8@1
  double v11; // ST00_8@3
  char v18; // [sp+8h] [bp-28h]@5

  __asm
  {
    fld     qword ptr [edx+18h]
    fstp    [esp+30h+var_30]
  }
  sub_10002580(v7);
  __asm
  {
    fld     qword ptr [ecx+18h]
    fsub    qword ptr [edx+18h]
    fld     qword ptr [ecx+18h]
    fsub    st, st(2)
    fxch    st(1)
    fabs
    fxch    st(1)
    fabs
    fcompp  st(1), st
    fnstsw  ax
    jp      short loc_100025E8
    fstp    qword ptr [edx+18h]
    fld     qword ptr [edx+20h]
    fstp    [esp+30h+var_30]
  }
  sub_10002580(v11);
  __asm
  {
    fld     qword ptr [ecx+20h]
    fsub    qword ptr [edx+20h]
    fld     qword ptr [ecx+20h]
    fsub    st, st(2)
    fxch    st(1)
    fabs
    fxch    st(1)
    fabs
    fcompp  st(1), st
    fnstsw  ax
    jp      short loc_1000261C
    fstp    qword ptr [edx+20h]
    fld     qword ptr [ecx+18h]
    fsub    qword ptr [edx+18h]
    fld     qword ptr [ecx+18h]
    fsub    qword ptr [ebx+18h]
    fxch    st(1)
    fabs
    fxch    st(1)
    fabs
    fcompp  st(1), st
    fnstsw  ax
    jp      short loc_10002660
  }
  memcpy(&v18, _EDX, 0x28u);
  memcpy((void *)_EDX, _EBX, 0x28u);
  memcpy((void *)_EBX, &v18, 0x28u);
  _ECX = dword_1000C3D8;
  __asm
  {
    fld     qword ptr [ecx+68h]
    fld     dbl_1000C000
    fsub    st(1), st
    fxch    st(1)
    fcomp   qword ptr [edx+18h]
    fnstsw  ax
    jp      short loc_1000268C
    fld     qword ptr [ecx+70h]
    fadd    st, st(1)
    fcomp   qword ptr [edx+18h]
    fnstsw  ax
  }
  if ( HIBYTE(result) & 0x41 )
  {
    __asm
    {
      fld     qword ptr [ecx+78h]
      fsub    st, st(1)
      fcomp   qword ptr [ebx+18h]
      fnstsw  ax
      jp      short loc_100026D4
      fadd    qword ptr [ecx+80h]
      fcomp   qword ptr [ebx+18h]
      fnstsw  ax
    }
    if ( !(HIBYTE(result) & 0x41) )
    {
      memcpy(&v18, _EDX, 0x28u);
      memcpy((void *)_EDX, _EBX, 0x28u);
      memcpy((void *)_EBX, &v18, 0x28u);
    }
  }
  else
  {
    __asm { fstp    st }
  }
  return result;
}

//----- (100026E0) --------------------------------------------------------
int __cdecl sub_100026E0(int a1)
{
  _EAX = a1;
  _ECX = dword_1000C3D8;
  *(_DWORD *)(dword_1000C3D8 + 16) = *(_DWORD *)(a1 + 192);
  *(_DWORD *)(dword_1000C3D8 + 20) = *(_DWORD *)(_EAX + 196);
  *(_DWORD *)(dword_1000C3D8 + 24) = *(_DWORD *)(_EAX + 200);
  *(_DWORD *)(dword_1000C3D8 + 28) = *(_DWORD *)(_EAX + 204);
  *(_DWORD *)(dword_1000C3D8 + 32) = *(_DWORD *)(_EAX + 208);
  *(_DWORD *)(dword_1000C3D8 + 36) = *(_DWORD *)(_EAX + 212);
  *(_DWORD *)(dword_1000C3D8 + 40) = *(_DWORD *)(_EAX + 216);
  *(_DWORD *)(dword_1000C3D8 + 44) = *(_DWORD *)(_EAX + 220);
  *(_DWORD *)(dword_1000C3D8 + 48) = *(_DWORD *)(_EAX + 224);
  *(_DWORD *)(dword_1000C3D8 + 52) = *(_DWORD *)(_EAX + 228);
  *(_DWORD *)(dword_1000C3D8 + 56) = *(_DWORD *)(_EAX + 232);
  *(_DWORD *)(dword_1000C3D8 + 60) = *(_DWORD *)(_EAX + 236);
  __asm
  {
    fld     qword ptr [eax+178h]
    fstp    qword ptr [ecx+88h]
  }
  return 0;
}

//----- (10002770) --------------------------------------------------------
int __cdecl sub_10002770(int a1, int a2, int a3, int a4)
{
  int result; // eax@1
  __int64 v14; // [sp+20h] [bp-28h]@1
  char v15; // [sp+8h] [bp-40h]@1
  __int64 v19; // [sp+40h] [bp-8h]@1

  _ESI = a2;
  UF_VEC3_sub(a2 + 24, a2, &v14);
  UF_VEC3_sub(a1, _ESI, &v15);
  __asm
  {
    fld     [ebp+var_18]
    fmul    st, st
    fld     [ebp+var_20]
    fmul    st, st
    faddp   st(1), st
    fld     [ebp+var_28]
    fmul    st, st
    faddp   st(1), st
    fst     [ebp+var_10]
    fldz
    fcom    st(1)
    fnstsw  ax
    fstp    st(1)
    jp      short loc_10002809
    fstp    st
  }
  UF_VEC3_dot(&v14, &v15, &v19);
  __asm
  {
    fld     [ebp+var_8]
    fdiv    [ebp+var_10]
  }
  _EAX = a4;
  _ECX = a3;
  __asm
  {
    fstp    qword ptr [eax]
    fld     qword ptr [eax]
    fmul    [ebp+var_28]
    fadd    qword ptr [esi]
    fstp    qword ptr [ecx]
    fld     qword ptr [eax]
    fmul    [ebp+var_20]
    fadd    qword ptr [esi+8]
    fstp    qword ptr [ecx+8]
    fld     qword ptr [eax]
  }
  result = 0;
  __asm
  {
    fmul    [ebp+var_18]
    fadd    qword ptr [esi+10h]
    fstp    qword ptr [ecx+10h]
  }
  return result;
}

//----- (10002830) --------------------------------------------------------
int __usercall sub_10002830<eax>(int a1<esi>, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // edi@2
  unsigned int v7; // ecx@3
  int v9; // ecx@18
  int v10; // eax@24
  signed int v13; // edi@28
  int v20; // eax@48
  unsigned int v24; // edi@49
  int v27; // edi@53
  int v28; // edx@57
  int v30; // edi@58
  int v31; // eax@60
  unsigned int v32; // edx@60
  int v33; // eax@1
  unsigned __int8 v53; // of@23
  char v54; // sf@23
  unsigned __int8 v63; // of@34
  char v64; // sf@34
  int v74; // edi@49
  int v75; // ebx@49
  int v89; // edx@66
  char v93; // [sp+8h] [bp-24h]@1
  int v94; // [sp+1Ch] [bp-10h]@1
  int v95; // [sp+24h] [bp-8h]@1
  int v96; // [sp+28h] [bp-4h]@24
  int v97; // [sp+14h] [bp-18h]@25
  int v98; // [sp+20h] [bp-Ch]@25
  int v99; // [sp+Ch] [bp-20h]@25
  int v100; // [sp+18h] [bp-14h]@43
  int v101; // [sp+10h] [bp-1Ch]@49

  v4 = a2;
  v33 = UF_allocate_memory(8 * a2, &v93);
  __asm { fld1 }
  _EDX = a4;
  __asm
  {
    fst     qword ptr [edx]
    fldz
  }
  v94 = v33;
  v95 = 0;
  if ( v4 > 0 )
  {
    do
    {
      v5 = 0;
      __asm { fld     st }
      if ( v4 >= 4 )
      {
        _EDX = *(_DWORD *)(a1 + 4 * v95) + 16;
        v7 = ((unsigned int)(v4 - 4) >> 2) + 1;
        v5 = 4 * v7;
        do
        {
          __asm
          {
            fld     qword ptr [edx-10h]
            fabs
            fcom    st(1)
            fnstsw  ax
          }
          if ( HIBYTE(_AX) & 0x41 )
            __asm { fstp    st }
          else
            __asm { fstp    st(1) }
          __asm
          {
            fld     qword ptr [edx-8]
            fabs
            fcom    st(1)
            fnstsw  ax
          }
          if ( HIBYTE(_AX) & 0x41 )
            __asm { fstp    st }
          else
            __asm { fstp    st(1) }
          __asm
          {
            fld     qword ptr [edx]
            fabs
            fcom    st(1)
            fnstsw  ax
          }
          if ( HIBYTE(_AX) & 0x41 )
            __asm { fstp    st }
          else
            __asm { fstp    st(1) }
          __asm
          {
            fld     qword ptr [edx+8]
            fabs
            fcom    st(1)
            fnstsw  ax
          }
          if ( HIBYTE(_AX) & 0x41 )
            __asm { fstp    st }
          else
            __asm { fstp    st(1) }
          _EDX += 32;
          --v7;
        }
        while ( v7 );
      }
      if ( v5 < v4 )
      {
        _EDX = *(_DWORD *)(a1 + 4 * v95) + 8 * v5;
        v9 = v4 - v5;
        do
        {
          __asm
          {
            fld     qword ptr [edx]
            fabs
            fcom    st(1)
            fnstsw  ax
          }
          if ( HIBYTE(_AX) & 0x41 )
            __asm { fstp    st }
          else
            __asm { fstp    st(1) }
          _EDX += 8;
          --v9;
        }
        while ( v9 );
      }
      __asm
      {
        fld     st(1)
        fucomp  st(1)
        fnstsw  ax
        jnp     short loc_10002959
        fdivr   st, st(2)
      }
      _ECX = v94;
      _EAX = v95 + 1;
      v53 = __SETO__(v95 + 1, v4);
      v54 = v95++ + 1 < v4;
      __asm { fstp    qword ptr [ecx+eax*8-8] }
    }
    while ( v54 ^ v53 );
  }
  v10 = 0;
  v96 = 0;
  if ( v4 > 0 )
  {
    __asm { fld     ds:dbl_100099F0 }
    v97 = v4 - 1;
    _ECX = 0;
    v98 = a1;
    v99 = a3 - a1;
    while ( 1 )
    {
      v13 = 0;
      if ( v10 > 0 )
      {
        do
        {
          _EDX = *(_DWORD *)(a1 + 4 * v13);
          __asm { fld     st(1) }
          _EAX = 0;
          __asm
          {
            fld     st(2)
            fld     qword ptr [ecx+edx]
          }
          if ( v13 >= 2 )
          {
            do
            {
              _EBX = *(_DWORD *)(a1 + 4 * _EAX);
              __asm { fld     qword ptr [ebx+ecx] }
              _EBX = *(_DWORD *)(a1 + 4 * _EAX + 4);
              __asm { fmul    qword ptr [edx] }
              _EAX += 2;
              _EDX += 16;
              __asm
              {
                fsubp   st(3), st
                fld     qword ptr [ebx+ecx]
                fmul    qword ptr [edx-8]
                fsubp   st(2), st
              }
            }
            while ( _EAX < v13 - 1 );
            v4 = a2;
          }
          if ( _EAX < v13 )
          {
            _EDX = *(_DWORD *)(a1 + 4 * _EAX);
            __asm { fld     qword ptr [edx+ecx] }
            _EDX = *(_DWORD *)(a1 + 4 * v13);
            __asm
            {
              fmul    qword ptr [edx+eax*8]
              fsubp   st(1), st
            }
          }
          _EAX = *(_DWORD *)(a1 + 4 * v13);
          __asm
          {
            fxch    st(1)
            faddp   st(2), st
          }
          ++v13;
          v63 = __SETO__(v13, v96);
          v64 = v13 < v96;
          __asm
          {
            faddp   st(1), st
            fstp    qword ptr [ecx+eax]
          }
        }
        while ( v64 ^ v63 );
        v10 = v96;
      }
      __asm { fld     st(1) }
      _EDI = v10;
      v95 = v10;
      if ( v10 < v4 )
      {
        do
        {
          _EDX = *(_DWORD *)(a1 + 4 * _EDI);
          __asm { fld     st(2) }
          _EAX = 0;
          __asm
          {
            fld     st(3)
            fld     qword ptr [ecx+edx]
          }
          if ( _ECX >= 16 )
          {
            do
            {
              _EBX = *(_DWORD *)(a1 + 4 * _EAX);
              __asm { fld     qword ptr [ebx+ecx] }
              _EBX = *(_DWORD *)(a1 + 4 * _EAX + 4);
              __asm { fmul    qword ptr [edx] }
              _EAX += 2;
              _EDX += 16;
              __asm
              {
                fsubp   st(3), st
                fld     qword ptr [ebx+ecx]
                fmul    qword ptr [edx-8]
                fsubp   st(2), st
              }
            }
            while ( _EAX < v96 - 1 );
            v4 = a2;
            _EDI = v95;
          }
          if ( _EAX < v96 )
          {
            _EDX = *(_DWORD *)(a1 + 4 * _EAX);
            __asm { fld     qword ptr [edx+ecx] }
            _EDX = *(_DWORD *)(a1 + 4 * _EDI);
            __asm
            {
              fmul    qword ptr [edx+eax*8]
              fsubp   st(1), st
            }
          }
          _EAX = *(_DWORD *)(a1 + 4 * _EDI);
          __asm
          {
            fxch    st(1)
            faddp   st(2), st
            faddp   st(1), st
            fst     qword ptr [ecx+eax]
          }
          _EAX = v94;
          __asm
          {
            fabs
            fmul    qword ptr [eax+edi*8]
            fcom    st(1)
            fnstsw  ax
          }
          if ( BYTE1(_EAX) & 1 )
          {
            __asm { fstp    st }
          }
          else
          {
            __asm { fstp    st(1) }
            v100 = _EDI;
          }
          ++_EDI;
          v95 = _EDI;
        }
        while ( _EDI < v4 );
        v10 = v96;
      }
      _EDX = v100;
      __asm { fstp    st }
      if ( v10 != v100 )
      {
        v20 = 0;
        v95 = 0;
        if ( v4 >= 4 )
        {
          v74 = *(_DWORD *)(a1 + 4 * v100);
          v75 = *(_DWORD *)v98;
          _EDX = v74 + 24;
          v101 = v74 - *(_DWORD *)v98;
          _EAX = v75 + 8;
          v24 = ((unsigned int)(a2 - 4) >> 2) + 1;
          v95 = 4 * v24;
          _EBX = v101;
          do
          {
            __asm { fld     qword ptr [edx-18h] }
            _EAX += 32;
            __asm { fld     qword ptr [eax-28h] }
            _EDX += 32;
            --v24;
            __asm
            {
              fstp    qword ptr [edx-38h]
              fstp    qword ptr [eax-28h]
              fld     qword ptr [ebx+eax-20h]
              fld     qword ptr [eax-20h]
              fstp    qword ptr [ebx+eax-20h]
              fstp    qword ptr [eax-20h]
              fld     qword ptr [edx-28h]
              fld     qword ptr [eax-18h]
              fstp    qword ptr [edx-28h]
              fstp    qword ptr [eax-18h]
              fld     qword ptr [edx-20h]
              fld     qword ptr [eax-10h]
              fstp    qword ptr [edx-20h]
              fstp    qword ptr [eax-10h]
            }
          }
          while ( v24 );
          v20 = v95;
          v4 = a2;
          _EDX = v100;
        }
        if ( v20 < v4 )
        {
          _EAX = *(_DWORD *)v98 + 8 * v20;
          _EDX = *(_DWORD *)(a1 + 4 * _EDX) - *(_DWORD *)v98;
          v27 = v4 - v95;
          do
          {
            __asm { fld     qword ptr [edx+eax] }
            _EAX += 8;
            --v27;
            __asm
            {
              fld     qword ptr [eax-8]
              fstp    qword ptr [edx+eax-8]
              fstp    qword ptr [eax-8]
            }
          }
          while ( v27 );
          _EDX = v100;
        }
        _EAX = a4;
        __asm
        {
          fld     qword ptr [eax]
          fchs
          fstp    qword ptr [eax]
        }
        _EAX = v94;
        __asm
        {
          fld     qword ptr [ecx+eax]
          fstp    qword ptr [eax+edx*8]
        }
      }
      __asm { fld     st(1) }
      *(_DWORD *)(v98 + v99) = _EDX;
      _EAX = *(_DWORD *)v98;
      __asm { fcomp   qword ptr [ecx+eax] }
      _EDI = _ECX + *(_DWORD *)v98;
      __asm
      {
        fnstsw  ax
        jp      short loc_10002B4B
        fst     qword ptr [edi]
      }
      v28 = v96;
      if ( v96 != v4 - 1 )
      {
        __asm
        {
          fld     st(2)
          fdiv    qword ptr [edi]
        }
        v30 = v96 + 1;
        if ( v96 + 1 < v4 )
        {
          if ( v97 >= 4 )
          {
            v31 = v98 + 12;
            v32 = ((unsigned int)(v4 - v30 - 4) >> 2) + 1;
            v30 += 4 * v32;
            do
            {
              _EBX = *(_DWORD *)(v31 - 8);
              __asm { fld     qword ptr [ebx+ecx] }
              _EBX = _ECX + _EBX;
              __asm { fmul    st, st(1) }
              v31 += 16;
              __asm { fstp    qword ptr [ebx] }
              _EBX = *(_DWORD *)(v31 - 20);
              __asm { fld     qword ptr [ebx+ecx] }
              _EBX = _ECX + _EBX;
              __asm
              {
                fmul    st, st(1)
                fstp    qword ptr [ebx]
              }
              _EBX = *(_DWORD *)(v31 - 16);
              __asm { fld     qword ptr [ebx+ecx] }
              _EBX = _ECX + _EBX;
              __asm
              {
                fmul    st, st(1)
                fstp    qword ptr [ebx]
              }
              _EBX = _ECX + *(_DWORD *)(v31 - 12);
              --v32;
              __asm
              {
                fld     st
                fmul    qword ptr [ebx]
                fstp    qword ptr [ebx]
              }
            }
            while ( v32 );
            v4 = a2;
            v28 = v96;
          }
          while ( v30 < v4 )
          {
            _EAX = *(_DWORD *)(a1 + 4 * v30);
            __asm { fld     qword ptr [eax+ecx] }
            _EAX = _ECX + _EAX;
            __asm { fmul    st, st(1) }
            ++v30;
            __asm { fstp    qword ptr [eax] }
          }
        }
        __asm { fstp    st }
      }
      --v97;
      v98 += 4;
      v89 = v28 + 1;
      _ECX += 8;
      v96 = v89;
      if ( v89 >= v4 )
        break;
      v10 = v96;
    }
    __asm { fstp    st(1) }
  }
  __asm
  {
    fstp    st
    fstp    st
  }
  UF_free(v94);
  return 0;
}

//----- (10002C00) --------------------------------------------------------
__int16 __usercall sub_10002C00<ax>(int _EAX<eax>, int _ECX<ecx>, int a3, int a4)
{
  signed int v4; // edx@1
  int v6; // eax@2
  int v7; // ebx@2
  int v8; // esi@2
  unsigned int v9; // eax@7
  int v12; // ebx@17
  unsigned int v14; // eax@20
  char v19; // zf@4
  int v21; // eax@7
  int v22; // ebx@7
  int v28; // eax@20
  int v29; // edi@20
  signed int v35; // [sp+Ch] [bp-Ch]@1
  int v36; // [sp+8h] [bp-10h]@2
  int v37; // [sp+4h] [bp-14h]@2
  int v38; // [sp+0h] [bp-18h]@7
  int v39; // [sp+10h] [bp-8h]@7
  int v40; // [sp+14h] [bp-4h]@7

  v4 = a4;
  __asm { fldz }
  _EDI = 0;
  v35 = 0;
  if ( a4 > 0 )
  {
    v7 = a3;
    v8 = a4;
    v6 = _EAX - a3;
    v36 = a3;
    v37 = v6;
    while ( 1 )
    {
      v19 = v35 == 0;
      _EAX = *(_DWORD *)(v6 + v7);
      __asm
      {
        fld     qword ptr [ecx+eax*8]
        fld     qword ptr [ecx+edi*8]
        fstp    qword ptr [ecx+eax*8]
        fld     st(1)
      }
      if ( v19 )
      {
        __asm
        {
          fucomp  st(1)
          fnstsw  ax
          jnp     short loc_10002CCC
        }
        v35 = 1;
        v8 = _EDI;
      }
      else
      {
        __asm { fld     st(2) }
        _EAX = v8;
        if ( v8 >= _EDI )
        {
          __asm
          {
            fstp    st(1)
            fstp    st
          }
        }
        else
        {
          if ( _EDI - v8 >= 2 )
          {
            v21 = *(_DWORD *)v7;
            v22 = *(_DWORD *)v7 + 8 * v8 + 8;
            v38 = v21 - _ECX;
            v9 = ((unsigned int)(_EDI - v8 - 2) >> 1) + 1;
            v39 = v22;
            _EDX = _ECX + 8 * v8;
            v40 = v8 + 2 * v9;
            do
            {
              _EBX = v38;
              __asm
              {
                fld     qword ptr [ebx+edx]
                fmul    qword ptr [edx]
              }
              _EBX = v39 + 16;
              _EDX += 16;
              --v9;
              __asm { fsubp   st(2), st }
              v39 += 16;
              __asm
              {
                fld     qword ptr [edx-8]
                fmul    qword ptr [ebx-10h]
                fsubp   st(1), st
              }
            }
            while ( v9 );
            _EAX = v40;
            v7 = v36;
          }
          if ( _EAX < _EDI )
          {
            _EDX = *(_DWORD *)v7;
            __asm
            {
              fld     qword ptr [ecx+eax*8]
              fmul    qword ptr [edx+eax*8]
              fsubp   st(3), st
            }
          }
          v4 = a4;
          __asm
          {
            faddp   st(1), st
            faddp   st(1), st
          }
        }
      }
      __asm { fstp    qword ptr [ecx+edi*8] }
      ++_EDI;
      v7 += 4;
      v36 = v7;
      if ( _EDI >= v4 )
        break;
      v6 = v37;
    }
  }
  _ESI = v4 - 1;
  if ( v4 - 1 >= 0 )
  {
    _EAX = v4 - _ESI - 1;
    v12 = v4;
    _EDI = _ECX + 8 * _ESI;
    v35 = v4;
    v39 = _ECX + 8 * _ESI;
    v36 = v4 - _ESI - 1;
    v38 = 8 - _ECX;
    do
    {
      __asm
      {
        fld     st
        fld     st(1)
      }
      v40 = v12;
      __asm { fld     qword ptr [edi] }
      if ( v12 >= a4 )
      {
        __asm
        {
          fstp    st(2)
          fstp    st
        }
      }
      else
      {
        if ( _EAX >= 2 )
        {
          v28 = _EDI + v38;
          v29 = *(_DWORD *)(a3 + 4 * _ESI);
          _EDX = v28 + _ECX;
          v37 = v29 + v28 + 8;
          _EDI = v29 - _ECX;
          v14 = ((unsigned int)(a4 - 1 - v12 - 1) >> 1) + 1;
          v40 = v12 + 2 * v14;
          _EBX = v37;
          do
          {
            __asm { fld     qword ptr [edx+edi] }
            _EBX += 16;
            __asm { fmul    qword ptr [edx] }
            _EDX += 16;
            --v14;
            __asm
            {
              fsubp   st(3), st
              fld     qword ptr [edx-8]
              fmul    qword ptr [ebx-10h]
              fsubp   st(2), st
            }
          }
          while ( v14 );
          _EDI = v39;
          v12 = v35;
        }
        _EAX = v40;
        if ( v40 < a4 )
        {
          _EDX = *(_DWORD *)(a3 + 4 * _ESI);
          __asm
          {
            fld     qword ptr [edx+eax*8]
            fmul    qword ptr [ecx+eax*8]
            fsubp   st(1), st
          }
        }
        _EAX = v36;
        __asm
        {
          fxch    st(1)
          faddp   st(2), st
          faddp   st(1), st
        }
      }
      _EDX = *(_DWORD *)(a3 + 4 * _ESI);
      __asm { fdiv    qword ptr [edx+esi*8] }
      --_ESI;
      ++_EAX;
      --v12;
      _EDI -= 8;
      v36 = _EAX;
      v35 = v12;
      v39 = _EDI;
      __asm { fstp    qword ptr [edi+8] }
    }
    while ( _ESI >= 0 );
  }
  __asm { fstp    st }
  return _EAX;
}

//----- (10002DC0) --------------------------------------------------------
__int16 __cdecl sub_10002DC0(int a2)
{
  int v2; // eax@1
  __int64 v5; // [sp+78h] [bp-50h]@1
  __int64 v6; // [sp+58h] [bp-70h]@1
  __int64 *v7; // [sp+9Ch] [bp-2Ch]@1
  __int64 v8; // [sp+18h] [bp-B0h]@1
  __int64 *v9; // [sp+A0h] [bp-28h]@1
  __int64 v10; // [sp+38h] [bp-90h]@1
  __int64 *v22; // [sp+98h] [bp-30h]@1
  __int64 *v24; // [sp+A4h] [bp-24h]@1
  char v25; // [sp+0h] [bp-C8h]@1
  char v26; // [sp+10h] [bp-B8h]@1
  __int64 v27; // [sp+A8h] [bp-20h]@3
  __int64 v28; // [sp+B0h] [bp-18h]@3
  __int64 v29; // [sp+B8h] [bp-10h]@3
  __int64 v30; // [sp+C0h] [bp-8h]@3

  __asm
  {
    fld     qword ptr [eax]
    fstp    [ebp+var_50]
    fld     qword ptr [eax+20h]
  }
  v7 = &v6;
  __asm
  {
    fstp    [ebp+var_70]
    fld     qword ptr [eax+40h]
    fstp    [ebp+var_B0]
  }
  v9 = &v8;
  __asm
  {
    fld     qword ptr [eax+60h]
    fstp    [ebp+var_90]
    fld     qword ptr [eax+8]
    fstp    [ebp+var_48]
    fld     qword ptr [eax+28h]
    fstp    [ebp+var_68]
    fld     qword ptr [eax+48h]
    fstp    [ebp+var_A8]
    fld     qword ptr [eax+68h]
    fstp    [ebp+var_88]
    fld     qword ptr [eax+10h]
    fstp    [ebp+var_40]
    fld     qword ptr [eax+30h]
    fstp    [ebp+var_60]
    fld     qword ptr [eax+50h]
    fstp    [ebp+var_A0]
    fld     qword ptr [eax+70h]
    fstp    [ebp+var_80]
    fld     qword ptr [eax+18h]
    fstp    [ebp+var_38]
    fld     qword ptr [eax+38h]
    fstp    [ebp+var_58]
    fld     qword ptr [eax+58h]
    fstp    [ebp+var_98]
    fld     qword ptr [eax+78h]
  }
  v22 = &v5;
  __asm { fstp    [ebp+var_78] }
  v24 = &v10;
  v2 = sub_10002830((int)&v22, 4, (int)&v25, (int)&v26);
  if ( !v2 )
  {
    _EDI = 0;
    _ESI = a2 + 64;
    do
    {
      __asm { fld1 }
      v27 = 0i64;
      v28 = 0i64;
      v29 = 0i64;
      v30 = 0i64;
      __asm { fstp    [ebp+edi*8+var_20] }
      LOWORD(v2) = sub_10002C00((int)&v25, (int)&v27, (int)&v22, 4);
      __asm
      {
        fld     [ebp+var_20]
        fstp    qword ptr [esi-40h]
      }
      ++_EDI;
      __asm
      {
        fld     [ebp+var_18]
        fstp    qword ptr [esi-20h]
      }
      _ESI += 8;
      __asm
      {
        fld     [ebp+var_10]
        fstp    qword ptr [esi-8]
        fld     [ebp+var_8]
        fstp    qword ptr [esi+18h]
      }
    }
    while ( _EDI < 4 );
  }
  return v2;
}

//----- (10002EE0) --------------------------------------------------------
int __cdecl sub_10002EE0(int a2, int a3)
{
  int result; // eax@11
  int v14; // eax@4
  int v15; // ST10_4@4
  double v16; // ST08_8@4
  int v17; // esi@4
  double v18; // ST00_8@4
  char *v19; // ST10_4@4
  char *v20; // ST0C_4@4
  __int64 v21; // ST04_8@4
  int *v22; // ST10_4@4
  __int64 v23; // ST08_8@4
  int v25; // eax@8
  int v26; // ST10_4@8
  double v27; // ST08_8@8
  int v28; // esi@8
  double v29; // ST00_8@8
  char *v30; // ST10_4@8
  char *v31; // ST0C_4@8
  __int64 v32; // ST04_8@8
  int *v33; // ST10_4@8
  __int64 v34; // ST08_8@8
  __int64 v35; // [sp+B0h] [bp-4Ch]@1
  char v54; // [sp+E0h] [bp-1Ch]@4
  char v55; // [sp+D8h] [bp-24h]@4
  int v56; // [sp+F8h] [bp-4h]@4
  __int64 v57; // [sp+20h] [bp-DCh]@7

  __asm { fldz }
  _EAX = a3;
  __asm
  {
    fst     [ebp+var_4C]
    fstp    [ebp+var_44]
    fld1
    fstp    [ebp+var_3C]
    fld     qword ptr [eax]
    fld     qword ptr [eax+8]
    fld     qword ptr [ecx]
    fst     [ebp+var_34]
    fld     qword ptr [ecx+8]
    fst     [ebp+var_2C]
    fxch    st(3)
    fst     [ebp+var_AC]
    fld     st
    fld     ds:dbl_100099C8
    fmul    st(1), st
    fxch    st(1)
    fst     [ebp+var_A4]
    fld     st(2)
    fld     ds:dbl_100099C0
    fadd    st(1), st
    fxch    st(1)
    fstp    [ebp+var_9C]
    fld     st
    fsubrp  st(4), st
    fxch    st(3)
    fstp    [ebp+var_94]
    fld     st(2)
    fsub    st, st(1)
    fstp    [ebp+var_8C]
    fadd    st, st(2)
    fstp    [ebp+var_84]
    fxch    st(3)
    fst     [ebp+var_7C]
    fld     st
    fmul    st, st(4)
    fst     [ebp+var_74]
    fld     st(1)
    fadd    st, st(3)
    fstp    [ebp+var_6C]
    fld     st(2)
    fsubrp  st(2), st
    fxch    st(1)
    fstp    [ebp+var_64]
    fld     st(1)
    fsub    st, st(1)
    fstp    [ebp+var_5C]
    faddp   st(1), st
    fstp    [ebp+var_54]
    fld     st
    fsub    st, st(3)
    fabs
    fcomp   dbl_1000C000
    fnstsw  ax
    jp      short loc_10002F9E
    fxch    st(2)
    fmulp   st(1), st
  }
  _EBX = 0;
  __asm { fstp    qword ptr [ecx+8] }
  _EDI = 0;
  while ( 1 )
  {
    v14 = a2;
    v15 = 0;
    __asm { fstp    [esp+0FCh+var_F4] }
    v17 = (int)&v54;
    __asm
    {
      fld     [ebp+edi*8+var_AC]
      fstp    [esp+0FCh+var_FC]
    }
    sub_10002190(v14, v17, v18, v16, v15);
    __asm { fld     dbl_1000C000 }
    v19 = &v54;
    v20 = &v55;
    __asm { fstp    [esp+0F8h+var_FC+4] }
    UF_VEC3_unitize(&v54, v21, *((_DWORD *)&v21 + 1), v20, v19);
    __asm { fld     dbl_1000C000 }
    v22 = &v56;
    __asm { fstp    [esp+0F4h+var_F4] }
    UF_VEC3_is_equal(&v35, &v54, v23, *((_DWORD *)&v23 + 1), v22);
    if ( v56 )
    {
      __asm { fld     [ebp+edi*8+var_AC] }
      ++_EBX;
      __asm { fstp    [ebp+ebx*8+var_E4] }
    }
    ++_EDI;
    if ( _EDI >= 6 )
      break;
    __asm { fld     [ebp+var_34] }
  }
  qsort(&v57, _EBX - 1, 8u, sub_100023F0);
  __asm { fld     [ebp+var_DC] }
  _ECX = a3;
  __asm { fstp    qword ptr [ecx] }
  _EBX = 0;
  _EDI = 0;
  do
  {
    __asm { fld     [ebp+var_2C] }
    v25 = a2;
    v26 = 0;
    __asm { fstp    [esp+0FCh+var_F4] }
    v28 = (int)&v54;
    __asm
    {
      fld     [ebp+edi*8+var_7C]
      fstp    [esp+0FCh+var_FC]
    }
    sub_10002190(v25, v28, v29, v27, v26);
    __asm { fld     dbl_1000C000 }
    v30 = &v54;
    v31 = &v55;
    __asm { fstp    [esp+0F8h+var_FC+4] }
    UF_VEC3_unitize(&v54, v32, *((_DWORD *)&v32 + 1), v31, v30);
    __asm { fld     dbl_1000C000 }
    v33 = &v56;
    __asm { fstp    [esp+0F4h+var_F4] }
    UF_VEC3_is_equal(&v35, &v54, v34, *((_DWORD *)&v34 + 1), v33);
    if ( v56 )
    {
      __asm { fld     [ebp+edi*8+var_7C] }
      ++_EBX;
      __asm { fstp    [ebp+ebx*8+var_E4] }
    }
    ++_EDI;
  }
  while ( _EDI < 6 );
  qsort(&v57, _EBX - 1, 8u, sub_100023F0);
  __asm { fld     [ebp+var_DC] }
  result = a3;
  __asm { fstp    qword ptr [eax+8] }
  return result;
}

//----- (10003100) --------------------------------------------------------
signed int __usercall sub_10003100<eax>(int a1<ebx>, int a2<edi>, int a3<esi>, const void *a4, int a5, int a6)
{
  int ST40_4_0; // ST40_4@0
  int ST44_4_0; // ST44_4@0
  int ST48_4_0; // ST48_4@0
  int v11; // ST34_4@1
  int v12; // ST38_4@1
  int v13; // ST3C_4@1
  signed int result; // eax@7
  signed int v15; // ecx@8
  int v16; // esi@8
  signed int v19; // eax@58
  signed int v21; // esi@68
  int v22; // eax@69
  signed int v23; // eax@74
  int (__cdecl *v25)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // esi@77
  int *v26; // ST38_4@77
  int v27; // ST3C_4@77
  char v28; // zf@1
  __int64 v30; // ST2C_8@2
  __int64 v31; // ST24_8@2
  __int64 v32; // ST1C_8@2
  __int64 v33; // ST14_8@2
  __int64 v34; // ST0C_8@2
  __int64 v35; // ST04_8@2
  int v36; // ST28_4@4
  int v37; // ST2C_4@4
  int v38; // ST30_4@4
  __int64 v39; // ST28_8@6
  __int64 *v40; // ST3C_4@8
  char *v41; // ST38_4@8
  __int64 v42; // ST30_8@8
  double v45; // ST38_8@10
  double v49; // ST38_8@11
  double v65; // ST38_8@18
  __int64 v87; // ST38_8@38
  __int64 v88; // ST30_8@38
  __int64 v89; // ST28_8@38
  __int64 v90; // ST20_8@38
  __int64 v91; // ST18_8@38
  __int64 v92; // ST10_8@38
  __int64 v93; // ST38_8@38
  int v112; // eax@59
  int v113; // ecx@59
  int v114; // edx@59
  int v115; // esi@59
  int v116; // esi@59
  int v117; // eax@59
  __int64 v119; // ST38_8@63
  __int64 v120; // ST30_8@63
  __int64 v121; // ST28_8@63
  __int64 v122; // ST20_8@63
  __int64 v123; // ST38_8@63
  __int64 v124; // ST30_8@63
  __int64 v125; // ST28_8@63
  __int64 v126; // ST20_8@63
  int v127; // ST3C_4@65
  double v128; // ST34_8@65
  double v129; // ST2C_8@65
  int v130; // ST3C_4@65
  double v131; // ST34_8@65
  double v132; // ST2C_8@65
  int v133; // ST3C_4@67
  double v134; // ST34_8@67
  int v135; // ST3C_4@67
  double v136; // ST34_8@67
  int v138; // ST3C_4@75
  __int64 *v139; // ST38_4@75
  __int64 v140; // ST30_8@75
  int v141; // ST3C_4@75
  __int64 *v142; // ST38_4@75
  __int64 v143; // ST30_8@75
  int v144; // ST3C_4@75
  double v145; // ST34_8@75
  int v146; // ST3C_4@75
  double v147; // ST34_8@75
  int v149; // ST3C_4@77
  double v150; // ST34_8@77
  int *v151; // ST3C_4@77
  char *v152; // ST38_4@77
  __int64 v153; // ST30_8@77
  int v155; // ST3C_4@77
  int *v156; // ST38_4@77
  __int64 v157; // ST30_8@77
  int v160; // ST3C_4@79
  double v161; // ST34_8@79
  double v162; // ST2C_8@79
  int v163; // ST3C_4@79
  double v164; // ST34_8@79
  double v165; // ST2C_8@79
  int *v166; // ST3C_4@79
  char *v167; // ST38_4@79
  __int64 v168; // ST30_8@79
  char *v169; // ST3C_4@79
  char *v170; // ST38_4@79
  __int64 v171; // ST30_8@79
  int v173; // ST3C_4@79
  int *v174; // ST38_4@79
  __int64 v175; // ST30_8@79
  __int64 v177; // ST30_8@80
  char v178; // zf@82
  char v191; // [sp+103h] [bp-1h]@1
  signed int v192; // [sp+D4h] [bp-30h]@1
  int v193; // [sp+3Ch] [bp-C8h]@4
  char v194; // [sp+54h] [bp-B0h]@4
  __int64 v195; // [sp+9Ch] [bp-68h]@8
  char v196; // [sp+7Ch] [bp-88h]@8
  int v209; // [sp+40h] [bp-C4h]@59
  int v210; // [sp+44h] [bp-C0h]@59
  int v211; // [sp+48h] [bp-BCh]@59
  int v212; // [sp+4Ch] [bp-B8h]@59
  int v213; // [sp+50h] [bp-B4h]@59
  __int64 v214; // [sp+8Ch] [bp-78h]@65
  int v216; // [sp+BCh] [bp-48h]@77
  char v217; // [sp+84h] [bp-80h]@79

  v28 = byte_1000C588 == 0;
  __asm { fldz }
  _EAX = a5;
  v13 = a1;
  _EBX = a6;
  __asm { fst     qword ptr [ebx] }
  v12 = a3;
  __asm
  {
    fst     qword ptr [eax]
    fst     qword ptr [ebx+8]
  }
  v11 = a2;
  _EDI = a4;
  __asm
  {
    fst     qword ptr [eax+8]
    fst     qword ptr [ebx+10h]
  }
  v191 = 0;
  __asm { fst     qword ptr [eax+10h] }
  v192 = 0;
  __asm
  {
    fst     qword ptr [ebx+18h]
    fst     qword ptr [eax+18h]
    fst     qword ptr [ebx+20h]
    fstp    qword ptr [eax+20h]
  }
  if ( !v28 )
  {
    printf("\n------------------------------------------------------\n", v11, a3, v13);
    __asm
    {
      fld     qword ptr [edi+28h]
      fstp    [esp+104h+var_DC]
      fld     qword ptr [edi+20h]
      fstp    [esp+104h+var_E4]
      fld     qword ptr [edi+18h]
      fstp    [esp+104h+var_EC]
      fld     qword ptr [edi+10h]
      fstp    [esp+104h+var_F4]
      fld     qword ptr [edi+8]
      fstp    [esp+104h+var_FC]
      fld     qword ptr [edi]
      fstp    [esp+104h+var_104]
    }
    printf("Starting old_pcoord_t[] = (%f,%f,%f,%f,%f,%f)\n", v35, *((_DWORD *)&v35 + 1), v34, v33, v32, v31, v30);
  }
  if ( dword_1000C3DC == 3 )
  {
    UF_MTX3_vec_multiply_t(_EDI, &unk_10009970, &v193, v11, v12, v13);
    UF_MTX3_vec_multiply_t((char *)_EDI + 24, &unk_10009970, &v194, v36, v37, v38);
  }
  else
  {
    memcpy(&v193, _EDI, 0x30u);
    _EDI = a4;
  }
  __asm
  {
    fld     dbl_1000C000
    fstp    [esp+0E0h+var_E4+4]
  }
  UF_VEC3_is_zero(&v194, v39, *((_DWORD *)&v39 + 1));
  if ( a6 )
    return 4;
  __asm { fld     dbl_1000C000 }
  v40 = &v195;
  v41 = &v196;
  __asm { fstp    [esp+0D8h+var_DC+4] }
  UF_VEC3_unitize(&v194, v42, *((_DWORD *)&v42 + 1), v41, v40);
  __asm { fld     qword ptr [ebp+var_68] }
  v16 = dword_1000C3D8;
  __asm
  {
    fst     [ebp+var_70]
    fld     [ebp+var_60]
  }
  v15 = *(_DWORD *)v16;
  __asm
  {
    fst     [ebp+var_90]
    fld     [ebp+var_58]
    fst     [ebp+var_98]
  }
  if ( v15 != 3 )
  {
    __asm
    {
      fld     dbl_1000C298
      fmul    st, st(1)
      fld     dbl_1000C278
      fmul    st, st(3)
      faddp   st(1), st
      fld     dbl_1000C258
      fmul    st, st(4)
      faddp   st(1), st
      fld     dbl_1000C2A0
      fmul    st, st(2)
      fld     dbl_1000C280
      fmul    st, st(4)
      faddp   st(1), st
      fld     dbl_1000C260
      fmul    st, st(5)
      faddp   st(1), st
      fmul    dbl_1000C560
      fsubp   st(1), st
      fld     dbl_1000C4D8
      fmul    st(1), st
      fxch    st(1)
      fstp    [ebp+var_2C]
      fld     dbl_1000C288
      fmul    st, st(2)
      fld     dbl_1000C268
      fmul    st, st(4)
      faddp   st(1), st
      fld     dbl_1000C248
      fmul    st, st(5)
      faddp   st(1), st
      fld     dbl_1000C290
      fmulp   st(3), st
      fld     dbl_1000C270
      fmulp   st(4), st
      fxch    st(2)
      faddp   st(3), st
      fld     dbl_1000C250
      fmulp   st(4), st
      fxch    st(2)
      faddp   st(3), st
      fld     dbl_1000C310
      fld     st
      fabs
      fld     dbl_1000C000
      fcom    st(1)
      fnstsw  ax
      fstp    st(1)
    }
    if ( HIBYTE(_AX) & 1 )
    {
      if ( v15 == 1 )
      {
        __asm { fld     dbl_1000C308 }
      }
      else
      {
        if ( v15 == 2 )
          __asm { fld     dbl_1000C308 }
        else
          __asm { fld     [ebp+var_38] }
      }
      __asm
      {
        fsub    [ebp+var_2C]
        fdiv    st, st(2)
        fstp    [ebp+var_2C]
        fldz
      }
    }
    else
    {
      __asm { fldz }
      v191 = 1;
      __asm { fst     [ebp+var_2C] }
    }
    __asm
    {
      fld     st(5)
      fmul    st, st(6)
      fld     st(4)
      fmul    st, st(5)
      faddp   st(1), st
      fsqrt
      fld     st(4)
      fabs
      fcomp   st(3)
      fnstsw  ax
      jp      short loc_10003575
      fld     st(6)
      fabs
      fcomp   st(3)
      fnstsw  ax
      jp      short loc_10003575
      fstp    st(6)
      fstp    st(3)
      fxch    st(2)
      fst     [ebp+var_50]
      fld     st(4)
      fabs
      fcomp   st(3)
      fnstsw  ax
      jp      short loc_10003599
      fstp    st(4)
      fld     st(3)
      fst     [ebp+var_2C]
      fld     st
      fabs
      fld     st(3)
      fld1
      fadd    st(1), st
      fxch    st(2)
      fcompp  st(1), st
      fnstsw  ax
    }
    if ( HIBYTE(_AX) & 0x41 )
    {
      __asm
      {
        fld     st(1)
        fmul    st, st(2)
        fsubr   st, st(1)
        fld     st
        fabs
        fcomp   st(5)
        fnstsw  ax
        jp      short loc_1000365D
        fstp    st
        fld     st(5)
        fld     st(2)
        fsubrp  st(2), st
        fxch    st(1)
        fabs
        fcomp   st(4)
        fnstsw  ax
        jp      short loc_10003674
        fstp    st
        fld     st(4)
        fld     st
      }
      _ECX = 0;
      __asm
      {
        fld     st(2)
        fxch    st(1)
        fpatan
        fadd    [ebp+var_50]
        fstp    [ebp+var_14]
        fchs
        fpatan
        fadd    [ebp+var_50]
        fstp    [ebp+var_C]
        fld     dbl_1000C4D0
        fabs
        fstp    [ebp+var_2C]
      }
    }
    else
    {
      __asm
      {
        fstp    st(1)
        fstp    st(4)
        fstp    st
        fstp    st(1)
        fstp    st
        fstp    st
        fld     qword ptr [edi+28h]
        fstp    [esp+0F8h+var_D0]
        fld     qword ptr [edi+20h]
        fstp    [esp+0F8h+var_DC+4]
        fld     qword ptr [edi+18h]
        fstp    [esp+0F8h+var_E4+4]
        fld     qword ptr [edi+10h]
        fstp    [esp+0F8h+var_EC+4]
        fld     qword ptr [edi+8]
        fstp    [esp+0F8h+var_F4+4]
        fld     qword ptr [edi]
        fstp    [esp+0F8h+var_FC+4]
      }
      printf("INPUT Point =%-.4f,%-.4f,%-.4f,%-.8f,%-.8f,%-.8f\n", v92, *((_DWORD *)&v92 + 1), v91, v90, v89, v88, v87);
      __asm
      {
        fld     [ebp+var_2C]
        fstp    [esp+0D0h+var_D0]
      }
      printf("WARNING: Degenerated G_lambda(%f) out of range (-1, 1)\n", v93, *((_DWORD *)&v93 + 1));
      __asm
      {
        fldz
        fst     [ebp+var_C]
        fst     [ebp+var_14]
        fld     dbl_1000C000
      }
      _ECX = 0;
      __asm
      {
        fld     dbl_1000C4D8
        fld     dbl_1000C310
        fxch    st(1)
        fxch    st(2)
        fxch    st(1)
        fld     dbl_1000C4D0
        fabs
        fstp    [ebp+var_2C]
      }
    }
    while ( 1 )
    {
      __asm
      {
        fld     [ebp+ecx+var_14]
        fsin
        fld     [ebp+ecx+var_14]
        fcos
        fxch    st(3)
        fcom    [ebp+var_2C]
        fnstsw  ax
      }
      if ( HIBYTE(_AX) & 1 )
      {
        __asm
        {
          fstp    st(5)
          fstp    st(4)
          fld     st(3)
          fmul    st, st(3)
          fchs
          fld     st(2)
          fmulp   st(4), st
          fxch    st(1)
          fmul    dbl_1000C560
          fchs
          fstp    [ebp+var_50]
          fld     st(3)
          fmul    dbl_1000C290
          fld     st(2)
          fmul    dbl_1000C288
          faddp   st(1), st
          fld     dbl_1000C558
          fmul    dbl_1000C2A0
          fsubp   st(1), st
          fmul    [ebp+var_98]
          fld     st(4)
          fmul    dbl_1000C270
          fld     st(3)
          fmul    dbl_1000C268
          faddp   st(1), st
          fld     dbl_1000C558
          fmul    dbl_1000C280
          fsubp   st(1), st
          fmul    [ebp+var_90]
          faddp   st(1), st
          fxch    st(4)
          fmul    dbl_1000C250
          fxch    st(2)
          fmul    dbl_1000C248
          faddp   st(2), st
          fld     dbl_1000C558
          fmul    dbl_1000C260
          fsubp   st(2), st
          fxch    st(1)
          fmul    [ebp+var_70]
          faddp   st(3), st
          fxch    st(2)
          fdiv    dbl_1000C4D0
          fstp    [ebp+var_38]
          fld     dbl_1000C310
          fld     dbl_1000C298
          fmul    st, st(1)
          fld     st(2)
          fmul    dbl_1000C290
          faddp   st(1), st
          fld     st(3)
          fmul    dbl_1000C288
          faddp   st(1), st
          fld     [ebp+var_50]
          fld     dbl_1000C2A0
          fmul    st, st(1)
          faddp   st(2), st
          fxch    st(1)
          fmul    [ebp+var_98]
          fld     st(2)
          fmul    dbl_1000C278
          fld     st(4)
          fmul    dbl_1000C270
          faddp   st(1), st
          fld     st(5)
          fmul    dbl_1000C268
          faddp   st(1), st
          fld     st(2)
          fmul    dbl_1000C280
          faddp   st(1), st
          fmul    [ebp+var_90]
          faddp   st(1), st
          fld     st(2)
          fmul    dbl_1000C258
          fxch    st(4)
          fmul    dbl_1000C250
          faddp   st(4), st
          fxch    st(4)
          fmul    dbl_1000C248
          faddp   st(3), st
          fmul    dbl_1000C260
          faddp   st(2), st
          fxch    st(1)
          fmul    [ebp+var_70]
          faddp   st(2), st
          fld     ds:dbl_100099C8
          fdiv    dbl_1000C4D0
          fmulp   st(2), st
          fldz
          fld     dbl_1000C000
          fld     dbl_1000C4D8
          fld     [ebp+var_38]
          fxch    st(3)
          fxch    st(5)
          fxch    st(1)
          fxch    st(4)
          fxch    st(2)
          fxch    st(3)
        }
      }
      else
      {
        __asm
        {
          fstp    st(3)
          fstp    st
          fld     st(3)
          fld     st(4)
        }
      }
      __asm
      {
        fld     st
        fabs
        fcomp   st(4)
        fnstsw  ax
        jp      short loc_10003844
        fld     st(1)
        fabs
        fcomp   st(4)
        fnstsw  ax
        jp      short loc_10003844
        fstp    st(1)
      }
      v191 = 1;
      __asm
      {
        fstp    st
        fxch    st(3)
        fst     [ebp+ecx+var_24]
      }
      _ECX += 8;
      if ( _ECX >= 16 )
        break;
      __asm { fxch    st(3) }
    }
    v16 = dword_1000C3D8;
    __asm { fstp    st }
    goto LABEL_50;
  }
  if ( dword_1000C3DC )
  {
    if ( dword_1000C3DC != 1 && dword_1000C3DC != 3 )
    {
      __asm
      {
        fstp    st
        fstp    st
        fstp    st
      }
      return 2;
    }
    __asm
    {
      fld     dbl_1000C300
      fld     st
      fld1
      fsub    st(1), st
      fxch    st(1)
      fabs
      fld     dbl_1000C000
      fcom    st(1)
      fnstsw  ax
      fstp    st(1)
    }
    if ( HIBYTE(_AX) & 1 )
    {
      __asm
      {
        fld     st(2)
        fmul    st, st(3)
        fsub    st(4), st
        fsubr   st, st(2)
        fdivp   st(4), st
        fld     st(3)
        fabs
        fld     st(1)
        fadd    st, st(3)
        fcompp  st(1), st
        fnstsw  ax
        jnp     short loc_100033BB
        fstp    st(4)
        fstp    st(4)
        fstp    st
        fstp    st(1)
        fstp    st(1)
        fstp    [esp+0D0h+var_D0]
      }
      sub_10001F90(v65);
      __asm
      {
        fst     [ebp+var_14]
        fchs
      }
      _ECX = 0;
      __asm
      {
        fstp    [ebp+var_C]
        fld     [ebp+var_60]
        fld     qword ptr [ebp+var_68]
        fld     dbl_1000C000
        fld     dbl_1000C300
        fld1
        fxch    st(3)
        fxch    st(4)
        fxch    st(3)
        fld     dbl_1000C2F8
      }
    }
    else
    {
      __asm
      {
        fstp    st(3)
        fld     dbl_1000C460
      }
      _ECX = 0;
      __asm
      {
        fstp    [ebp+var_14]
        fld     dbl_1000C468
        fstp    [ebp+var_C]
        fld     dbl_1000C2F8
      }
    }
    while ( 1 )
    {
      __asm
      {
        fld     [ebp+ecx+var_14]
        fsin
        fld     [ebp+ecx+var_14]
        fcos
        fsubp   st(3), st
        fxch    st(2)
        fmulp   st(3), st
        fld     st(2)
        fmul    dbl_1000C2F0
        fld     st(1)
        fmul    st, st(3)
        faddp   st(1), st
        fxch    st(3)
        fmul    st, st(1)
        fld     dbl_1000C2F0
        fmulp   st(3), st
        fsubrp  st(2), st
        fld     st(1)
        fmul    st, st(5)
        fld     st(3)
        fmul    st, st(7)
        faddp   st(1), st
        fxch    st(3)
        fmul    st, st(5)
        fxch    st(2)
        fmul    st, st(6)
        fsubp   st(2), st
        fld     st(1)
        fabs
        fcomp   st(4)
        fnstsw  ax
        jp      short loc_10003453
        fld     st(2)
        fabs
        fcomp   st(4)
        fnstsw  ax
        jp      short loc_10003453
        fstp    st(1)
      }
      v191 = 1;
      __asm
      {
        fstp    st(1)
        fld     dbl_1000C318[ecx]
        fstp    [ebp+ecx+var_24]
      }
      _ECX += 8;
      if ( _ECX >= 16 )
        break;
      __asm
      {
        fld1
        fld     dbl_1000C300
        fxch    st(2)
      }
    }
    __asm { fstp    st(2) }
LABEL_50:
    __asm
    {
      fstp    st(2)
      fstp    st
    }
    if ( !v191 )
      goto LABEL_54;
    goto LABEL_51;
  }
  __asm
  {
    fstp    st
    fstp    st(1)
    fchs
  }
  CIasin(ST40_4_0, ST44_4_0, ST48_4_0);
  __asm
  {
    fstp    [ebp+var_14]
    fld     [ebp+var_58]
    fmul    st, st
    fld     qword ptr [ebp+var_68]
    fmul    st, st
    faddp   st(1), st
    fsqrt
    fst     [ebp+var_70]
    fstp    [esp+0D0h+var_D0]
  }
  sub_10001F90(v45);
  __asm
  {
    fst     [ebp+var_C]
    fsubr   [ebp+var_14]
    fabs
    fld     dbl_1000C000
    fcom    st(1)
    fnstsw  ax
    fstp    st(1)
  }
  if ( !(HIBYTE(_AX) & 1) )
  {
    __asm
    {
      fstp    st
      fld     [ebp+var_70]
      fchs
      fstp    [esp+0D0h+var_D0]
    }
    sub_10001F90(v49);
    __asm
    {
      fstp    [ebp+var_C]
      fld     dbl_1000C000
    }
  }
  __asm
  {
    fld     qword ptr [ebp+var_68]
    fld     st
    fabs
    fcomp   st(2)
    fnstsw  ax
    fld     [ebp+var_58]
    jp      short loc_10003302
    fld     st
    fabs
    fcomp   st(3)
    fnstsw  ax
    jp      short loc_10003302
    fstp    st
  }
  v191 = 1;
  __asm
  {
    fstp    st
    fld     dbl_1000C318
    fstp    [ebp+var_24]
    fld     dbl_1000C320
    fstp    [ebp+var_1C]
  }
LABEL_51:
  if ( *(_DWORD *)v16 != 3 )
  {
    __asm
    {
      fld     dbl_1000C460
      fstp    [ebp+var_14]
      fld     dbl_1000C468
      fstp    [ebp+var_C]
      fld     dbl_1000C318
      fstp    [ebp+var_24]
      fld     dbl_1000C320
      fstp    [ebp+var_1C]
    }
  }
  v192 = 1;
LABEL_54:
  if ( byte_1000C009 && (*(_DWORD *)v16 == 2 || *(_DWORD *)v16 == 3) )
  {
    __asm { fstp    st }
    sub_10002430();
    __asm { fld     [ebp+var_14] }
    result = v192;
    __asm
    {
      fstp    dbl_1000C530
      fld     [ebp+var_C]
      fstp    dbl_1000C538
      fld     [ebp+var_24]
      fstp    dbl_1000C2E0
      fld     [ebp+var_1C]
      fstp    dbl_1000C2E8
    }
    return result;
  }
  v19 = *(_DWORD *)v16;
  if ( *(_DWORD *)v16 == 1 )
  {
    _EDI = a5;
    v112 = v193;
    v113 = v209;
    v114 = v210;
    v115 = v211;
    *(_DWORD *)a5 = v193;
    *(_DWORD *)(a5 + 4) = v113;
    *(_DWORD *)(a5 + 8) = v114;
    *(_DWORD *)(a5 + 12) = v115;
    *(_DWORD *)(a5 + 16) = v212;
    v116 = v213;
    *(_DWORD *)(a5 + 20) = v213;
    *(_DWORD *)_EBX = v112;
    v117 = v212;
    *(_DWORD *)(_EBX + 4) = v113;
    *(_DWORD *)(_EBX + 8) = v114;
    *(_DWORD *)(_EBX + 12) = v211;
    *(_DWORD *)(_EBX + 16) = v117;
    *(_DWORD *)(_EBX + 20) = v116;
    goto LABEL_74;
  }
  if ( v19 != 2 && v19 != 3 )
  {
    _EDI = a5;
  }
  else
  {
    __asm { fstp    st }
    if ( byte_1000C588 )
    {
      printf("About adjusting theta with initial angle...\n");
      __asm
      {
        fld     dbl_1000C2E0
        fld     ds:dbl_10009308
        fmul    st(1), st
        fld     [ebp+var_24]
        fsub    st(2), st
        fld     ds:dbl_100099D8
        fmul    st(3), st
        fxch    st(3)
        fstp    [esp+0E8h+var_D0]
        fld     dbl_1000C530
        fmulp   st(2), st
        fld     [ebp+var_14]
        fsub    st(2), st
        fxch    st(2)
        fmul    st, st(3)
        fstp    [esp+0E8h+var_DC+4]
        fmul    st, st(2)
        fstp    [esp+0E8h+var_E4+4]
        fmulp   st(1), st
        fstp    [esp+0E8h+var_EC+4]
      }
      printf(
        "computing t1[0]=%f, t2[0]=%f, (Init_T1[0]*2-t1[0])=%f,(Init_T2[0]*2-t2[0])=%f\n",
        v122,
        *((_DWORD *)&v122 + 1),
        v121,
        v120,
        v119);
      __asm
      {
        fld     dbl_1000C2E8
        fld     ds:dbl_10009308
        fmul    st(1), st
        fld     [ebp+var_1C]
        fsub    st(2), st
        fld     ds:dbl_100099D8
        fmul    st(3), st
        fxch    st(3)
        fstp    [esp+0E8h+var_D0]
        fld     dbl_1000C538
        fmulp   st(2), st
        fld     [ebp+var_C]
        fsub    st(2), st
        fxch    st(2)
        fmul    st, st(3)
        fstp    [esp+0E8h+var_DC+4]
        fmul    st, st(2)
        fstp    [esp+0E8h+var_E4+4]
        fmulp   st(1), st
        fstp    [esp+0E8h+var_EC+4]
      }
      printf(
        "computing t1[1]=%f, t2[1]=%f, (Init_T1[1]*2-t1[1])=%f,(Init_T2[1]*2-t2[1])=%f\n",
        v126,
        *((_DWORD *)&v126 + 1),
        v125,
        v124,
        v123);
    }
    sub_10002430();
    if ( *(_DWORD *)dword_1000C3D8 == 2 )
    {
      __asm
      {
        fld     [ebp+var_14]
        fstp    [ebp+var_78]
        fld     [ebp+var_C]
        fstp    [ebp+var_70]
        fld     [ebp+var_24]
        fstp    [ebp+var_40]
        fld     [ebp+var_1C]
        fstp    [ebp+var_38]
      }
      sub_10002EE0((int)&v195, (int)&v214);
      __asm { fld     [ebp+var_78] }
      _EDI = a5;
      __asm
      {
        fst     [ebp+var_14]
        fld     [ebp+var_70]
      }
      v127 = 1;
      __asm
      {
        fstp    [ebp+var_C]
        fld     [ebp+var_40]
        fst     [ebp+var_24]
        fld     [ebp+var_38]
        fstp    [ebp+var_1C]
        fstp    qword ptr [esp+8]
        fstp    [esp+0DCh+var_DC]
      }
      sub_10002190((int)&v193, a5, v129, v128, v127);
      __asm { fld     [ebp+var_38] }
      v130 = 1;
      __asm
      {
        fstp    qword ptr [esp+8]
        fld     [ebp+var_70]
        fstp    [esp+0DCh+var_DC]
      }
      sub_10002190((int)&v193, _EBX, v132, v131, v130);
LABEL_66:
      __asm { fld     dbl_1000C000 }
      goto LABEL_74;
    }
    _EDI = a5;
    __asm { fld     [ebp+var_24] }
    v133 = a5;
    __asm
    {
      fchs
      fstp    qword ptr [esp]
    }
    sub_10002390((int)&v193, v134, v133);
    __asm
    {
      fld     [ebp+var_1C]
      fchs
    }
    v135 = _EBX;
    __asm { fstp    qword ptr [esp] }
    sub_10002390((int)&v193, v136, v135);
    if ( dword_1000C3DC != 3 )
      goto LABEL_66;
    v21 = 0;
    do
    {
      v22 = _EDI;
      if ( v21 )
        v22 = _EBX;
      UF_MTX3_vec_multiply_t(v22, &unk_10009928, v22, ST40_4_0, ST44_4_0, ST48_4_0);
      ++v21;
    }
    while ( v21 < 2 );
    __asm { fld     dbl_1000C000 }
  }
LABEL_74:
  _ECX = dword_1000C3D8;
  v23 = *(_DWORD *)dword_1000C3D8;
  if ( *(_DWORD *)dword_1000C3D8 == 1 )
  {
    __asm
    {
      fstp    st
      fld     qword ptr [ecx+90h]
    }
    v138 = _EDI;
    __asm { fadd    qword ptr [ecx+88h] }
    v139 = &v195;
    __asm
    {
      fst     [ebp+var_38]
      fstp    [esp+0D8h+var_DC+4]
    }
    UF_VEC3_affine_comb(_EDI, v140, *((_DWORD *)&v140 + 1), v139, v138);
    __asm { fld     [ebp+var_38] }
    v141 = _EBX;
    v142 = &v195;
    __asm { fstp    [esp+0D8h+var_DC+4] }
    UF_VEC3_affine_comb(_EBX, v143, *((_DWORD *)&v143 + 1), v142, v141);
    __asm { fld     [ebp+var_14] }
    v144 = _EDI;
    __asm { fstp    qword ptr [esp] }
    sub_10002310(_EDI, v145, v144);
    __asm { fld     [ebp+var_C] }
    v146 = _EBX;
    __asm { fstp    qword ptr [esp] }
    sub_10002310(_EBX, v147, v146);
LABEL_81:
    __asm { fld     dbl_1000C000 }
    goto LABEL_82;
  }
  if ( v23 == 3 )
  {
    __asm
    {
      fstp    st
      fld     [ebp+var_24]
    }
    v149 = (int)&v216;
    __asm
    {
      fchs
      fstp    qword ptr [esp]
    }
    sub_10002390((int)&v195, v150, v149);
    __asm { fld     dbl_1000C000 }
    v151 = &v216;
    v152 = &v196;
    __asm { fstp    [esp+0D8h+var_DC+4] }
    UF_VEC3_unitize(&v216, v153, *((_DWORD *)&v153 + 1), v152, v151);
    _EDX = dword_1000C3D8;
    __asm { fld     qword ptr [edx+88h] }
    v25 = UF_VEC3_affine_comb;
    v155 = _EDI;
    v156 = &v216;
    __asm { fstp    [esp+0D8h+var_DC+4] }
    UF_VEC3_affine_comb(_EDI, v157, *((_DWORD *)&v157 + 1), v156, v155);
    _ECX = dword_1000C3D8;
    __asm { fld     qword ptr [ecx+88h] }
    v27 = _EBX;
    v26 = &v216;
LABEL_80:
    __asm { fstp    [esp+0D8h+var_DC+4] }
    v25(_EBX, v177, *((_DWORD *)&v177 + 1), v26, v27);
    goto LABEL_81;
  }
  if ( v23 == 2 )
  {
    __asm { fstp    st }
    v160 = 0;
    __asm
    {
      fld     [ebp+var_24]
      fstp    qword ptr [esp+8]
      fld     [ebp+var_14]
      fstp    [esp+0DCh+var_DC]
    }
    sub_10002190((int)&v195, (int)&v216, v162, v161, v160);
    __asm { fld     [ebp+var_1C] }
    v163 = 0;
    __asm
    {
      fstp    qword ptr [esp+8]
      fld     [ebp+var_C]
      fstp    [esp+0DCh+var_DC]
    }
    sub_10002190((int)&v195, (int)&v217, v165, v164, v163);
    __asm { fld     dbl_1000C000 }
    v166 = &v216;
    v167 = &v196;
    __asm { fstp    [esp+0D8h+var_DC+4] }
    UF_VEC3_unitize(&v216, v168, *((_DWORD *)&v168 + 1), v167, v166);
    __asm { fld     dbl_1000C000 }
    v169 = &v217;
    v170 = &v196;
    __asm { fstp    [esp+0D8h+var_DC+4] }
    UF_VEC3_unitize(&v217, v171, *((_DWORD *)&v171 + 1), v170, v169);
    _EAX = dword_1000C3D8;
    __asm { fld     qword ptr [eax+88h] }
    v25 = UF_VEC3_affine_comb;
    v173 = _EDI;
    v174 = &v216;
    __asm { fstp    [esp+0D8h+var_DC+4] }
    UF_VEC3_affine_comb(_EDI, v175, *((_DWORD *)&v175 + 1), v174, v173);
    _EDX = dword_1000C3D8;
    __asm { fld     qword ptr [edx+88h] }
    v27 = _EBX;
    v26 = (int *)&v217;
    goto LABEL_80;
  }
LABEL_82:
  v178 = byte_1000C008 == 0;
  __asm
  {
    fld     [ebp+var_14]
    fld     st
    fld     ds:dbl_100099D8
    fmul    st(1), st
    fxch    st(1)
    fstp    qword ptr [edi+18h]
    fld     [ebp+var_C]
    fld     st
    fmul    st, st(2)
    fstp    qword ptr [ebx+18h]
    fld     [ebp+var_24]
    fld     st
    fmul    st, st(3)
    fstp    qword ptr [edi+20h]
    fld     [ebp+var_1C]
    fmulp   st(3), st
    fxch    st(2)
    fstp    qword ptr [ebx+20h]
  }
  if ( !v178 )
  {
    if ( *(_DWORD *)dword_1000C3D8 != 3 )
    {
      __asm
      {
        fld     qword ptr [edi+20h]
        fld     ds:dbl_10009A30
        fsub    st(1), st
        fxch    st(1)
        fst     qword ptr [edi+20h]
        fld     ds:dbl_10009A28
        fcom    st(1)
        fnstsw  ax
        fld     ds:dbl_100099E8
      }
      if ( HIBYTE(_AX) & 0x41 )
      {
        __asm { fstp    st(2) }
      }
      else
      {
        __asm
        {
          fadd    st(2), st
          fxch    st(2)
          fstp    qword ptr [edi+20h]
        }
      }
      __asm
      {
        fld     qword ptr [ebx+20h]
        fsubrp  st(3), st
        fxch    st(2)
        fst     qword ptr [ebx+20h]
        fcom    st(2)
        fnstsw  ax
        fstp    st(2)
        jp      short loc_10003D7E
        faddp   st(1), st
        fstp    qword ptr [ebx+20h]
      }
    }
  }
  if ( v191 )
  {
    if ( *(_DWORD *)dword_1000C3D8 != 3 )
    {
      *(_DWORD *)(_EDI + 24) = dword_1000C4F8;
      *(_DWORD *)(_EDI + 28) = dword_1000C4FC;
      *(_DWORD *)(_EDI + 32) = dword_1000C500;
      *(_DWORD *)(_EDI + 36) = dword_1000C504;
      *(_DWORD *)(_EBX + 24) = dword_1000C520;
      *(_DWORD *)(_EBX + 28) = dword_1000C524;
      *(_DWORD *)(_EBX + 32) = dword_1000C528;
      *(_DWORD *)(_EBX + 36) = dword_1000C52C;
    }
  }
  if ( byte_1000C588 )
  {
    __asm
    {
      fsubp   st(2), st
      fxch    st(1)
      fabs
      fcomp   st(2)
      fnstsw  ax
      jp      short loc_10003E12
      fsub    [ebp+var_1C]
      fabs
      fcompp  st(1), st
      fnstsw  ax
      jp      short loc_10003E16
    }
    printf("WARNING: same value of rotary produced:\n");
  }
  else
  {
    __asm
    {
      fstp    st
      fstp    st(1)
      fstp    st(1)
      fstp    st
    }
  }
  __asm { fld     [ebp+var_14] }
  result = v192;
  memcpy(&dword_1000C4E0, (const void *)a5, 0x28u);
  memcpy(&dword_1000C508, (const void *)_EBX, 0x28u);
  __asm
  {
    fstp    dbl_1000C460
    fld     [ebp+var_C]
    fstp    dbl_1000C468
    fld     [ebp+var_24]
    fstp    dbl_1000C318
    fld     [ebp+var_1C]
    fstp    dbl_1000C320
  }
  return result;
}

//----- (10003E70) --------------------------------------------------------
int __cdecl sub_10003E70(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // esi@1
  int v8; // edi@1
  __int64 v48; // [sp+3Ch] [bp-40h]@1
  char v49; // [sp+Ch] [bp-70h]@1
  __int64 v50; // [sp+24h] [bp-58h]@1
  __int64 v51; // [sp+5Ch] [bp-20h]@1
  __int64 v52; // [sp+64h] [bp-18h]@1
  __int64 v53; // [sp+54h] [bp-28h]@1
  __int64 v54; // [sp+6Ch] [bp-10h]@1
  __int64 v55; // [sp+74h] [bp-8h]@1

  v7 = a1;
  UF_VEC3_sub(a1 + 24, a1, &v48);
  v8 = a2;
  UF_VEC3_sub(v7, a2, &v49);
  UF_VEC3_sub(v8 + 24, v8, &v50);
  UF_VEC3_dot(&v48, &v49, &v51);
  UF_VEC3_dot(&v50, &v48, &v52);
  UF_VEC3_dot(&v50, &v49, &v53);
  UF_VEC3_dot(&v50, &v50, &v54);
  UF_VEC3_dot(&v48, &v48, &v55);
  __asm
  {
    fldz
    fld     st
    fld     [ebp+var_10]
    fucom   st(1)
    fnstsw  ax
    fstp    st(1)
    jp      short loc_10003F62
    fstp    st(1)
    fstp    st
  }
  UF_VEC3_copy(v8, a4);
  __asm { fldz }
  _EDX = a6;
  __asm
  {
    fst     qword ptr [edx]
    fcomp   [ebp+var_8]
    fnstsw  ax
    jp      short loc_10003F44
  }
  UF_VEC3_copy(v7, a3);
  __asm { fldz }
  _ECX = a5;
  __asm { fstp    qword ptr [ecx] }
  return 0;
}

//----- (10004090) --------------------------------------------------------
signed int __cdecl sub_10004090(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int ST64_4_0; // ST64_4@0
  int ST68_4_0; // ST68_4@0
  int ST6C_4_0; // ST6C_4@0
  signed int v12; // eax@1
  signed int result; // eax@4
  char *v15; // ST60_4@9
  int v17; // edx@1
  double *v18; // ST60_4@1
  __int64 *v19; // ST5C_4@1
  __int64 v20; // ST54_8@1
  double *v21; // ST60_4@1
  __int64 *v22; // ST5C_4@1
  __int64 v23; // ST54_8@1
  int *v24; // ST60_4@5
  __int64 v25; // ST58_8@5
  int *v26; // ST60_4@5
  __int64 v27; // ST58_8@5
  int *v28; // ST60_4@5
  __int64 v29; // ST58_8@5
  __int64 v30; // ST5C_8@6
  int *v31; // ST60_4@7
  __int64 v32; // ST58_8@7
  __int64 v34; // ST5C_8@13
  __int64 v35; // ST54_8@13
  __int64 v36; // ST4C_8@13
  __int64 v37; // ST5C_8@13
  __int64 v38; // ST54_8@13
  __int64 v39; // ST4C_8@13
  __int64 v41; // ST5C_8@13
  __int64 v42; // ST54_8@13
  __int64 v43; // ST4C_8@13
  __int64 v44; // ST5C_8@13
  __int64 v45; // ST54_8@13
  __int64 v46; // ST4C_8@13
  __int64 v48; // ST5C_8@13
  __int64 v49; // ST54_8@13
  __int64 v50; // ST4C_8@13
  __int64 v52; // ST5C_8@13
  __int64 v53; // ST54_8@13
  __int64 v54; // ST4C_8@13
  __int64 v55; // ST5C_8@13
  __int64 v56; // ST54_8@13
  __int64 v57; // ST4C_8@13
  __int64 v58; // ST44_8@13
  __int64 v59; // ST3C_8@13
  __int64 v60; // ST34_8@13
  __int64 v61; // ST2C_8@13
  __int64 v62; // ST24_8@13
  __int64 v63; // ST1C_8@13
  __int64 v64; // ST14_8@13
  __int64 v65; // ST0C_8@13
  __int64 v66; // ST04_8@13
  char v67; // zf@15
  int *v68; // ST60_4@16
  __int64 v69; // ST58_8@16
  signed int *v70; // ST60_4@17
  __int64 v71; // ST58_8@17
  char *v72; // ST60_4@17
  __int64 v73; // ST58_8@17
  int v74; // ST58_4@21
  int v75; // ST5C_4@21
  int v76; // ST60_4@21
  __int64 v77; // ST5C_8@22
  __int64 v78; // ST54_8@22
  __int64 v79; // ST4C_8@22
  __int64 v80; // ST5C_8@22
  __int64 v81; // ST54_8@22
  __int64 v82; // ST4C_8@22
  int *v83; // ST60_4@25
  __int64 v84; // ST58_8@25
  int v85; // edi@25
  int *v86; // ST60_4@25
  __int64 v87; // ST58_8@25
  int *v88; // ST60_4@25
  __int64 v89; // ST58_8@25
  __int64 v90; // ST5C_8@31
  __int64 v93; // ST5C_8@34
  int v103; // esi@53
  int v106; // eax@57
  int v107; // edx@57
  int v108; // ecx@57
  int v109; // eax@57
  int v110; // edx@57
  __int64 v111; // ST5C_8@57
  __int64 v112; // ST5C_8@57
  __int64 v113; // ST5C_8@58
  __int64 v114; // ST54_8@58
  __int64 v115; // ST4C_8@58
  __int64 v116; // ST44_8@58
  __int64 v117; // ST3C_8@58
  __int64 v118; // ST34_8@58
  int v122; // ecx@61
  int v123; // edx@61
  int v124; // ecx@61
  int v125; // edx@61
  int v126; // eax@61
  int v127; // edx@61
  int v128; // ecx@61
  int v129; // edx@61
  int v130; // ecx@61
  int v131; // edx@61
  __int64 v132; // ST5C_8@62
  __int64 v133; // ST54_8@62
  __int64 v134; // ST5C_8@62
  __int64 v135; // ST54_8@62
  signed int v136; // [sp+268h] [bp-10h]@1
  __int64 v137; // [sp+224h] [bp-54h]@1
  __int64 v138; // [sp+244h] [bp-34h]@1
  __int64 v139; // [sp+20Ch] [bp-6Ch]@1
  __int64 v140; // [sp+26Ch] [bp-Ch]@1
  int v141; // [sp+274h] [bp-4h]@5
  char v142; // [sp+194h] [bp-E4h]@6
  char v143; // [sp+1DCh] [bp-9Ch]@7
  char v144; // [sp+A4h] [bp-1D4h]@16
  char v145; // [sp+7Ch] [bp-1FCh]@16
  int v146; // [sp+1C4h] [bp-B4h]@16
  __int64 v147; // [sp+23Ch] [bp-3Ch]@17
  __int64 v148; // [sp+134h] [bp-144h]@38
  __int64 v149; // [sp+164h] [bp-114h]@38
  char v164; // [sp+11Ch] [bp-15Ch]@38
  char v165; // [sp+1F4h] [bp-84h]@38
  __int64 v166; // [sp+25Ch] [bp-1Ch]@38
  char v167; // [sp+264h] [bp-14h]@38
  int v170; // [sp+BCh] [bp-1BCh]@57
  int v171; // [sp+C4h] [bp-1B4h]@57
  int v172; // [sp+C0h] [bp-1B8h]@57
  int v173; // [sp+C8h] [bp-1B0h]@57
  int v174; // [sp+D0h] [bp-1A8h]@57
  int v175; // [sp+CCh] [bp-1ACh]@57
  char v176; // [sp+D4h] [bp-1A4h]@57
  char v180; // [sp+ECh] [bp-18Ch]@57
  int v181; // [sp+1ACh] [bp-CCh]@61
  int v182; // [sp+1B0h] [bp-C8h]@61
  int v183; // [sp+1B4h] [bp-C4h]@61
  int v184; // [sp+1B8h] [bp-C0h]@61
  int v185; // [sp+1BCh] [bp-BCh]@61
  int v186; // [sp+1C0h] [bp-B8h]@61
  int v187; // [sp+1C8h] [bp-B0h]@61
  int v188; // [sp+1CCh] [bp-ACh]@61
  int v189; // [sp+1D0h] [bp-A8h]@61
  int v190; // [sp+1D4h] [bp-A4h]@61
  int v191; // [sp+1D8h] [bp-A0h]@61
  char v192; // [sp+6Ch] [bp-20Ch]@61
  char v193; // [sp+94h] [bp-1E4h]@61

  _EBX = a3;
  dword_1000C540 = *(_DWORD *)a3;
  dword_1000C544 = *(_DWORD *)(a3 + 4);
  dword_1000C548 = *(_DWORD *)(a3 + 8);
  dword_1000C54C = *(_DWORD *)(a3 + 12);
  dword_1000C550 = *(_DWORD *)(a3 + 16);
  dword_1000C554 = *(_DWORD *)(a3 + 20);
  dword_1000C2C8 = *(_DWORD *)a5;
  dword_1000C2CC = *(_DWORD *)(a5 + 4);
  dword_1000C2D0 = *(_DWORD *)(a5 + 8);
  dword_1000C2D4 = *(_DWORD *)(a5 + 12);
  dword_1000C2D8 = *(_DWORD *)(a5 + 16);
  v17 = *(_DWORD *)(a5 + 20);
  v136 = 0;
  dword_1000C2DC = v17;
  UF_VEC3_copy(a4, &v137);
  UF_VEC3_copy(a6, &v138);
  UF_VEC3_copy(a8, &v139);
  __asm
  {
    fldz
    fst     dbl_1000C558
    fst     dbl_1000C560
    fst     dbl_1000C568
    fst     dbl_1000C570
  }
  memcpy(&unk_1000C340, (const void *)a9, 0x98u);
  __asm
  {
    fst     dbl_1000C578
    fst     dbl_1000C580
    fld     dbl_1000C348
    fst     dbl_1000C000
    fxch    st(1)
  }
  memcpy(&dbl_1000C470, (const void *)a2, 0x60u);
  __asm
  {
    fst     dbl_1000C538
    fst     dbl_1000C530
    fst     dbl_1000C2E8
    fst     dbl_1000C2E0
    fst     dbl_1000C468
    fst     dbl_1000C460
    fst     dbl_1000C320
    fstp    dbl_1000C318
  }
  v18 = &dbl_1000C2F0;
  v19 = &v140;
  byte_1000C588 = 0;
  dword_1000C3D8 = (int)&unk_1000C340;
  __asm { fstp    [esp+228h+var_228] }
  UF_VEC3_unitize(a4, v20, *((_DWORD *)&v20 + 1), v19, v18);
  __asm { fld     dbl_1000C000 }
  v21 = &dbl_1000C328;
  v22 = &v140;
  __asm { fstp    [esp+228h+var_228] }
  UF_VEC3_unitize(a6, v23, *((_DWORD *)&v23 + 1), v22, v21);
  dword_1000C4E0 = 0;
  dword_1000C4E4 = 0;
  dword_1000C4E8 = 0;
  dword_1000C4EC = 0;
  dword_1000C4F0 = 0;
  dword_1000C4F4 = 0;
  dword_1000C4F8 = 0;
  dword_1000C4FC = 0;
  dword_1000C500 = 0;
  dword_1000C504 = 0;
  dword_1000C508 = 0;
  dword_1000C50C = 0;
  dword_1000C510 = 0;
  dword_1000C514 = 0;
  dword_1000C518 = 0;
  dword_1000C51C = 0;
  dword_1000C520 = 0;
  dword_1000C524 = 0;
  dword_1000C528 = 0;
  dword_1000C52C = 0;
  v12 = *(_DWORD *)dword_1000C3D8;
  byte_1000C009 = 1;
  byte_1000C00A = 1;
  if ( v12 != 1 && v12 != 2 && v12 != 3 )
    return 2;
  __asm { fld     dbl_1000C000 }
  v24 = &v141;
  __asm { fstp    [esp+224h+var_228+4] }
  UF_VEC3_is_parallel(&v137, &v138, v25, *((_DWORD *)&v25 + 1), v24);
  __asm { fld     dbl_1000C000 }
  v26 = &v141;
  BYTE3(a2) = v141 != 0;
  __asm { fstp    [esp+224h+var_228+4] }
  UF_VEC3_is_parallel(&v137, &v139, v27, *((_DWORD *)&v27 + 1), v26);
  __asm { fld     dbl_1000C000 }
  v28 = &v141;
  BYTE3(a9) = v141 != 0;
  __asm { fstp    [esp+224h+var_228+4] }
  UF_VEC3_is_parallel(&v138, &v139, v29, *((_DWORD *)&v29 + 1), v28);
  BYTE3(a3) = v141 != 0;
  if ( !BYTE3(a9) )
  {
    __asm
    {
      fld     [ebp+var_C]
      fstp    [esp+220h+var_220]
    }
    sub_10001F60((int)&v139, (int)&v137, (int)&v142, v30);
  }
  UF_VEC3_cross(&v137, &v138, &v143);
  __asm { fld     dbl_1000C000 }
  v31 = &v141;
  __asm { fstp    [esp+224h+var_228+4] }
  UF_VEC3_is_parallel(&v143, &v139, v32, *((_DWORD *)&v32 + 1), v31);
  byte_1000C008 = v141 != 0;
  if ( byte_1000C588 )
  {
    printf("\n\n======================================================================\n");
    printf("Is_orthogonal_case = %d, ", (unsigned __int8)byte_1000C008);
    if ( *(_DWORD *)dword_1000C3D8 == 2 )
    {
      v15 = "is_5_axis_dual_table\n";
    }
    else
    {
      if ( *(_DWORD *)dword_1000C3D8 == 1 )
        v15 = "is_5_axis_dual_head\n";
      else
        v15 = "is_5_axis_head_table\n";
    }
    printf(v15);
    _EAX = a4;
    __asm
    {
      fld     qword ptr [eax+10h]
      fstp    [esp+230h+var_220]
      fld     qword ptr [eax+8]
      fstp    [esp+230h+var_228]
      fld     qword ptr [eax]
      fstp    [esp+230h+var_230]
    }
    printf("primary=(%f,%f,%f)\n", v36, *((_DWORD *)&v36 + 1), v35, v34);
    __asm
    {
      fld     qword ptr [ebx+10h]
      fstp    [esp+230h+var_220]
      fld     qword ptr [ebx+8]
      fstp    [esp+230h+var_228]
      fld     qword ptr [ebx]
      fstp    [esp+230h+var_230]
    }
    printf("primary_machine_center=(%f,%f,%f)\n", v39, *((_DWORD *)&v39 + 1), v38, v37);
    _EAX = a6;
    __asm
    {
      fld     qword ptr [eax+10h]
      fstp    [esp+230h+var_220]
      fld     qword ptr [eax+8]
      fstp    [esp+230h+var_228]
      fld     qword ptr [eax]
      fstp    [esp+230h+var_230]
    }
    printf("secondary=(%f,%f,%f)\n", v43, *((_DWORD *)&v43 + 1), v42, v41);
    _ESI = a5;
    __asm
    {
      fld     qword ptr [esi+10h]
      fstp    [esp+230h+var_220]
      fld     qword ptr [esi+8]
      fstp    [esp+230h+var_228]
      fld     qword ptr [esi]
      fstp    [esp+230h+var_230]
    }
    printf("secondary_machine_center=(%f,%f,%f)\n", v46, *((_DWORD *)&v46 + 1), v45, v44);
    _EAX = a7;
    __asm
    {
      fld     qword ptr [eax+10h]
      fstp    [esp+230h+var_220]
      fld     qword ptr [eax+8]
      fstp    [esp+230h+var_228]
      fld     qword ptr [eax]
      fstp    [esp+230h+var_230]
    }
    printf("tool_machine_center=(%f,%f,%f)\n", v50, *((_DWORD *)&v50 + 1), v49, v48);
    _EAX = a8;
    __asm
    {
      fld     qword ptr [eax+10h]
      fstp    [esp+230h+var_220]
      fld     qword ptr [eax+8]
      fstp    [esp+230h+var_228]
      fld     qword ptr [eax]
      fstp    [esp+230h+var_230]
    }
    printf("tool_vector=(%f,%f,%f)\n", v54, *((_DWORD *)&v54 + 1), v53, v52);
    __asm
    {
      fld     dbl_1000C4C8
      fstp    [esp+278h+var_220]
      fld     dbl_1000C4C0
      fstp    [esp+278h+var_228]
      fld     dbl_1000C4B8
      fstp    [esp+278h+var_230]
      fld     dbl_1000C4B0
      fstp    [esp+278h+var_238]
      fld     dbl_1000C4A8
      fstp    [esp+278h+var_240]
      fld     dbl_1000C4A0
      fstp    [esp+278h+var_248]
      fld     dbl_1000C498
      fstp    [esp+278h+var_250]
      fld     dbl_1000C490
      fstp    [esp+278h+var_258]
      fld     dbl_1000C488
      fstp    [esp+278h+var_260]
      fld     dbl_1000C480
      fstp    [esp+278h+var_268]
      fld     dbl_1000C478
      fstp    [esp+278h+var_270]
      fld     dbl_1000C470
      fstp    [esp+278h+var_278]
    }
    printf(
      "Mcsys= (%f,%f,%f) (%f,%f,%f) (%f,%f,%f)  (%f,%f,%f)\n",
      v66,
      *((_DWORD *)&v66 + 1),
      v65,
      v64,
      v63,
      v62,
      v61,
      v60,
      v59,
      v58,
      v57,
      v56,
      v55);
  }
  else
  {
    _ESI = a5;
  }
  v67 = *(_DWORD *)dword_1000C3D8 == 3;
  dword_1000C3DC = -1;
  if ( !v67 )
    goto LABEL_23;
  UF_MTX3_x_vec(&unk_100098E0, &v144);
  UF_MTX3_y_vec(&unk_100098E0, &v145);
  UF_MTX3_z_vec(&unk_100098E0, &v146);
  __asm { fld     dbl_1000C000 }
  v68 = &a9;
  __asm { fstp    [esp+224h+var_228+4] }
  UF_VEC3_is_equal(a8, &v146, v69, *((_DWORD *)&v69 + 1), v68);
  __asm { fld     dbl_1000C000 }
  if ( !a9 )
  {
    v70 = &v136;
    __asm { fstp    [esp+224h+var_228+4] }
    UF_VEC3_is_equal(a8, &v145, v71, *((_DWORD *)&v71 + 1), v70);
    __asm { fld     dbl_1000C000 }
    v72 = (char *)&v147 + 4;
    __asm { fstp    [esp+224h+var_228+4] }
    UF_VEC3_is_equal(&v137, &v146, v73, *((_DWORD *)&v73 + 1), v72);
    if ( byte_1000C008 || !BYTE3(a3) || !v136 || !*((_DWORD *)&v147 + 1) )
      return 2;
    dword_1000C3DC = 3;
    UF_MTX3_vec_multiply_t(&dbl_1000C2F0, &unk_10009970, &dbl_1000C2F0, ST64_4_0, ST68_4_0, ST6C_4_0);
    UF_MTX3_vec_multiply_t(&dbl_1000C328, &unk_10009970, &dbl_1000C328, v74, v75, v76);
    if ( byte_1000C588 )
    {
      printf("Sulzer case:\n");
      __asm
      {
        fld     dbl_1000C300
        fstp    [esp+230h+var_220]
        fld     dbl_1000C2F8
        fstp    [esp+230h+var_228]
        fld     dbl_1000C2F0
        fstp    [esp+230h+var_230]
      }
      printf("local PrimaryAxis=(%f,%f,%f)\n", v79, *((_DWORD *)&v79 + 1), v78, v77);
      __asm
      {
        fld     dbl_1000C338
        fstp    [esp+230h+var_220]
        fld     dbl_1000C330
        fstp    [esp+230h+var_228]
        fld     dbl_1000C328
        fstp    [esp+230h+var_230]
      }
      printf("local SecondaryAxis=(%f,%f,%f)\n", v82, *((_DWORD *)&v82 + 1), v81, v80);
    }
LABEL_23:
    if ( BYTE3(a2) )
    {
      __asm { fldz }
    }
    else
    {
      __asm
      {
        fld     [ebp+var_C]
        fstp    [esp+220h+var_220]
      }
      sub_10001F60((int)&v138, (int)&v137, (int)&v142, v90);
      sub_100023D0((int)&v142, (int)&v138, (int)&v137);
      _ESI = a5;
    }
    __asm { fst     dbl_1000C578 }
    if ( BYTE3(a3) )
    {
      __asm { fstp    st }
      printf("WARNING: Tool axis is parallelled with secondary axis that may cause unresolved rotaries");
      __asm
      {
        fldz
        fstp    dbl_1000C580
        fld     [ebp+var_54]
        fld     ds:dbl_10009C58
        fmul    st(1), st
        fld     qword ptr [ebx]
        fadd    st, st(2)
        fld     qword ptr [ebx]
        fsubrp  st(3), st
        fld     [ebp+var_34]
        fmul    st, st(2)
        fld     qword ptr [esi]
        fadd    st, st(1)
        fld     qword ptr [esi]
        fsubrp  st(2), st
        fxch    st(2)
        fstp    [ebp+var_144]
        fxch    st(1)
        fstp    [ebp+var_114]
        fxch    st(2)
        fstp    [ebp+var_12C]
        fxch    st(1)
        fstp    [ebp+var_FC]
        fld     [ebp+var_4C]
        fmul    st, st(1)
        fld     qword ptr [ebx+8]
        fadd    st, st(1)
        fld     qword ptr [ebx+8]
        fsubrp  st(2), st
        fld     [ebp+var_2C]
        fmul    st, st(3)
        fld     qword ptr [esi+8]
        fadd    st, st(1)
        fld     qword ptr [esi+8]
        fsubrp  st(2), st
        fxch    st(2)
        fstp    [ebp+var_13C]
        fxch    st(1)
        fstp    [ebp+var_10C]
        fxch    st(1)
        fstp    [ebp+var_124]
        fstp    [ebp+var_F4]
        fld     [ebp+var_44]
        fmul    st, st(1)
        fld     qword ptr [ebx+10h]
        fadd    st, st(1)
        fld     qword ptr [ebx+10h]
        fsubrp  st(2), st
        fld     [ebp+var_24]
        fmulp   st(3), st
        fld     qword ptr [esi+10h]
        fadd    st, st(3)
        fld     qword ptr [esi+10h]
        fsubrp  st(4), st
        fxch    st(1)
        fstp    [ebp+var_134]
        fstp    [ebp+var_104]
        fstp    [ebp+var_11C]
        fstp    [ebp+var_EC]
      }
      if ( sub_10003E70((int)&v148, (int)&v149, (int)&v164, (int)&v165, (int)&v166, (int)&v167) )
        goto LABEL_66;
      UF_VEC3_distance(&v164, &v165, &dbl_1000C558);
      __asm
      {
        fld     dbl_1000C000
        fcomp   dbl_1000C558
        fnstsw  ax
        jp      short loc_100049C3
      }
      UF_VEC3_sub(&v165, &v164, &v143);
      UF_VEC3_dot(&v143, &v142, &v147);
      __asm
      {
        fldz
        fcomp   [ebp+var_3C]
        fnstsw  ax
      }
      if ( !(HIBYTE(_AX) & 0x41) )
      {
        __asm
        {
          fld     dbl_1000C558
          fchs
          fstp    dbl_1000C558
        }
      }
      UF_VEC3_distance(&v165, _EBX, &dbl_1000C560);
      __asm
      {
        fld     dbl_1000C000
        fcomp   dbl_1000C560
        fnstsw  ax
        jp      short loc_10004A37
      }
      UF_VEC3_sub(&v165, _EBX, &v143);
      UF_VEC3_dot(&v143, &v137, &v147);
      __asm
      {
        fldz
        fcomp   [ebp+var_3C]
        fnstsw  ax
      }
      if ( !(HIBYTE(_AX) & 0x41) )
      {
        __asm
        {
          fld     dbl_1000C560
          fchs
          fstp    dbl_1000C560
        }
      }
      __asm { fld     [ebp+var_34] }
      _EAX = a7;
      __asm
      {
        fld     ds:dbl_10009C58
        fmul    st(1), st
        fld     qword ptr [esi]
        fadd    st, st(2)
        fld     qword ptr [esi]
        fsubrp  st(3), st
        fld     [ebp+var_6C]
        fmul    st, st(2)
        fld     qword ptr [eax]
        fadd    st, st(1)
        fld     qword ptr [eax]
        fsubrp  st(2), st
        fxch    st(2)
        fstp    [ebp+var_144]
        fxch    st(1)
        fstp    [ebp+var_114]
        fxch    st(2)
        fstp    [ebp+var_12C]
        fxch    st(1)
        fstp    [ebp+var_FC]
        fld     [ebp+var_2C]
        fmul    st, st(1)
        fld     qword ptr [esi+8]
        fadd    st, st(1)
        fld     qword ptr [esi+8]
        fsubrp  st(2), st
        fld     [ebp+var_64]
        fmul    st, st(3)
        fld     qword ptr [eax+8]
        fadd    st, st(1)
        fld     qword ptr [eax+8]
        fsubrp  st(2), st
        fxch    st(2)
        fstp    [ebp+var_13C]
        fxch    st(1)
        fstp    [ebp+var_10C]
        fxch    st(1)
        fstp    [ebp+var_124]
        fstp    [ebp+var_F4]
        fld     [ebp+var_24]
        fmul    st, st(1)
        fld     qword ptr [esi+10h]
        fadd    st, st(1)
        fld     qword ptr [esi+10h]
        fsubrp  st(2), st
        fld     [ebp+var_5C]
        fmulp   st(3), st
        fld     qword ptr [eax+10h]
        fadd    st, st(3)
        fld     qword ptr [eax+10h]
        fsubrp  st(4), st
        fxch    st(1)
        fstp    [ebp+var_134]
        fstp    [ebp+var_104]
        fstp    [ebp+var_11C]
        fstp    [ebp+var_EC]
      }
      if ( sub_10003E70((int)&v148, (int)&v149, (int)&v164, (int)&v165, (int)&v166, (int)&v167) )
      {
LABEL_66:
        result = 5;
      }
      else
      {
        UF_VEC3_distance(&v164, &v165, &dbl_1000C568);
        __asm
        {
          fld     dbl_1000C000
          fcomp   dbl_1000C568
          fnstsw  ax
          jp      short loc_10004BA5
        }
        UF_VEC3_sub(&v165, &v164, &v143);
        UF_VEC3_dot(&v143, &v142, &v166);
        __asm
        {
          fldz
          fcomp   [ebp+var_1C]
          fnstsw  ax
        }
        if ( !(HIBYTE(_AX) & 0x41) )
        {
          __asm
          {
            fld     dbl_1000C568
            fchs
            fstp    dbl_1000C568
          }
        }
        v103 = a7;
        UF_VEC3_distance(&v165, a7, &dbl_1000C570);
        __asm
        {
          fld     dbl_1000C000
          fcomp   dbl_1000C570
          fnstsw  ax
          jp      short loc_10004C1C
        }
        UF_VEC3_sub(&v165, v103, &v143);
        UF_VEC3_dot(&v143, &v138, &v166);
        __asm
        {
          fldz
          fcomp   [ebp+var_1C]
          fnstsw  ax
        }
        if ( !(HIBYTE(_AX) & 0x41) )
        {
          __asm
          {
            fld     dbl_1000C570
            fchs
            fstp    dbl_1000C570
          }
        }
        __asm { fld     [ebp+var_C] }
        v106 = *(_DWORD *)(_EBX + 8);
        v107 = *(_DWORD *)(_EBX + 4);
        v170 = *(_DWORD *)_EBX;
        v108 = *(_DWORD *)(_EBX + 12);
        v171 = v106;
        v109 = *(_DWORD *)(_EBX + 20);
        v172 = v107;
        v110 = *(_DWORD *)(_EBX + 16);
        v173 = v108;
        v174 = v109;
        __asm { fstp    [esp+220h+var_220] }
        v175 = v110;
        sub_10001F60((int)&v138, (int)&v137, (int)&v176, v111);
        __asm
        {
          fld     [ebp+var_54]
          fstp    [ebp+var_174]
          fld     [ebp+var_4C]
          fstp    [ebp+var_16C]
          fld     [ebp+var_44]
          fstp    [ebp+var_164]
          fld     [ebp+var_C]
          fstp    [esp+220h+var_220]
        }
        sub_10001F60((int)&v176, (int)&v137, (int)&v180, v112);
        sub_100020C0((int)&v170, a1, (int)&unk_1000C3E0);
        sub_10002DC0((int)&dbl_1000C248);
        __asm
        {
          fld     dbl_1000C578
          fld     st
          fsin
          fstp    dbl_1000C310
          fld     dbl_1000C580
          fld     st
          fsin
          fstp    dbl_1000C4D0
          fld     st(1)
          fcos
          fstp    dbl_1000C4D8
          fld     st
          fcos
          fstp    dbl_1000C308
          fld     ds:dbl_100099D8
        }
        if ( byte_1000C588 )
        {
          __asm
          {
            fmul    st(1), st
            fxch    st(1)
            fstp    [esp+248h+var_220]
            fld     dbl_1000C570
            fstp    [esp+248h+var_228]
            fld     dbl_1000C568
            fstp    [esp+248h+var_230]
            fmulp   st(1), st
            fstp    [esp+248h+var_238]
            fld     dbl_1000C560
            fstp    [esp+248h+var_240]
            fld     dbl_1000C558
            fstp    [esp+248h+var_248]
          }
          printf(
            "A1=%f,D1=%f,Alpha1=%f,A2=%f,D2=%f,Alpha2=%f\n",
            v118,
            *((_DWORD *)&v118 + 1),
            v117,
            v116,
            v115,
            v114,
            v113);
        }
        else
        {
          __asm
          {
            fstp    st
            fstp    st(1)
            fstp    st
          }
        }
        if ( *(_DWORD *)dword_1000C3D8 == 2 )
        {
          v122 = *(_DWORD *)(a7 + 4);
          v181 = *(_DWORD *)a7;
          v123 = *(_DWORD *)(a7 + 8);
          v182 = v122;
          v124 = *(_DWORD *)(a7 + 12);
          v183 = v123;
          v125 = *(_DWORD *)(a7 + 16);
          v126 = *(_DWORD *)(a7 + 20);
          v184 = v124;
          v185 = v125;
          v186 = v126;
          v127 = *(_DWORD *)(a8 + 4);
          v146 = *(_DWORD *)a8;
          v128 = *(_DWORD *)(a8 + 8);
          v187 = v127;
          v129 = *(_DWORD *)(a8 + 12);
          v188 = v128;
          v130 = *(_DWORD *)(a8 + 16);
          v189 = v129;
          v131 = *(_DWORD *)(a8 + 20);
          v190 = v130;
          v191 = v131;
          sub_10003100(_EBX, (int)printf, (int)&v180, &v181, (int)&v192, (int)&v193);
          if ( byte_1000C588 )
          {
            __asm
            {
              fld     dbl_1000C2E0
              fld     ds:dbl_100099D8
              fmul    st(1), st
              fxch    st(1)
              fstp    [esp+228h+var_220]
              fmul    dbl_1000C530
              fstp    [esp+228h+var_228]
            }
            printf("Init_T1[0], Init_T2[0] = (%f,%f)\n", v133, *((_DWORD *)&v133 + 1), v132);
            __asm
            {
              fld     dbl_1000C2E8
              fld     ds:dbl_100099D8
              fmul    st(1), st
              fxch    st(1)
              fstp    [esp+228h+var_220]
              fmul    dbl_1000C538
              fstp    [esp+228h+var_228]
            }
            printf("Init_T1[1], Init_T2[1] = (%f,%f)\n", v135, *((_DWORD *)&v135 + 1), v134);
          }
        }
        result = 0;
        byte_1000C009 = 0;
      }
    }
    else
    {
      __asm
      {
        fabs
        fcomp   dbl_1000C000
        fnstsw  ax
        jp      short loc_10004804
        fld     [ebp+var_C]
        fstp    [esp+220h+var_220]
      }
      sub_10001F60((int)&v139, (int)&v138, (int)&v142, v93);
      __asm
      {
        fld     [ebp+var_C]
        fabs
        fcomp   dbl_1000C000
        fnstsw  ax
        jp      short loc_10004801
      }
      result = 3;
    }
    return result;
  }
  v83 = &a5;
  __asm { fstp    [esp+224h+var_228+4] }
  UF_VEC3_is_equal(a4, &v144, v84, *((_DWORD *)&v84 + 1), v83);
  __asm { fld     dbl_1000C000 }
  v85 = a6;
  v86 = &a3;
  __asm { fstp    [esp+224h+var_228+4] }
  UF_VEC3_is_equal(a6, &v145, v87, *((_DWORD *)&v87 + 1), v86);
  __asm { fld     dbl_1000C000 }
  v88 = &a2;
  __asm { fstp    [esp+224h+var_228+4] }
  UF_VEC3_is_equal(v85, &v146, v89, *((_DWORD *)&v89 + 1), v88);
  if ( a5 && a3 )
  {
    result = v136;
    dword_1000C3DC = 0;
    byte_1000C009 = 0;
  }
  else
  {
    if ( a2 )
    {
      result = v136;
      dword_1000C3DC = 1;
      byte_1000C009 = 0;
    }
    else
    {
      result = 2;
      byte_1000C009 = 0;
    }
  }
  return result;
}

//----- (10004E60) --------------------------------------------------------
int __cdecl sub_10004E60(int a1, int a2, int a3)
{
  signed int v5; // esi@3
  __int64 *v9; // ST38_4@2
  __int64 *v10; // ST34_4@2
  __int64 v11; // ST2C_8@2
  char v14; // zf@8
  __int64 v15; // ST34_8@9
  __int64 v16; // ST2C_8@9
  __int64 v17; // ST24_8@9
  __int64 v18; // ST1C_8@9
  __int64 v19; // ST14_8@9
  __int64 v20; // ST34_8@9
  __int64 v21; // ST2C_8@9
  __int64 v22; // ST24_8@9
  __int64 v23; // ST1C_8@9
  __int64 v24; // ST14_8@9
  char v25; // [sp+34h] [bp-98h]@1
  _BYTE v26[40]; // [sp+64h] [bp-68h]@1
  _BYTE v27[40]; // [sp+8Ch] [bp-40h]@1
  __int64 v28; // [sp+B4h] [bp-18h]@2

  _EBX = a1;
  memcpy(&v25, (const void *)a1, 0x30u);
  UF_VEC3_add(&v25, dword_1000C3D8 + 16, &v25);
  UF_VEC3_sub(&v25, dword_1000C3D8 + 40, &v25);
  a1 = sub_10003100(_EBX, (int)v26, (int)UF_VEC3_add, &v25, (int)v27, (int)v26);
  UF_VEC3_add(v27, dword_1000C3D8 + 64, v27);
  UF_VEC3_add(v26, dword_1000C3D8 + 64, v26);
  _EAX = dword_1000C3D8;
  if ( *(_BYTE *)(dword_1000C3D8 + 88) )
  {
    __asm
    {
      fld     qword ptr [ebx+18h]
      fstp    [ebp+var_18]
    }
    v9 = &v28;
    __asm
    {
      fld     qword ptr [ebx+20h]
      fstp    [ebp+var_10]
    }
    v10 = &v28;
    __asm
    {
      fld     qword ptr [ebx+28h]
      fstp    [ebp+var_8]
      fld     qword ptr [eax+60h]
      fstp    [esp+0B4h+var_B4]
    }
    UF_VEC3_scale(v11, *((_DWORD *)&v11 + 1), v10, v9);
    UF_VEC3_add(v27, &v28, v27);
    UF_VEC3_add(v26, &v28, v26);
  }
  v5 = 0;
  do
  {
    _EDI = &v27[v5];
    sub_10005050((int)&v27[v5], dword_1000C3D8 + 8);
    __asm { fstp    qword ptr [edi] }
    _EDI = &v26[v5];
    sub_10005050((int)&v26[v5], dword_1000C3D8 + 8);
    __asm { fstp    qword ptr [edi] }
    v5 += 8;
  }
  while ( v5 <= 16 );
  if ( byte_1000C00A )
    byte_1000C00A = 0;
  else
    sub_100025B0((int)v27, v26);
  v14 = byte_1000C588 == 0;
  _EAX = (const void *)a2;
  _EBX = (void *)a3;
  memcpy((void *)a2, v27, 0x28u);
  memcpy(_EBX, v26, 0x28u);
  memcpy(&unk_1000C5B8, _EAX, 0x28u);
  memcpy(&unk_1000C590, _EBX, 0x28u);
  if ( !v14 )
  {
    __asm
    {
      fld     qword ptr [eax+20h]
      fstp    [esp+0CCh+var_AC]
      fld     qword ptr [eax+18h]
      fstp    [esp+0CCh+var_B4]
      fld     qword ptr [eax+10h]
      fstp    [esp+0CCh+var_BC]
      fld     qword ptr [eax+8]
      fstp    [esp+0CCh+var_C4]
      fld     qword ptr [eax]
      fstp    [esp+0CCh+var_CC]
    }
    printf("final ufunc mcoord[] = (%f,%f,%f), (%f,%f)\n", v19, *((_DWORD *)&v19 + 1), v18, v17, v16, v15);
    __asm
    {
      fld     qword ptr [ebx+20h]
      fstp    [esp+0D0h+var_AC]
      fld     qword ptr [ebx+18h]
      fstp    [esp+0CCh+var_B4]
      fld     qword ptr [ebx+10h]
      fstp    [esp+0CCh+var_BC]
      fld     qword ptr [ebx+8]
      fstp    [esp+0CCh+var_C4]
      fld     qword ptr [ebx]
      fstp    [esp+0CCh+var_CC]
    }
    printf("final ufunc alt_mcoord[] = (%f,%f,%f), (%f,%f)\n", v24, *((_DWORD *)&v24 + 1), v23, v22, v21, v20);
  }
  return a1;
}

//----- (10005050) --------------------------------------------------------
__int16 __cdecl sub_10005050(int a1, int a2)
{
  __int16 result; // ax@1

  _ECX = a2;
  __asm
  {
    fld     qword ptr [ecx]
    fabs
    fabs
    fcomp   ds:dbl_100099B8
    fnstsw  ax
    jp      short loc_10005072
    fldz
  }
  return result;
}

//----- (100050E0) --------------------------------------------------------
signed int __usercall sub_100050E0<eax>(int a1<eax>)
{
  signed int result; // eax@10
  char *v14; // ST1C_4@8
  char *v16; // ST18_4@8
  __int64 v17; // ST10_8@8
  char *v18; // ST1C_4@9
  char *v19; // ST18_4@9
  __int64 v20; // ST10_8@9
  char v21; // [sp+94h] [bp-20h]@1
  char v22; // [sp+7Ch] [bp-38h]@1
  char v23; // [sp+64h] [bp-50h]@1
  char v24; // [sp+1Ch] [bp-98h]@1
  char v25; // [sp+ACh] [bp-8h]@8

  _ESI = a1;
  UF_VEC3_copy(a1, &v21);
  UF_VEC3_copy(_ESI + 24, &v22);
  UF_VEC3_copy(_ESI + 48, &v23);
  UF_MTX3_copy(_ESI, &v24);
  __asm
  {
    fld     ds:dbl_100099B8
    fldz
    fld1
  }
  _ECX = 0;
  __asm { fld     ds:dbl_100099C8 }
  while ( 1 )
  {
    __asm
    {
      fld     qword ptr [esi+ecx*8]
      fabs
      fcom    st(4)
      fnstsw  ax
      jp      short loc_10005152
      fstp    st
      fxch    st(2)
      fst     qword ptr [esi+ecx*8]
    }
    ++_ECX;
    if ( _ECX >= 9 )
      break;
    __asm { fxch    st(2) }
  }
  __asm
  {
    fstp    st(1)
    fstp    st
  }
  v14 = &v21;
  __asm { fstp    st }
  v16 = &v25;
  __asm { fstp    [esp+0B4h+var_B4] }
  if ( !UF_VEC3_unitize(&v21, v17, *((_DWORD *)&v17 + 1), v16, v14) )
    goto LABEL_14;
  __asm { fld     ds:dbl_100099B8 }
  v18 = &v22;
  v19 = &v25;
  __asm { fstp    [esp+0B4h+var_B4] }
  if ( UF_VEC3_unitize(&v22, v20, *((_DWORD *)&v20 + 1), v19, v18) )
  {
    UF_VEC3_cross(&v21, &v22, &v23);
    UF_VEC3_cross(&v23, &v21, &v22);
    result = 1;
  }
  else
  {
LABEL_14:
    result = 0;
  }
  return result;
}

//----- (10005200) --------------------------------------------------------
signed int __cdecl sub_10005200(int a1)
{
  int v2; // esi@1
  signed int v3; // edi@1
  char v4; // [sp+8h] [bp-48h]@1

  v2 = a1;
  UF_MTX4_ask_rotation(a1, &v4);
  v3 = sub_100050E0((int)&v4);
  UF_MTX4_edit_rotation(v2, &v4);
  return v3;
}

//----- (10005240) --------------------------------------------------------
int __fastcall sub_10005240(int a1, int a2, char a3)
{
  return UF_MOM_ask_string(a2, a1, &a3);
}

//----- (10005260) --------------------------------------------------------
int __cdecl sub_10005260(int a1, int a2)
{
  int v2; // ebx@1
  char *v3; // esi@1
  char *v5; // eax@4
  int v6; // edx@6
  char *v7; // eax@9
  int v8; // edx@11
  char *v9; // eax@14
  int v10; // edx@16
  void *v11; // eax@19
  int v12; // edx@21
  char *v13; // eax@24
  char *v14; // eax@27
  char v16; // cl@7
  char v17; // cl@12
  char v18; // cl@17
  char v19; // cl@22
  char *v20; // [sp+8h] [bp-24h]@1
  char *v21; // [sp+Ch] [bp-20h]@1
  char *v22; // [sp+10h] [bp-1Ch]@1
  char *v23; // [sp+14h] [bp-18h]@1
  char *v24; // [sp+18h] [bp-14h]@1
  char *v25; // [sp+1Ch] [bp-10h]@1
  char *v26; // [sp+20h] [bp-Ch]@1
  char *v27; // [sp+28h] [bp-4h]@3
  int v28; // [sp+24h] [bp-8h]@3

  v3 = "mom_kin_nurbs_output_type";
  v20 = "mom_kin_nurbs_output_type";
  v21 = "mom_kin_output_unit";
  v22 = "mom_kin_polar_radius_side";
  v23 = "mom_kin_read_ahead_next_motion";
  v24 = "mom_kin_pivot_gauge_offset";
  v25 = "mom_kin_rapid_feed_rate";
  v26 = "END";
  v2 = 0;
  if ( strcmp("mom_kin_nurbs_output_type", "END") )
  {
    _EDI = a2;
    do
    {
      v28 = UF_MOM_ask_string(a1, v3 + 4, &v27);
      switch ( v2 )
      {
        case 0:
          v5 = v27;
          if ( !v27 )
          {
            v5 = "NONE";
            v27 = "NONE";
          }
          v6 = _EDI - (_DWORD)v5;
          do
          {
            v16 = *v5;
            v5[v6] = *v5;
            ++v5;
          }
          while ( v16 );
          break;
        case 1:
          v7 = v27;
          if ( !v27 )
          {
            v7 = "IN";
            v27 = "IN";
          }
          v8 = _EDI - (_DWORD)v7 + 133;
          do
          {
            v17 = *v7;
            v7[v8] = *v7;
            ++v7;
          }
          while ( v17 );
          break;
        case 2:
          v9 = v27;
          if ( !v27 )
          {
            v9 = "NONE";
            v27 = "NONE";
          }
          v10 = _EDI - (_DWORD)v9 + 266;
          do
          {
            v18 = *v9;
            v9[v10] = *v9;
            ++v9;
          }
          while ( v18 );
          break;
        case 3:
          v11 = v27;
          if ( !v27 )
          {
            v11 = L"F";
            v27 = (char *)L"F";
          }
          v12 = _EDI - (_DWORD)v11 + 399;
          do
          {
            v19 = *(_BYTE *)v11;
            *((_BYTE *)v11 + v12) = *(_BYTE *)v11;
            v11 = (char *)v11 + 1;
          }
          while ( v19 );
          break;
        case 4:
          v13 = v27;
          if ( !v27 )
          {
            v13 = "0.0";
            v27 = "0.0";
          }
          strtod(v13, 0);
          __asm { fstp    qword ptr [edi+218h] }
          break;
        case 5:
          v14 = v27;
          if ( !v27 )
          {
            v14 = "400.00";
            v27 = "400.00";
          }
          strtod(v14, 0);
          __asm { fstp    qword ptr [edi+220h] }
          break;
        default:
          break;
      }
      v3 = (&v21)[4 * v2++];
    }
    while ( strcmp(v3, "END") );
  }
  return v28;
}

//----- (10005430) --------------------------------------------------------
int __cdecl sub_10005430(int a1, int a2)
{
  int v2; // ebx@1
  char *v3; // esi@1
  char *v5; // eax@4
  int v6; // edx@6
  char *v7; // eax@9
  int v8; // edx@11
  char *v9; // eax@14
  char *v10; // eax@17
  char v12; // cl@7
  char v13; // cl@12
  char *v14; // [sp+8h] [bp-1Ch]@1
  char *v15; // [sp+Ch] [bp-18h]@1
  char *v16; // [sp+10h] [bp-14h]@1
  char *v17; // [sp+14h] [bp-10h]@1
  char *v18; // [sp+18h] [bp-Ch]@1
  char *v19; // [sp+20h] [bp-4h]@3
  int v20; // [sp+1Ch] [bp-8h]@3

  v3 = "mom_kin_arc_output_mode";
  v14 = "mom_kin_arc_output_mode";
  v15 = "mom_kin_arc_valid_plane";
  v16 = "mom_kin_min_arc_radius";
  v17 = "mom_kin_max_arc_radius";
  v18 = "END";
  v2 = 0;
  if ( strcmp("mom_kin_arc_output_mode", "END") )
  {
    _EDI = a2;
    do
    {
      v20 = UF_MOM_ask_string(a1, v3 + 4, &v19);
      switch ( v2 )
      {
        case 0:
          v5 = v19;
          if ( !v19 )
          {
            v5 = "FULL_CIRCLE";
            v19 = "FULL_CIRCLE";
          }
          v6 = _EDI - (_DWORD)v5;
          do
          {
            v12 = *v5;
            v5[v6] = *v5;
            ++v5;
          }
          while ( v12 );
          break;
        case 1:
          v7 = v19;
          if ( !v19 )
          {
            v7 = "XY";
            v19 = "XY";
          }
          v8 = _EDI - (_DWORD)v7 + 133;
          do
          {
            v13 = *v7;
            v7[v8] = *v7;
            ++v7;
          }
          while ( v13 );
          break;
        case 2:
          v9 = v19;
          if ( !v19 )
          {
            v9 = "0.0001";
            v19 = "0.0001";
          }
          strtod(v9, 0);
          __asm { fstp    qword ptr [edi+110h] }
          break;
        case 3:
          v10 = v19;
          if ( !v19 )
          {
            v10 = "9999.9999";
            v19 = "9999.9999";
          }
          strtod(v10, 0);
          __asm { fstp    qword ptr [edi+118h] }
          break;
        default:
          break;
      }
      v3 = (&v15)[4 * v2++];
    }
    while ( strcmp(v3, "END") );
  }
  return v20;
}

//----- (100055A0) --------------------------------------------------------
int __cdecl sub_100055A0(int a1, int a2)
{
  int v2; // ebx@1
  char *v3; // esi@1
  char *v5; // eax@4
  char *v6; // eax@7
  char *v7; // eax@10
  char *v8; // eax@13
  char *v9; // eax@16
  char *v10; // eax@19
  char *v11; // eax@22
  char *v12; // eax@25
  char *v14; // [sp+8h] [bp-2Ch]@1
  char *v15; // [sp+Ch] [bp-28h]@1
  char *v16; // [sp+10h] [bp-24h]@1
  char *v17; // [sp+14h] [bp-20h]@1
  char *v18; // [sp+18h] [bp-1Ch]@1
  char *v19; // [sp+1Ch] [bp-18h]@1
  char *v20; // [sp+20h] [bp-14h]@1
  char *v21; // [sp+24h] [bp-10h]@1
  char *v22; // [sp+28h] [bp-Ch]@1
  char *v23; // [sp+30h] [bp-4h]@3
  int v24; // [sp+2Ch] [bp-8h]@3

  v3 = "mom_kin_max_fpm";
  v14 = "mom_kin_max_fpm";
  v15 = "mom_kin_min_fpm";
  v16 = "mom_kin_max_fpr";
  v17 = "mom_kin_min_fpr";
  v18 = "mom_kin_max_frn";
  v19 = "mom_kin_min_frn";
  v20 = "mom_kin_max_dpm";
  v21 = "mom_kin_min_dpm";
  v22 = "END";
  v2 = 0;
  if ( strcmp("mom_kin_max_fpm", "END") )
  {
    _EDI = a2;
    do
    {
      v24 = UF_MOM_ask_string(a1, v3 + 4, &v23);
      switch ( v2 )
      {
        case 0:
          v5 = v23;
          if ( !v23 )
          {
            v5 = "999.999";
            v23 = "999.999";
          }
          strtod(v5, 0);
          __asm { fstp    qword ptr [edi] }
          break;
        case 1:
          v6 = v23;
          if ( !v23 )
          {
            v6 = "0.001";
            v23 = "0.001";
          }
          strtod(v6, 0);
          __asm { fstp    qword ptr [edi+20h] }
          break;
        case 2:
          v7 = v23;
          if ( !v23 )
          {
            v7 = "99.999";
            v23 = "99.999";
          }
          strtod(v7, 0);
          __asm { fstp    qword ptr [edi+8] }
          break;
        case 3:
          v8 = v23;
          if ( !v23 )
          {
            v8 = "0.001";
            v23 = "0.001";
          }
          strtod(v8, 0);
          __asm { fstp    qword ptr [edi+28h] }
          break;
        case 4:
          v9 = v23;
          if ( !v23 )
          {
            v9 = "99999.999";
            v23 = "99999.999";
          }
          strtod(v9, 0);
          __asm { fstp    qword ptr [edi+10h] }
          break;
        case 5:
          v10 = v23;
          if ( !v23 )
          {
            v10 = "0.001";
            v23 = "0.001";
          }
          strtod(v10, 0);
          __asm { fstp    qword ptr [edi+30h] }
          break;
        case 6:
          v11 = v23;
          if ( !v23 )
          {
            v11 = "99.999";
            v23 = "99.999";
          }
          strtod(v11, 0);
          __asm { fstp    qword ptr [edi+18h] }
          break;
        case 7:
          v12 = v23;
          if ( !v23 )
          {
            v12 = "0.0";
            v23 = "0.0";
          }
          strtod(v12, 0);
          __asm { fstp    qword ptr [edi+38h] }
          break;
        default:
          break;
      }
      v3 = (&v15)[4 * v2++];
    }
    while ( strcmp(v3, "END") );
  }
  return v24;
}

//----- (100057A0) --------------------------------------------------------
int __cdecl sub_100057A0(int a1, int a2)
{
  int v2; // ebx@1
  char *v3; // esi@1
  char *v5; // eax@4
  int v6; // edx@6
  char *v7; // eax@9
  int v8; // edx@11
  char *v9; // eax@14
  int v10; // edx@16
  char *v11; // eax@19
  char *v12; // eax@22
  char *v13; // eax@25
  char *v14; // eax@28
  char *v15; // eax@31
  char *v16; // eax@34
  char *v17; // eax@37
  char *v18; // eax@40
  char *v19; // eax@43
  char *v20; // eax@46
  char *v21; // eax@49
  char *v22; // eax@52
  char v24; // cl@7
  char v25; // cl@12
  char v26; // cl@17
  char *v27; // [sp+8h] [bp-48h]@1
  char *v28; // [sp+Ch] [bp-44h]@1
  char *v29; // [sp+10h] [bp-40h]@1
  char *v30; // [sp+14h] [bp-3Ch]@1
  char *v31; // [sp+18h] [bp-38h]@1
  char *v32; // [sp+1Ch] [bp-34h]@1
  char *v33; // [sp+20h] [bp-30h]@1
  char *v34; // [sp+24h] [bp-2Ch]@1
  char *v35; // [sp+28h] [bp-28h]@1
  char *v36; // [sp+2Ch] [bp-24h]@1
  char *v37; // [sp+30h] [bp-20h]@1
  char *v38; // [sp+34h] [bp-1Ch]@1
  char *v39; // [sp+38h] [bp-18h]@1
  char *v40; // [sp+3Ch] [bp-14h]@1
  char *v41; // [sp+40h] [bp-10h]@1
  char *v42; // [sp+44h] [bp-Ch]@1
  char *v43; // [sp+4Ch] [bp-4h]@3
  int v44; // [sp+48h] [bp-8h]@3

  v3 = "mom_kin_4th_axis_plane";
  v27 = "mom_kin_4th_axis_plane";
  v28 = "mom_kin_4th_axis_direction";
  v29 = "mom_kin_4th_axis_rotation";
  v30 = "mom_kin_4th_axis_min_incr";
  v31 = "mom_kin_4th_axis_min_limit";
  v32 = "mom_kin_4th_axis_max_limit";
  v33 = "mom_kin_4th_axis_zero";
  v34 = "mom_kin_4th_axis_center_offset_x";
  v35 = "mom_kin_4th_axis_center_offset_y";
  v36 = "mom_kin_4th_axis_center_offset_z";
  v37 = "mom_kin_4th_axis_vector_i";
  v38 = "mom_kin_4th_axis_vector_j";
  v39 = "mom_kin_4th_axis_vector_k";
  v40 = "mom_kin_4th_axis_angles_a1";
  v41 = "mom_kin_4th_axis_angles_a2";
  v42 = "END";
  v2 = 0;
  if ( strcmp("mom_kin_4th_axis_plane", "END") )
  {
    _EDI = a2;
    do
    {
      v44 = UF_MOM_ask_string(a1, v3 + 4, &v43);
      switch ( v2 )
      {
        case 0:
          v5 = v43;
          if ( !v43 )
          {
            v5 = "YZ";
            v43 = "YZ";
          }
          v6 = _EDI - (_DWORD)v5;
          do
          {
            v24 = *v5;
            v5[v6] = *v5;
            ++v5;
          }
          while ( v24 );
          break;
        case 1:
          v7 = v43;
          if ( !v43 )
          {
            v7 = "MAGNITUDE_DETERMINES_DIRECTION";
            v43 = "MAGNITUDE_DETERMINES_DIRECTION";
          }
          v8 = _EDI - (_DWORD)v7 + 133;
          do
          {
            v25 = *v7;
            v7[v8] = *v7;
            ++v7;
          }
          while ( v25 );
          break;
        case 2:
          v9 = v43;
          if ( !v43 )
          {
            v9 = "STANDARD";
            v43 = "STANDARD";
          }
          v10 = _EDI - (_DWORD)v9 + 266;
          do
          {
            v26 = *v9;
            v9[v10] = *v9;
            ++v9;
          }
          while ( v26 );
          break;
        case 3:
          v11 = v43;
          if ( !v43 )
          {
            v11 = "0.001";
            v43 = "0.001";
          }
          strtod(v11, 0);
          __asm { fstp    qword ptr [edi+190h] }
          break;
        case 4:
          v12 = v43;
          if ( !v43 )
          {
            v12 = "0.0";
            v43 = "0.0";
          }
          strtod(v12, 0);
          __asm { fstp    qword ptr [edi+198h] }
          break;
        case 5:
          v13 = v43;
          if ( !v43 )
          {
            v13 = "360.0";
            v43 = "360.0";
          }
          strtod(v13, 0);
          __asm { fstp    qword ptr [edi+1A0h] }
          break;
        case 6:
          v14 = v43;
          if ( !v43 )
          {
            v14 = "0.0";
            v43 = "0.0";
          }
          strtod(v14, 0);
          __asm { fstp    qword ptr [edi+1A8h] }
          break;
        case 7:
          v15 = v43;
          if ( !v43 )
          {
            v15 = "0.0";
            v43 = "0.0";
          }
          strtod(v15, 0);
          __asm { fstp    qword ptr [edi+1B0h] }
          break;
        case 8:
          v16 = v43;
          if ( !v43 )
          {
            v16 = "0.0";
            v43 = "0.0";
          }
          strtod(v16, 0);
          __asm { fstp    qword ptr [edi+1B8h] }
          break;
        case 9:
          v17 = v43;
          if ( !v43 )
          {
            v17 = "0.0";
            v43 = "0.0";
          }
          strtod(v17, 0);
          __asm { fstp    qword ptr [edi+1C0h] }
          break;
        case 10:
          v18 = v43;
          if ( !v43 )
          {
            v18 = "0.0";
            v43 = "0.0";
          }
          strtod(v18, 0);
          __asm { fstp    qword ptr [edi+1C8h] }
          break;
        case 11:
          v19 = v43;
          if ( !v43 )
          {
            v19 = "0.0";
            v43 = "0.0";
          }
          strtod(v19, 0);
          __asm { fstp    qword ptr [edi+1D0h] }
          break;
        case 12:
          v20 = v43;
          if ( !v43 )
          {
            v20 = "0.0";
            v43 = "0.0";
          }
          strtod(v20, 0);
          __asm { fstp    qword ptr [edi+1D8h] }
          break;
        case 13:
          v21 = v43;
          if ( !v43 )
          {
            v21 = "0.0";
            v43 = "0.0";
          }
          strtod(v21, 0);
          __asm { fstp    qword ptr [edi+1E0h] }
          break;
        case 14:
          v22 = v43;
          if ( !v43 )
          {
            v22 = "0.0";
            v43 = "0.0";
          }
          strtod(v22, 0);
          __asm { fstp    qword ptr [edi+1E8h] }
          break;
        default:
          break;
      }
      v3 = (&v28)[4 * v2++];
    }
    while ( strcmp(v3, "END") );
  }
  return v44;
}

//----- (10005B10) --------------------------------------------------------
int __cdecl sub_10005B10(int a1, int a2)
{
  int v2; // ebx@1
  char *v3; // esi@1
  char *v5; // eax@4
  int v6; // edx@6
  char *v7; // eax@9
  int v8; // edx@11
  char *v9; // eax@14
  int v10; // edx@16
  char *v11; // eax@19
  char *v12; // eax@22
  char *v13; // eax@25
  char *v14; // eax@28
  char *v15; // eax@31
  char *v16; // eax@34
  char *v17; // eax@37
  char *v18; // eax@40
  char *v19; // eax@43
  char *v20; // eax@46
  char *v21; // eax@49
  char *v22; // eax@52
  char v24; // cl@7
  char v25; // cl@12
  char v26; // cl@17
  char *v27; // [sp+8h] [bp-48h]@1
  char *v28; // [sp+Ch] [bp-44h]@1
  char *v29; // [sp+10h] [bp-40h]@1
  char *v30; // [sp+14h] [bp-3Ch]@1
  char *v31; // [sp+18h] [bp-38h]@1
  char *v32; // [sp+1Ch] [bp-34h]@1
  char *v33; // [sp+20h] [bp-30h]@1
  char *v34; // [sp+24h] [bp-2Ch]@1
  char *v35; // [sp+28h] [bp-28h]@1
  char *v36; // [sp+2Ch] [bp-24h]@1
  char *v37; // [sp+30h] [bp-20h]@1
  char *v38; // [sp+34h] [bp-1Ch]@1
  char *v39; // [sp+38h] [bp-18h]@1
  char *v40; // [sp+3Ch] [bp-14h]@1
  char *v41; // [sp+40h] [bp-10h]@1
  char *v42; // [sp+44h] [bp-Ch]@1
  char *v43; // [sp+4Ch] [bp-4h]@3
  int v44; // [sp+48h] [bp-8h]@3

  v3 = "mom_kin_5th_axis_plane";
  v27 = "mom_kin_5th_axis_plane";
  v28 = "mom_kin_5th_axis_direction";
  v29 = "mom_kin_5th_axis_rotation";
  v30 = "mom_kin_5th_axis_min_incr";
  v31 = "mom_kin_5th_axis_min_limit";
  v32 = "mom_kin_5th_axis_max_limit";
  v33 = "mom_kin_5th_axis_zero";
  v34 = "mom_kin_5th_axis_center_offset_x";
  v35 = "mom_kin_5th_axis_center_offset_y";
  v36 = "mom_kin_5th_axis_center_offset_z";
  v37 = "mom_kin_5th_axis_vector_i";
  v38 = "mom_kin_5th_axis_vector_j";
  v39 = "mom_kin_5th_axis_vector_k";
  v40 = "mom_kin_5th_axis_angles_a1";
  v41 = "mom_kin_5th_axis_angles_a2";
  v42 = "END";
  v2 = 0;
  if ( strcmp("mom_kin_5th_axis_plane", "END") )
  {
    _EDI = a2;
    do
    {
      v44 = UF_MOM_ask_string(a1, v3 + 4, &v43);
      switch ( v2 )
      {
        case 0:
          v5 = v43;
          if ( !v43 )
          {
            v5 = "YZ";
            v43 = "YZ";
          }
          v6 = _EDI - (_DWORD)v5;
          do
          {
            v24 = *v5;
            v5[v6] = *v5;
            ++v5;
          }
          while ( v24 );
          break;
        case 1:
          v7 = v43;
          if ( !v43 )
          {
            v7 = "MAGNITUDE_DETERMINES_DIRECTION";
            v43 = "MAGNITUDE_DETERMINES_DIRECTION";
          }
          v8 = _EDI - (_DWORD)v7 + 133;
          do
          {
            v25 = *v7;
            v7[v8] = *v7;
            ++v7;
          }
          while ( v25 );
          break;
        case 2:
          v9 = v43;
          if ( !v43 )
          {
            v9 = "STANDARD";
            v43 = "STANDARD";
          }
          v10 = _EDI - (_DWORD)v9 + 266;
          do
          {
            v26 = *v9;
            v9[v10] = *v9;
            ++v9;
          }
          while ( v26 );
          break;
        case 3:
          v11 = v43;
          if ( !v43 )
          {
            v11 = "0.001";
            v43 = "0.001";
          }
          strtod(v11, 0);
          __asm { fstp    qword ptr [edi+190h] }
          break;
        case 4:
          v12 = v43;
          if ( !v43 )
          {
            v12 = "0.0";
            v43 = "0.0";
          }
          strtod(v12, 0);
          __asm { fstp    qword ptr [edi+198h] }
          break;
        case 5:
          v13 = v43;
          if ( !v43 )
          {
            v13 = "360.0";
            v43 = "360.0";
          }
          strtod(v13, 0);
          __asm { fstp    qword ptr [edi+1A0h] }
          break;
        case 6:
          v14 = v43;
          if ( !v43 )
          {
            v14 = "0.0";
            v43 = "0.0";
          }
          strtod(v14, 0);
          __asm { fstp    qword ptr [edi+1A8h] }
          break;
        case 7:
          v15 = v43;
          if ( !v43 )
          {
            v15 = "0.0";
            v43 = "0.0";
          }
          strtod(v15, 0);
          __asm { fstp    qword ptr [edi+1B0h] }
          break;
        case 8:
          v16 = v43;
          if ( !v43 )
          {
            v16 = "0.0";
            v43 = "0.0";
          }
          strtod(v16, 0);
          __asm { fstp    qword ptr [edi+1B8h] }
          break;
        case 9:
          v17 = v43;
          if ( !v43 )
          {
            v17 = "0.0";
            v43 = "0.0";
          }
          strtod(v17, 0);
          __asm { fstp    qword ptr [edi+1C0h] }
          break;
        case 10:
          v18 = v43;
          if ( !v43 )
          {
            v18 = "0.0";
            v43 = "0.0";
          }
          strtod(v18, 0);
          __asm { fstp    qword ptr [edi+1C8h] }
          break;
        case 11:
          v19 = v43;
          if ( !v43 )
          {
            v19 = "0.0";
            v43 = "0.0";
          }
          strtod(v19, 0);
          __asm { fstp    qword ptr [edi+1D0h] }
          break;
        case 12:
          v20 = v43;
          if ( !v43 )
          {
            v20 = "0.0";
            v43 = "0.0";
          }
          strtod(v20, 0);
          __asm { fstp    qword ptr [edi+1D8h] }
          break;
        case 13:
          v21 = v43;
          if ( !v43 )
          {
            v21 = "0.0";
            v43 = "0.0";
          }
          strtod(v21, 0);
          __asm { fstp    qword ptr [edi+1E0h] }
          break;
        case 14:
          v22 = v43;
          if ( !v43 )
          {
            v22 = "0.0";
            v43 = "0.0";
          }
          strtod(v22, 0);
          __asm { fstp    qword ptr [edi+1E8h] }
          break;
        default:
          break;
      }
      v3 = (&v28)[4 * v2++];
    }
    while ( strcmp(v3, "END") );
  }
  return v44;
}

//----- (10005E80) --------------------------------------------------------
int __cdecl sub_10005E80(int a1, int a2)
{
  signed int v2; // edi@1
  char *v3; // esi@1
  char *v5; // eax@6
  char *v6; // eax@9
  char *v7; // eax@12
  int v8; // edx@14
  char v10; // cl@15
  char *v11; // [sp+8h] [bp-18h]@1
  char *v12; // [sp+Ch] [bp-14h]@1
  char *v13; // [sp+10h] [bp-10h]@1
  char *v14; // [sp+14h] [bp-Ch]@1
  char *v15; // [sp+1Ch] [bp-4h]@3
  int v16; // [sp+18h] [bp-8h]@3

  v3 = "mom_kin_independent_head";
  v11 = "mom_kin_independent_head";
  v12 = "mom_kin_ind_to_dependent_head_x";
  v13 = "mom_kin_ind_to_dependent_head_z";
  v14 = "END";
  v2 = 0;
  if ( strcmp("mom_kin_independent_head", "END") )
  {
    _EBX = a2;
    do
    {
      v16 = UF_MOM_ask_string(a1, v3 + 4, &v15);
      if ( v2 )
      {
        if ( v2 == 1 )
        {
          v6 = v15;
          if ( !v15 )
          {
            v6 = "0.0";
            v15 = "0.0";
          }
          strtod(v6, 0);
          __asm { fstp    qword ptr [ebx+88h] }
        }
        else
        {
          if ( v2 == 2 )
          {
            v5 = v15;
            if ( !v15 )
            {
              v5 = "0.0";
              v15 = "0.0";
            }
            strtod(v5, 0);
            __asm { fstp    qword ptr [ebx+90h] }
          }
        }
      }
      else
      {
        v7 = v15;
        if ( !v15 )
        {
          v7 = "FRONT";
          v15 = "FRONT";
        }
        v8 = _EBX - (_DWORD)v7;
        do
        {
          v10 = *v7;
          v7[v8] = *v7;
          ++v7;
        }
        while ( v10 );
      }
      v3 = (&v12)[4 * v2++];
    }
    while ( strcmp(v3, "END") );
  }
  return v16;
}

//----- (10005FC0) --------------------------------------------------------
int __cdecl sub_10005FC0(int a1, int a2)
{
  signed int v2; // edi@1
  char *v3; // esi@1
  char *v5; // eax@6
  char *v6; // eax@9
  char *v7; // eax@12
  char *v9; // [sp+8h] [bp-18h]@1
  char *v10; // [sp+Ch] [bp-14h]@1
  char *v11; // [sp+10h] [bp-10h]@1
  char *v12; // [sp+14h] [bp-Ch]@1
  char *v13; // [sp+1Ch] [bp-4h]@3
  int v14; // [sp+18h] [bp-8h]@3

  v3 = "mom_kin_tool_change_time";
  v9 = "mom_kin_tool_change_time";
  v10 = "mom_kin_clamp_time";
  v11 = "mom_kin_flush_time";
  v12 = "END";
  v2 = 0;
  if ( strcmp("mom_kin_tool_change_time", "END") )
  {
    _EBX = a2;
    do
    {
      v14 = UF_MOM_ask_string(a1, v3 + 4, &v13);
      if ( v2 )
      {
        if ( v2 == 1 )
        {
          v6 = v13;
          if ( !v13 )
          {
            v6 = "0.5";
            v13 = "0.5";
          }
          strtod(v6, 0);
          __asm { fstp    qword ptr [ebx+8] }
        }
        else
        {
          if ( v2 == 2 )
          {
            v5 = v13;
            if ( !v13 )
            {
              v5 = "0.5";
              v13 = "0.5";
            }
            strtod(v5, 0);
            __asm { fstp    qword ptr [ebx+10h] }
          }
        }
      }
      else
      {
        v7 = v13;
        if ( !v13 )
        {
          v7 = "3.0";
          v13 = "3.0";
        }
        strtod(v7, 0);
        __asm { fstp    qword ptr [ebx] }
      }
      v3 = (&v10)[4 * v2++];
    }
    while ( strcmp(v3, "END") );
  }
  return v14;
}

//----- (100060F0) --------------------------------------------------------
int __cdecl sub_100060F0(int a1, int a2)
{
  int v2; // ebx@1
  char *v3; // esi@1
  char *v5; // eax@4
  int v6; // edx@6
  char *v7; // eax@9
  int v8; // edx@11
  char *v9; // eax@14
  int v10; // edx@16
  char *v11; // eax@19
  int v12; // edx@21
  char *v13; // eax@24
  int v14; // edx@26
  char *v15; // eax@29
  int v16; // edx@31
  char *v17; // eax@34
  char *v18; // eax@37
  char *v19; // eax@40
  char *v20; // eax@43
  char *v21; // eax@46
  char *v22; // eax@49
  char *v23; // eax@52
  char *v24; // eax@55
  char *v25; // eax@58
  char *v26; // eax@61
  char *v27; // eax@64
  char *v28; // eax@67
  char *v29; // eax@70
  char *v30; // eax@73
  char *v31; // eax@76
  char *v32; // eax@79
  char *v33; // eax@82
  char *v34; // eax@85
  char v36; // cl@7
  char v37; // cl@12
  char v38; // cl@17
  char v39; // cl@22
  char v40; // cl@27
  char v41; // cl@32
  char *v42; // [sp+8h] [bp-6Ch]@1
  char *v43; // [sp+Ch] [bp-68h]@1
  char *v44; // [sp+10h] [bp-64h]@1
  char *v45; // [sp+14h] [bp-60h]@1
  char *v46; // [sp+18h] [bp-5Ch]@1
  char *v47; // [sp+1Ch] [bp-58h]@1
  char *v48; // [sp+20h] [bp-54h]@1
  char *v49; // [sp+24h] [bp-50h]@1
  char *v50; // [sp+28h] [bp-4Ch]@1
  char *v51; // [sp+2Ch] [bp-48h]@1
  char *v52; // [sp+30h] [bp-44h]@1
  char *v53; // [sp+34h] [bp-40h]@1
  char *v54; // [sp+38h] [bp-3Ch]@1
  char *v55; // [sp+3Ch] [bp-38h]@1
  char *v56; // [sp+40h] [bp-34h]@1
  char *v57; // [sp+44h] [bp-30h]@1
  char *v58; // [sp+48h] [bp-2Ch]@1
  char *v59; // [sp+4Ch] [bp-28h]@1
  char *v60; // [sp+50h] [bp-24h]@1
  char *v61; // [sp+54h] [bp-20h]@1
  char *v62; // [sp+58h] [bp-1Ch]@1
  char *v63; // [sp+5Ch] [bp-18h]@1
  char *v64; // [sp+60h] [bp-14h]@1
  char *v65; // [sp+64h] [bp-10h]@1
  char *v66; // [sp+68h] [bp-Ch]@1
  char *v67; // [sp+70h] [bp-4h]@3
  int v68; // [sp+6Ch] [bp-8h]@3

  v3 = "mom_kin_holder1_orientation";
  v42 = "mom_kin_holder1_orientation";
  v43 = "mom_kin_holder2_orientation";
  v44 = "mom_kin_holder3_orientation";
  v45 = "mom_kin_holder4_orientation";
  v46 = "mom_kin_holder5_orientation";
  v47 = "mom_kin_holder6_orientation";
  v48 = "mom_kin_holder1_offset_x";
  v49 = "mom_kin_holder1_offset_y";
  v50 = "mom_kin_holder1_offset_z";
  v51 = "mom_kin_holder2_offset_x";
  v52 = "mom_kin_holder2_offset_y";
  v53 = "mom_kin_holder2_offset_z";
  v54 = "mom_kin_holder3_offset_x";
  v55 = "mom_kin_holder3_offset_y";
  v56 = "mom_kin_holder3_offset_z";
  v57 = "mom_kin_holder4_offset_x";
  v58 = "mom_kin_holder4_offset_y";
  v59 = "mom_kin_holder4_offset_z";
  v60 = "mom_kin_holder5_offset_x";
  v61 = "mom_kin_holder5_offset_y";
  v62 = "mom_kin_holder5_offset_z";
  v63 = "mom_kin_holder6_offset_x";
  v64 = "mom_kin_holder6_offset_y";
  v65 = "mom_kin_holder6_offset_z";
  v66 = "END";
  v2 = 0;
  if ( strcmp("mom_kin_holder1_orientation", "END") )
  {
    _EDI = a2;
    do
    {
      v68 = UF_MOM_ask_string(a1, v3 + 4, &v67);
      switch ( v2 )
      {
        case 0:
          v5 = v67;
          if ( !v67 )
          {
            v5 = "POSZ";
            v67 = "POSZ";
          }
          v6 = _EDI - (_DWORD)v5;
          do
          {
            v36 = *v5;
            v5[v6] = *v5;
            ++v5;
          }
          while ( v36 );
          break;
        case 1:
          v7 = v67;
          if ( !v67 )
          {
            v7 = "POSZ";
            v67 = "POSZ";
          }
          v8 = _EDI - (_DWORD)v7 + 133;
          do
          {
            v37 = *v7;
            v7[v8] = *v7;
            ++v7;
          }
          while ( v37 );
          break;
        case 2:
          v9 = v67;
          if ( !v67 )
          {
            v9 = "POSZ";
            v67 = "POSZ";
          }
          v10 = _EDI - (_DWORD)v9 + 266;
          do
          {
            v38 = *v9;
            v9[v10] = *v9;
            ++v9;
          }
          while ( v38 );
          break;
        case 3:
          v11 = v67;
          if ( !v67 )
          {
            v11 = "POSZ";
            v67 = "POSZ";
          }
          v12 = _EDI - (_DWORD)v11 + 399;
          do
          {
            v39 = *v11;
            v11[v12] = *v11;
            ++v11;
          }
          while ( v39 );
          break;
        case 4:
          v13 = v67;
          if ( !v67 )
          {
            v13 = "POSZ";
            v67 = "POSZ";
          }
          v14 = _EDI - (_DWORD)v13 + 532;
          do
          {
            v40 = *v13;
            v13[v14] = *v13;
            ++v13;
          }
          while ( v40 );
          break;
        case 5:
          v15 = v67;
          if ( !v67 )
          {
            v15 = "POSZ";
            v67 = "POSZ";
          }
          v16 = _EDI - (_DWORD)v15 + 665;
          do
          {
            v41 = *v15;
            v15[v16] = *v15;
            ++v15;
          }
          while ( v41 );
          break;
        case 6:
          v17 = v67;
          if ( !v67 )
          {
            v17 = "0.0";
            v67 = "0.0";
          }
          strtod(v17, 0);
          __asm { fstp    qword ptr [edi+320h] }
          break;
        case 7:
          v18 = v67;
          if ( !v67 )
          {
            v18 = "0.0";
            v67 = "0.0";
          }
          strtod(v18, 0);
          __asm { fstp    qword ptr [edi+328h] }
          break;
        case 8:
          v19 = v67;
          if ( !v67 )
          {
            v19 = "0.0";
            v67 = "0.0";
          }
          strtod(v19, 0);
          __asm { fstp    qword ptr [edi+330h] }
          break;
        case 9:
          v20 = v67;
          if ( !v67 )
          {
            v20 = "0.0";
            v67 = "0.0";
          }
          strtod(v20, 0);
          __asm { fstp    qword ptr [edi+338h] }
          break;
        case 10:
          v21 = v67;
          if ( !v67 )
          {
            v21 = "0.0";
            v67 = "0.0";
          }
          strtod(v21, 0);
          __asm { fstp    qword ptr [edi+340h] }
          break;
        case 11:
          v22 = v67;
          if ( !v67 )
          {
            v22 = "0.0";
            v67 = "0.0";
          }
          strtod(v22, 0);
          __asm { fstp    qword ptr [edi+348h] }
          break;
        case 12:
          v23 = v67;
          if ( !v67 )
          {
            v23 = "0.0";
            v67 = "0.0";
          }
          strtod(v23, 0);
          __asm { fstp    qword ptr [edi+350h] }
          break;
        case 13:
          v24 = v67;
          if ( !v67 )
          {
            v24 = "0.0";
            v67 = "0.0";
          }
          strtod(v24, 0);
          __asm { fstp    qword ptr [edi+358h] }
          break;
        case 14:
          v25 = v67;
          if ( !v67 )
          {
            v25 = "0.0";
            v67 = "0.0";
          }
          strtod(v25, 0);
          __asm { fstp    qword ptr [edi+360h] }
          break;
        case 15:
          v26 = v67;
          if ( !v67 )
          {
            v26 = "0.0";
            v67 = "0.0";
          }
          strtod(v26, 0);
          __asm { fstp    qword ptr [edi+368h] }
          break;
        case 16:
          v27 = v67;
          if ( !v67 )
          {
            v27 = "0.0";
            v67 = "0.0";
          }
          strtod(v27, 0);
          __asm { fstp    qword ptr [edi+370h] }
          break;
        case 17:
          v28 = v67;
          if ( !v67 )
          {
            v28 = "0.0";
            v67 = "0.0";
          }
          strtod(v28, 0);
          __asm { fstp    qword ptr [edi+378h] }
          break;
        case 18:
          v29 = v67;
          if ( !v67 )
          {
            v29 = "0.0";
            v67 = "0.0";
          }
          strtod(v29, 0);
          __asm { fstp    qword ptr [edi+380h] }
          break;
        case 19:
          v30 = v67;
          if ( !v67 )
          {
            v30 = "0.0";
            v67 = "0.0";
          }
          strtod(v30, 0);
          __asm { fstp    qword ptr [edi+388h] }
          break;
        case 20:
          v31 = v67;
          if ( !v67 )
          {
            v31 = "0.0";
            v67 = "0.0";
          }
          strtod(v31, 0);
          __asm { fstp    qword ptr [edi+390h] }
          break;
        case 21:
          v32 = v67;
          if ( !v67 )
          {
            v32 = "0.0";
            v67 = "0.0";
          }
          strtod(v32, 0);
          __asm { fstp    qword ptr [edi+398h] }
          break;
        case 22:
          v33 = v67;
          if ( !v67 )
          {
            v33 = "0.0";
            v67 = "0.0";
          }
          strtod(v33, 0);
          __asm { fstp    qword ptr [edi+3A0h] }
          break;
        case 23:
          v34 = v67;
          if ( !v67 )
          {
            v34 = "0.0";
            v67 = "0.0";
          }
          strtod(v34, 0);
          __asm { fstp    qword ptr [edi+3A8h] }
          break;
        default:
          break;
      }
      v3 = (&v43)[4 * v2++];
    }
    while ( strcmp(v3, "END") );
  }
  return v68;
}

//----- (10006610) --------------------------------------------------------
int __cdecl sub_10006610(int a1, int a2)
{
  int v2; // edi@1
  char *v3; // esi@1
  char *v5; // eax@4
  int v6; // edx@6
  void *v7; // eax@9
  int v8; // edx@11
  char *v9; // eax@14
  int v10; // edx@16
  void *v11; // eax@19
  int v12; // edx@21
  char *v13; // eax@24
  int v14; // edx@26
  void *v15; // eax@29
  int v16; // edx@31
  char *v17; // eax@34
  char *v18; // eax@37
  char *v19; // eax@40
  char *v20; // eax@43
  char *v21; // ecx@46
  int v22; // eax@47
  char *v23; // ecx@51
  int v24; // eax@52
  char *v25; // ecx@56
  int v26; // eax@57
  char v28; // cl@7
  char v29; // cl@12
  char v30; // cl@17
  char v31; // cl@22
  char v32; // cl@27
  char v33; // cl@32
  char *v34; // [sp+84h] [bp-1Ch]@1
  char *v35; // [sp+8Ch] [bp-14h]@1
  char *v36; // [sp+5Ch] [bp-44h]@1
  char *v37; // [sp+60h] [bp-40h]@1
  char *v38; // [sp+64h] [bp-3Ch]@1
  char *v39; // [sp+68h] [bp-38h]@1
  char *v40; // [sp+6Ch] [bp-34h]@1
  char *v41; // [sp+70h] [bp-30h]@1
  char *v42; // [sp+74h] [bp-2Ch]@1
  char *v43; // [sp+78h] [bp-28h]@1
  char *v44; // [sp+7Ch] [bp-24h]@1
  char *v45; // [sp+80h] [bp-20h]@1
  char *v46; // [sp+88h] [bp-18h]@1
  char *v47; // [sp+90h] [bp-10h]@1
  int v48; // [sp+98h] [bp-8h]@1
  char *v49; // [sp+9Ch] [bp-4h]@3
  int v50; // [sp+94h] [bp-Ch]@3
  char v51; // [sp+40h] [bp-60h]@47
  char v52; // [sp+8h] [bp-98h]@52
  char v53; // [sp+24h] [bp-7Ch]@57

  v3 = "mom_kin_machine_type";
  v2 = 0;
  v34 = "mom_kin_gauge_to_pivot_x";
  v35 = "mom_kin_gauge_to_pivot_x";
  v36 = "mom_kin_machine_type";
  v37 = "mom_kin_track_center_of_ball";
  v38 = "mom_kin_wire_tilt_output_type";
  v39 = "mom_kin_clsf_generation";
  v40 = "mom_kin_coordinate_type";
  v41 = "mom_kin_linearization_flag";
  v42 = "mom_kin_machine_resolution";
  v43 = "mom_kin_tool_tracking_height";
  v44 = "mom_kin_5th_axis_inclination_to_4th";
  v45 = "mom_kin_linearization_tol";
  v46 = "mom_kin_gauge_to_pivot_y";
  v47 = "END";
  v48 = 0;
  if ( strcmp("mom_kin_machine_type", "END") )
  {
    _EBX = a2;
    do
    {
      v50 = UF_MOM_ask_string(a1, v3 + 4, &v49);
      switch ( v2 )
      {
        case 0:
          v5 = v49;
          if ( !v49 )
          {
            v5 = "3_axis_mill";
            v49 = "3_axis_mill";
          }
          v6 = _EBX - (_DWORD)v5;
          do
          {
            v28 = *v5;
            v5[v6] = *v5;
            ++v5;
          }
          while ( v28 );
          break;
        case 1:
          v7 = v49;
          if ( !v49 )
          {
            v7 = L"T";
            v49 = (char *)L"T";
          }
          v8 = _EBX - (_DWORD)v7 + 133;
          do
          {
            v29 = *(_BYTE *)v7;
            *((_BYTE *)v7 + v8) = *(_BYTE *)v7;
            v7 = (char *)v7 + 1;
          }
          while ( v29 );
          break;
        case 2:
          v9 = v49;
          if ( !v49 )
          {
            v9 = "NONE";
            v49 = "NONE";
          }
          v10 = _EBX - (_DWORD)v9 + 266;
          do
          {
            v30 = *v9;
            v9[v10] = *v9;
            ++v9;
          }
          while ( v30 );
          break;
        case 3:
          v11 = v49;
          if ( !v49 )
          {
            v11 = L"F";
            v49 = (char *)L"F";
          }
          v12 = _EBX - (_DWORD)v11 + 399;
          do
          {
            v31 = *(_BYTE *)v11;
            *((_BYTE *)v11 + v12) = *(_BYTE *)v11;
            v11 = (char *)v11 + 1;
          }
          while ( v31 );
          break;
        case 4:
          v13 = v49;
          if ( !v49 )
          {
            v13 = "CARTESIAN";
            v49 = "CARTESIAN";
          }
          v14 = _EBX - (_DWORD)v13 + 532;
          do
          {
            v32 = *v13;
            v13[v14] = *v13;
            ++v13;
          }
          while ( v32 );
          break;
        case 5:
          v15 = v49;
          if ( !v49 )
          {
            v15 = L"F";
            v49 = (char *)L"F";
          }
          v16 = _EBX - (_DWORD)v15 + 665;
          do
          {
            v33 = *(_BYTE *)v15;
            *((_BYTE *)v15 + v16) = *(_BYTE *)v15;
            v15 = (char *)v15 + 1;
          }
          while ( v33 );
          break;
        case 6:
          v17 = v49;
          if ( !v49 )
          {
            v17 = "0.0001";
            v49 = "0.0001";
          }
          strtod(v17, 0);
          __asm { fstp    qword ptr [ebx+320h] }
          break;
        case 7:
          v18 = v49;
          if ( !v49 )
          {
            v18 = "0.0";
            v49 = "0.0";
          }
          strtod(v18, 0);
          __asm { fstp    qword ptr [ebx+328h] }
          break;
        case 8:
          v19 = v49;
          if ( !v49 )
          {
            v19 = "90.0";
            v49 = "90.0";
          }
          strtod(v19, 0);
          __asm { fstp    qword ptr [ebx+330h] }
          break;
        case 9:
          v20 = v49;
          if ( !v49 )
          {
            v20 = "0.0001";
            v49 = "0.0001";
          }
          strtod(v20, 0);
          __asm { fstp    qword ptr [ebx+338h] }
          break;
        case 10:
          v21 = v49;
          if ( !v49 )
          {
            memcpy(&v51, "kin_4th_to_tracking_point_x", 0x1Cu);
            v22 = sub_10005240((int)&v51, a1, 0);
            v21 = v49;
            if ( !v49 || v22 )
            {
              v21 = "0.0";
              v49 = "0.0";
            }
          }
          strtod(v21, 0);
          __asm { fstp    qword ptr [ebx+340h] }
          break;
        case 11:
          v23 = v49;
          if ( !v49 )
          {
            memcpy(&v52, "kin_4th_to_tracking_point_y", 0x1Cu);
            v24 = sub_10005240((int)&v52, a1, 0);
            v23 = v49;
            if ( !v49 || v24 )
            {
              v23 = "0.0";
              v49 = "0.0";
            }
          }
          strtod(v23, 0);
          __asm { fstp    qword ptr [ebx+348h] }
          break;
        case 12:
          v25 = v49;
          if ( !v49 )
          {
            memcpy(&v53, "kin_4th_to_tracking_point_z", 0x1Cu);
            v26 = sub_10005240((int)&v53, a1, 0);
            v25 = v49;
            if ( !v49 || v26 )
            {
              v25 = "0.0";
              v49 = "0.0";
            }
          }
          strtod(v25, 0);
          __asm { fstp    qword ptr [ebx+350h] }
          break;
        default:
          break;
      }
      v3 = (&v37)[4 * v48];
      v2 = v48++ + 1;
    }
    while ( strcmp(v3, "END") );
  }
  return v50;
}

//----- (100069C0) --------------------------------------------------------
int __cdecl sub_100069C0(int a1, int a2)
{
  int v2; // ebx@1
  char *v3; // esi@1
  char *v5; // eax@4
  char *v6; // eax@7
  char *v7; // eax@10
  char *v8; // eax@13
  char *v9; // eax@16
  char *v10; // eax@19
  char *v11; // eax@22
  char *v12; // eax@25
  char *v13; // eax@28
  char *v14; // eax@31
  char *v15; // eax@34
  char *v16; // eax@37
  char *v18; // [sp+8h] [bp-3Ch]@1
  char *v19; // [sp+Ch] [bp-38h]@1
  char *v20; // [sp+10h] [bp-34h]@1
  char *v21; // [sp+14h] [bp-30h]@1
  char *v22; // [sp+18h] [bp-2Ch]@1
  char *v23; // [sp+1Ch] [bp-28h]@1
  char *v24; // [sp+20h] [bp-24h]@1
  char *v25; // [sp+24h] [bp-20h]@1
  char *v26; // [sp+28h] [bp-1Ch]@1
  char *v27; // [sp+2Ch] [bp-18h]@1
  char *v28; // [sp+30h] [bp-14h]@1
  char *v29; // [sp+34h] [bp-10h]@1
  char *v30; // [sp+38h] [bp-Ch]@1
  char *v31; // [sp+40h] [bp-4h]@3
  int v32; // [sp+3Ch] [bp-8h]@3

  v3 = "mom_msys_origin_x";
  v18 = "mom_msys_origin_x";
  v19 = "mom_msys_origin_y";
  v20 = "mom_msys_origin_z";
  v21 = "mom_msys_x_axis_i";
  v22 = "mom_msys_x_axis_j";
  v23 = "mom_msys_x_axis_k";
  v24 = "mom_msys_y_axis_i";
  v25 = "mom_msys_y_axis_j";
  v26 = "mom_msys_y_axis_k";
  v27 = "mom_msys_z_axis_i";
  v28 = "mom_msys_z_axis_j";
  v29 = "mom_msys_z_axis_k";
  v30 = "END";
  v2 = 0;
  if ( strcmp("mom_msys_origin_x", "END") )
  {
    _EDI = a2;
    do
    {
      v32 = UF_MOM_ask_string(a1, v3 + 4, &v31);
      switch ( v2 )
      {
        case 0:
          v5 = v31;
          if ( !v31 )
          {
            v5 = "0.0";
            v31 = "0.0";
          }
          strtod(v5, 0);
          __asm { fstp    qword ptr [edi] }
          break;
        case 1:
          v6 = v31;
          if ( !v31 )
          {
            v6 = "0.0";
            v31 = "0.0";
          }
          strtod(v6, 0);
          __asm { fstp    qword ptr [edi+8] }
          break;
        case 2:
          v7 = v31;
          if ( !v31 )
          {
            v7 = "0.0";
            v31 = "0.0";
          }
          strtod(v7, 0);
          __asm { fstp    qword ptr [edi+10h] }
          break;
        case 3:
          v8 = v31;
          if ( !v31 )
          {
            v8 = "1.0";
            v31 = "1.0";
          }
          strtod(v8, 0);
          __asm { fstp    qword ptr [edi+18h] }
          break;
        case 4:
          v9 = v31;
          if ( !v31 )
          {
            v9 = "0.0";
            v31 = "0.0";
          }
          strtod(v9, 0);
          __asm { fstp    qword ptr [edi+20h] }
          break;
        case 5:
          v10 = v31;
          if ( !v31 )
          {
            v10 = "0.0";
            v31 = "0.0";
          }
          strtod(v10, 0);
          __asm { fstp    qword ptr [edi+28h] }
          break;
        case 6:
          v11 = v31;
          if ( !v31 )
          {
            v11 = "0.0";
            v31 = "0.0";
          }
          strtod(v11, 0);
          __asm { fstp    qword ptr [edi+30h] }
          break;
        case 7:
          v12 = v31;
          if ( !v31 )
          {
            v12 = "1.0";
            v31 = "1.0";
          }
          strtod(v12, 0);
          __asm { fstp    qword ptr [edi+38h] }
          break;
        case 8:
          v13 = v31;
          if ( !v31 )
          {
            v13 = "0.0";
            v31 = "0.0";
          }
          strtod(v13, 0);
          __asm { fstp    qword ptr [edi+40h] }
          break;
        case 9:
          v14 = v31;
          if ( !v31 )
          {
            v14 = "0.0";
            v31 = "0.0";
          }
          strtod(v14, 0);
          __asm { fstp    qword ptr [edi+48h] }
          break;
        case 10:
          v15 = v31;
          if ( !v31 )
          {
            v15 = "0.0";
            v31 = "0.0";
          }
          strtod(v15, 0);
          __asm { fstp    qword ptr [edi+50h] }
          break;
        case 11:
          v16 = v31;
          if ( !v31 )
          {
            v16 = "1.0";
            v31 = "1.0";
          }
          strtod(v16, 0);
          __asm { fstp    qword ptr [edi+58h] }
          break;
        default:
          break;
      }
      v3 = (&v19)[4 * v2++];
    }
    while ( strcmp(v3, "END") );
  }
  return v32;
}

//----- (10006C70) --------------------------------------------------------
int __cdecl sub_10006C70(int a1, int a2)
{
  int v2; // ebx@1
  char *v3; // esi@1
  char *v5; // eax@4
  char *v6; // eax@7
  char *v7; // eax@10
  char *v8; // eax@13
  char *v9; // eax@16
  char *v10; // eax@19
  char *v11; // eax@22
  char *v12; // eax@25
  char *v13; // eax@28
  char *v14; // eax@31
  char *v15; // eax@34
  char *v16; // eax@37
  char *v18; // [sp+8h] [bp-3Ch]@1
  char *v19; // [sp+Ch] [bp-38h]@1
  char *v20; // [sp+10h] [bp-34h]@1
  char *v21; // [sp+14h] [bp-30h]@1
  char *v22; // [sp+18h] [bp-2Ch]@1
  char *v23; // [sp+1Ch] [bp-28h]@1
  char *v24; // [sp+20h] [bp-24h]@1
  char *v25; // [sp+24h] [bp-20h]@1
  char *v26; // [sp+28h] [bp-1Ch]@1
  char *v27; // [sp+2Ch] [bp-18h]@1
  char *v28; // [sp+30h] [bp-14h]@1
  char *v29; // [sp+34h] [bp-10h]@1
  char *v30; // [sp+38h] [bp-Ch]@1
  char *v31; // [sp+40h] [bp-4h]@3
  int v32; // [sp+3Ch] [bp-8h]@3

  v3 = "mom_mtsys_origin_x";
  v18 = "mom_mtsys_origin_x";
  v19 = "mom_mtsys_origin_y";
  v20 = "mom_mtsys_origin_z";
  v21 = "mom_mtsys_x_axis_i";
  v22 = "mom_mtsys_x_axis_j";
  v23 = "mom_mtsys_x_axis_k";
  v24 = "mom_mtsys_y_axis_i";
  v25 = "mom_mtsys_y_axis_j";
  v26 = "mom_mtsys_y_axis_k";
  v27 = "mom_mtsys_z_axis_i";
  v28 = "mom_mtsys_z_axis_j";
  v29 = "mom_mtsys_z_axis_k";
  v30 = "END";
  v2 = 0;
  if ( strcmp("mom_mtsys_origin_x", "END") )
  {
    _EDI = a2;
    do
    {
      v32 = UF_MOM_ask_string(a1, v3 + 4, &v31);
      switch ( v2 )
      {
        case 0:
          v5 = v31;
          if ( !v31 )
          {
            v5 = "0.0";
            v31 = "0.0";
          }
          strtod(v5, 0);
          __asm { fstp    qword ptr [edi+60h] }
          break;
        case 1:
          v6 = v31;
          if ( !v31 )
          {
            v6 = "0.0";
            v31 = "0.0";
          }
          strtod(v6, 0);
          __asm { fstp    qword ptr [edi+68h] }
          break;
        case 2:
          v7 = v31;
          if ( !v31 )
          {
            v7 = "0.0";
            v31 = "0.0";
          }
          strtod(v7, 0);
          __asm { fstp    qword ptr [edi+70h] }
          break;
        case 3:
          v8 = v31;
          if ( !v31 )
          {
            v8 = "1.0";
            v31 = "1.0";
          }
          strtod(v8, 0);
          __asm { fstp    qword ptr [edi+78h] }
          break;
        case 4:
          v9 = v31;
          if ( !v31 )
          {
            v9 = "0.0";
            v31 = "0.0";
          }
          strtod(v9, 0);
          __asm { fstp    qword ptr [edi+80h] }
          break;
        case 5:
          v10 = v31;
          if ( !v31 )
          {
            v10 = "0.0";
            v31 = "0.0";
          }
          strtod(v10, 0);
          __asm { fstp    qword ptr [edi+88h] }
          break;
        case 6:
          v11 = v31;
          if ( !v31 )
          {
            v11 = "0.0";
            v31 = "0.0";
          }
          strtod(v11, 0);
          __asm { fstp    qword ptr [edi+90h] }
          break;
        case 7:
          v12 = v31;
          if ( !v31 )
          {
            v12 = "1.0";
            v31 = "1.0";
          }
          strtod(v12, 0);
          __asm { fstp    qword ptr [edi+98h] }
          break;
        case 8:
          v13 = v31;
          if ( !v31 )
          {
            v13 = "0.0";
            v31 = "0.0";
          }
          strtod(v13, 0);
          __asm { fstp    qword ptr [edi+0A0h] }
          break;
        case 9:
          v14 = v31;
          if ( !v31 )
          {
            v14 = "0.0";
            v31 = "0.0";
          }
          strtod(v14, 0);
          __asm { fstp    qword ptr [edi+0A8h] }
          break;
        case 10:
          v15 = v31;
          if ( !v31 )
          {
            v15 = "0.0";
            v31 = "0.0";
          }
          strtod(v15, 0);
          __asm { fstp    qword ptr [edi+0B0h] }
          break;
        case 11:
          v16 = v31;
          if ( !v31 )
          {
            v16 = "1.0";
            v31 = "1.0";
          }
          strtod(v16, 0);
          __asm { fstp    qword ptr [edi+0B8h] }
          break;
        default:
          break;
      }
      v3 = (&v19)[4 * v2++];
    }
    while ( strcmp(v3, "END") );
  }
  return v32;
}

//----- (10006F40) --------------------------------------------------------
int __cdecl sub_10006F40(int a1, int a2)
{
  int v2; // ebx@1
  char *v3; // esi@1
  char *v5; // eax@4
  char *v6; // eax@7
  char *v7; // eax@10
  char *v8; // eax@13
  char *v9; // eax@16
  char *v10; // eax@19
  char *v11; // eax@22
  int v12; // edx@24
  char *v13; // eax@27
  char *v14; // eax@30
  char v16; // cl@25
  char *v17; // [sp+8h] [bp-2Ch]@1
  char *v18; // [sp+Ch] [bp-28h]@1
  char *v19; // [sp+10h] [bp-24h]@1
  char *v20; // [sp+14h] [bp-20h]@1
  char *v21; // [sp+18h] [bp-1Ch]@1
  char *v22; // [sp+1Ch] [bp-18h]@1
  char *v23; // [sp+20h] [bp-14h]@1
  char *v24; // [sp+24h] [bp-10h]@1
  char *v25; // [sp+28h] [bp-Ch]@1
  char *v26; // [sp+2Ch] [bp-8h]@1
  char *v27; // [sp+30h] [bp-4h]@3

  v3 = "mom_origin_x";
  v17 = "mom_origin_x";
  v18 = "mom_origin_y";
  v19 = "mom_origin_z";
  v20 = "mom_translate_x";
  v21 = "mom_translate_y";
  v22 = "mom_translate_z";
  v23 = "mom_tool_type";
  v24 = "mom_tool_z_offset";
  v25 = "mom_tool_corner1_radius";
  v26 = "END";
  v2 = 0;
  if ( strcmp("mom_origin_x", "END") )
  {
    _EDI = a2;
    do
    {
      UF_MOM_ask_string(a1, v3 + 4, &v27);
      switch ( v2 )
      {
        case 0:
          v5 = v27;
          if ( !v27 )
          {
            v5 = "0.0";
            v27 = "0.0";
          }
          strtod(v5, 0);
          __asm { fstp    qword ptr [edi+0D8h] }
          break;
        case 1:
          v6 = v27;
          if ( !v27 )
          {
            v6 = "0.0";
            v27 = "0.0";
          }
          strtod(v6, 0);
          __asm { fstp    qword ptr [edi+0E0h] }
          break;
        case 2:
          v7 = v27;
          if ( !v27 )
          {
            v7 = "0.0";
            v27 = "0.0";
          }
          strtod(v7, 0);
          __asm { fstp    qword ptr [edi+0E8h] }
          break;
        case 3:
          v8 = v27;
          if ( !v27 )
          {
            v8 = "0.0";
            v27 = "0.0";
          }
          strtod(v8, 0);
          __asm { fstp    qword ptr [edi+0C0h] }
          break;
        case 4:
          v9 = v27;
          if ( !v27 )
          {
            v9 = "0.0";
            v27 = "0.0";
          }
          strtod(v9, 0);
          __asm { fstp    qword ptr [edi+0C8h] }
          break;
        case 5:
          v10 = v27;
          if ( !v27 )
          {
            v10 = "0.0";
            v27 = "0.0";
          }
          strtod(v10, 0);
          __asm { fstp    qword ptr [edi+0D0h] }
          break;
        case 6:
          v11 = v27;
          if ( !v27 )
          {
            v11 = "MILL";
            v27 = "MILL";
          }
          v12 = _EDI - (_DWORD)v11 + 240;
          do
          {
            v16 = *v11;
            v11[v12] = *v11;
            ++v11;
          }
          while ( v16 );
          break;
        case 7:
          v13 = v27;
          if ( !v27 )
          {
            v13 = "0.0";
            v27 = "0.0";
          }
          strtod(v13, 0);
          __asm { fstp    qword ptr [edi+178h] }
          break;
        case 8:
          v14 = v27;
          if ( !v27 )
          {
            v14 = "0.0";
            v27 = "0.0";
          }
          strtod(v14, 0);
          __asm { fstp    qword ptr [edi+180h] }
          break;
        default:
          break;
      }
      v3 = (&v18)[4 * v2++];
    }
    while ( strcmp(v3, "END") );
  }
  return 0;
}

//----- (10007190) --------------------------------------------------------
int __cdecl sub_10007190(int a1, int a2)
{
  int v2; // ebx@1
  char *v3; // esi@1
  char *v5; // eax@4
  char *v6; // eax@7
  char *v7; // eax@10
  char *v8; // eax@13
  char *v9; // eax@16
  char *v10; // eax@19
  char *v12; // [sp+8h] [bp-24h]@1
  char *v13; // [sp+Ch] [bp-20h]@1
  char *v14; // [sp+10h] [bp-1Ch]@1
  char *v15; // [sp+14h] [bp-18h]@1
  char *v16; // [sp+18h] [bp-14h]@1
  char *v17; // [sp+1Ch] [bp-10h]@1
  char *v18; // [sp+20h] [bp-Ch]@1
  char *v19; // [sp+28h] [bp-4h]@3
  int v20; // [sp+24h] [bp-8h]@3

  v3 = "mom_mcs_goto_x";
  v12 = "mom_mcs_goto_x";
  v13 = "mom_mcs_goto_y";
  v14 = "mom_mcs_goto_z";
  v15 = "mom_tool_axis_i";
  v16 = "mom_tool_axis_j";
  v17 = "mom_tool_axis_k";
  v18 = "END";
  v2 = 0;
  if ( strcmp("mom_mcs_goto_x", "END") )
  {
    _EDI = a2;
    do
    {
      v20 = UF_MOM_ask_string(a1, v3 + 4, &v19);
      switch ( v2 )
      {
        case 0:
          v5 = v19;
          if ( !v19 )
          {
            v5 = "0.0";
            v19 = "0.0";
          }
          strtod(v5, 0);
          __asm { fstp    qword ptr [edi] }
          break;
        case 1:
          v6 = v19;
          if ( !v19 )
          {
            v6 = "0.0";
            v19 = "0.0";
          }
          strtod(v6, 0);
          __asm { fstp    qword ptr [edi+8] }
          break;
        case 2:
          v7 = v19;
          if ( !v19 )
          {
            v7 = "0.0";
            v19 = "0.0";
          }
          strtod(v7, 0);
          __asm { fstp    qword ptr [edi+10h] }
          break;
        case 3:
          v8 = v19;
          if ( !v19 )
          {
            v8 = "0.0";
            v19 = "0.0";
          }
          strtod(v8, 0);
          __asm { fstp    qword ptr [edi+18h] }
          break;
        case 4:
          v9 = v19;
          if ( !v19 )
          {
            v9 = "0.0";
            v19 = "0.0";
          }
          strtod(v9, 0);
          __asm { fstp    qword ptr [edi+20h] }
          break;
        case 5:
          v10 = v19;
          if ( !v19 )
          {
            v10 = "0.0";
            v19 = "0.0";
          }
          strtod(v10, 0);
          __asm { fstp    qword ptr [edi+28h] }
          break;
        default:
          break;
      }
      v3 = (&v13)[4 * v2++];
    }
    while ( strcmp(v3, "END") );
  }
  return v20;
}

//----- (10007340) --------------------------------------------------------
int __cdecl sub_10007340(int a1, char *a2)
{
  int v2; // ebx@1
  char *v3; // edi@1
  char *v5; // eax@3
  char *v6; // eax@6
  char *v7; // eax@9
  char *v8; // eax@12
  char *v9; // eax@15
  char *v10; // eax@18
  char *v11; // eax@21
  char *v12; // eax@24
  char *v13; // eax@27
  int result; // eax@31
  char *v15; // [sp+Ch] [bp-2Ch]@1
  char *v16; // [sp+10h] [bp-28h]@1
  char *v17; // [sp+14h] [bp-24h]@1
  char *v18; // [sp+18h] [bp-20h]@1
  char *v19; // [sp+1Ch] [bp-1Ch]@1
  char *v20; // [sp+20h] [bp-18h]@1
  char *v21; // [sp+24h] [bp-14h]@1
  char *v22; // [sp+28h] [bp-10h]@1
  char *v23; // [sp+2Ch] [bp-Ch]@1
  char *v24; // [sp+30h] [bp-8h]@1
  int v25; // [sp+34h] [bp-4h]@2

  v3 = "mom_origin_x";
  v15 = "mom_origin_x";
  v16 = "mom_origin_y";
  v17 = "mom_origin_z";
  v18 = "mom_translate_x";
  v19 = "mom_translate_y";
  v20 = "mom_translate_z";
  v21 = "mom_tool_z_offset";
  v22 = "mom_kin_track_center_of_ball";
  v23 = "mom_tool_corner1_radius";
  v24 = "END";
  v2 = 0;
  for ( _ESI = a2; strcmp(v3, "END"); ++v2 )
  {
    v25 = UF_MOM_ask_string(a1, v3 + 4, &a2);
    switch ( v2 )
    {
      case 0:
        v5 = a2;
        if ( !a2 )
        {
          v5 = "0.0";
          a2 = "0.0";
        }
        strtod(v5, 0);
        __asm { fstp    qword ptr [esi] }
        break;
      case 1:
        v6 = a2;
        if ( !a2 )
        {
          v6 = "0.0";
          a2 = "0.0";
        }
        strtod(v6, 0);
        __asm { fstp    qword ptr [esi+8] }
        break;
      case 2:
        v7 = a2;
        if ( !a2 )
        {
          v7 = "0.0";
          a2 = "0.0";
        }
        strtod(v7, 0);
        __asm { fstp    qword ptr [esi+10h] }
        break;
      case 3:
        v8 = a2;
        if ( !a2 )
        {
          v8 = "0.0";
          a2 = "0.0";
        }
        strtod(v8, 0);
        __asm { fstp    qword ptr [esi+60h] }
        break;
      case 4:
        v9 = a2;
        if ( !a2 )
        {
          v9 = "0.0";
          a2 = "0.0";
        }
        strtod(v9, 0);
        __asm { fstp    qword ptr [esi+68h] }
        break;
      case 5:
        v10 = a2;
        if ( !a2 )
        {
          v10 = "0.0";
          a2 = "0.0";
        }
        strtod(v10, 0);
        __asm { fstp    qword ptr [esi+70h] }
        break;
      case 6:
        v11 = a2;
        if ( !a2 )
        {
          v11 = "0.0";
          a2 = "0.0";
        }
        strtod(v11, 0);
        __asm { fstp    qword ptr [esi+78h] }
        break;
      case 7:
        v12 = a2;
        if ( !a2 )
        {
          v12 = "0.0";
          a2 = "0.0";
        }
        strtod(v12, 0);
        *((_DWORD *)_ESI + 32) = sub_10007C70();
        break;
      case 8:
        v13 = a2;
        if ( !a2 )
        {
          v13 = "0.0";
          a2 = "0.0";
        }
        strtod(v13, 0);
        __asm { fstp    qword ptr [esi+88h] }
        break;
      default:
        break;
    }
    v3 = (&v16)[4 * v2];
  }
  result = v25;
  memcpy(&unk_1000C5E0, _ESI, 0x90u);
  return result;
}

//----- (10007590) --------------------------------------------------------
int __cdecl sub_10007590(int a1, int a2)
{
  int v2; // esi@1
  int *v4; // ST24_4@2
  __int64 v5; // ST1C_8@2
  int v6; // ebx@5
  __int64 v7; // [sp+18h] [bp-78h]@1
  char v16; // [sp+78h] [bp-18h]@5
  char v17; // [sp+60h] [bp-30h]@5

  __asm
  {
    fld     dbl_1000C5F8
    fstp    [ebp+var_78]
    fld     dbl_1000C610
    fstp    [ebp+var_60]
  }
  v2 = a1;
  __asm
  {
    fld     dbl_1000C628
    fstp    [ebp+var_48]
    fld     dbl_1000C600
    fstp    [ebp+var_70]
    fld     dbl_1000C618
    fstp    [ebp+var_58]
    fld     dbl_1000C630
    fstp    [ebp+var_40]
    fld     dbl_1000C608
    fstp    [ebp+var_68]
    fld     dbl_1000C620
    fstp    [ebp+var_50]
    fld     dbl_1000C638
    fstp    [ebp+var_38]
  }
  if ( !dword_1000C670 )
  {
    __asm { fld     ds:dbl_1000AD98 }
    v4 = &a1;
    __asm { fstp    [esp+90h+var_90] }
    UF_VEC3_is_equal(a1 + 24, &dbl_1000C628, v5, *((_DWORD *)&v5 + 1), v4);
    if ( !a1 )
    {
      printf("WARNING  The tool axis is not matching with the                 rotated MCS-Z axis. The output may be INCORRECT\n");
      uc1601(
        "WARNING  The tool axis is not matching with the *                     rotated MCS-Z axis. The output may be INCORRECT\n",
        1);
    }
    dword_1000C670 = 1;
  }
  UF_VEC3_copy(v2, &v16);
  UF_VEC3_copy(v2 + 24, &v17);
  v6 = a2;
  UF_MTX3_vec_multiply(v2, &v7, a2);
  UF_MTX3_vec_multiply(v2 + 24, &v7, v6 + 24);
  return 0;
}

//----- (10007690) --------------------------------------------------------
int __cdecl sub_10007690(int a1, int a2)
{
  int v2; // esi@1
  int v4; // ebx@1
  char *v5; // ST1C_4@1
  int v6; // ST18_4@1
  __int64 v7; // ST10_8@1
  char *v8; // ST1C_4@2
  int v9; // ST18_4@2
  __int64 v10; // ST10_8@2
  char v11; // [sp+1Ch] [bp-18h]@1

  v4 = a1;
  v2 = a2;
  UF_VEC3_add(a1, &unk_1000C640, a2);
  UF_VEC3_sub(v4, &unk_1000C5E0, v2);
  UF_VEC3_copy(v4 + 24, v2 + 24);
  __asm { fld     dbl_1000C658 }
  v5 = &v11;
  v6 = v2 + 24;
  __asm { fstp    [esp+34h+var_34] }
  UF_VEC3_scale(v7, *((_DWORD *)&v7 + 1), v6, v5);
  UF_VEC3_add(v2, &v11, v2);
  if ( dword_1000C660 == 1 )
  {
    __asm { fld     dbl_1000C668 }
    v8 = &v11;
    v9 = v2 + 24;
    __asm { fstp    [esp+34h+var_34] }
    UF_VEC3_scale(v10, *((_DWORD *)&v10 + 1), v9, v8);
    UF_VEC3_add(v2, &v11, v2);
  }
  return 0;
}

//----- (10007730) --------------------------------------------------------
int __usercall sub_10007730<eax>(int a1<ebx>, int a2<edi>, int a3<esi>, int a4, int a5, int a6)
{
  char *v6; // edi@1
  int v8; // eax@2
  int v9; // eax@3
  int v10; // edi@10
  char *v11; // esi@11
  char *v13; // ST14_4@8
  __int64 v14; // ST0C_8@8
  __int64 v19; // [sp+110h] [bp-58h]@1
  int v28; // [sp+164h] [bp-4h]@1
  char v30; // [sp+18h] [bp-150h]@1
  signed int v31; // [sp+160h] [bp-8h]@1
  char v33; // [sp+F0h] [bp-78h]@5

  __asm
  {
    fld1
    fst     [ebp+var_58]
    fldz
    fst     [ebp+var_50]
    fst     [ebp+var_48]
    fst     [ebp+var_40]
    fst     [ebp+var_30]
    fst     [ebp+var_28]
    fstp    [ebp+var_20]
    fst     [ebp+var_38]
    fst     [ebp+var_18]
  }
  CIasin(a2, a3, a1);
  __asm { fmul    ds:dbl_1000ADA0 }
  v28 = 0;
  __asm { fst     [ebp+var_60] }
  v6 = &v30;
  __asm { fld     ds:dbl_100099C8 }
  _ESI = a6 + 8;
  v31 = 3;
  do
  {
    __asm { fld     qword ptr [esi-8] }
    v8 = sub_10007C70() - 1;
    if ( v8 )
    {
      v9 = v8 - 1;
      if ( v9 )
      {
        if ( v9 != 1 )
          goto LABEL_9;
        __asm
        {
          fld     qword ptr [esi]
          fmulp   st(2), st
          fmulp   st(1), st
          fstp    [ebp+var_10]
        }
        UF_MTX3_z_vec(&v19, &v33);
      }
      else
      {
        __asm
        {
          fld     qword ptr [esi]
          fmulp   st(2), st
          fmulp   st(1), st
          fstp    [ebp+var_10]
        }
        UF_MTX3_y_vec(&v19, &v33);
      }
    }
    else
    {
      __asm
      {
        fld     qword ptr [esi]
        fmulp   st(2), st
        fmulp   st(1), st
        fstp    [ebp+var_10]
      }
      UF_MTX3_x_vec(&v19, &v33);
    }
    __asm { fld     [ebp+var_10] }
    v13 = v6;
    __asm { fstp    [esp+15Ch+var_15C] }
    UF_MTX3_rotate_about_axis(&v33, v14, *((_DWORD *)&v14 + 1), v13);
    __asm { fld     [ebp+var_60] }
    ++v28;
    __asm { fld     ds:dbl_100099C8 }
    v6 += 72;
LABEL_9:
    _ESI += 16;
  }
  while ( v31-- != 1 );
  v10 = v28;
  __asm
  {
    fstp    st(1)
    fstp    st
  }
  if ( v28 > 0 )
  {
    v11 = &v30;
    do
    {
      UF_MTX3_multiply(&v19, v11, &v19);
      v11 += 72;
      --v10;
    }
    while ( v10 );
  }
  _EAX = a5;
  __asm
  {
    fld     [ebp+var_58]
    fstp    qword ptr [eax+18h]
    fld     [ebp+var_40]
    fstp    qword ptr [eax+30h]
  }
  dword_1000C670 = 0;
  __asm
  {
    fld     [ebp+var_28]
    fstp    qword ptr [eax+48h]
    fld     [ebp+var_50]
    fstp    qword ptr [eax+20h]
    fld     [ebp+var_38]
    fstp    qword ptr [eax+38h]
    fld     [ebp+var_20]
    fstp    qword ptr [eax+50h]
    fld     [ebp+var_48]
    fstp    qword ptr [eax+28h]
    fld     [ebp+var_30]
    fstp    qword ptr [eax+40h]
    fld     [ebp+var_18]
    fstp    qword ptr [eax+58h]
  }
  return 0;
}

//----- (100078F0) --------------------------------------------------------
signed int __stdcall sub_100078F0(int a1, void *a2, int a3)
{
  void *v3; // edi@5
  void *v4; // ST08_4@5
  PVOID v6; // eax@9
  int v7; // eax@13
  int v8; // ST08_4@20
  void *v9; // edi@24
  PVOID v10; // eax@27
  int v11; // ecx@33
  unsigned int v12; // edi@33
  int v13; // eax@37
  int v14; // eax@32
  int v15; // eax@33
  int v16; // ST08_4@33
  int v17; // ecx@37
  int v18; // ST08_4@40
  int v19; // eax@40
  signed int v20; // [sp+4h] [bp-4h]@24
  int v21; // [sp+0h] [bp-8h]@37

  if ( !a2 )
  {
    if ( dword_1000C674 <= 0 )
      return 0;
    --dword_1000C674;
  }
  dword_1000C9B0 = (int)adjust_fdiv;
  if ( a2 == (void *)1 )
  {
    v3 = *(void **)(*MK_FP(__FS__, 24) + 4);
    a2 = 0;
    v4 = 0;
    while ( 1 )
    {
      v6 = InterlockedCompareExchange(&Destination, v3, v4);
      if ( !v6 )
        break;
      if ( v6 == v3 )
      {
        a2 = (void *)1;
        break;
      }
      Sleep(0x3E8u);
      v4 = 0;
    }
    if ( dword_1000C9B4 )
    {
      v7 = amsg_exit(31);
    }
    else
    {
      dword_1000C9B4 = 1;
      if ( initterm_e(&unk_10009170, &unk_1000917C) )
        return 0;
      v7 = initterm(&unk_10009168);
      dword_1000C9B4 = 2;
    }
    if ( !a2 )
      v7 = InterlockedExchange((__int32 *)&Destination, 0);
    if ( dword_1000C9C4 )
    {
      if ( sub_10007EC0(v7, (int)&dword_1000C9C4) )
        dword_1000C9C4(v8, a1, 2, a3);
    }
    ++dword_1000C674;
  }
  else
  {
    if ( !a2 )
    {
      v9 = *(void **)(*MK_FP(__FS__, 24) + 4);
      v20 = 0;
      while ( 1 )
      {
        v10 = InterlockedCompareExchange(&Destination, v9, 0);
        if ( !v10 )
          break;
        if ( v10 == v9 )
        {
          v20 = 1;
          break;
        }
        Sleep(0x3E8u);
      }
      if ( dword_1000C9B4 == 2 )
      {
        v14 = decode_pointer(dword_1000C9C0);
        a2 = (void *)v14;
        if ( v14 )
        {
          v15 = decode_pointer(dword_1000C9BC);
          v12 = v15;
          v11 = v16;
          a3 = (int)a2;
          a1 = v15;
          while ( 1 )
          {
            v12 -= 4;
            if ( v12 < (unsigned int)a2 )
              break;
            if ( *(_DWORD *)v12 )
            {
              if ( *(_DWORD *)v12 != encoded_null(v11) )
              {
                v21 = decode_pointer(*(_DWORD *)v12);
                *(_DWORD *)v12 = encoded_null(v17);
                ((int (*)(void))v21)();
                v21 = decode_pointer(dword_1000C9C0);
                v13 = decode_pointer(dword_1000C9BC);
                v11 = v21;
                if ( a3 != v21 || a1 != v13 )
                {
                  a3 = v21;
                  a2 = (void *)v21;
                  a1 = v13;
                  v12 = v13;
                }
              }
            }
          }
          free(a2);
          v19 = encoded_null(v18);
          dword_1000C9BC = v19;
          dword_1000C9C0 = v19;
        }
        dword_1000C9B4 = 0;
        if ( !v20 )
          InterlockedExchange((__int32 *)&Destination, 0);
      }
      else
      {
        amsg_exit(31);
      }
    }
  }
  return 1;
}

//----- (10007B16) --------------------------------------------------------
int __fastcall sub_10007B16(int a1, int a2, HMODULE hLibModule)
{
  HMODULE v3; // ebx@1
  int v4; // edi@1
  signed int v5; // esi@1
  int v6; // eax@10
  signed int v7; // eax@16
  signed int v9; // eax@9
  int v10; // [sp+14h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+18h] [bp-18h]@1

  v4 = a1;
  v5 = a2;
  v3 = hLibModule;
  v10 = 1;
  dword_1000C230 = a2;
  ms_exc.disabled = 1;
  if ( a2 || dword_1000C674 )
  {
    if ( a2 != 1 && a2 != 2 )
      goto LABEL_24;
    if ( dword_1000ADA8 )
      v10 = dword_1000ADA8(hLibModule, a2, a1);
    if ( v10 )
    {
      v9 = sub_100078F0((int)v3, (void *)v5, v4);
      v10 = v9;
      if ( v9 )
      {
LABEL_24:
        v6 = sub_10007F96(v3, v5, v4);
        v10 = v6;
        if ( v5 == 1 )
        {
          if ( !v6 )
          {
            sub_10007F96(v3, v6, v4);
            sub_100078F0((int)v3, 0, v4);
            if ( dword_1000ADA8 )
              dword_1000ADA8(v3, 0, v4);
          }
        }
        if ( !v5 || v5 == 3 )
        {
          v7 = sub_100078F0((int)v3, (void *)v5, v4);
          if ( !v7 )
            v10 &= v7;
          if ( v10 )
          {
            if ( dword_1000ADA8 )
              v10 = dword_1000ADA8(v3, v5, v4);
          }
        }
      }
    }
  }
  else
  {
    v10 = 0;
  }
  sub_10007C21();
  return v10;
}

//----- (10007C21) --------------------------------------------------------
void __cdecl sub_10007C21()
{
  dword_1000C230 = -1;
}

//----- (10007C2C) --------------------------------------------------------
BOOL __stdcall DllEntryPoint(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)
{
  if ( fdwReason == 1 )
    sub_1000803A();
  return sub_10007B16((int)lpReserved, fdwReason, hinstDLL);
}

//----- (10007C70) --------------------------------------------------------
int __cdecl sub_10007C70()
{
  __int64 v1; // [sp+18h] [bp-Ch]@2
  __int64 v2; // [sp+10h] [bp-14h]@3
  int v3; // [sp+0h] [bp-24h]@5

  if ( dword_1000C9AC )
  {
    __asm
    {
      fstp    [esp+0Ch+var_C]
      cvttsd2si eax, [esp+0Ch+var_C]
    }
  }
  else
  {
    __asm
    {
      fld     st
      fst     dword ptr [esp+24h+var_C]
      fistp   [esp+24h+var_14]
      fild    [esp+24h+var_14]
    }
    *((_DWORD *)&_QAX + 1) = v1;
    *(_DWORD *)&_QAX = v2;
    if ( (_DWORD)v2 || (*((_DWORD *)&_QAX + 1) = *((_DWORD *)&v2 + 1), *((_DWORD *)&v2 + 1) & 0x7FFFFFFF) )
    {
      __asm { fsubp   st(1), st }
      if ( *((_DWORD *)&_QAX + 1) >= 0 )
      {
        __asm { fstp    [esp+24h+var_24] }
        _QAX = v2 - __MKCADD__(2147483647, v3);
      }
      else
      {
        __asm { fstp    [esp+24h+var_24] }
        _QAX = __MKCADD__(2147483647, v3 ^ 0x80000000) + v2;
      }
    }
    else
    {
      __asm
      {
        fstp    dword ptr [esp+24h+var_C]
        fstp    dword ptr [esp+24h+var_C]
      }
    }
  }
  return _QAX;
}

//----- (10007D1B) --------------------------------------------------------
int __cdecl sub_10007D1B()
{
  return _clean_type_info_names_internal(&unk_1000C67C);
}

//----- (10007D27) --------------------------------------------------------
_onexit_t __cdecl sub_10007D27(_onexit_t a1)
{
  _onexit_t result; // eax@2
  int v2; // eax@1
  int v3; // eax@3
  int v4; // [sp+18h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+1Ch] [bp-18h]@3
  int v6; // [sp+14h] [bp-20h]@3
  int v7; // [sp+10h] [bp-24h]@3

  v2 = decode_pointer(dword_1000C9C0);
  v4 = v2;
  if ( v2 == -1 )
  {
    result = onexit(a1);
  }
  else
  {
    lock(8);
    ms_exc.disabled = 0;
    v4 = decode_pointer(dword_1000C9C0);
    v6 = decode_pointer(dword_1000C9BC);
    v3 = encode_pointer(a1);
    v7 = _dllonexit(v3, &v4, &v6);
    dword_1000C9C0 = encode_pointer(v4);
    dword_1000C9BC = encode_pointer(v6);
    ms_exc.disabled = -2;
    sub_10007DC3();
    result = (_onexit_t)v7;
  }
  return result;
}

//----- (10007DC3) --------------------------------------------------------
int __cdecl sub_10007DC3()
{
  return unlock(8);
}

//----- (10007DCC) --------------------------------------------------------
int __cdecl sub_10007DCC(_onexit_t a1)
{
  return (sub_10007D27(a1) != 0) - 1;
}

//----- (10007DE3) --------------------------------------------------------
int (*__cdecl sub_10007DE3())(void)
{
  int (*result)(void); // eax@1
  unsigned int v1; // edi@1

  result = (int (*)(void))&unk_1000AE58;
  v1 = (unsigned int)&unk_1000AE58;
  if ( &unk_1000AE58 < &unk_1000AE58 )
  {
    do
    {
      result = *(int (**)(void))v1;
      if ( *(_DWORD *)v1 )
        result = (int (*)(void))result();
      v1 += 4;
    }
    while ( v1 < (unsigned int)&unk_1000AE58 );
  }
  return result;
}

//----- (10007E30) --------------------------------------------------------
bool __cdecl sub_10007E30(int a1)
{
  bool result; // eax@2
  int v2; // eax@3

  if ( *(_WORD *)a1 != 23117 || (v2 = a1 + *(_DWORD *)(a1 + 60), *(_DWORD *)v2 != 17744) )
    result = 0;
  else
    result = *(_WORD *)(v2 + 24) == 267;
  return result;
}

//----- (10007E70) --------------------------------------------------------
int __cdecl sub_10007E70(int a1, unsigned int a2)
{
  int result; // eax@1
  unsigned int v3; // edx@1
  unsigned int v4; // esi@1
  unsigned int v5; // ecx@2
  int v6; // ecx@1

  v6 = a1 + *(_DWORD *)(a1 + 60);
  v4 = *(_WORD *)(v6 + 6);
  v3 = 0;
  result = *(_WORD *)(v6 + 20) + v6 + 24;
  if ( v4 )
  {
    while ( 1 )
    {
      v5 = *(_DWORD *)(result + 12);
      if ( a2 >= v5 )
      {
        if ( a2 < v5 + *(_DWORD *)(result + 8) )
          break;
      }
      ++v3;
      result += 40;
      if ( v3 >= v4 )
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    result = 0;
  }
  return result;
}

//----- (10007EC0) --------------------------------------------------------
unsigned int __usercall sub_10007EC0<eax>(int a1<eax>, int a2)
{
  int v2; // eax@2
  unsigned int result; // eax@3
  int (__cdecl *v4)(int, int, int, int); // [sp+Ch] [bp-Ch]@1
  int v5; // [sp+8h] [bp-10h]@1
  unsigned int v6; // [sp+10h] [bp-8h]@1
  int v7; // [sp-10h] [bp-28h]@1
  int *v8; // [sp+0h] [bp-18h]@1
  int v9; // [sp+14h] [bp-4h]@1

  v4 = sub_10008015;
  v5 = a1;
  v6 = dword_1000C238 ^ (unsigned int)&unk_1000AEB0;
  v8 = &v7;
  v9 = 0;
  if ( sub_10007E30(268435456) && (v2 = sub_10007E70(268435456, a2 - 268435456), v2) )
    result = ~(unsigned __int8)(*(_DWORD *)(v2 + 36) >> 31) & 1;
  else
    result = 0;
  return result;
}

//----- (10007F96) --------------------------------------------------------
signed int __stdcall sub_10007F96(HMODULE hLibModule, int a2, int a3)
{
  if ( a2 == 1 )
  {
    if ( !dword_1000ADA8 )
      DisableThreadLibraryCalls(hLibModule);
  }
  return 1;
}

//----- (10008015) --------------------------------------------------------
int __cdecl sub_10008015(int a1, int a2, int a3, int a4)
{
  return except_handler4_common(&dword_1000C238, sub_100081A8, a1, a2, a3, a4);
}

//----- (1000803A) --------------------------------------------------------
unsigned __int32 __cdecl sub_1000803A()
{
  unsigned __int32 result; // eax@3
  int v1; // esi@4
  unsigned __int32 v2; // esi@4
  unsigned __int32 v3; // esi@4
  unsigned __int32 v4; // esi@4
  struct _FILETIME SystemTimeAsFileTime; // [sp+10h] [bp-8h]@1
  LARGE_INTEGER PerformanceCount; // [sp+8h] [bp-10h]@4

  SystemTimeAsFileTime.dwLowDateTime = 0;
  SystemTimeAsFileTime.dwHighDateTime = 0;
  if ( dword_1000C238 != -1153374642 && dword_1000C238 & 0xFFFF0000 )
  {
    result = ~dword_1000C238;
    dword_1000C23C = ~dword_1000C238;
  }
  else
  {
    GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
    v2 = GetCurrentProcessId() ^ SystemTimeAsFileTime.dwLowDateTime ^ SystemTimeAsFileTime.dwHighDateTime;
    v3 = GetCurrentThreadId() ^ v2;
    v4 = GetTickCount() ^ v3;
    QueryPerformanceCounter(&PerformanceCount);
    result = PerformanceCount.LowPart ^ PerformanceCount.HighPart;
    v1 = PerformanceCount.LowPart ^ PerformanceCount.HighPart ^ v4;
    if ( v1 == -1153374642 )
    {
      v1 = -1153374641;
    }
    else
    {
      if ( !(v1 & 0xFFFF0000) )
      {
        result = v1 << 16;
        v1 |= v1 << 16;
      }
    }
    dword_1000C238 = v1;
    dword_1000C23C = ~v1;
  }
  return result;
}

//----- (100080D0) --------------------------------------------------------
signed int __cdecl sub_100080D0()
{
  __asm { movapd  xmm0, xmm1 }
  return 1;
}

//----- (10008120) --------------------------------------------------------
bool __usercall sub_10008120<eax>(int a1<ebx>)
{
  int v10; // [sp+18h] [bp-4h]@1
  int v11; // [sp+10h] [bp-Ch]@1
  signed int v12; // [sp+14h] [bp-8h]@1
  int v13; // [sp+4h] [bp-18h]@2
  int v14; // [sp+8h] [bp-14h]@2
  int v15; // [sp+Ch] [bp-10h]@2

  v10 = 0;
  v11 = 0;
  v12 = 0;
  __asm
  {
    pushf
    popf
    pushf
  }
  if ( (a1 ^ 0x200000) != a1 )
  {
    __asm
    {
      popf
      cpuid
    }
    v11 = 0;
    v13 = a1;
    v14 = (a1 ^ 0x200000) - a1;
    v15 = a1;
    __asm { cpuid }
    v10 = (a1 ^ 0x200000) - a1;
    v12 = 1;
  }
  return v10 & 0x4000000 && sub_100080D0();
}

//----- (10008182) --------------------------------------------------------
int __usercall sub_10008182<eax>(int a1<ebx>)
{
  dword_1000C9AC = sub_10008120(a1);
  return 0;
}

//----- (100081A8) --------------------------------------------------------
BOOL __usercall sub_100081A8<eax>(int a1<eax>, int a2<edx>, int a3<ecx>, int a4<ebx>, int a5<edi>, int a6<esi>, char a7)
{
  if ( a3 == dword_1000C238 )
    __asm { rep retn }
  return sub_100081BE(a1, a2, a3, a4, a5, a6, a7);
}

//----- (100081BE) --------------------------------------------------------
BOOL __usercall sub_100081BE<eax>(int a1<eax>, int a2<edx>, int a3<ecx>, int a4<ebx>, int a5<edi>, int a6<esi>, char a7)
{
  int ST04_4_0; // ST04_4@0
  HANDLE v9; // eax@3
  int  s; // [sp+328h] [bp+0h]@1
  int  r; // [sp+32Ch] [bp+4h]@1
  int v12; // [sp+0h] [bp-328h]@1
  int v13; // [sp+4h] [bp-324h]@1

  dword_1000C790 = a1;
  dword_1000C78C = a3;
  dword_1000C788 = a2;
  dword_1000C784 = a4;
  dword_1000C780 = a6;
  dword_1000C77C = a5;
  word_1000C7A8 = __SS__;
  word_1000C79C = __CS__;
  word_1000C778 = __DS__;
  word_1000C774 = __ES__;
  word_1000C770 = __FS__;
  word_1000C76C = __GS__;
  __asm { pushf }
  dword_1000C7A0 = ST04_4_0;
  dword_1000C794 =  s;
  dword_1000C798 =  r;
  dword_1000C7A4 = (int)&a7;
  dword_1000C6E0 = 65537;
  dword_1000C694 = dword_1000C798;
  dword_1000C688 = -1073740791;
  dword_1000C68C = 1;
  v12 = dword_1000C238;
  v13 = dword_1000C23C;
  dword_1000C6D8 = IsDebuggerPresent();
  crt_debugger_hook(1);
  SetUnhandledExceptionFilter(0);
  UnhandledExceptionFilter(&ExceptionInfo);
  if ( !dword_1000C6D8 )
    crt_debugger_hook(1);
  v9 = GetCurrentProcess();
  return TerminateProcess(v9, 0xC0000409u);
}

// ALL OK, 72 function(s) have been successfully decompiled
