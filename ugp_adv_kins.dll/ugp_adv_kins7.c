/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

signed int __cdecl sub_10001000(char *a1, const void *a2, _DWORD *a3, int a4, _DWORD *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8, const void *a9);
int __cdecl sub_10001F10(int a1, int a2, char a3, int a4, int a5);
signed int __cdecl sub_10001F50(int a1, int a2);
int __cdecl sub_10002060(char *a1, char *a2, int a3);
double __cdecl sub_10002140(int a1, int a2, int a3);
signed int __cdecl sub_10002170(_DWORD *a1, _DWORD *a2, _DWORD *a3);
void __cdecl sub_100023B0(int a1, int a2, double *a3, double *a4);
double __cdecl sub_10002500(double a1);
int __cdecl sub_10002530(_DWORD *a1);
signed int __cdecl sub_10002590(_DWORD *a1, int a2, int *a3);
long double __cdecl sub_100035B0(double a1);
int __cdecl sub_10003600(int, double, double, int, int); // idb
int __cdecl sub_100037A0(int, double, int, int, int); // idb
int __cdecl sub_10003820(int, double, int); // idb
int __cdecl sub_10003870(double, int, int); // idb
int __cdecl sub_10003990(int a1, int a2, double *a3);
int __cdecl PtFuncCompare(const void *, const void *); // idb
void __cdecl sub_10003CD0(double *a1, int a2);
int __cdecl sub_10003EC0(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_10004150(int a1, int a2, int a3, double *a4);
signed int __cdecl sub_10004230(_DWORD *a1, int a2, int a3, double *a4);
int __cdecl sub_10004510(_DWORD *a1, int a2, int a3, int a4);
double __cdecl sub_10004600(double *a1, long double *a2);
signed int __cdecl sub_100046A0(int a1);
signed int __cdecl sub_100046E0(int a1);
int __cdecl sub_10004810(int a1, int a2);
int sub_10004C90(int a1, int a2, ...);
int __cdecl sub_10004CB0(int, char *Str); // idb
int __cdecl sub_10004EF0(int, char *Str); // idb
int __cdecl sub_100050A0(int, char *Str); // idb
int __cdecl sub_100052F0(int a1, int a2);
int __cdecl sub_10005700(int a1, int a2);
int __cdecl sub_10005B10(int, char *Str); // idb
int __cdecl sub_10005C60(int, char *Str); // idb
int __cdecl sub_10005DA0(int a1, int a2);
int __cdecl sub_100063B0(int a1, double *a2);
int __cdecl sub_100066D0(int a1, double *a2);
int __cdecl sub_10006A00(int, char *Str); // idb
int __cdecl sub_10006CA0(int, char *Str); // idb
int __cdecl sub_10006E90(int a1, double *a2);
int __cdecl sub_10007130(int a1, int a2);
int __cdecl sub_10007220(int a1, int a2);
int __cdecl sub_100072C0(int a1, int a2, int a3);
int __cdecl ufusr(int a1, _DWORD *a2);
int __cdecl sub_10007670(int a1, int a2, int a3, int a4);
int __cdecl sub_100076F0(char *Dest); // idb
signed int sub_100077B0();
signed int __cdecl sub_100078F0(int a1, int a2, signed int a3, int a4);
int __cdecl sub_10007B50(int a1);
signed int __cdecl sub_10007C40(int a1);
int __cdecl sub_100081E0(int a1);
signed int __cdecl sub_10008300(int a1, int a2, int a3, int a4);
// char *__cdecl strstr(const char *Str, const char *SubStr);
// int __cdecl atoi(const char *Str);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Memory);
// time_t __cdecl static mktime(struct tm *Tm);
// struct tm *__cdecl static localtime(const time_t *Time);
// time_t __cdecl static time(time_t *Time);
// int sprintf(char *Dest, const char *Format, ...);
// double __cdecl strtod(const char *Str, char **EndPtr);
// double __cdecl ceil(double x); idb
// double __cdecl floor(double x); idb
// void __cdecl qsort(void *Base, size_t NumOfElements, size_t SizeOfElements, int (__cdecl *PtFuncCompare)(const void *, const void *));
// int printf(const char *Format, ...);
// int __cdecl UF_MTX4_vec3_multiply_t(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_free(_DWORD); weak
// int __cdecl UF_MTX4_rotation(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_ask_rotation(_DWORD, _DWORD); weak
// int __cdecl UF_allocate_memory(_DWORD, _DWORD); weak
// int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_rotate_about_axis(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int UF_MOM_extend_xlator(_DWORD, _DWORD, const char *, ...); weak
// int __cdecl UF_MTX4_edit_rotation(_DWORD, _DWORD); weak
// int __cdecl UF_MTX4_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_vec3_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_get_fail_message(_DWORD, _DWORD); weak
// int __cdecl UF_get_release(_DWORD); weak
// int UF_initialize(void); weak
// int __cdecl UF_MISC_set_program_name(_DWORD); weak
// int __cdecl UF_MOM_set_double(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MOM_set_string(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_ATTR_read_value(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_OBJ_cycle_by_name(_DWORD, _DWORD); weak
// int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_dot(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_vec_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_is_zero(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_affine_comb(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_add(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_scale(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_angle_between(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_copy(_DWORD, _DWORD); weak
// int __cdecl UF_MTX4_csys_to_csys(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_copy(_DWORD, _DWORD); weak
// int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_is_parallel(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_cross(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_x_vec(_DWORD, _DWORD); weak
// int __cdecl UF_MTX3_y_vec(_DWORD, _DWORD); weak
// int __cdecl UF_MTX3_z_vec(_DWORD, _DWORD); weak
// int __cdecl UF_VEC3_is_equal(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_vec_multiply_t(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_distance(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_vec_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MOM_ask_mom(_DWORD, _DWORD); weak
// int __cdecl UF_MOM_ask_interp_from_param(_DWORD, _DWORD); weak
// int UF_terminate(void); weak
// int __cdecl uc1601(_DWORD, _DWORD); weak

//-------------------------------------------------------------------------
// Data declarations

// extern _UNKNOWN UF_terminate; weak
_UNKNOWN unk_10009110; // weak
_UNKNOWN unk_10009158; // weak
_UNKNOWN unk_100091A0; // weak
double dbl_1000A010 =  1.0e-10; // weak
int dword_1000A018 = 65793; // weak
char aInitT11InitT21[] = "Init_T1[1], Init_T2[1] = (%f,%f)\n"; // idb
char aInitT10InitT20[] = "Init_T1[0], Init_T2[0] = (%f,%f)\n"; // idb
char aA1FD1FAlpha1FA[] = "A1=%f,D1=%f,Alpha1=%f,A2=%f,D2=%f,Alpha2=%f\n"; // idb
char aWarningToolAxi[] = "WARNING: Tool axis is parallelled with secondary axis that may cause unresolved rotaries"; // idb
char aLocalSecondary[] = "local SecondaryAxis=(%f,%f,%f)\n"; // idb
char aLocalPrimaryax[] = "local PrimaryAxis=(%f,%f,%f)\n"; // idb
char aSulzerCase[] = "Sulzer case:\n"; // idb
char aMcsysFFFFFFFFF[] = "Mcsys= (%f,%f,%f) (%f,%f,%f) (%f,%f,%f)  (%f,%f,%f)\n"; // idb
char aToolVectorFFF[] = "tool_vector=(%f,%f,%f)\n"; // idb
char aToolMachineCen[] = "tool_machine_center=(%f,%f,%f)\n"; // idb
char aSecondaryMachi[] = "secondary_machine_center=(%f,%f,%f)\n"; // idb
char aSecondaryFFF[] = "secondary=(%f,%f,%f)\n"; // idb
char aPrimaryMachine[] = "primary_machine_center=(%f,%f,%f)\n"; // idb
char aPrimaryFFF[] = "primary=(%f,%f,%f)\n"; // idb
char aIs5AxisHeadTab[] = "is_5_axis_head_table\n"; // idb
char aIs5AxisDualHea[21] = "is_5_axis_dual_head\n"; // weak
char aIs5AxisDualTab[22] = "is_5_axis_dual_table\n"; // weak
char aIsOrthogonalCa[] = "Is_orthogonal_case = %d, "; // idb
char Format[] = "\n\n======================================================================\n"; // idb
char aFinalUfuncAltM[] = "final ufunc alt_mcoord[] = (%f,%f,%f), (%f,%f)\n"; // idb
char aFinalUfuncMcoo[] = "final ufunc mcoord[] = (%f,%f,%f), (%f,%f)\n"; // idb
char aWarningSameVal[] = "WARNING: same value of rotary produced:\n"; // idb
char aComputingT11FT[] = "computing t1[1]=%f, t2[1]=%f, (Init_T1[1]*2-t1[1])=%f,(Init_T2[1]*2-t2[1])=%f\n"; // idb
char aComputingT10FT[] = "computing t1[0]=%f, t2[0]=%f, (Init_T1[0]*2-t1[0])=%f,(Init_T2[0]*2-t2[0])=%f\n"; // idb
char aAboutAdjusting[] = "About adjusting theta with initial angle...\n"; // idb
char aWarningDegener[] = "WARNING: Degenerated G_lambda(%f) out of range (-1, 1)\n"; // idb
char aInputPoint4f4f[] = "INPUT Point =%-.4f,%-.4f,%-.4f,%-.8f,%-.8f,%-.8f\n"; // idb
char aStartingOldPco[] = "Starting old_pcoord_t[] = (%f,%f,%f,%f,%f,%f)\n"; // idb
char asc_1000A4CC[] = "\n------------------------------------------------------\n"; // idb
char a900[5] = "90.0"; // weak
char a00[4] = "0.0"; // weak
char a00001[7] = "0.0001"; // weak
char aCartesian[10] = "CARTESIAN"; // weak
char asc_1000A57C[2] = "F"; // weak
char aNone[5] = "NONE"; // weak
char aT[2] = "T"; // weak
char a3AxisMill[12] = "3_axis_mill"; // weak
char aMomKinGaugeToP_0[25] = "mom_kin_gauge_to_pivot_y"; // weak
char aMomKinLineariz_0[26] = "mom_kin_linearization_tol"; // weak
char aMomKin5thAxisI[36] = "mom_kin_5th_axis_inclination_to_4th"; // weak
char aMomKinToolTrac[29] = "mom_kin_tool_tracking_height"; // weak
char aMomKinMachineR[27] = "mom_kin_machine_resolution"; // weak
char aMomKinLineariz[27] = "mom_kin_linearization_flag"; // weak
char aMomKinCoordina[24] = "mom_kin_coordinate_type"; // weak
char aMomKinClsfGene[24] = "mom_kin_clsf_generation"; // weak
char aMomKinWireTilt[30] = "mom_kin_wire_tilt_output_type"; // weak
char aMomKinTrackCen[29] = "mom_kin_track_center_of_ball"; // weak
char aEnd[4] = "END"; // weak
char aMomKinMachineT[21] = "mom_kin_machine_type"; // weak
char aMomKinGaugeToP[25] = "mom_kin_gauge_to_pivot_x"; // weak
char a40000[7] = "400.00"; // weak
char aIn[3] = "IN"; // weak
char aMomKinRapidFee[24] = "mom_kin_rapid_feed_rate"; // weak
char aMomKinPivotGau[27] = "mom_kin_pivot_gauge_offset"; // weak
char aMomKinReadAhea[31] = "mom_kin_read_ahead_next_motion"; // weak
char aMomKinPolarRad[26] = "mom_kin_polar_radius_side"; // weak
char aMomKinOutputUn[20] = "mom_kin_output_unit"; // weak
char aMomKinNurbsOut[26] = "mom_kin_nurbs_output_type"; // weak
char a99999999[10] = "9999.9999"; // weak
char aXy[3] = "XY"; // weak
char aFullCircle[12] = "FULL_CIRCLE"; // weak
char aMomKinMaxArcRa[23] = "mom_kin_max_arc_radius"; // weak
char aMomKinMinArcRa[23] = "mom_kin_min_arc_radius"; // weak
char aMomKinArcValid[24] = "mom_kin_arc_valid_plane"; // weak
char aMomKinArcOutpu[24] = "mom_kin_arc_output_mode"; // weak
char a99999999_0[10] = "99999.999"; // weak
char a99999[7] = "99.999"; // weak
char a0001[6] = "0.001"; // weak
char a999999[8] = "999.999"; // weak
char aMomKinMinDpm[16] = "mom_kin_min_dpm"; // weak
char aMomKinMaxDpm[16] = "mom_kin_max_dpm"; // weak
char aMomKinMinFrn[16] = "mom_kin_min_frn"; // weak
char aMomKinMaxFrn[16] = "mom_kin_max_frn"; // weak
char aMomKinMinFpr[16] = "mom_kin_min_fpr"; // weak
char aMomKinMaxFpr[16] = "mom_kin_max_fpr"; // weak
char aMomKinMinFpm[16] = "mom_kin_min_fpm"; // weak
char aMomKinMaxFpm[16] = "mom_kin_max_fpm"; // weak
char a3600[6] = "360.0"; // weak
char aStandard[9] = "STANDARD"; // weak
char aMagnitudeDeter[31] = "MAGNITUDE_DETERMINES_DIRECTION"; // weak
char aYz[3] = "YZ"; // weak
char aMomKin4thAxisA_0[27] = "mom_kin_4th_axis_angles_a2"; // weak
char aMomKin4thAxisA[27] = "mom_kin_4th_axis_angles_a1"; // weak
char aMomKin4thAxisV_1[26] = "mom_kin_4th_axis_vector_k"; // weak
char aMomKin4thAxisV_0[26] = "mom_kin_4th_axis_vector_j"; // weak
char aMomKin4thAxisV[26] = "mom_kin_4th_axis_vector_i"; // weak
char aMomKin4thAxisC_1[33] = "mom_kin_4th_axis_center_offset_z"; // weak
char aMomKin4thAxisC_0[33] = "mom_kin_4th_axis_center_offset_y"; // weak
char aMomKin4thAxisC[33] = "mom_kin_4th_axis_center_offset_x"; // weak
char aMomKin4thAxisZ[22] = "mom_kin_4th_axis_zero"; // weak
char aMomKin4thAxisM_1[27] = "mom_kin_4th_axis_max_limit"; // weak
char aMomKin4thAxisM_0[27] = "mom_kin_4th_axis_min_limit"; // weak
char aMomKin4thAxisM[26] = "mom_kin_4th_axis_min_incr"; // weak
char aMomKin4thAxisR[26] = "mom_kin_4th_axis_rotation"; // weak
char aMomKin4thAxisD[27] = "mom_kin_4th_axis_direction"; // weak
char aMomKin4thAxisP[23] = "mom_kin_4th_axis_plane"; // weak
char aMomKin5thAxisA_0[27] = "mom_kin_5th_axis_angles_a2"; // weak
char aMomKin5thAxisA[27] = "mom_kin_5th_axis_angles_a1"; // weak
char aMomKin5thAxisV_1[26] = "mom_kin_5th_axis_vector_k"; // weak
char aMomKin5thAxisV_0[26] = "mom_kin_5th_axis_vector_j"; // weak
char aMomKin5thAxisV[26] = "mom_kin_5th_axis_vector_i"; // weak
char aMomKin5thAxisC_1[33] = "mom_kin_5th_axis_center_offset_z"; // weak
char aMomKin5thAxisC_0[33] = "mom_kin_5th_axis_center_offset_y"; // weak
char aMomKin5thAxisC[33] = "mom_kin_5th_axis_center_offset_x"; // weak
char aMomKin5thAxisZ[22] = "mom_kin_5th_axis_zero"; // weak
char aMomKin5thAxisM_1[27] = "mom_kin_5th_axis_max_limit"; // weak
char aMomKin5thAxisM_0[27] = "mom_kin_5th_axis_min_limit"; // weak
char aMomKin5thAxisM[26] = "mom_kin_5th_axis_min_incr"; // weak
char aMomKin5thAxisR[26] = "mom_kin_5th_axis_rotation"; // weak
char aMomKin5thAxisD[27] = "mom_kin_5th_axis_direction"; // weak
char aMomKin5thAxisP[23] = "mom_kin_5th_axis_plane"; // weak
char aFront[6] = "FRONT"; // weak
char aMomKinIndToDep_0[32] = "mom_kin_ind_to_dependent_head_z"; // weak
char aMomKinIndToDep[32] = "mom_kin_ind_to_dependent_head_x"; // weak
char aMomKinIndepend[25] = "mom_kin_independent_head"; // weak
char a30[4] = "3.0"; // weak
char a05[4] = "0.5"; // weak
char aMomKinFlushTim[19] = "mom_kin_flush_time"; // weak
char aMomKinClampTim[19] = "mom_kin_clamp_time"; // weak
char aMomKinToolChan[25] = "mom_kin_tool_change_time"; // weak
char aPosz[] = "POSZ"; // idb
char aMomKinHolder6O_2[25] = "mom_kin_holder6_offset_z"; // weak
char aMomKinHolder6O_1[25] = "mom_kin_holder6_offset_y"; // weak
char aMomKinHolder6O_0[25] = "mom_kin_holder6_offset_x"; // weak
char aMomKinHolder5O_2[25] = "mom_kin_holder5_offset_z"; // weak
char aMomKinHolder5O_1[25] = "mom_kin_holder5_offset_y"; // weak
char aMomKinHolder5O_0[25] = "mom_kin_holder5_offset_x"; // weak
char aMomKinHolder4O_2[25] = "mom_kin_holder4_offset_z"; // weak
char aMomKinHolder4O_1[25] = "mom_kin_holder4_offset_y"; // weak
char aMomKinHolder4O_0[25] = "mom_kin_holder4_offset_x"; // weak
char aMomKinHolder3O_2[25] = "mom_kin_holder3_offset_z"; // weak
char aMomKinHolder3O_1[25] = "mom_kin_holder3_offset_y"; // weak
char aMomKinHolder3O_0[25] = "mom_kin_holder3_offset_x"; // weak
char aMomKinHolder2O_2[25] = "mom_kin_holder2_offset_z"; // weak
char aMomKinHolder2O_1[25] = "mom_kin_holder2_offset_y"; // weak
char aMomKinHolder2O_0[25] = "mom_kin_holder2_offset_x"; // weak
char aMomKinHolder1O_2[25] = "mom_kin_holder1_offset_z"; // weak
char aMomKinHolder1O_1[25] = "mom_kin_holder1_offset_y"; // weak
char aMomKinHolder1O_0[25] = "mom_kin_holder1_offset_x"; // weak
char aMomKinHolder6O[28] = "mom_kin_holder6_orientation"; // weak
char aMomKinHolder5O[28] = "mom_kin_holder5_orientation"; // weak
char aMomKinHolder4O[28] = "mom_kin_holder4_orientation"; // weak
char aMomKinHolder3O[28] = "mom_kin_holder3_orientation"; // weak
char aMomKinHolder2O[28] = "mom_kin_holder2_orientation"; // weak
char aMomKinHolder1O[28] = "mom_kin_holder1_orientation"; // weak
char a10[4] = "1.0"; // weak
char aMomMsysZAxisK[18] = "mom_msys_z_axis_k"; // weak
char aMomMsysZAxisJ[18] = "mom_msys_z_axis_j"; // weak
char aMomMsysZAxisI[18] = "mom_msys_z_axis_i"; // weak
char aMomMsysYAxisK[18] = "mom_msys_y_axis_k"; // weak
char aMomMsysYAxisJ[18] = "mom_msys_y_axis_j"; // weak
char aMomMsysYAxisI[18] = "mom_msys_y_axis_i"; // weak
char aMomMsysXAxisK[18] = "mom_msys_x_axis_k"; // weak
char aMomMsysXAxisJ[18] = "mom_msys_x_axis_j"; // weak
char aMomMsysXAxisI[18] = "mom_msys_x_axis_i"; // weak
char aMomMsysOriginZ[18] = "mom_msys_origin_z"; // weak
char aMomMsysOriginY[18] = "mom_msys_origin_y"; // weak
char aMomMsysOriginX[18] = "mom_msys_origin_x"; // weak
char aMomMtsysZAxisK[19] = "mom_mtsys_z_axis_k"; // weak
char aMomMtsysZAxisJ[19] = "mom_mtsys_z_axis_j"; // weak
char aMomMtsysZAxisI[19] = "mom_mtsys_z_axis_i"; // weak
char aMomMtsysYAxisK[19] = "mom_mtsys_y_axis_k"; // weak
char aMomMtsysYAxisJ[19] = "mom_mtsys_y_axis_j"; // weak
char aMomMtsysYAxisI[19] = "mom_mtsys_y_axis_i"; // weak
char aMomMtsysXAxisK[19] = "mom_mtsys_x_axis_k"; // weak
char aMomMtsysXAxisJ[19] = "mom_mtsys_x_axis_j"; // weak
char aMomMtsysXAxisI[19] = "mom_mtsys_x_axis_i"; // weak
char aMomMtsysOrigin_1[19] = "mom_mtsys_origin_z"; // weak
char aMomMtsysOrigin_0[19] = "mom_mtsys_origin_y"; // weak
char aMomMtsysOrigin[19] = "mom_mtsys_origin_x"; // weak
char aMill[5] = "MILL"; // weak
char aMomToolCorner1[24] = "mom_tool_corner1_radius"; // weak
char aMomToolZOffset[18] = "mom_tool_z_offset"; // weak
char aMomToolType[14] = "mom_tool_type"; // weak
char aMomTranslateZ[16] = "mom_translate_z"; // weak
char aMomTranslateY[16] = "mom_translate_y"; // weak
char aMomTranslateX[16] = "mom_translate_x"; // weak
char aMomOriginZ[13] = "mom_origin_z"; // weak
char aMomOriginY[13] = "mom_origin_y"; // weak
char aMomOriginX[13] = "mom_origin_x"; // weak
char aMomToolAxisK[16] = "mom_tool_axis_k"; // weak
char aMomToolAxisJ[16] = "mom_tool_axis_j"; // weak
char aMomToolAxisI[16] = "mom_tool_axis_i"; // weak
char aMomMcsGotoZ[15] = "mom_mcs_goto_z"; // weak
char aMomMcsGotoY[15] = "mom_mcs_goto_y"; // weak
char aMomMcsGotoX[15] = "mom_mcs_goto_x"; // weak
char aWarningTheTool_0[119] = "WARNING  The tool axis is not matching with the *                     rotated MCS-Z axis. The output may be INCORRECT\n"; // weak
char aWarningTheTool[] = "WARNING  The tool axis is not matching with the                 rotated MCS-Z axis. The output may be INCORRECT\n"; // idb
char aUfMomExtendXla_4[87] = "UF_MOM_extend_xlator ( mom, \"MOM_exit_kinematics_module\", mom_exit_kinematics_module )"; // weak
char aMomExitKinemat[27] = "MOM_exit_kinematics_module"; // weak
char aUfMomExtendXla_3[81] = "UF_MOM_extend_xlator ( mom, \"MOM_map_to_rotated_csys\", mom_map_to_rotated_csys )"; // weak
char aMomMapToRotate[24] = "MOM_map_to_rotated_csys"; // weak
char aUfMomExtendXla_2[75] = "UF_MOM_extend_xlator ( mom, \"MOM_rotate_mach_csys\", mom_rotate_mach_csys )"; // weak
char aMomRotateMachC[21] = "MOM_rotate_mach_csys"; // weak
char aUfMomExtendXla_1[80] = "UF_MOM_extend_xlator ( mom , \"MOM_get_tool_attribute\", mom_get_tool_attribute )"; // weak
char aMomGetToolAttr[23] = "MOM_get_tool_attribute"; // weak
char aUfMomExtendXla_0[69] = "UF_MOM_extend_xlator ( mom, \"MOM_convert_point\", mom_convert_point )"; // weak
char aMomConvertPoin[18] = "MOM_convert_point"; // weak
char aZV18projsBatch[73] = "Z:\\v18projs\\batch\\project\\phase14\\ugp_adv_kins\\uf_mom_add_ufun_tclexts.c"; // weak
char aUfMomExtendXla[73] = "UF_MOM_extend_xlator ( mom, \"MOM_load_kinematics\", mom_load_kinematics )"; // weak
char aMomLoadKinemat[20] = "MOM_load_kinematics"; // weak
char aErrorUgpostAdv[] = "ERROR : Ugpost Advanced Kinematics license not found \n"; // idb
char aReturnedErrorD[] = "    returned error %d:  %s\n"; // idb
char aReturnedAD[] = "    returned a %d\n"; // idb
char aSLineDS[] = "%s, line %d:  %s\n"; // idb
char aErrorKinematic[] = "ERROR : Kinematics Module License has expired"; // idb
char aUfGetReleaseUg[31] = "UF_get_release ( &ug_release )"; // weak
char aKinematics[11] = "Kinematics"; // weak
char aErrorAdvancedK[] = "ERROR!: Advanced Kinematics Module Unavailable"; // idb
char aUgpkin[13] = "<!<UGPKIN>!>"; // weak
char aRemainingDaysD[] = "  Remaining days: %d\n"; // idb
char aS[] = "%s\n"; // idb
char aYourLicenseHas[85] = "\nYour license has expired. \nPlease contact customer support for renewal information."; // weak
char aExpirationDate[] = "EXPIRATION Date: %s."; // idb
char a02d02d04d[] = "%02d/%02d/%04d"; // idb
char aNumberOfArgume[] = " Number of arguments should be between 1 and 6\n "; // idb
char aIncorrectNumbe[] = " Incorrect number of arguments\n"; // idb
char aSetRotdOperati[] = " SET_rotd_operation_data failed in mom_rotate_mach_csys \n "; // idb
char aSetRotdMcsMatr[] = " SET_rotd_mcs_matrix failed in mom_rotate_mach_csys \n "; // idb
char aCaxis[6] = "CAXIS"; // weak
char aBaxis[6] = "BAXIS"; // weak
char aAaxis[6] = "AAXIS"; // weak
char aInsufficientNu[] = " Insufficient number of arguments, There should be               atleast 2 arguments\n "; // idb
char aPosZ[6] = "pos_z"; // weak
char aPosY[6] = "pos_y"; // weak
char aPosX[6] = "pos_x"; // weak
char aMomTransferGot[] = " mom_transfer_gotos_rotd_mcsys failed in mom_map_to_rotated_csys\n "; // idb
char aMomProcessInpu[] = " mom_process_input_gotos failed in mom_map_to_rotated_csys\n "; // idb
char aSetInputPointF[] = " SET_input_point failed in mom_map_to_rotated_csys\n "; // idb
char a5AxisHeadTable[] = "5_axis_head_table"; // idb
char a5AxisDualHead[] = "5_axis_dual_head"; // idb
char a5AxisDualTable[] = "5_axis_dual_table"; // idb
char aNegz[] = "NEGZ"; // idb
char aNegy[] = "NEGY"; // idb
char aNegx[] = "NEGX"; // idb
char aPosy[] = "POSY"; // idb
char SubStr[] = "POSX"; // idb
char aAltPosA2[11] = "alt_pos_a2"; // weak
char aAltPosA1[11] = "alt_pos_a1"; // weak
char aAltPosZ[10] = "alt_pos_z"; // weak
char aAltPosY[10] = "alt_pos_y"; // weak
char aAltPosX[10] = "alt_pos_x"; // weak
char aPosA2[7] = "pos_a2"; // weak
char aPosA1[7] = "pos_a1"; // weak
char aUfAttrReadValu[] = " UF_ATTR_read_value could not return tool string \n"; // idb
char aUfObjCycleByNa[] = " UF_OBJ_cycle_by_name could not get the tool_object_tag \n"; // idb
char aErrorS[] = " ERROR : %s \n "; // idb
int dword_1000BB84 = 1819242356; // weak
int dword_1000BB88 = 1835101791; // weak
__int16 word_1000BB8C = 101; // weak
int dword_1000BB90 = 2105376; // weak
double dbl_1000BBA0 =  0.0; // weak
double dbl_1000BBA8 =  0.0; // weak
double dbl_1000BBB0 =  0.0; // weak
double dbl_1000BBB8 =  0.0; // weak
int dword_1000BBC0 = 0; // weak
int dword_1000BBC4 = 0; // weak
int dword_1000BBC8 = 0; // weak
int dword_1000BBCC = 0; // weak
int dword_1000BBD0 = 0; // weak
int dword_1000BBD4 = 0; // weak
double dbl_1000BBD8 =  0.0; // weak
double dbl_1000BBE0 =  0.0; // weak
_UNKNOWN unk_1000BBE8; // weak
int dword_1000BC00 = 0; // weak
_UNKNOWN unk_1000BC08; // weak
_UNKNOWN unk_1000BC20; // weak
int dword_1000BC38 = 0; // weak
int dword_1000BC3C = 0; // weak
int dword_1000BC40 = 0; // weak
int dword_1000BC44 = 0; // weak
_UNKNOWN unk_1000BC48; // weak
_UNKNOWN unk_1000BC70; // weak
double dbl_1000BCF0 =  0.0; // weak
double dbl_1000BCF8 =  0.0; // weak
double dbl_1000BD00 =  0.0; // weak
double dbl_1000BD08 =  0.0; // weak
double dbl_1000BD10 =  0.0; // weak
double dbl_1000BD18 =  0.0; // weak
double dbl_1000BD20 =  0.0; // weak
double dbl_1000BD28 =  0.0; // weak
double dbl_1000BD30 =  0.0; // weak
double dbl_1000BD38 =  0.0; // weak
double dbl_1000BD40 =  0.0; // weak
double dbl_1000BD48 =  0.0; // weak
int dword_1000BD70 = 0; // weak
int dword_1000BD74 = 0; // weak
int dword_1000BD78 = 0; // weak
int dword_1000BD7C = 0; // weak
int dword_1000BD80 = 0; // weak
int dword_1000BD84 = 0; // weak
int dword_1000BD88 = 0; // weak
int dword_1000BD8C = 0; // weak
int dword_1000BD90 = 0; // weak
int dword_1000BD94 = 0; // weak
int dword_1000BD98 = 0; // weak
int dword_1000BD9C = 0; // weak
int dword_1000BDA0 = 0; // weak
int dword_1000BDA4 = 0; // weak
int dword_1000BDA8 = 0; // weak
int dword_1000BDAC = 0; // weak
__int64 qword_1000BDB0 = 0i64; // weak
__int64 qword_1000BDB8 = 0i64; // weak
__int64 qword_1000BDC0 = 0i64; // weak
int dword_1000BDC8 = 0; // weak
int dword_1000BDCC = 0; // weak
_UNKNOWN unk_1000BDD0; // weak
__int64 qword_1000BDF8[] = { 0i64 }; // weak
__int64 qword_1000BE00 = 0i64; // weak
__int64 qword_1000BE08 = 0i64; // weak
__int64 qword_1000BE10 = 0i64; // weak
_UNKNOWN unk_1000BE18; // weak
__int64 qword_1000BE20 = 0i64; // weak
_UNKNOWN unk_1000BEB0; // weak
int dword_1000BEC8 = 0; // weak
int dword_1000BECC = 0; // weak
int dword_1000BED0 = 0; // weak
int dword_1000BED4 = 0; // weak
__int64 qword_1000BED8 = 0i64; // weak
__int64 qword_1000BEE0 = 0i64; // weak
double dbl_1000BEE8 =  0.0; // weak
int dword_1000BEF0 = 0; // weak
double dbl_1000BEF8 =  0.0; // weak
double dbl_1000BF00 =  0.0; // weak
double dbl_1000BF10 =  0.0; // weak
double dbl_1000BF18 =  0.0; // weak
double dbl_1000BF20 =  0.0; // weak
double dbl_1000BF28 =  0.0; // weak
double dbl_1000BF30 =  0.0; // weak
double dbl_1000BF38 =  0.0; // weak
char byte_1000BF40 = '\0'; // weak
_UNKNOWN unk_1000BF48; // weak
int dword_1000BF60[] = { 0 }; // weak
int dword_1000BF64[] = { 0 }; // weak
int dword_1000BF78[] = { 0 }; // weak
int dword_1000BF7C[] = { 0 }; // weak
int dword_1000BF90[] = { 0 }; // weak
int dword_1000BF94[] = { 0 }; // weak
_UNKNOWN unk_1000BFA8; // weak
int dword_1000BFC0 = 0; // weak
int dword_1000BFC4 = 0; // weak
int dword_1000BFC8 = 0; // weak
int dword_1000BFD0 = 0; // weak
int dword_1000BFD4 = 0; // weak
int dword_1000BFDC = 0; // weak
int dword_1000BFE0 = 0; // weak


//----- (10001000) --------------------------------------------------------
signed int __cdecl sub_10001000(char *a1, const void *a2, _DWORD *a3, int a4, _DWORD *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8, const void *a9)
{
  int v9; // eax
  signed int result; // eax
  void (*v11)(const char *, ...); // edi
  _DWORD *v12; // esi
  double v13; // st7
  int v14; // edx
  unsigned int v15; // eax
  double v16; // st7
  double *v17; // ecx
  double v18; // st7
  double v19; // st6
  double v20; // st6
  int v21; // ecx
  int v22; // ecx
  double v23; // st7
  int v24; // edx
  unsigned int v25; // eax
  double v26; // st7
  double *v27; // ecx
  double v28; // st7
  double v29; // st6
  double v30; // st6
  int v31; // ecx
  int v32; // ecx
  double v33; // st7
  void (*v34)(const char *, ...); // ebx
  char v35; // [esp+2Fh] [ebp-231h]
  char v36; // [esp+30h] [ebp-230h]
  char v37; // [esp+36h] [ebp-22Ah]
  char v38; // [esp+37h] [ebp-229h]
  long double v39; // [esp+38h] [ebp-228h]
  double v40; // [esp+40h] [ebp-220h]
  double v41; // [esp+48h] [ebp-218h]
  double v42[3]; // [esp+50h] [ebp-210h]
  double v43[3]; // [esp+68h] [ebp-1F8h]
  int v44; // [esp+80h] [ebp-1E0h]
  int v45; // [esp+84h] [ebp-1DCh]
  char v46; // [esp+88h] [ebp-1D8h]
  double v47; // [esp+98h] [ebp-1C8h]
  char v48; // [esp+A0h] [ebp-1C0h]
  char v49; // [esp+B8h] [ebp-1A8h]
  char v50; // [esp+D0h] [ebp-190h]
  double v51; // [esp+E0h] [ebp-180h]
  char v52; // [esp+E8h] [ebp-178h]
  double v53[4]; // [esp+F8h] [ebp-168h]
  char v54; // [esp+118h] [ebp-148h]
  char v55; // [esp+130h] [ebp-130h]
  double v56; // [esp+138h] [ebp-128h]
  char v57; // [esp+140h] [ebp-120h]
  double v58[3]; // [esp+150h] [ebp-110h]
  int v59; // [esp+168h] [ebp-F8h]
  int v60; // [esp+16Ch] [ebp-F4h]
  char v61; // [esp+170h] [ebp-F0h]
  double v62[3]; // [esp+180h] [ebp-E0h]
  int v63; // [esp+198h] [ebp-C8h]
  int v64; // [esp+19Ch] [ebp-C4h]
  char v65; // [esp+1A0h] [ebp-C0h]
  double v66[4]; // [esp+1B0h] [ebp-B0h]
  char v67; // [esp+1D0h] [ebp-90h]
  char v68; // [esp+1E8h] [ebp-78h]
  char v69; // [esp+200h] [ebp-60h]
  char v70; // [esp+218h] [ebp-48h]
  char v71; // [esp+230h] [ebp-30h]
  char v72; // [esp+248h] [ebp-18h]

  qmemcpy(&unk_1000BBE8, a3, 0x18u);
  qmemcpy(&unk_1000BC08, a5, 0x18u);
  LODWORD(v41) = 0;
  UF_VEC3_copy(a4, v43);
  UF_VEC3_copy(a6, v42);
  UF_VEC3_copy(a8, &v48);
  byte_1000BF40 = 0;
  dbl_1000BF10 = 0.0;
  dbl_1000BF18 = 0.0;
  dbl_1000BF20 = 0.0;
  dbl_1000BF28 = 0.0;
  dbl_1000BF30 = 0.0;
  dbl_1000BF38 = 0.0;
  qmemcpy(&unk_1000BE18, a9, 0x98u);
  dword_1000BEF0 = (int)&unk_1000BE18;
  *(_QWORD *)&dbl_1000A010 = qword_1000BE20;
  qmemcpy(&dword_1000BD70, a2, 0x60u);
  dbl_1000BBB8 = 0.0;
  dbl_1000BBB0 = 0.0;
  dbl_1000BBA8 = 0.0;
  dbl_1000BBA0 = 0.0;
  qword_1000BE10 = 0i64;
  qword_1000BE08 = 0i64;
  qword_1000BE00 = 0i64;
  qword_1000BDF8[0] = 0i64;
  UF_VEC3_unitize(a4, qword_1000BE20, HIDWORD(qword_1000BE20), &v39, &qword_1000BED8);
  UF_VEC3_unitize(a6, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v39, &dword_1000BBC0);
  BYTE1(dword_1000A018) = 1;
  memset(&unk_1000BC20, 0, 0x28u);
  memset(&unk_1000BEB0, 0, 0x28u);
  BYTE2(dword_1000A018) = 1;
  v9 = *(_DWORD *)dword_1000BEF0;
  if ( *(_DWORD *)dword_1000BEF0 != 1 && v9 != 2 && v9 != 3 )
    return 2;
  UF_VEC3_is_parallel(v43, v42, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v36);
  v38 = v36;
  UF_VEC3_is_parallel(v43, &v48, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v36);
  v37 = v36;
  UF_VEC3_is_parallel(v42, &v48, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v36);
  v35 = v36;
  if ( !v37 )
    sub_10001F10((int)v43, (int)&v48, SLOBYTE(v39), SHIDWORD(v39), (int)&v50);
  UF_VEC3_cross(v43, v42, &v46);
  UF_VEC3_is_parallel(&v46, &v48, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v36);
  LOBYTE(dword_1000A018) = v36;
  if ( byte_1000BF40 )
  {
    v11 = (void (*)(const char *, ...))printf;
    printf(Format);
    printf(aIsOrthogonalCa, (unsigned __int8)dword_1000A018);
    if ( *(_DWORD *)dword_1000BEF0 == 2 )
    {
      printf(aIs5AxisDualTab);
    }
    else if ( *(_DWORD *)dword_1000BEF0 == 1 )
    {
      printf(aIs5AxisDualHea);
    }
    else
    {
      printf(aIs5AxisHeadTab);
    }
    printf(
      aPrimaryFFF,
      *(_QWORD *)a4,
      *(_DWORD *)(a4 + 8),
      *(_DWORD *)(a4 + 12),
      *(_DWORD *)(a4 + 16),
      *(_DWORD *)(a4 + 20));
    printf(aPrimaryMachine, *a3, a3[1], a3[2], a3[3], a3[4], a3[5]);
    printf(aSecondaryFFF, *a6, a6[1], a6[2], a6[3], a6[4], a6[5]);
    printf(aSecondaryMachi, *(_QWORD *)a5, a5[2], a5[3], a5[4], a5[5]);
    printf(aToolMachineCen, *a7, a7[1], a7[2], a7[3], a7[4], a7[5]);
    v12 = a8;
    printf(aToolVectorFFF, *a8, a8[1], a8[2], a8[3], a8[4], a8[5]);
    printf(
      aMcsysFFFFFFFFF,
      dword_1000BD70,
      dword_1000BD74,
      dword_1000BD78,
      dword_1000BD7C,
      dword_1000BD80,
      dword_1000BD84,
      dword_1000BD88,
      dword_1000BD8C,
      dword_1000BD90,
      dword_1000BD94,
      dword_1000BD98,
      dword_1000BD9C,
      dword_1000BDA0,
      dword_1000BDA4,
      dword_1000BDA8,
      dword_1000BDAC,
      qword_1000BDB0,
      qword_1000BDB8,
      qword_1000BDC0,
      dword_1000BDC8,
      dword_1000BDCC);
  }
  else
  {
    v11 = (void (*)(const char *, ...))printf;
    v12 = a8;
  }
  dword_1000BC00 = -1;
  if ( *(_DWORD *)dword_1000BEF0 == 3 )
  {
    UF_MTX3_x_vec(&unk_10009110, &v52);
    UF_MTX3_y_vec(&unk_10009110, &v57);
    UF_MTX3_z_vec(&unk_10009110, &v67);
    UF_VEC3_is_equal(v12, &v67, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v44);
    if ( v44 )
    {
      UF_VEC3_is_equal(a4, &v52, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), (char *)&v41 + 4);
      UF_VEC3_is_equal(a6, &v57, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v45);
      UF_VEC3_is_equal(a6, &v67, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v40);
      if ( HIDWORD(v41) && v45 )
      {
        result = LODWORD(v41);
        dword_1000BC00 = 0;
        BYTE1(dword_1000A018) = 0;
      }
      else
      {
        if ( LODWORD(v40) )
        {
          result = LODWORD(v41);
          dword_1000BC00 = 1;
        }
        else
        {
          LODWORD(v41) = 2;
          result = 2;
        }
        BYTE1(dword_1000A018) = 0;
      }
      return result;
    }
    UF_VEC3_is_equal(v12, &v57, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v41);
    UF_VEC3_is_equal(v43, &v67, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), (char *)&v41 + 4);
    if ( (_BYTE)dword_1000A018 || !v35 || !LODWORD(v41) || !HIDWORD(v41) )
      return 2;
    dword_1000BC00 = 3;
    UF_MTX3_vec_multiply_t(&qword_1000BED8, &unk_100091A0, &qword_1000BED8);
    UF_MTX3_vec_multiply_t(&dword_1000BBC0, &unk_100091A0, &dword_1000BBC0);
    if ( byte_1000BF40 )
    {
      v11(aSulzerCase);
      v11(aLocalPrimaryax, qword_1000BED8, qword_1000BEE0, dbl_1000BEE8);
      v11(
        aLocalSecondary,
        dword_1000BBC0,
        dword_1000BBC4,
        dword_1000BBC8,
        dword_1000BBCC,
        dword_1000BBD0,
        dword_1000BBD4);
    }
  }
  if ( v38 )
  {
    dbl_1000BF30 = 0.0;
  }
  else
  {
    sub_10001F10((int)v43, (int)v42, SLOBYTE(v39), SHIDWORD(v39), (int)&v50);
    dbl_1000BF30 = sub_10002140((int)v43, (int)v42, (int)&v50);
  }
  if ( v35 )
  {
    v11(aWarningToolAxi);
    dbl_1000BF38 = 0.0;
  }
  else
  {
    if ( fabs(dbl_1000BF30) <= dbl_1000A010 )
    {
      sub_10001F10((int)v42, (int)&v48, SLOBYTE(v39), SHIDWORD(v39), (int)&v50);
      if ( fabs(v39) <= dbl_1000A010 )
        return 3;
    }
    if ( (_BYTE)dword_1000A018 )
    {
      sub_10001F10((int)v42, (int)&v48, SLOBYTE(v39), SHIDWORD(v39), (int)&v52);
      v13 = sub_10002140((int)v42, (int)&v48, (int)&v52);
    }
    else
    {
      v13 = sub_10002140((int)v42, (int)&v48, (int)&v50);
    }
    dbl_1000BF38 = v13;
  }
  v14 = (char *)a3 - (char *)v43;
  v15 = 0;
  do
  {
    v16 = v43[v15 / 8] * 1000000.0;
    v17 = &v43[v15 / 8];
    v15 += 8;
    *(double *)((char *)&v51 + v15) = v16 + *(double *)((char *)v17 + v14);
    v18 = *(double *)((char *)v17 + v14) - v16;
    v53[v15 / 8] = v18;
    v19 = *(double *)((char *)&v41 + v15) * 1000000.0;
    *(double *)((char *)&v56 + v15) = v19 + *(double *)&a5[v15 / 4 - 2];
    v20 = *(double *)&a5[v15 / 4 - 2] - v19;
    *(int *)((char *)&v63 + v15) = *(_DWORD *)((char *)&v51 + v15);
    v21 = *(_DWORD *)((char *)&v51 + v15 + 4);
    v40 = v20;
    v58[v15 / 8] = v20;
    *(int *)((char *)&v64 + v15) = v21;
    v22 = *(_DWORD *)((char *)&v56 + v15);
    v66[v15 / 8] = v18;
    v23 = v40;
    *(int *)((char *)&v59 + v15) = v22;
    *(int *)((char *)&v60 + v15) = *(_DWORD *)((char *)&v56 + v15 + 4);
    v62[v15 / 8] = v23;
  }
  while ( (signed int)v15 < 24 );
  if ( sub_10003EC0((int)&v65, (int)&v61, (int)&v54, (int)&v49, (int)&v56, (int)&v55) )
    return 5;
  UF_VEC3_distance(&v54, &v49, &dbl_1000BF10);
  if ( dbl_1000A010 >= dbl_1000BF10 )
  {
    dbl_1000BF10 = 0.0;
  }
  else
  {
    UF_VEC3_sub(&v49, &v54, &v46);
    UF_VEC3_dot(&v46, &v50, &v40);
    if ( v40 < 0.0 )
      dbl_1000BF10 = -dbl_1000BF10;
  }
  UF_VEC3_distance(&v49, a3, &dbl_1000BF18);
  if ( dbl_1000A010 >= dbl_1000BF18 )
  {
    dbl_1000BF18 = 0.0;
  }
  else
  {
    UF_VEC3_sub(&v49, a3, &v46);
    UF_VEC3_dot(&v46, v43, &v40);
    if ( v40 < 0.0 )
      dbl_1000BF18 = -dbl_1000BF18;
  }
  v24 = (char *)a5 - (char *)v42;
  v25 = 0;
  do
  {
    v26 = v42[v25 / 8] * 1000000.0;
    v27 = &v42[v25 / 8];
    v25 += 8;
    *(double *)((char *)&v51 + v25) = v26 + *(double *)((char *)v27 + v24);
    v28 = *(double *)((char *)v27 + v24) - v26;
    v53[v25 / 8] = v28;
    v29 = *(double *)((char *)&v47 + v25) * 1000000.0;
    *(double *)((char *)&v56 + v25) = v29 + *(double *)&a7[v25 / 4 - 2];
    v30 = *(double *)&a7[v25 / 4 - 2] - v29;
    *(int *)((char *)&v63 + v25) = *(_DWORD *)((char *)&v51 + v25);
    v31 = *(_DWORD *)((char *)&v51 + v25 + 4);
    v40 = v30;
    v58[v25 / 8] = v30;
    *(int *)((char *)&v64 + v25) = v31;
    v32 = *(_DWORD *)((char *)&v56 + v25);
    v66[v25 / 8] = v28;
    v33 = v40;
    *(int *)((char *)&v59 + v25) = v32;
    *(int *)((char *)&v60 + v25) = *(_DWORD *)((char *)&v56 + v25 + 4);
    v62[v25 / 8] = v33;
  }
  while ( (signed int)v25 < 24 );
  if ( sub_10003EC0((int)&v65, (int)&v61, (int)&v54, (int)&v49, (int)&v56, (int)&v55) )
    return 5;
  UF_VEC3_distance(&v54, &v49, &dbl_1000BF20);
  if ( dbl_1000A010 >= dbl_1000BF20 )
  {
    dbl_1000BF20 = 0.0;
  }
  else
  {
    UF_VEC3_sub(&v49, &v54, &v46);
    UF_VEC3_dot(&v46, &v50, &v40);
    if ( v40 < 0.0 )
      dbl_1000BF20 = -dbl_1000BF20;
  }
  UF_VEC3_distance(&v49, a7, &dbl_1000BF28);
  if ( dbl_1000A010 >= dbl_1000BF28 )
  {
    dbl_1000BF28 = 0.0;
  }
  else
  {
    UF_VEC3_sub(&v49, a7, &v46);
    UF_VEC3_dot(&v46, v42, &v40);
    if ( v40 < 0.0 )
      dbl_1000BF28 = -dbl_1000BF28;
  }
  qmemcpy(&v69, a3, 0x18u);
  sub_10001F10((int)v43, (int)v42, SLOBYTE(v39), SHIDWORD(v39), (int)&v70);
  qmemcpy(&v72, v43, 0x18u);
  sub_10001F10((int)v43, (int)&v70, SLOBYTE(v39), SHIDWORD(v39), (int)&v71);
  sub_10002060(a1, &v69, (int)&unk_1000BC70);
  sub_10001F50((int)&unk_1000BC70, (int)&dbl_1000BCF0);
  dbl_1000BBE0 = sin(dbl_1000BF30);
  dbl_1000BBD8 = sin(dbl_1000BF38);
  dbl_1000BEF8 = cos(dbl_1000BF30);
  dbl_1000BF00 = cos(dbl_1000BF38);
  if ( byte_1000BF40 )
  {
    v34 = (void (*)(const char *, ...))printf;
    printf(
      aA1FD1FAlpha1FA,
      dbl_1000BF10,
      dbl_1000BF18,
      dbl_1000BF30 * 57.29577951308235,
      dbl_1000BF20,
      dbl_1000BF28,
      dbl_1000BF38 * 57.29577951308235);
  }
  else
  {
    v34 = (void (*)(const char *, ...))printf;
  }
  if ( *(_DWORD *)dword_1000BEF0 == 2 )
  {
    qmemcpy(&v67, a7, 0x18u);
    qmemcpy(&v68, a8, 0x18u);
    sub_10002590(&v67, (int)&v57, (int *)&v52);
    if ( byte_1000BF40 )
    {
      v34(aInitT10InitT20, dbl_1000BBB0 * 57.29577951308235, dbl_1000BBA0 * 57.29577951308235);
      v34(aInitT11InitT21, dbl_1000BBB8 * 57.29577951308235, dbl_1000BBA8 * 57.29577951308235);
    }
  }
  BYTE1(dword_1000A018) = 0;
  return 0;
}
// 100090A4: using guessed type int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD);
// 100090A8: using guessed type int __cdecl UF_VEC3_dot(_DWORD, _DWORD, _DWORD);
// 100090CC: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);
// 100090D0: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090D4: using guessed type int __cdecl UF_VEC3_is_parallel(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090D8: using guessed type int __cdecl UF_VEC3_cross(_DWORD, _DWORD, _DWORD);
// 100090DC: using guessed type int __cdecl UF_MTX3_x_vec(_DWORD, _DWORD);
// 100090E0: using guessed type int __cdecl UF_MTX3_y_vec(_DWORD, _DWORD);
// 100090E4: using guessed type int __cdecl UF_MTX3_z_vec(_DWORD, _DWORD);
// 100090E8: using guessed type int __cdecl UF_VEC3_is_equal(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090EC: using guessed type int __cdecl UF_MTX3_vec_multiply_t(_DWORD, _DWORD, _DWORD);
// 100090F0: using guessed type int __cdecl UF_VEC3_distance(_DWORD, _DWORD, _DWORD);
// 1000A010: using guessed type double dbl_1000A010;
// 1000A018: using guessed type int dword_1000A018;
// 1000BBA0: using guessed type double dbl_1000BBA0;
// 1000BBA8: using guessed type double dbl_1000BBA8;
// 1000BBB0: using guessed type double dbl_1000BBB0;
// 1000BBB8: using guessed type double dbl_1000BBB8;
// 1000BBC0: using guessed type int dword_1000BBC0;
// 1000BBC4: using guessed type int dword_1000BBC4;
// 1000BBC8: using guessed type int dword_1000BBC8;
// 1000BBCC: using guessed type int dword_1000BBCC;
// 1000BBD0: using guessed type int dword_1000BBD0;
// 1000BBD4: using guessed type int dword_1000BBD4;
// 1000BBD8: using guessed type double dbl_1000BBD8;
// 1000BBE0: using guessed type double dbl_1000BBE0;
// 1000BC00: using guessed type int dword_1000BC00;
// 1000BCF0: using guessed type double dbl_1000BCF0;
// 1000BD70: using guessed type int dword_1000BD70;
// 1000BD74: using guessed type int dword_1000BD74;
// 1000BD78: using guessed type int dword_1000BD78;
// 1000BD7C: using guessed type int dword_1000BD7C;
// 1000BD80: using guessed type int dword_1000BD80;
// 1000BD84: using guessed type int dword_1000BD84;
// 1000BD88: using guessed type int dword_1000BD88;
// 1000BD8C: using guessed type int dword_1000BD8C;
// 1000BD90: using guessed type int dword_1000BD90;
// 1000BD94: using guessed type int dword_1000BD94;
// 1000BD98: using guessed type int dword_1000BD98;
// 1000BD9C: using guessed type int dword_1000BD9C;
// 1000BDA0: using guessed type int dword_1000BDA0;
// 1000BDA4: using guessed type int dword_1000BDA4;
// 1000BDA8: using guessed type int dword_1000BDA8;
// 1000BDAC: using guessed type int dword_1000BDAC;
// 1000BDB0: using guessed type __int64 qword_1000BDB0;
// 1000BDB8: using guessed type __int64 qword_1000BDB8;
// 1000BDC0: using guessed type __int64 qword_1000BDC0;
// 1000BDC8: using guessed type int dword_1000BDC8;
// 1000BDCC: using guessed type int dword_1000BDCC;
// 1000BDF8: using guessed type __int64 qword_1000BDF8[];
// 1000BE00: using guessed type __int64 qword_1000BE00;
// 1000BE08: using guessed type __int64 qword_1000BE08;
// 1000BE10: using guessed type __int64 qword_1000BE10;
// 1000BE20: using guessed type __int64 qword_1000BE20;
// 1000BED8: using guessed type __int64 qword_1000BED8;
// 1000BEE0: using guessed type __int64 qword_1000BEE0;
// 1000BEE8: using guessed type double dbl_1000BEE8;
// 1000BEF0: using guessed type int dword_1000BEF0;
// 1000BEF8: using guessed type double dbl_1000BEF8;
// 1000BF00: using guessed type double dbl_1000BF00;
// 1000BF10: using guessed type double dbl_1000BF10;
// 1000BF18: using guessed type double dbl_1000BF18;
// 1000BF20: using guessed type double dbl_1000BF20;
// 1000BF28: using guessed type double dbl_1000BF28;
// 1000BF30: using guessed type double dbl_1000BF30;
// 1000BF38: using guessed type double dbl_1000BF38;
// 1000BF40: using guessed type char byte_1000BF40;
// 10001000: using guessed type double var_1F8[3];
// 10001000: using guessed type double var_210[3];
// 10001000: using guessed type double var_168[4];
// 10001000: using guessed type double var_110[3];
// 10001000: using guessed type double var_B0[4];
// 10001000: using guessed type double var_E0[3];

//----- (10001F10) --------------------------------------------------------
int __cdecl sub_10001F10(int a1, int a2, char a3, int a4, int a5)
{
  int v5; // esi

  v5 = a5;
  UF_VEC3_cross(a1, a2, a5);
  return UF_VEC3_unitize(v5, -640172613, 1037794527, &a3, v5);
}
// 100090D0: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090D8: using guessed type int __cdecl UF_VEC3_cross(_DWORD, _DWORD, _DWORD);

//----- (10001F50) --------------------------------------------------------
signed int __cdecl sub_10001F50(int a1, int a2)
{
  signed int result; // eax
  _DWORD *v3; // esi
  char *v4; // ebx
  char *v5; // eax
  _DWORD *v6; // ecx
  signed int v7; // edx
  int v8; // edi
  signed int v9; // [esp+Ch] [ebp-CCh]
  char *v10; // [esp+10h] [ebp-C8h]
  char *v11; // [esp+14h] [ebp-C4h]
  char *v12; // [esp+18h] [ebp-C0h]
  char *v13; // [esp+1Ch] [ebp-BCh]
  char v14[32]; // [esp+20h] [ebp-B8h]
  char v15; // [esp+40h] [ebp-98h]
  char v16; // [esp+50h] [ebp-88h]
  char v17; // [esp+58h] [ebp-80h]
  char v18; // [esp+78h] [ebp-60h]
  char v19; // [esp+98h] [ebp-40h]
  char v20; // [esp+B8h] [ebp-20h]

  qmemcpy(&v20, (const void *)(a1 + 96), 0x20u);
  qmemcpy(&v18, (const void *)(a1 + 64), 0x20u);
  qmemcpy(&v19, (const void *)(a1 + 32), 0x20u);
  qmemcpy(&v17, (const void *)a1, 0x20u);
  v10 = &v17;
  v11 = &v19;
  v12 = &v18;
  v13 = &v20;
  result = sub_10004230(&v10, 4, (int)&v15, (double *)&v16);
  if ( !result )
  {
    v3 = (_DWORD *)a2;
    v4 = &v14[-a2];
    v9 = 4;
    do
    {
      memset(v14, 0, sizeof(v14));
      *(_DWORD *)((char *)v3 + (_DWORD)v4) = 0;
      *(_DWORD *)((char *)v3 + (_DWORD)v4 + 4) = 1072693248;
      sub_10004510(&v10, 4, (int)&v15, (int)v14);
      v5 = v14;
      v6 = v3;
      v7 = 4;
      do
      {
        v8 = *(_DWORD *)v5;
        v5 += 8;
        *v6 = v8;
        v6[1] = *((_DWORD *)v5 - 1);
        v6 += 8;
        --v7;
      }
      while ( v7 );
      v3 += 2;
      result = v9-- - 1;
    }
    while ( v9 );
  }
  return result;
}
// 10001F50: using guessed type char var_B8[32];

//----- (10002060) --------------------------------------------------------
int __cdecl sub_10002060(char *a1, char *a2, int a3)
{
  char v4; // [esp+10h] [ebp-120h]
  char v5; // [esp+28h] [ebp-108h]
  char v6; // [esp+40h] [ebp-F0h]
  char v7; // [esp+58h] [ebp-D8h]
  char v8; // [esp+70h] [ebp-C0h]
  char v9; // [esp+88h] [ebp-A8h]
  char v10; // [esp+A0h] [ebp-90h]
  char v11; // [esp+E8h] [ebp-48h]

  UF_MTX3_copy(a2 + 24, &v10);
  UF_MTX3_copy(a1 + 24, &v11);
  qmemcpy(&v9, a1, 0x18u);
  qmemcpy(&v7, a2, 0x18u);
  UF_MTX3_x_vec(&v10, &v5);
  UF_MTX3_y_vec(&v10, &v4);
  UF_MTX3_x_vec(&v11, &v6);
  UF_MTX3_y_vec(&v11, &v8);
  return UF_MTX4_csys_to_csys(&v7, &v5, &v4, &v9, &v6, &v8, a3);
}
// 100090C4: using guessed type int __cdecl UF_MTX3_copy(_DWORD, _DWORD);
// 100090C8: using guessed type int __cdecl UF_MTX4_csys_to_csys(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090DC: using guessed type int __cdecl UF_MTX3_x_vec(_DWORD, _DWORD);
// 100090E0: using guessed type int __cdecl UF_MTX3_y_vec(_DWORD, _DWORD);

//----- (10002140) --------------------------------------------------------
double __cdecl sub_10002140(int a1, int a2, int a3)
{
  double v4; // [esp+0h] [ebp-8h]

  UF_VEC3_angle_between(a1, a2, a3, &v4);
  return v4;
}
// 100090C0: using guessed type int __cdecl UF_VEC3_angle_between(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10002170) --------------------------------------------------------
signed int __cdecl sub_10002170(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // eax
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  int v7; // ecx
  int v8; // edx
  signed int v9; // esi
  double v10; // st7
  int v11; // eax
  signed int v13; // [esp+Ch] [ebp-9Ch]
  int v14; // [esp+10h] [ebp-98h]
  int v15; // [esp+14h] [ebp-94h]
  int v16; // [esp+18h] [ebp-90h]
  int v17; // [esp+1Ch] [ebp-8Ch]
  int v18; // [esp+20h] [ebp-88h]
  int v19; // [esp+24h] [ebp-84h]
  char v20[40]; // [esp+28h] [ebp-80h]
  char v21[40]; // [esp+50h] [ebp-58h]
  char v22; // [esp+78h] [ebp-30h]

  qmemcpy(&v22, a1, 0x30u);
  UF_VEC3_add(&v22, dword_1000BEF0 + 16, &v22);
  UF_VEC3_sub(&v22, dword_1000BEF0 + 40, &v22);
  v13 = sub_10002590(&v22, (int)v20, (int *)v21);
  UF_VEC3_add(v20, dword_1000BEF0 + 64, v20);
  UF_VEC3_add(v21, dword_1000BEF0 + 64, v21);
  v3 = dword_1000BEF0;
  if ( *(_BYTE *)(dword_1000BEF0 + 88) )
  {
    v4 = a1[7];
    v14 = a1[6];
    v5 = a1[8];
    v15 = v4;
    v6 = a1[9];
    v16 = v5;
    v7 = a1[10];
    v17 = v6;
    v8 = a1[11];
    v18 = v7;
    v19 = v8;
    UF_VEC3_scale(*(_DWORD *)(dword_1000BEF0 + 96), *(_DWORD *)(dword_1000BEF0 + 100), &v14, &v14);
    UF_VEC3_add(v20, &v14, v20);
    UF_VEC3_add(v21, &v14, v21);
    v3 = dword_1000BEF0;
  }
  v9 = 0;
  while ( 1 )
  {
    v10 = sub_10004600((double *)&v20[v9], (long double *)(v3 + 8));
    v11 = dword_1000BEF0;
    *(double *)&v20[v9] = v10;
    *(double *)&v21[v9] = sub_10004600((double *)&v21[v9], (long double *)(v11 + 8));
    v9 += 8;
    if ( v9 > 16 )
      break;
    v3 = dword_1000BEF0;
  }
  if ( BYTE2(dword_1000A018) )
    BYTE2(dword_1000A018) = 0;
  else
    sub_100023B0((int)&unk_1000BC48, (int)&unk_1000BDD0, (double *)v20, (double *)v21);
  qmemcpy(a2, v20, 0x28u);
  qmemcpy(a3, v21, 0x28u);
  qmemcpy(&unk_1000BC48, a2, 0x28u);
  qmemcpy(&unk_1000BDD0, a3, 0x28u);
  if ( byte_1000BF40 )
  {
    printf(aFinalUfuncMcoo, *a2, a2[1], a2[2], a2[3], a2[4], a2[5], a2[6], a2[7], a2[8], a2[9]);
    printf(aFinalUfuncAltM, *a3, a3[1], a3[2], a3[3], a3[4], a3[5], a3[6], a3[7], a3[8], a3[9]);
  }
  return v13;
}
// 100090A4: using guessed type int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD);
// 100090B8: using guessed type int __cdecl UF_VEC3_add(_DWORD, _DWORD, _DWORD);
// 100090BC: using guessed type int __cdecl UF_VEC3_scale(_DWORD, _DWORD, _DWORD, _DWORD);
// 1000A018: using guessed type int dword_1000A018;
// 1000BEF0: using guessed type int dword_1000BEF0;
// 1000BF40: using guessed type char byte_1000BF40;
// 10002170: using guessed type char var_58[40];
// 10002170: using guessed type char var_80[40];

//----- (100023B0) --------------------------------------------------------
void __cdecl sub_100023B0(int a1, int a2, double *a3, double *a4)
{
  double v4; // st7
  double v5; // st7
  char v6; // [esp+10h] [ebp-28h]

  v4 = sub_10002500(a3[3]);
  if ( fabs(*(double *)(a1 + 24) - v4) < fabs(*(double *)(a1 + 24) - a3[3]) )
    a3[3] = v4;
  v5 = sub_10002500(a3[4]);
  if ( fabs(*(double *)(a1 + 32) - v5) < fabs(*(double *)(a1 + 32) - a3[4]) )
    a3[4] = v5;
  if ( fabs(*(double *)(a1 + 24) - a4[3]) < fabs(*(double *)(a1 + 24) - a3[3]) )
  {
    qmemcpy(&v6, a3, 0x28u);
    qmemcpy(a3, a4, 0x28u);
    qmemcpy(a4, &v6, 0x28u);
  }
  if ( (*(double *)(dword_1000BEF0 + 104) - dbl_1000A010 >= a3[3]
     || *(double *)(dword_1000BEF0 + 112) + dbl_1000A010 <= a3[3])
    && *(double *)(dword_1000BEF0 + 120) - dbl_1000A010 < a4[3]
    && *(double *)(dword_1000BEF0 + 128) + dbl_1000A010 > a4[3] )
  {
    qmemcpy(&v6, a3, 0x28u);
    qmemcpy(a3, a4, 0x28u);
    qmemcpy(a4, &v6, 0x28u);
  }
}
// 1000A010: using guessed type double dbl_1000A010;
// 1000BEF0: using guessed type int dword_1000BEF0;

//----- (10002500) --------------------------------------------------------
double __cdecl sub_10002500(double a1)
{
  double result; // st7

  result = a1;
  if ( a1 > 0.0 )
    return a1 - 360.0;
  if ( a1 < 0.0 )
    result = a1 + 360.0;
  return result;
}

//----- (10002530) --------------------------------------------------------
int __cdecl sub_10002530(_DWORD *a1)
{
  qmemcpy((void *)(dword_1000BEF0 + 16), a1 + 48, 0x18u);
  qmemcpy((void *)(dword_1000BEF0 + 40), a1 + 54, 0x18u);
  *(_DWORD *)(dword_1000BEF0 + 136) = a1[94];
  *(_DWORD *)(dword_1000BEF0 + 140) = a1[95];
  return 0;
}
// 1000BEF0: using guessed type int dword_1000BEF0;

//----- (10002590) --------------------------------------------------------
signed int __cdecl sub_10002590(_DWORD *a1, int a2, int *a3)
{
  int v3; // esi
  _DWORD *v4; // eax
  int v5; // ecx
  signed int v6; // edx
  _DWORD *v7; // edi
  signed int result; // eax
  int v9; // ecx
  signed int v10; // ecx
  long double v11; // st7
  long double v12; // st6
  long double v13; // st7
  long double v14; // st7
  long double v15; // st7
  int v16; // eax
  double v17; // st6
  long double v18; // st7
  long double v19; // st6
  long double v20; // st6
  signed int v21; // ecx
  long double v22; // st7
  long double v23; // st6
  long double v24; // st6
  long double v25; // st6
  int v26; // eax
  signed int v27; // edi
  int v28; // eax
  int v29; // eax
  double v30; // st7
  int v31; // edi
  double v32; // st7
  char v34; // c0
  double v35; // st7
  char v37; // c0
  char v38; // [esp+2Fh] [ebp-D9h]
  double v39; // [esp+30h] [ebp-D8h]
  double v40; // [esp+30h] [ebp-D8h]
  double v41; // [esp+30h] [ebp-D8h]
  double v42; // [esp+30h] [ebp-D8h]
  double v43; // [esp+38h] [ebp-D0h]
  double v44; // [esp+40h] [ebp-C8h]
  double v45; // [esp+48h] [ebp-C0h]
  double v46; // [esp+50h] [ebp-B8h]
  double v47; // [esp+58h] [ebp-B0h]
  long double v48; // [esp+60h] [ebp-A8h]
  double v49; // [esp+68h] [ebp-A0h]
  double v50; // [esp+70h] [ebp-98h]
  long double v51; // [esp+80h] [ebp-88h]
  int v52[2]; // [esp+88h] [ebp-80h]
  double v53; // [esp+90h] [ebp-78h]
  long double v54; // [esp+98h] [ebp-70h]
  double v55; // [esp+A0h] [ebp-68h]
  double v56; // [esp+A8h] [ebp-60h]
  int v57; // [esp+BCh] [ebp-4Ch]
  double v58; // [esp+C0h] [ebp-48h]
  double v59; // [esp+C8h] [ebp-40h]
  int v60; // [esp+D4h] [ebp-34h]
  int v61; // [esp+D8h] [ebp-30h]
  char v62; // [esp+F0h] [ebp-18h]

  v3 = (int)a3;
  v38 = 0;
  v57 = 0;
  v4 = (_DWORD *)a2;
  v5 = (int)a3 - a2;
  v6 = 5;
  do
  {
    *(_DWORD *)((char *)v4 + v5) = 0;
    *(_DWORD *)((char *)v4 + v5 + 4) = 0;
    *v4 = 0;
    v4[1] = 0;
    v4 += 2;
    --v6;
  }
  while ( v6 );
  v7 = a1;
  if ( byte_1000BF40 )
  {
    printf(asc_1000A4CC);
    printf(aStartingOldPco, *a1, a1[1], a1[2], a1[3], a1[4], a1[5], a1[6], a1[7], a1[8], a1[9], a1[10], a1[11]);
  }
  if ( dword_1000BC00 == 3 )
  {
    UF_MTX3_vec_multiply_t(a1, &unk_100091A0, &v61);
    UF_MTX3_vec_multiply_t(a1 + 6, &unk_100091A0, &v62);
  }
  else
  {
    qmemcpy(&v61, a1, 0x30u);
    v3 = (int)a3;
    v7 = a1;
  }
  UF_VEC3_is_zero(&v62, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v60);
  if ( v60 )
    return 4;
  UF_VEC3_unitize(&v62, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v59, v52);
  v51 = *(double *)v52;
  v48 = v54;
  v58 = v53;
  v9 = *(_DWORD *)dword_1000BEF0;
  if ( *(_DWORD *)dword_1000BEF0 != 3 )
  {
    v47 = dbl_1000BD30 * v54 + dbl_1000BD10 * v53 + dbl_1000BCF0 * *(double *)v52;
    v40 = dbl_1000BD38 * v54 + dbl_1000BD18 * v53 + dbl_1000BCF8 * *(double *)v52;
    if ( fabs(dbl_1000BBE0) > dbl_1000A010 )
    {
      if ( v9 == 1 )
      {
        v17 = dbl_1000BF00;
      }
      else if ( v9 == 2 )
      {
        v17 = dbl_1000BF00;
      }
      else
      {
        v17 = v59;
      }
      v55 = (v17
           - (dbl_1000BD40 * v54
            + dbl_1000BD20 * v53
            + dbl_1000BD00 * *(double *)v52
            - (dbl_1000BD48 * v54 + dbl_1000BD28 * v53 + dbl_1000BD08 * *(double *)v52) * dbl_1000BF18)
           * dbl_1000BEF8)
          / dbl_1000BBE0;
    }
    else
    {
      v55 = 0.0;
      v38 = 1;
    }
    v49 = sqrt(v40 * v40 + v47 * v47);
    if ( fabs(v47) > dbl_1000A010 || fabs(v40) > dbl_1000A010 )
      v18 = atan2(v40, v47);
    else
      v18 = 0.0;
    if ( fabs(v49) > dbl_1000A010 )
      v41 = v55 / v49;
    else
      v41 = 0.0;
    if ( dbl_1000A010 + 1.0 >= fabs(v41) )
    {
      v19 = 1.0 - v41 * v41;
      if ( fabs(v19) <= dbl_1000A010 )
        v19 = 0.0;
      if ( fabs(v41 - 1.0) > dbl_1000A010 )
        v20 = sqrt(v19);
      else
        v20 = 0.0;
      v43 = atan2(v41, v20) + v18;
      v44 = atan2(v41, -v20) + v18;
    }
    else
    {
      printf(aInputPoint4f4f, *v7, v7[1], v7[2], v7[3], v7[4], v7[5], v7[6], v7[7], v7[8], v7[9], v7[10], v7[11]);
      printf(aWarningDegener, v41);
      v38 = 1;
      v44 = 0.0;
      v43 = 0.0;
    }
    v21 = 0;
    v22 = fabs(dbl_1000BBD8);
    do
    {
      v23 = *(double *)((char *)&v43 + v21);
      v47 = sin(v23);
      v24 = cos(v23);
      if ( v22 > dbl_1000A010 )
      {
        v55 = v24 * dbl_1000BEF8;
        v49 = -(dbl_1000BBE0 * dbl_1000BF18);
        v25 = ((v47 * dbl_1000BD38 + v24 * dbl_1000BD30 - dbl_1000BF10 * dbl_1000BD48) * v48
             + (v47 * dbl_1000BD18 + v24 * dbl_1000BD10 - dbl_1000BF10 * dbl_1000BD28) * v58
             + (v47 * dbl_1000BCF8 + v24 * dbl_1000BCF0 - dbl_1000BF10 * dbl_1000BD08) * v51)
            / dbl_1000BBD8;
        v42 = -(((dbl_1000BBE0 * dbl_1000BD40
                + v55 * dbl_1000BD38
                + -(v47 * dbl_1000BEF8) * dbl_1000BD30
                + v49 * dbl_1000BD48)
               * v48
               + (dbl_1000BBE0 * dbl_1000BD20
                + v55 * dbl_1000BD18
                + -(v47 * dbl_1000BEF8) * dbl_1000BD10
                + v49 * dbl_1000BD28)
               * v58
               + (dbl_1000BBE0 * dbl_1000BD00
                + v55 * dbl_1000BCF8
                + -(v47 * dbl_1000BEF8) * dbl_1000BCF0
                + v49 * dbl_1000BD08)
               * v51)
              / dbl_1000BBD8);
      }
      else
      {
        v25 = 0.0;
        v42 = 0.0;
      }
      if ( fabs(v25) > dbl_1000A010 || fabs(v42) > dbl_1000A010 )
      {
        *(double *)((char *)&v45 + v21) = atan2(v25, v42);
      }
      else
      {
        *(_DWORD *)((char *)&v45 + v21) = 0;
        *(_DWORD *)((char *)&v45 + v21 + 4) = 0;
        v38 = 1;
      }
      v21 += 8;
    }
    while ( v21 < 16 );
    goto LABEL_64;
  }
  if ( dword_1000BC00 )
  {
    if ( dword_1000BC00 != 1 && dword_1000BC00 != 3 )
      return 2;
    v39 = *(double *)&qword_1000BED8;
    v49 = dbl_1000BEE8;
    v48 = *(double *)&qword_1000BEE0;
    if ( fabs(dbl_1000BEE8 - 1.0) <= dbl_1000A010
      || (v47 = (v54 - dbl_1000BEE8 * dbl_1000BEE8) / (1.0 - dbl_1000BEE8 * dbl_1000BEE8), dbl_1000A010 + 1.0 < fabs(v47)) )
    {
      v43 = *(double *)&qword_1000BE08;
      v38 = 1;
      v44 = *(double *)&qword_1000BE10;
    }
    else
    {
      v43 = sub_100035B0(v47);
      v44 = -v43;
    }
    v10 = 0;
    do
    {
      v11 = *(double *)((char *)&v43 + v10 * 8);
      v12 = sin(v11);
      v13 = (1.0 - cos(v11)) * v49;
      v47 = v13 * v39 + v12 * v48;
      v14 = v13 * v48 - v12 * v39;
      v55 = v14 * v58 + v47 * v51;
      v15 = v47 * v58 - v14 * v51;
      if ( fabs(v15) > dbl_1000A010 || fabs(v55) > dbl_1000A010 )
      {
        *(double *)((char *)&v45 + v10 * 8) = atan2(v15, v55);
      }
      else
      {
        v16 = HIDWORD(qword_1000BDF8[v10]);
        *(_DWORD *)((char *)&v45 + v10 * 8) = qword_1000BDF8[v10];
        *(_DWORD *)((char *)&v45 + v10 * 8 + 4) = v16;
        v38 = 1;
      }
      ++v10;
    }
    while ( v10 < 2 );
LABEL_64:
    if ( v38 )
      goto LABEL_65;
    goto LABEL_68;
  }
  v43 = asin(-v53);
  v44 = sub_100035B0(sqrt(v54 * v54 + *(double *)v52 * *(double *)v52));
  if ( fabs(v43 - v44) <= dbl_1000A010 )
    v44 = sub_100035B0(-sqrt(v48 * v48 + v51 * v51));
  if ( fabs(v51) <= dbl_1000A010 && fabs(v48) <= dbl_1000A010 )
  {
    v45 = *(double *)qword_1000BDF8;
    v46 = *(double *)&qword_1000BE00;
    v38 = 1;
LABEL_65:
    if ( *(_DWORD *)dword_1000BEF0 != 3 )
    {
      v43 = *(double *)&qword_1000BE08;
      v44 = *(double *)&qword_1000BE10;
      v45 = *(double *)qword_1000BDF8;
      v46 = *(double *)&qword_1000BE00;
    }
    v57 = 1;
    goto LABEL_68;
  }
  v45 = atan2(v51, v48);
  v46 = atan2(-v51, -v48);
LABEL_68:
  if ( BYTE1(dword_1000A018) && (*(_DWORD *)dword_1000BEF0 == 2 || *(_DWORD *)dword_1000BEF0 == 3) )
  {
    sub_10003CD0(&v43, (int)&v45);
    dbl_1000BBB0 = v43;
    dbl_1000BBB8 = v44;
    dbl_1000BBA0 = v45;
    dbl_1000BBA8 = v46;
    result = v57;
  }
  else
  {
    v26 = *(_DWORD *)dword_1000BEF0;
    if ( *(_DWORD *)dword_1000BEF0 == 1 )
    {
      qmemcpy((void *)a2, &v61, 0x18u);
      qmemcpy(a3, &v61, 0x18u);
      v3 = (int)a3;
    }
    else if ( v26 == 2 || v26 == 3 )
    {
      if ( byte_1000BF40 )
      {
        printf(aAboutAdjusting);
        printf(
          aComputingT10FT,
          v43 * 57.29577951308235,
          v45 * 57.29577951308235,
          (dbl_1000BBB0 + dbl_1000BBB0 - v43) * 57.29577951308235,
          (dbl_1000BBA0 + dbl_1000BBA0 - v45) * 57.29577951308235);
        printf(
          aComputingT11FT,
          v44 * 57.29577951308235,
          v46 * 57.29577951308235,
          (dbl_1000BBB8 + dbl_1000BBB8 - v44) * 57.29577951308235,
          (dbl_1000BBA8 + dbl_1000BBA8 - v46) * 57.29577951308235);
      }
      sub_10003CD0(&v43, (int)&v45);
      if ( *(_DWORD *)dword_1000BEF0 == 2 )
      {
        v55 = v43;
        v56 = v44;
        v49 = v45;
        v50 = v46;
        sub_10003990((int)v52, (int)&v55, &v49);
        v46 = v50;
        v44 = v56;
        v43 = v55;
        v45 = v49;
        sub_10003600((int)&v61, v55, v49, a2, 1);
        sub_10003600((int)&v61, v56, v50, v3, 1);
      }
      else
      {
        sub_10003820((int)&v61, -v45, a2);
        sub_10003820((int)&v61, -v46, v3);
        if ( dword_1000BC00 == 3 )
        {
          v27 = 0;
          do
          {
            v28 = a2;
            if ( v27 )
              v28 = v3;
            UF_MTX3_vec_multiply_t(v28, &unk_10009158, v28);
            ++v27;
          }
          while ( v27 < 2 );
        }
      }
    }
    v29 = *(_DWORD *)dword_1000BEF0;
    if ( *(_DWORD *)dword_1000BEF0 == 1 )
    {
      v30 = *(double *)(dword_1000BEF0 + 144) + *(double *)(dword_1000BEF0 + 136);
      v49 = v30;
      v31 = HIDWORD(v49);
      UF_VEC3_affine_comb(a2, LODWORD(v30), *(unsigned __int64 *)&v30 >> 32, v52, a2);
      UF_VEC3_affine_comb(v3, LODWORD(v49), v31, v52, v3);
      sub_100037A0(a2, v43, 0, 0, a2);
      sub_100037A0(v3, v44, 0, 0, v3);
    }
    else if ( v29 == 3 )
    {
      sub_10003820((int)v52, -v45, (int)&v49);
      UF_VEC3_unitize(&v49, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v59, &v49);
      UF_VEC3_affine_comb(a2, *(_DWORD *)(dword_1000BEF0 + 136), *(_DWORD *)(dword_1000BEF0 + 140), &v49, a2);
      UF_VEC3_affine_comb(v3, *(_DWORD *)(dword_1000BEF0 + 136), *(_DWORD *)(dword_1000BEF0 + 140), &v49, v3);
    }
    else if ( v29 == 2 )
    {
      sub_10003600((int)v52, v43, v45, (int)&v49, 0);
      sub_10003600((int)v52, v44, v46, (int)&v55, 0);
      UF_VEC3_unitize(&v49, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v59, &v49);
      UF_VEC3_unitize(&v55, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v59, &v55);
      UF_VEC3_affine_comb(a2, *(_DWORD *)(dword_1000BEF0 + 136), *(_DWORD *)(dword_1000BEF0 + 140), &v49, a2);
      UF_VEC3_affine_comb(v3, *(_DWORD *)(dword_1000BEF0 + 136), *(_DWORD *)(dword_1000BEF0 + 140), &v55, v3);
    }
    *(double *)(a2 + 24) = v43 * 57.29577951308235;
    *(double *)(v3 + 24) = v44 * 57.29577951308235;
    *(double *)(a2 + 32) = v45 * 57.29577951308235;
    *(double *)(v3 + 32) = v46 * 57.29577951308235;
    if ( (_BYTE)dword_1000A018 && *(_DWORD *)dword_1000BEF0 != 3 )
    {
      v32 = *(double *)(a2 + 32) - 90.0;
      *(double *)(a2 + 32) = v32;
      if ( v34 )
        *(double *)(a2 + 32) = v32 + 360.0;
      v35 = *(double *)(v3 + 32) - 90.0;
      *(double *)(v3 + 32) = v35;
      if ( v37 )
        *(double *)(v3 + 32) = v35 + 360.0;
    }
    if ( v38 && *(_DWORD *)dword_1000BEF0 != 3 )
    {
      *(_DWORD *)(a2 + 24) = dword_1000BC38;
      *(_DWORD *)(a2 + 28) = dword_1000BC3C;
      *(_DWORD *)(a2 + 32) = dword_1000BC40;
      *(_DWORD *)(a2 + 36) = dword_1000BC44;
      *(_DWORD *)(v3 + 24) = dword_1000BEC8;
      *(_DWORD *)(v3 + 28) = dword_1000BECC;
      *(_DWORD *)(v3 + 32) = dword_1000BED0;
      *(_DWORD *)(v3 + 36) = dword_1000BED4;
    }
    if ( byte_1000BF40 && fabs(v43 - v44) <= dbl_1000A010 && fabs(v45 - v46) <= dbl_1000A010 )
      printf(aWarningSameVal);
    qmemcpy(&unk_1000BC20, (const void *)a2, 0x28u);
    qmemcpy(&unk_1000BEB0, a3, 0x28u);
    qword_1000BE08 = *(_QWORD *)&v43;
    *(double *)qword_1000BDF8 = v45;
    qword_1000BE10 = *(_QWORD *)&v44;
    result = v57;
    qword_1000BE00 = *(_QWORD *)&v46;
  }
  return result;
}
// 100090B0: using guessed type int __cdecl UF_VEC3_is_zero(_DWORD, _DWORD, _DWORD, _DWORD);
// 100090B4: using guessed type int __cdecl UF_VEC3_affine_comb(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090D0: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090EC: using guessed type int __cdecl UF_MTX3_vec_multiply_t(_DWORD, _DWORD, _DWORD);
// 1000A010: using guessed type double dbl_1000A010;
// 1000A018: using guessed type int dword_1000A018;
// 1000BBA0: using guessed type double dbl_1000BBA0;
// 1000BBA8: using guessed type double dbl_1000BBA8;
// 1000BBB0: using guessed type double dbl_1000BBB0;
// 1000BBB8: using guessed type double dbl_1000BBB8;
// 1000BBD8: using guessed type double dbl_1000BBD8;
// 1000BBE0: using guessed type double dbl_1000BBE0;
// 1000BC00: using guessed type int dword_1000BC00;
// 1000BC38: using guessed type int dword_1000BC38;
// 1000BC3C: using guessed type int dword_1000BC3C;
// 1000BC40: using guessed type int dword_1000BC40;
// 1000BC44: using guessed type int dword_1000BC44;
// 1000BCF0: using guessed type double dbl_1000BCF0;
// 1000BCF8: using guessed type double dbl_1000BCF8;
// 1000BD00: using guessed type double dbl_1000BD00;
// 1000BD08: using guessed type double dbl_1000BD08;
// 1000BD10: using guessed type double dbl_1000BD10;
// 1000BD18: using guessed type double dbl_1000BD18;
// 1000BD20: using guessed type double dbl_1000BD20;
// 1000BD28: using guessed type double dbl_1000BD28;
// 1000BD30: using guessed type double dbl_1000BD30;
// 1000BD38: using guessed type double dbl_1000BD38;
// 1000BD40: using guessed type double dbl_1000BD40;
// 1000BD48: using guessed type double dbl_1000BD48;
// 1000BDF8: using guessed type __int64 qword_1000BDF8[];
// 1000BE00: using guessed type __int64 qword_1000BE00;
// 1000BE08: using guessed type __int64 qword_1000BE08;
// 1000BE10: using guessed type __int64 qword_1000BE10;
// 1000BEC8: using guessed type int dword_1000BEC8;
// 1000BECC: using guessed type int dword_1000BECC;
// 1000BED0: using guessed type int dword_1000BED0;
// 1000BED4: using guessed type int dword_1000BED4;
// 1000BED8: using guessed type __int64 qword_1000BED8;
// 1000BEE0: using guessed type __int64 qword_1000BEE0;
// 1000BEE8: using guessed type double dbl_1000BEE8;
// 1000BEF0: using guessed type int dword_1000BEF0;
// 1000BEF8: using guessed type double dbl_1000BEF8;
// 1000BF00: using guessed type double dbl_1000BF00;
// 1000BF10: using guessed type double dbl_1000BF10;
// 1000BF18: using guessed type double dbl_1000BF18;
// 1000BF40: using guessed type char byte_1000BF40;

//----- (100035B0) --------------------------------------------------------
long double __cdecl sub_100035B0(double a1)
{
  if ( fabs(a1 - 1.0) <= dbl_1000A010 )
    return 0.0;
  if ( fabs(a1 - -1.0) > dbl_1000A010 )
    return acos(a1);
  return 3.141592653589793;
}
// 1000A010: using guessed type double dbl_1000A010;

//----- (10003600) --------------------------------------------------------
int __cdecl sub_10003600(int a1, double a2, double a3, int a4, int a5)
{
  int v5; // ST48_4
  int v6; // ST4C_4
  int result; // eax
  int v8; // [esp+1Ch] [ebp-258h]
  int v9; // [esp+20h] [ebp-254h]
  int v10; // [esp+24h] [ebp-250h]
  int v11; // [esp+28h] [ebp-24Ch]
  int v12; // [esp+2Ch] [ebp-248h]
  int v13; // [esp+30h] [ebp-244h]
  char v14; // [esp+34h] [ebp-240h]
  char v15; // [esp+4Ch] [ebp-228h]
  char v16; // [esp+54h] [ebp-220h]
  double v17; // [esp+6Ch] [ebp-208h]
  char v18; // [esp+74h] [ebp-200h]
  char v19; // [esp+8Ch] [ebp-1E8h]
  char v20; // [esp+ACh] [ebp-1C8h]
  char v21; // [esp+12Ch] [ebp-148h]
  char v22; // [esp+174h] [ebp-100h]
  char v23; // [esp+1F4h] [ebp-80h]

  qmemcpy(&v16, (const void *)a1, 0x18u);
  v17 = (double)a5;
  v5 = *(_DWORD *)(dword_1000BEF0 + 8);
  v6 = *(_DWORD *)(dword_1000BEF0 + 12);
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  UF_MTX4_rotation(
    &unk_1000BC08,
    &dword_1000BBC0,
    COERCE_UNSIGNED_INT64(a3 * -57.29577951308235),
    COERCE_UNSIGNED_INT64(a3 * -57.29577951308235) >> 32,
    &v20);
  sub_100046A0((int)&v20);
  UF_MTX4_ask_rotation(&v20, &v21);
  UF_MTX3_vec_multiply(&dword_1000BED8, &v21, &v14);
  UF_VEC3_unitize(&v14, v5, v6, &v15, &v14);
  UF_MTX4_vec3_multiply(&v8, &v20, &v18);
  UF_MTX4_rotation(
    &v18,
    &v14,
    COERCE_UNSIGNED_INT64(a2 * -57.29577951308235),
    COERCE_UNSIGNED_INT64(a2 * -57.29577951308235) >> 32,
    &v22);
  sub_100046A0((int)&v22);
  UF_MTX4_multiply(&v20, &v22, &v23);
  sub_100046A0((int)&v23);
  result = UF_MTX4_vec_multiply(&v16, &v23, &v19);
  qmemcpy((void *)a4, &v19, 0x18u);
  return result;
}
// 1000905C: using guessed type int __cdecl UF_MTX4_rotation(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10009060: using guessed type int __cdecl UF_MTX4_ask_rotation(_DWORD, _DWORD);
// 1000907C: using guessed type int __cdecl UF_MTX4_multiply(_DWORD, _DWORD, _DWORD);
// 10009080: using guessed type int __cdecl UF_MTX4_vec3_multiply(_DWORD, _DWORD, _DWORD);
// 100090AC: using guessed type int __cdecl UF_MTX4_vec_multiply(_DWORD, _DWORD, _DWORD);
// 100090D0: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090F4: using guessed type int __cdecl UF_MTX3_vec_multiply(_DWORD, _DWORD, _DWORD);
// 1000BBC0: using guessed type int dword_1000BBC0;
// 1000BED8: using guessed type int dword_1000BED8;
// 1000BEF0: using guessed type int dword_1000BEF0;

//----- (100037A0) --------------------------------------------------------
int __cdecl sub_100037A0(int a1, double a2, int a3, int a4, int a5)
{
  char v6; // [esp+Ch] [ebp-E0h]
  char v7; // [esp+24h] [ebp-C8h]
  char v8; // [esp+6Ch] [ebp-80h]

  UF_MTX4_rotation(
    &unk_1000BBE8,
    &dword_1000BED8,
    COERCE_UNSIGNED_INT64(a2 * 57.29577951308235),
    COERCE_UNSIGNED_INT64(a2 * 57.29577951308235) >> 32,
    &v8);
  sub_100046A0((int)&v8);
  UF_MTX4_ask_rotation(&v8, &v7);
  UF_MTX3_vec_multiply(&unk_1000BC08, &v7, &v6);
  return UF_VEC3_add(a1, &v6, a5);
}
// 1000905C: using guessed type int __cdecl UF_MTX4_rotation(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10009060: using guessed type int __cdecl UF_MTX4_ask_rotation(_DWORD, _DWORD);
// 100090B8: using guessed type int __cdecl UF_VEC3_add(_DWORD, _DWORD, _DWORD);
// 100090F4: using guessed type int __cdecl UF_MTX3_vec_multiply(_DWORD, _DWORD, _DWORD);
// 1000BED8: using guessed type int dword_1000BED8;

//----- (10003820) --------------------------------------------------------
int __cdecl sub_10003820(int a1, double a2, int a3)
{
  int v4; // [esp+0h] [ebp-80h]

  sub_10003870(a2, (int)&dword_1000BBC0, (int)&v4);
  sub_100046A0((int)&v4);
  return UF_MTX4_vec3_multiply_t(a1, &v4, a3);
}
// 10009054: using guessed type int __cdecl UF_MTX4_vec3_multiply_t(_DWORD, _DWORD, _DWORD);
// 1000BBC0: using guessed type int dword_1000BBC0;

//----- (10003870) --------------------------------------------------------
int __cdecl sub_10003870(double a1, int a2, int a3)
{
  long double v3; // st7
  double *v4; // ecx
  int result; // eax
  long double v6; // st6
  double v7; // ST08_8
  double v8; // ST10_8
  long double v9; // st4
  long double v10; // st3
  long double v11; // st4
  long double v12; // st3

  v3 = cos(a1);
  v4 = (double *)a2;
  result = a3;
  v6 = sin(a1);
  v7 = *(double *)(a2 + 8) * *(double *)(a2 + 8);
  v8 = *(double *)(a2 + 16) * *(double *)(a2 + 16);
  *(long double *)a3 = (1.0 - *(double *)a2 * *(double *)a2) * v3 + *(double *)a2 * *(double *)a2;
  *(long double *)(a3 + 8) = v4[1] * *v4 * (1.0 - v3) + v6 * v4[2];
  v9 = v4[2] * *v4 * (1.0 - v3);
  v10 = v6 * *(double *)(a2 + 8);
  *(_DWORD *)(a3 + 24) = 0;
  *(_DWORD *)(a3 + 28) = 0;
  *(long double *)(a3 + 16) = v9 - v10;
  *(long double *)(a3 + 32) = v4[1] * *v4 * (1.0 - v3) - v6 * v4[2];
  *(long double *)(a3 + 40) = (1.0 - v7) * v3 + v7;
  v11 = v4[2] * v4[1] * (1.0 - v3);
  v12 = v6 * *(double *)a2;
  *(_DWORD *)(a3 + 56) = 0;
  *(_DWORD *)(a3 + 60) = 0;
  *(long double *)(a3 + 48) = v11 + v12;
  *(long double *)(a3 + 64) = v4[2] * *v4 * (1.0 - v3) + v6 * v4[1];
  *(long double *)(a3 + 72) = v4[2] * v4[1] * (1.0 - v3) - v6 * *v4;
  *(_DWORD *)(a3 + 88) = 0;
  *(_DWORD *)(a3 + 96) = 0;
  *(_DWORD *)(a3 + 104) = 0;
  *(_DWORD *)(a3 + 112) = 0;
  *(_DWORD *)(a3 + 120) = 0;
  *(_DWORD *)(a3 + 92) = 0;
  *(_DWORD *)(a3 + 100) = 0;
  *(_DWORD *)(a3 + 108) = 0;
  *(_DWORD *)(a3 + 116) = 0;
  *(_DWORD *)(a3 + 124) = 1072693248;
  *(long double *)(a3 + 80) = (1.0 - v8) * v3 + v8;
  return result;
}

//----- (10003990) --------------------------------------------------------
int __cdecl sub_10003990(int a1, int a2, double *a3)
{
  unsigned int v3; // ecx
  unsigned int v4; // edx
  double v5; // ST54_8
  int v6; // edx
  double v7; // rax
  int v8; // ebx
  int *v9; // edi
  double *v10; // esi
  int v11; // edx
  int v12; // edx
  int v13; // ebx
  int *v14; // edi
  __int64 *v15; // esi
  int v16; // edx
  int result; // eax
  int v18; // edx
  signed int v19; // [esp+10h] [ebp-E8h]
  signed int v20; // [esp+10h] [ebp-E8h]
  double v21; // [esp+18h] [ebp-E0h]
  double v22; // [esp+20h] [ebp-D8h]
  double v23; // [esp+28h] [ebp-D0h]
  int v24; // [esp+30h] [ebp-C8h]
  int v25; // [esp+34h] [ebp-C4h]
  int v26; // [esp+38h] [ebp-C0h]
  int v27; // [esp+3Ch] [ebp-BCh]
  int v28; // [esp+40h] [ebp-B8h]
  int v29; // [esp+44h] [ebp-B4h]
  int v30; // [esp+48h] [ebp-B0h]
  char v31; // [esp+60h] [ebp-98h]
  int Base; // [esp+68h] [ebp-90h]
  int v33; // [esp+6Ch] [ebp-8Ch]
  double v34; // [esp+98h] [ebp-60h]
  double v35; // [esp+A0h] [ebp-58h]
  double v36; // [esp+A8h] [ebp-50h]
  double v37; // [esp+B0h] [ebp-48h]
  double v38; // [esp+B8h] [ebp-40h]
  double v39; // [esp+C0h] [ebp-38h]
  double v40; // [esp+C8h] [ebp-30h]
  double v41; // [esp+D0h] [ebp-28h]
  double v42; // [esp+D8h] [ebp-20h]
  double v43; // [esp+E0h] [ebp-18h]
  double v44; // [esp+E8h] [ebp-10h]
  double v45; // [esp+F0h] [ebp-8h]

  v3 = *(_DWORD *)(a2 + 8);
  v4 = *(_DWORD *)(a2 + 12);
  v40 = *(double *)a2;
  v5 = COERCE_DOUBLE(__PAIR__(v4, v3));
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v21 = v40 * -1.0;
  v41 = v21;
  v6 = *((_DWORD *)a3 + 1);
  LODWORD(v23) = *(_DWORD *)a3;
  LODWORD(v7) = *((_DWORD *)a3 + 2);
  HIDWORD(v23) = v6;
  HIDWORD(v7) = *((_DWORD *)a3 + 3);
  v22 = v7;
  v42 = v40 + 3.141592653589793;
  v34 = v5;
  v27 = 0;
  v28 = 0;
  v29 = 1072693248;
  v43 = 3.141592653589793 - v40;
  v44 = 3.141592653589793 - v21;
  v45 = v21 + 3.141592653589793;
  v35 = v5 * -1.0;
  v36 = v5 + 3.141592653589793;
  v37 = 3.141592653589793 - v5;
  v38 = 3.141592653589793 - v35;
  v39 = v35 + 3.141592653589793;
  if ( fabs(v23 - v7) <= dbl_1000A010 )
    a3[1] = v22 * -1.0;
  v8 = 0;
  v9 = &Base;
  v10 = &v40;
  v19 = 6;
  do
  {
    sub_10003600(a1, *v10, v23, (int)&v30, 0);
    UF_VEC3_unitize(&v30, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v31, &v30);
    UF_VEC3_is_equal(&v24, &v30, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v21);
    if ( LODWORD(v21) )
    {
      v11 = *((_DWORD *)v10 + 1);
      *v9 = *(_DWORD *)v10;
      v9[1] = v11;
      ++v8;
      v9 += 2;
    }
    ++v10;
    --v19;
  }
  while ( v19 );
  qsort(&Base, v8 - 1, 8u, PtFuncCompare);
  v12 = v33;
  *(_DWORD *)a2 = Base;
  *(_DWORD *)(a2 + 4) = v12;
  v13 = 0;
  v14 = &Base;
  v15 = (__int64 *)&v34;
  v20 = 6;
  do
  {
    sub_10003600(a1, *(double *)v15, v22, (int)&v30, 0);
    UF_VEC3_unitize(&v30, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v31, &v30);
    UF_VEC3_is_equal(&v24, &v30, LODWORD(dbl_1000A010), HIDWORD(dbl_1000A010), &v21);
    if ( LODWORD(v21) )
    {
      v16 = *((_DWORD *)v15 + 1);
      *v14 = *(_DWORD *)v15;
      v14[1] = v16;
      ++v13;
      v14 += 2;
    }
    ++v15;
    --v20;
  }
  while ( v20 );
  qsort(&Base, v13 - 1, 8u, PtFuncCompare);
  result = a2;
  v18 = v33;
  *(_DWORD *)(a2 + 8) = Base;
  *(_DWORD *)(a2 + 12) = v18;
  return result;
}
// 100090D0: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090E8: using guessed type int __cdecl UF_VEC3_is_equal(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1000A010: using guessed type double dbl_1000A010;

//----- (10003C90) --------------------------------------------------------
int __cdecl PtFuncCompare(const void *a1, const void *a2)
{
  if ( fabs(*(double *)a1 - *(double *)a2) <= dbl_1000A010 )
    return 0;
  if ( dbl_1000A010 + *(double *)a2 >= *(double *)a1 )
    return -1;
  return 1;
}
// 1000A010: using guessed type double dbl_1000A010;

//----- (10003CD0) --------------------------------------------------------
void __cdecl sub_10003CD0(double *a1, int a2)
{
  double v2; // st7
  long double v3; // st7
  double v4; // st7
  double v5; // [esp+0h] [ebp-8h]

  if ( fabs(*a1 - a1[1]) <= dbl_1000A010
    && fabs(*(double *)a2 - *(double *)(a2 + 8)) <= dbl_1000A010
    && fabs(*a1 - *(double *)a2) > dbl_1000A010 )
  {
    v5 = -dbl_1000A010;
    if ( *a1 >= v5 )
    {
      if ( *(double *)a2 >= v5 )
      {
        if ( dbl_1000A010 < *(double *)(a2 + 8) )
          *(double *)(a2 + 8) = *(double *)(a2 + 8) - 6.283185307179586;
      }
      else
      {
        v4 = *(double *)a2 + 6.283185307179586;
        if ( fabs(v4 - *a1) <= dbl_1000A010 )
        {
          if ( *(double *)(a2 + 8) < v5 )
            *(double *)(a2 + 8) = *(double *)(a2 + 8) + 6.283185307179586;
        }
        else
        {
          *(double *)a2 = v4;
          if ( fabs(v4 - *(double *)(a2 + 8)) <= dbl_1000A010 )
            *(double *)(a2 + 8) = 6.283185307179586 - v4;
        }
      }
    }
    else
    {
      v2 = *a1 + 6.283185307179586;
      *a1 = v2;
      a1[1] = 6.283185307179586 - v2;
    }
  }
  v3 = *a1;
  if ( fabs(v3 - *(double *)a2) <= dbl_1000A010 && fabs(a1[1] - *(double *)(a2 + 8)) <= dbl_1000A010 )
  {
    if ( -dbl_1000A010 <= *(double *)(a2 + 8) )
    {
      if ( dbl_1000A010 >= *(double *)(a2 + 8) )
      {
        if ( fabs(v3) <= dbl_1000A010 && fabs(*(long double *)a2) <= dbl_1000A010 )
        {
          *(_DWORD *)(a2 + 8) = 1413754136;
          *(_DWORD *)(a2 + 12) = 1075388923;
        }
      }
      else
      {
        *(double *)(a2 + 8) = 6.283185307179586 - *(double *)(a2 + 8);
      }
    }
    else
    {
      *(double *)(a2 + 8) = *(double *)(a2 + 8) + 6.283185307179586;
    }
  }
}
// 1000A010: using guessed type double dbl_1000A010;

//----- (10003EC0) --------------------------------------------------------
int __cdecl sub_10003EC0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  bool v6; // c3
  int result; // eax
  double v8; // st7
  double v9; // st6
  int v10; // eax
  double v11; // st7
  double v12; // st7
  double v13; // st7
  double v14; // st7
  bool v15; // zf
  double v16; // [esp+10h] [ebp-78h]
  double v17; // [esp+18h] [ebp-70h]
  double v18; // [esp+20h] [ebp-68h]
  double v19; // [esp+28h] [ebp-60h]
  double v20; // [esp+30h] [ebp-58h]
  double v21; // [esp+38h] [ebp-50h]
  char v22[24]; // [esp+40h] [ebp-48h]
  char v23[24]; // [esp+58h] [ebp-30h]
  char v24; // [esp+70h] [ebp-18h]

  UF_VEC3_sub(a1 + 24, a1, v22);
  UF_VEC3_sub(a1, a2, &v24);
  UF_VEC3_sub(a2 + 24, a2, v23);
  UF_VEC3_dot(v22, &v24, &v20);
  UF_VEC3_dot(v23, v22, &v17);
  UF_VEC3_dot(v23, &v24, &v19);
  UF_VEC3_dot(v23, v23, &v16);
  UF_VEC3_dot(v22, v22, &v18);
  if ( v16 != 0.0 )
  {
    if ( v18 == 0.0 )
    {
      UF_VEC3_copy(a1, a3);
      *(_DWORD *)a5 = 0;
      *(_DWORD *)(a5 + 4) = 0;
      return 0;
    }
    v21 = v17 * v17 - v18 * v16;
    if ( v21 != 0.0 )
    {
      v8 = v17 * v17 / (v18 * v16);
      if ( v8 < 0.0 )
        v8 = -v8;
      if ( v8 < 1.0 - (dbl_1000A010 + dbl_1000A010) )
      {
        v9 = (v16 * v20 - v19 * v17) / v21;
        *(double *)a5 = v9;
        v10 = a1;
        v11 = v9 * v17;
        LODWORD(v17) = a2 - a1;
        v12 = (v11 + v19) / v16;
        LODWORD(v16) = 3;
        *(double *)a6 = v12;
        do
        {
          v13 = *(double *)&v22[v10 - a1] * *(double *)a5;
          v10 += 8;
          *(double *)(a3 - a1 + v10 - 8) = v13 + *(double *)(v10 - 8);
          v14 = *(double *)&v23[v10 - a1 - 8] * *(double *)a6 + *(double *)(LODWORD(v17) + v10 - 8);
          v15 = LODWORD(v16)-- == 1;
          *(double *)(a4 - a1 + v10 - 8) = v14;
        }
        while ( !v15 );
        return 0;
      }
    }
    UF_VEC3_copy(a1, a3);
    *(_DWORD *)a5 = 0;
    *(_DWORD *)(a5 + 4) = 0;
    result = sub_10004150(a3, a2, a4, (double *)a6);
    if ( result )
      return result;
    return 0;
  }
  UF_VEC3_copy(a2, a4);
  v6 = v18 == 0.0;
  *(_DWORD *)a6 = 0;
  *(_DWORD *)(a6 + 4) = 0;
  if ( v6 )
  {
    UF_VEC3_copy(a1, a3);
    *(_DWORD *)a5 = 0;
    *(_DWORD *)(a5 + 4) = 0;
    return 0;
  }
  result = sub_10004150(a4, a1, a3, (double *)a5);
  if ( !result )
    return 0;
  return result;
}
// 100090A4: using guessed type int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD);
// 100090A8: using guessed type int __cdecl UF_VEC3_dot(_DWORD, _DWORD, _DWORD);
// 100090CC: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);
// 1000A010: using guessed type double dbl_1000A010;
// 10003EC0: using guessed type char var_48[24];
// 10003EC0: using guessed type char var_30[24];

//----- (10004150) --------------------------------------------------------
int __cdecl sub_10004150(int a1, int a2, int a3, double *a4)
{
  int v4; // eax
  signed int v5; // esi
  double v6; // st7
  int result; // eax
  double v8; // [esp+8h] [ebp-40h]
  double v9; // [esp+10h] [ebp-38h]
  double v10; // [esp+18h] [ebp-30h]
  double v11; // [esp+20h] [ebp-28h]
  double v12; // [esp+28h] [ebp-20h]
  char v13; // [esp+30h] [ebp-18h]

  UF_VEC3_sub(a2 + 24, a2, &v10);
  UF_VEC3_sub(a1, a2, &v13);
  v9 = v12 * v12 + v11 * v11 + v10 * v10;
  if ( v9 <= 0.0 )
  {
    *(_DWORD *)a4 = 0;
    *((_DWORD *)a4 + 1) = 0;
    UF_VEC3_copy(a2, a3);
    result = 0;
  }
  else
  {
    UF_VEC3_dot(&v10, &v13, &v8);
    v4 = a2;
    v5 = 3;
    *a4 = v8 / v9;
    do
    {
      v6 = *(double *)((char *)&v10 + v4 - a2) * *a4;
      v4 += 8;
      --v5;
      *(double *)(a3 - a2 + v4 - 8) = v6 + *(double *)(v4 - 8);
    }
    while ( v5 );
    result = 0;
  }
  return result;
}
// 100090A4: using guessed type int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD);
// 100090A8: using guessed type int __cdecl UF_VEC3_dot(_DWORD, _DWORD, _DWORD);
// 100090CC: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);

//----- (10004230) --------------------------------------------------------
signed int __cdecl sub_10004230(_DWORD *a1, int a2, int a3, double *a4)
{
  int v4; // ebx
  int v5; // ecx
  int v6; // esi
  long double **v7; // edx
  long double *v8; // ecx
  int v9; // edi
  long double v10; // st7
  int v11; // ecx
  _DWORD *v12; // edx
  _DWORD *v13; // edi
  signed int result; // eax
  int v15; // esi
  int v16; // eax
  double v17; // st7
  _DWORD *v18; // edx
  int v19; // edi
  double *v20; // ebx
  int v21; // eax
  int v22; // edx
  int v23; // edi
  long double v24; // st7
  int *v25; // edx
  int v26; // esi
  int v27; // eax
  int v28; // ebx
  long double v29; // st7
  int v30; // esi
  _DWORD *v31; // ebx
  int v32; // edx
  double v33; // st7
  _DWORD *v34; // edx
  int v35; // edx
  int *v36; // edx
  int v37; // esi
  int v38; // eax
  int v39; // [esp+10h] [ebp-30h]
  int v40; // [esp+14h] [ebp-2Ch]
  _DWORD *v41; // [esp+18h] [ebp-28h]
  int v42; // [esp+1Ch] [ebp-24h]
  int v43; // [esp+20h] [ebp-20h]
  _DWORD *v44; // [esp+20h] [ebp-20h]
  double *v45; // [esp+20h] [ebp-20h]
  int v46; // [esp+24h] [ebp-1Ch]
  _DWORD *v47; // [esp+28h] [ebp-18h]
  double v48; // [esp+28h] [ebp-18h]
  char v49; // [esp+34h] [ebp-Ch]
  double v50; // [esp+38h] [ebp-8h]

  v4 = a2;
  v5 = UF_allocate_memory(8 * a2, &v49);
  v6 = 0;
  *(_DWORD *)a4 = 0;
  v42 = v5;
  *((_DWORD *)a4 + 1) = 1072693248;
  if ( a2 <= 0 )
  {
LABEL_9:
    v11 = 0;
    v39 = 0;
    if ( a2 > 0 )
    {
      v12 = a1;
      v13 = a1;
      v41 = a1;
      while ( 1 )
      {
        v15 = 0;
        if ( v11 > 0 )
        {
          v44 = v12;
          do
          {
            v16 = *v12;
            v17 = *(double *)(v11 + *v12);
            if ( v15 > 0 )
            {
              v18 = a1;
              v19 = v15;
              do
              {
                v16 += 8;
                v20 = (double *)(*v18 + v11);
                ++v18;
                --v19;
                v17 = v17 - *v20 * *(double *)(v16 - 8);
              }
              while ( v19 );
              v12 = v44;
              v4 = a2;
              v13 = v41;
            }
            v21 = *v12;
            ++v15;
            ++v12;
            *(double *)(v11 + v21) = v17;
            v44 = v12;
          }
          while ( v15 < v39 );
        }
        v22 = v39;
        v50 = 0.0;
        v46 = v39;
        if ( v39 < v4 )
        {
          v47 = v13;
          v45 = (double *)(v11 + v42);
          do
          {
            v23 = *v13;
            v24 = *(double *)(v11 + v23);
            if ( v11 > 0 )
            {
              v25 = a1;
              v26 = v39;
              v27 = v23;
              do
              {
                v28 = *v25;
                v27 += 8;
                ++v25;
                --v26;
                v24 = v24 - *(double *)(v28 + v11) * *(double *)(v27 - 8);
              }
              while ( v26 );
              v22 = v46;
              v4 = a2;
            }
            *(long double *)(v11 + v23) = v24;
            v29 = fabs(v24) * *v45;
            if ( v29 >= v50 )
            {
              v50 = v29;
              v40 = v22;
            }
            ++v22;
            v13 = v47 + 1;
            v46 = v22;
            ++v47;
            ++v45;
          }
          while ( v22 < v4 );
          v13 = v41;
        }
        if ( v39 != v40 )
        {
          v30 = 0;
          do
          {
            v31 = (_DWORD *)(*v13 + 8 * v30);
            v32 = 8 * v30 + a1[v40];
            v33 = *(double *)v32;
            *(_DWORD *)v32 = *v31;
            *(_DWORD *)(v32 + 4) = v31[1];
            v13 = v41;
            *(double *)(8 * v30 + *v41) = v33;
            v4 = a2;
            ++v30;
          }
          while ( v30 < a2 );
          *a4 = -*a4;
          *(_DWORD *)(v42 + 8 * v40) = *(_DWORD *)(v11 + v42);
          *(_DWORD *)(v42 + 8 * v40 + 4) = *(_DWORD *)(v11 + v42 + 4);
        }
        *(_DWORD *)((char *)v13 + a3 - (_DWORD)a1) = v40;
        v34 = (_DWORD *)(v11 + *v13);
        if ( *(double *)(v11 + *v13) == 0.0 )
        {
          *v34 = 210911779;
          v34[1] = 1002937505;
        }
        v35 = v39;
        if ( v39 != v4 - 1 )
        {
          v48 = 1.0 / *(double *)(*v13 + v11);
          if ( v39 + 1 < v4 )
          {
            v36 = v13 + 1;
            v37 = v4 - (v39 + 1);
            do
            {
              v38 = *v36;
              ++v36;
              --v37;
              *(double *)(v11 + v38) = v48 * *(double *)(v38 + v11);
            }
            while ( v37 );
            v35 = v39;
          }
        }
        ++v13;
        v11 += 8;
        v39 = v35 + 1;
        v41 = v13;
        if ( v35 + 1 >= v4 )
          break;
        v12 = a1;
      }
    }
    UF_free(v42);
    result = 0;
  }
  else
  {
    v7 = (long double **)a1;
    v43 = v5;
    while ( 1 )
    {
      v8 = *v7;
      v50 = 0.0;
      v9 = a2;
      do
      {
        v10 = fabs(*v8);
        if ( v10 > v50 )
          v50 = v10;
        ++v8;
        --v9;
      }
      while ( v9 );
      if ( v50 == 0.0 )
        break;
      ++v6;
      ++v7;
      v43 += 8;
      *(double *)(v43 - 8) = 1.0 / v50;
      if ( v6 >= a2 )
        goto LABEL_9;
    }
    UF_free(v42);
    result = 1;
  }
  return result;
}
// 10009058: using guessed type int __cdecl UF_free(_DWORD);
// 10009064: using guessed type int __cdecl UF_allocate_memory(_DWORD, _DWORD);

//----- (10004510) --------------------------------------------------------
int __cdecl sub_10004510(_DWORD *a1, int a2, int a3, int a4)
{
  int v4; // ecx
  _DWORD *v5; // ebp
  int v6; // esi
  int v7; // edx
  int v8; // edi
  int v9; // eax
  _DWORD *v10; // ebx
  int v11; // eax
  double v12; // st7
  double *v13; // eax
  int v14; // esi
  double v15; // st6
  int result; // eax
  int v17; // ebx
  int *v18; // ebp
  double v19; // st7
  double *v20; // edx
  int v21; // esi
  double v22; // st6
  int v23; // edx
  signed int v24; // [esp+10h] [ebp-4h]
  int i; // [esp+20h] [ebp+Ch]

  v4 = a4;
  v5 = a1;
  v6 = a2;
  v7 = 0;
  v24 = 0;
  if ( a2 > 0 )
  {
    v8 = a4;
    v9 = a3 - (_DWORD)a1;
    v10 = a1;
    for ( i = a3 - (_DWORD)a1; ; v9 = i )
    {
      v11 = *(_DWORD *)((char *)v10 + v9);
      v12 = *(double *)(v4 + 8 * v11);
      *(_DWORD *)(v4 + 8 * v11) = *(_DWORD *)(v4 + 8 * v7);
      *(_DWORD *)(v4 + 8 * v11 + 4) = *(_DWORD *)(v4 + 8 * v7 + 4);
      if ( v24 )
      {
        if ( v8 < v7 )
        {
          v13 = (double *)(v4 + 8 * v8);
          v14 = v7 - a4;
          do
          {
            v15 = *(double *)((char *)v13 + *v10 - v4) * *v13;
            ++v13;
            --v14;
            v12 = v12 - v15;
          }
          while ( v14 );
          v6 = a2;
          v8 = a4;
        }
      }
      else if ( v12 != 0.0 )
      {
        v8 = v7;
        v24 = 1;
        a4 = v7;
      }
      *(double *)(v4 + 8 * v7++) = v12;
      ++v10;
      if ( v7 >= v6 )
        break;
    }
    v5 = a1;
  }
  result = v6 - 1;
  if ( v6 - 1 >= 0 )
  {
    v17 = v6;
    v18 = &v5[result];
    do
    {
      v19 = *(double *)(v4 + 8 * result);
      if ( v17 < v6 )
      {
        v20 = (double *)(v4 + 8 * result + 8);
        v21 = v6 - v17;
        do
        {
          v22 = *(double *)((char *)v20 + *v18 - v4) * *v20;
          ++v20;
          --v21;
          v19 = v19 - v22;
        }
        while ( v21 );
        v6 = a2;
      }
      v23 = *v18;
      --result;
      --v17;
      --v18;
      *(double *)(v4 + 8 * result + 8) = v19 / *(double *)(v23 + 8 * result + 8);
    }
    while ( result >= 0 );
  }
  return result;
}

//----- (10004600) --------------------------------------------------------
double __cdecl sub_10004600(double *a1, long double *a2)
{
  double v3; // st7
  double v4; // st7
  double v5; // [esp+8h] [ebp-8h]

  if ( fabs(fabs(*a2)) <= 1.0e-10 )
    return 0.0;
  v3 = 1.0 / *a2;
  v5 = v3;
  v4 = v3 * *a1;
  if ( v4 >= 0.000001 )
    return floor(v4 + 0.5) / v5;
  if ( v4 <= -0.000001 )
    return ceil(v4 - 0.5) / v5;
  return 0.0 / v5;
}

//----- (100046A0) --------------------------------------------------------
signed int __cdecl sub_100046A0(int a1)
{
  signed int v1; // edi
  char v3; // [esp+8h] [ebp-48h]

  UF_MTX4_ask_rotation(a1, &v3);
  v1 = sub_100046E0((int)&v3);
  UF_MTX4_edit_rotation(a1, &v3);
  return v1;
}
// 10009060: using guessed type int __cdecl UF_MTX4_ask_rotation(_DWORD, _DWORD);
// 10009078: using guessed type int __cdecl UF_MTX4_edit_rotation(_DWORD, _DWORD);

//----- (100046E0) --------------------------------------------------------
signed int __cdecl sub_100046E0(int a1)
{
  int v1; // esi
  signed int v2; // ecx
  long double v3; // st7
  double v4; // st7
  char v6; // [esp+10h] [ebp-98h]
  char v7; // [esp+18h] [ebp-90h]
  char v8; // [esp+30h] [ebp-78h]
  char v9; // [esp+48h] [ebp-60h]
  char v10; // [esp+60h] [ebp-48h]

  v1 = a1;
  UF_VEC3_copy(a1, &v7);
  UF_VEC3_copy(a1 + 24, &v8);
  UF_VEC3_copy(a1 + 48, &v9);
  UF_MTX3_copy(a1, &v10);
  v2 = 9;
  do
  {
    v3 = *(double *)v1;
    if ( fabs(v3) > 1.0e-10 )
    {
      if ( fabs(fabs(v3) - 1.0) <= 1.0e-10 )
      {
        if ( *(double *)v1 <= 0.0 )
          v4 = -1.0;
        else
          v4 = 1.0;
        *(double *)v1 = v4;
      }
    }
    else
    {
      *(_DWORD *)v1 = 0;
      *(_DWORD *)(v1 + 4) = 0;
    }
    v1 += 8;
    --v2;
  }
  while ( v2 );
  if ( !UF_VEC3_unitize(&v7, -640172613, 1037794527, &v6, &v7)
    || !UF_VEC3_unitize(&v8, -640172613, 1037794527, &v6, &v8) )
  {
    return 0;
  }
  UF_VEC3_cross(&v7, &v8, &v9);
  UF_VEC3_cross(&v9, &v7, &v8);
  return 1;
}
// 100090C4: using guessed type int __cdecl UF_MTX3_copy(_DWORD, _DWORD);
// 100090CC: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);
// 100090D0: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090D8: using guessed type int __cdecl UF_VEC3_cross(_DWORD, _DWORD, _DWORD);

//----- (10004810) --------------------------------------------------------
int __cdecl sub_10004810(int a1, int a2)
{
  char *v2; // edi
  char *v3; // edi
  char *v4; // edi
  char *v5; // edi
  char *v6; // edi
  char *v7; // edi
  char *v8; // edi
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  char *v13; // ecx
  int v14; // eax
  char *v15; // ecx
  int v16; // eax
  char *v17; // ecx
  int v18; // eax
  char *Str; // [esp+Ch] [ebp-98h]
  int v21; // [esp+10h] [ebp-94h]
  int v22; // [esp+14h] [ebp-90h]
  char *v23; // [esp+18h] [ebp-8Ch]
  char *v24; // [esp+1Ch] [ebp-88h]
  char *v25; // [esp+20h] [ebp-84h]
  char *v26; // [esp+24h] [ebp-80h]
  char *v27; // [esp+28h] [ebp-7Ch]
  char *v28; // [esp+2Ch] [ebp-78h]
  char *v29; // [esp+30h] [ebp-74h]
  char *v30; // [esp+34h] [ebp-70h]
  char *v31; // [esp+38h] [ebp-6Ch]
  char *v32; // [esp+3Ch] [ebp-68h]
  char *v33; // [esp+40h] [ebp-64h]
  char *v34; // [esp+44h] [ebp-60h]
  char *v35; // [esp+48h] [ebp-5Ch]
  char *v36; // [esp+4Ch] [ebp-58h]
  char v37; // [esp+50h] [ebp-54h]
  char v38; // [esp+6Ch] [ebp-38h]
  char v39; // [esp+88h] [ebp-1Ch]

  v2 = aMomKinMachineT;
  v33 = aMomKinGaugeToP;
  v35 = aMomKinGaugeToP;
  v23 = aMomKinMachineT;
  v24 = aMomKinTrackCen;
  v25 = aMomKinWireTilt;
  v26 = aMomKinClsfGene;
  v27 = aMomKinCoordina;
  v28 = aMomKinLineariz;
  v29 = aMomKinMachineR;
  v30 = aMomKinToolTrac;
  v31 = aMomKin5thAxisI;
  v32 = aMomKinLineariz_0;
  v34 = aMomKinGaugeToP_0;
  v36 = aEnd;
  v21 = 0;
  if ( !strcmp(aMomKinMachineT, aEnd) )
    return v22;
  do
  {
    v22 = UF_MOM_ask_string(a1, v2 + 4, &Str);
    switch ( v21 )
    {
      case 0:
        v3 = Str;
        if ( !Str )
        {
          v3 = a3AxisMill;
          Str = a3AxisMill;
        }
        strcpy((char *)a2, v3);
        break;
      case 1:
        v4 = Str;
        if ( !Str )
        {
          v4 = aT;
          Str = aT;
        }
        strcpy((char *)(a2 + 133), v4);
        break;
      case 2:
        v5 = Str;
        if ( !Str )
        {
          v5 = aNone;
          Str = aNone;
        }
        strcpy((char *)(a2 + 266), v5);
        break;
      case 3:
        v6 = Str;
        if ( !Str )
        {
          v6 = asc_1000A57C;
          Str = asc_1000A57C;
        }
        strcpy((char *)(a2 + 399), v6);
        break;
      case 4:
        v7 = Str;
        if ( !Str )
        {
          v7 = aCartesian;
          Str = aCartesian;
        }
        strcpy((char *)(a2 + 532), v7);
        break;
      case 5:
        v8 = Str;
        if ( !Str )
        {
          v8 = asc_1000A57C;
          Str = asc_1000A57C;
        }
        strcpy((char *)(a2 + 665), v8);
        break;
      case 6:
        v9 = Str;
        if ( !Str )
        {
          v9 = a00001;
          Str = a00001;
        }
        *(double *)(a2 + 800) = strtod(v9, 0);
        break;
      case 7:
        v10 = Str;
        if ( !Str )
        {
          v10 = a00;
          Str = a00;
        }
        *(double *)(a2 + 808) = strtod(v10, 0);
        break;
      case 8:
        v11 = Str;
        if ( !Str )
        {
          v11 = a900;
          Str = a900;
        }
        *(double *)(a2 + 816) = strtod(v11, 0);
        break;
      case 9:
        v12 = Str;
        if ( !Str )
        {
          v12 = a00001;
          Str = a00001;
        }
        *(double *)(a2 + 824) = strtod(v12, 0);
        break;
      case 10:
        v13 = Str;
        if ( !Str )
        {
          strcpy(&v37, "kin_4th_to_tracking_point_x");
          v14 = sub_10004C90(a1, (int)&v37, 0);
          v13 = Str;
          if ( !Str || v14 )
          {
            v13 = a00;
            Str = a00;
          }
        }
        *(double *)(a2 + 832) = strtod(v13, 0);
        break;
      case 11:
        v15 = Str;
        if ( !Str )
        {
          strcpy(&v39, "kin_4th_to_tracking_point_y");
          v16 = sub_10004C90(a1, (int)&v39, 0);
          v15 = Str;
          if ( !Str || v16 )
          {
            v15 = a00;
            Str = a00;
          }
        }
        *(double *)(a2 + 840) = strtod(v15, 0);
        break;
      case 12:
        v17 = Str;
        if ( !Str )
        {
          strcpy(&v38, "kin_4th_to_tracking_point_z");
          v18 = sub_10004C90(a1, (int)&v38, 0);
          v17 = Str;
          if ( !Str || v18 )
          {
            v17 = a00;
            Str = a00;
          }
        }
        *(double *)(a2 + 848) = strtod(v17, 0);
        break;
      default:
        break;
    }
    v2 = (&v23)[++v21];
  }
  while ( strcmp((&v23)[v21], aEnd) );
  return v22;
}
// 10009068: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10004C90) --------------------------------------------------------
int sub_10004C90(int a1, int a2, ...)
{
  va_list va; // [esp+Ch] [ebp+Ch]

  va_start(va, a2);
  return UF_MOM_ask_string(a1, a2, va);
}
// 10009068: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10004CB0) --------------------------------------------------------
int __cdecl sub_10004CB0(int a1, char *Str)
{
  const char *v2; // edi
  int v3; // ebx
  char *v4; // ebp
  char *v5; // edi
  char *v6; // edi
  char *v7; // edi
  char *v8; // edi
  char *v9; // eax
  char *v10; // eax
  int v12; // [esp+Ch] [ebp-20h]
  int v13; // [esp+Ch] [ebp-20h]
  char *v14; // [esp+14h] [ebp-18h]
  char *v15; // [esp+18h] [ebp-14h]
  char *v16; // [esp+1Ch] [ebp-10h]
  char *v17; // [esp+20h] [ebp-Ch]
  char *v18; // [esp+24h] [ebp-8h]
  char *v19; // [esp+28h] [ebp-4h]

  v2 = aMomKinNurbsOut;
  v14 = aMomKinOutputUn;
  v15 = aMomKinPolarRad;
  v16 = aMomKinReadAhea;
  v17 = aMomKinPivotGau;
  v18 = aMomKinRapidFee;
  v19 = aEnd;
  v3 = 0;
  if ( !strcmp(aMomKinNurbsOut, aEnd) )
    return v12;
  v4 = Str;
  do
  {
    v13 = UF_MOM_ask_string(a1, v2 + 4, &Str);
    switch ( v3 )
    {
      case 0:
        v5 = Str;
        if ( !Str )
        {
          v5 = aNone;
          Str = aNone;
        }
        strcpy(v4, v5);
        break;
      case 1:
        v6 = Str;
        if ( !Str )
        {
          v6 = aIn;
          Str = aIn;
        }
        strcpy(v4 + 133, v6);
        break;
      case 2:
        v7 = Str;
        if ( !Str )
        {
          v7 = aNone;
          Str = aNone;
        }
        strcpy(v4 + 266, v7);
        break;
      case 3:
        v8 = Str;
        if ( !Str )
        {
          v8 = asc_1000A57C;
          Str = asc_1000A57C;
        }
        strcpy(v4 + 399, v8);
        break;
      case 4:
        v9 = Str;
        if ( !Str )
        {
          v9 = a00;
          Str = a00;
        }
        *((double *)v4 + 67) = strtod(v9, 0);
        break;
      case 5:
        v10 = Str;
        if ( !Str )
        {
          v10 = a40000;
          Str = a40000;
        }
        *((double *)v4 + 68) = strtod(v10, 0);
        break;
      default:
        break;
    }
    v2 = (&v14)[v3++];
  }
  while ( strcmp(v2, aEnd) );
  return v13;
}
// 10009068: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10004EF0) --------------------------------------------------------
int __cdecl sub_10004EF0(int a1, char *Str)
{
  const char *v2; // edi
  int v3; // ebx
  char *v4; // ebp
  char *v5; // edi
  char *v6; // edi
  char *v7; // eax
  char *v8; // eax
  int v10; // [esp+Ch] [ebp-18h]
  int v11; // [esp+Ch] [ebp-18h]
  char *v12; // [esp+14h] [ebp-10h]
  char *v13; // [esp+18h] [ebp-Ch]
  char *v14; // [esp+1Ch] [ebp-8h]
  char *v15; // [esp+20h] [ebp-4h]

  v2 = aMomKinArcOutpu;
  v12 = aMomKinArcValid;
  v13 = aMomKinMinArcRa;
  v14 = aMomKinMaxArcRa;
  v15 = aEnd;
  v3 = 0;
  if ( !strcmp(aMomKinArcOutpu, aEnd) )
    return v10;
  v4 = Str;
  do
  {
    v11 = UF_MOM_ask_string(a1, v2 + 4, &Str);
    switch ( v3 )
    {
      case 0:
        v5 = Str;
        if ( !Str )
        {
          v5 = aFullCircle;
          Str = aFullCircle;
        }
        strcpy(v4, v5);
        break;
      case 1:
        v6 = Str;
        if ( !Str )
        {
          v6 = aXy;
          Str = aXy;
        }
        strcpy(v4 + 133, v6);
        break;
      case 2:
        v7 = Str;
        if ( !Str )
        {
          v7 = a00001;
          Str = a00001;
        }
        *((double *)v4 + 34) = strtod(v7, 0);
        break;
      case 3:
        v8 = Str;
        if ( !Str )
        {
          v8 = a99999999;
          Str = a99999999;
        }
        *((double *)v4 + 35) = strtod(v8, 0);
        break;
      default:
        break;
    }
    v2 = (&v12)[v3++];
  }
  while ( strcmp(v2, aEnd) );
  return v11;
}
// 10009068: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (100050A0) --------------------------------------------------------
int __cdecl sub_100050A0(int a1, char *Str)
{
  const char *v2; // edi
  int v3; // ebx
  double *v4; // ebp
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  int v14; // [esp+Ch] [ebp-28h]
  int v15; // [esp+Ch] [ebp-28h]
  char *v16; // [esp+14h] [ebp-20h]
  char *v17; // [esp+18h] [ebp-1Ch]
  char *v18; // [esp+1Ch] [ebp-18h]
  char *v19; // [esp+20h] [ebp-14h]
  char *v20; // [esp+24h] [ebp-10h]
  char *v21; // [esp+28h] [ebp-Ch]
  char *v22; // [esp+2Ch] [ebp-8h]
  char *v23; // [esp+30h] [ebp-4h]

  v2 = aMomKinMaxFpm;
  v16 = aMomKinMinFpm;
  v17 = aMomKinMaxFpr;
  v18 = aMomKinMinFpr;
  v19 = aMomKinMaxFrn;
  v20 = aMomKinMinFrn;
  v21 = aMomKinMaxDpm;
  v22 = aMomKinMinDpm;
  v23 = aEnd;
  v3 = 0;
  if ( !strcmp(aMomKinMaxFpm, aEnd) )
    return v14;
  v4 = (double *)Str;
  do
  {
    v15 = UF_MOM_ask_string(a1, v2 + 4, &Str);
    switch ( v3 )
    {
      case 0:
        v5 = Str;
        if ( !Str )
        {
          v5 = a999999;
          Str = a999999;
        }
        *v4 = strtod(v5, 0);
        break;
      case 1:
        v6 = Str;
        if ( !Str )
        {
          v6 = a0001;
          Str = a0001;
        }
        v4[4] = strtod(v6, 0);
        break;
      case 2:
        v7 = Str;
        if ( !Str )
        {
          v7 = a99999;
          Str = a99999;
        }
        v4[1] = strtod(v7, 0);
        break;
      case 3:
        v8 = Str;
        if ( !Str )
        {
          v8 = a0001;
          Str = a0001;
        }
        v4[5] = strtod(v8, 0);
        break;
      case 4:
        v9 = Str;
        if ( !Str )
        {
          v9 = a99999999_0;
          Str = a99999999_0;
        }
        v4[2] = strtod(v9, 0);
        break;
      case 5:
        v10 = Str;
        if ( !Str )
        {
          v10 = a0001;
          Str = a0001;
        }
        v4[6] = strtod(v10, 0);
        break;
      case 6:
        v11 = Str;
        if ( !Str )
        {
          v11 = a99999;
          Str = a99999;
        }
        v4[3] = strtod(v11, 0);
        break;
      case 7:
        v12 = Str;
        if ( !Str )
        {
          v12 = a00;
          Str = a00;
        }
        v4[7] = strtod(v12, 0);
        break;
      default:
        break;
    }
    v2 = (&v16)[v3++];
  }
  while ( strcmp(v2, aEnd) );
  return v15;
}
// 10009068: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (100052F0) --------------------------------------------------------
int __cdecl sub_100052F0(int a1, int a2)
{
  char *v2; // edi
  char *v3; // edi
  char *v4; // edi
  char *v5; // edi
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  char *v13; // eax
  char *v14; // eax
  char *v15; // eax
  char *v16; // eax
  char *v17; // eax
  char *Str; // [esp+Ch] [ebp-4Ch]
  int v20; // [esp+10h] [ebp-48h]
  int v21; // [esp+14h] [ebp-44h]
  char *v22; // [esp+18h] [ebp-40h]
  char *v23; // [esp+1Ch] [ebp-3Ch]
  char *v24; // [esp+20h] [ebp-38h]
  char *v25; // [esp+24h] [ebp-34h]
  char *v26; // [esp+28h] [ebp-30h]
  char *v27; // [esp+2Ch] [ebp-2Ch]
  char *v28; // [esp+30h] [ebp-28h]
  char *v29; // [esp+34h] [ebp-24h]
  char *v30; // [esp+38h] [ebp-20h]
  char *v31; // [esp+3Ch] [ebp-1Ch]
  char *v32; // [esp+40h] [ebp-18h]
  char *v33; // [esp+44h] [ebp-14h]
  char *v34; // [esp+48h] [ebp-10h]
  char *v35; // [esp+4Ch] [ebp-Ch]
  char *v36; // [esp+50h] [ebp-8h]
  char *v37; // [esp+54h] [ebp-4h]

  v2 = aMomKin4thAxisP;
  v22 = aMomKin4thAxisP;
  v23 = aMomKin4thAxisD;
  v24 = aMomKin4thAxisR;
  v25 = aMomKin4thAxisM;
  v26 = aMomKin4thAxisM_0;
  v27 = aMomKin4thAxisM_1;
  v28 = aMomKin4thAxisZ;
  v29 = aMomKin4thAxisC;
  v30 = aMomKin4thAxisC_0;
  v31 = aMomKin4thAxisC_1;
  v32 = aMomKin4thAxisV;
  v33 = aMomKin4thAxisV_0;
  v34 = aMomKin4thAxisV_1;
  v35 = aMomKin4thAxisA;
  v36 = aMomKin4thAxisA_0;
  v37 = aEnd;
  v20 = 0;
  if ( strcmp(aMomKin4thAxisP, aEnd) )
  {
    do
    {
      v21 = UF_MOM_ask_string(a1, v2 + 4, &Str);
      switch ( v20 )
      {
        case 0:
          v3 = Str;
          if ( !Str )
          {
            v3 = aYz;
            Str = aYz;
          }
          strcpy((char *)a2, v3);
          break;
        case 1:
          v4 = Str;
          if ( !Str )
          {
            v4 = aMagnitudeDeter;
            Str = aMagnitudeDeter;
          }
          strcpy((char *)(a2 + 133), v4);
          break;
        case 2:
          v5 = Str;
          if ( !Str )
          {
            v5 = aStandard;
            Str = aStandard;
          }
          strcpy((char *)(a2 + 266), v5);
          break;
        case 3:
          v6 = Str;
          if ( !Str )
          {
            v6 = a0001;
            Str = a0001;
          }
          *(double *)(a2 + 400) = strtod(v6, 0);
          break;
        case 4:
          v7 = Str;
          if ( !Str )
          {
            v7 = a00;
            Str = a00;
          }
          *(double *)(a2 + 408) = strtod(v7, 0);
          break;
        case 5:
          v8 = Str;
          if ( !Str )
          {
            v8 = a3600;
            Str = a3600;
          }
          *(double *)(a2 + 416) = strtod(v8, 0);
          break;
        case 6:
          v9 = Str;
          if ( !Str )
          {
            v9 = a00;
            Str = a00;
          }
          *(double *)(a2 + 424) = strtod(v9, 0);
          break;
        case 7:
          v10 = Str;
          if ( !Str )
          {
            v10 = a00;
            Str = a00;
          }
          *(double *)(a2 + 432) = strtod(v10, 0);
          break;
        case 8:
          v11 = Str;
          if ( !Str )
          {
            v11 = a00;
            Str = a00;
          }
          *(double *)(a2 + 440) = strtod(v11, 0);
          break;
        case 9:
          v12 = Str;
          if ( !Str )
          {
            v12 = a00;
            Str = a00;
          }
          *(double *)(a2 + 448) = strtod(v12, 0);
          break;
        case 10:
          v13 = Str;
          if ( !Str )
          {
            v13 = a00;
            Str = a00;
          }
          *(double *)(a2 + 456) = strtod(v13, 0);
          break;
        case 11:
          v14 = Str;
          if ( !Str )
          {
            v14 = a00;
            Str = a00;
          }
          *(double *)(a2 + 464) = strtod(v14, 0);
          break;
        case 12:
          v15 = Str;
          if ( !Str )
          {
            v15 = a00;
            Str = a00;
          }
          *(double *)(a2 + 472) = strtod(v15, 0);
          break;
        case 13:
          v16 = Str;
          if ( !Str )
          {
            v16 = a00;
            Str = a00;
          }
          *(double *)(a2 + 480) = strtod(v16, 0);
          break;
        case 14:
          v17 = Str;
          if ( !Str )
          {
            v17 = a00;
            Str = a00;
          }
          *(double *)(a2 + 488) = strtod(v17, 0);
          break;
        default:
          break;
      }
      v2 = (&v22)[++v20];
    }
    while ( strcmp((&v22)[v20], aEnd) );
  }
  return v21;
}
// 10009068: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10005700) --------------------------------------------------------
int __cdecl sub_10005700(int a1, int a2)
{
  char *v2; // edi
  char *v3; // edi
  char *v4; // edi
  char *v5; // edi
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  char *v13; // eax
  char *v14; // eax
  char *v15; // eax
  char *v16; // eax
  char *v17; // eax
  char *Str; // [esp+Ch] [ebp-4Ch]
  int v20; // [esp+10h] [ebp-48h]
  int v21; // [esp+14h] [ebp-44h]
  char *v22; // [esp+18h] [ebp-40h]
  char *v23; // [esp+1Ch] [ebp-3Ch]
  char *v24; // [esp+20h] [ebp-38h]
  char *v25; // [esp+24h] [ebp-34h]
  char *v26; // [esp+28h] [ebp-30h]
  char *v27; // [esp+2Ch] [ebp-2Ch]
  char *v28; // [esp+30h] [ebp-28h]
  char *v29; // [esp+34h] [ebp-24h]
  char *v30; // [esp+38h] [ebp-20h]
  char *v31; // [esp+3Ch] [ebp-1Ch]
  char *v32; // [esp+40h] [ebp-18h]
  char *v33; // [esp+44h] [ebp-14h]
  char *v34; // [esp+48h] [ebp-10h]
  char *v35; // [esp+4Ch] [ebp-Ch]
  char *v36; // [esp+50h] [ebp-8h]
  char *v37; // [esp+54h] [ebp-4h]

  v2 = aMomKin5thAxisP;
  v22 = aMomKin5thAxisP;
  v23 = aMomKin5thAxisD;
  v24 = aMomKin5thAxisR;
  v25 = aMomKin5thAxisM;
  v26 = aMomKin5thAxisM_0;
  v27 = aMomKin5thAxisM_1;
  v28 = aMomKin5thAxisZ;
  v29 = aMomKin5thAxisC;
  v30 = aMomKin5thAxisC_0;
  v31 = aMomKin5thAxisC_1;
  v32 = aMomKin5thAxisV;
  v33 = aMomKin5thAxisV_0;
  v34 = aMomKin5thAxisV_1;
  v35 = aMomKin5thAxisA;
  v36 = aMomKin5thAxisA_0;
  v37 = aEnd;
  v20 = 0;
  if ( strcmp(aMomKin5thAxisP, aEnd) )
  {
    do
    {
      v21 = UF_MOM_ask_string(a1, v2 + 4, &Str);
      switch ( v20 )
      {
        case 0:
          v3 = Str;
          if ( !Str )
          {
            v3 = aYz;
            Str = aYz;
          }
          strcpy((char *)a2, v3);
          break;
        case 1:
          v4 = Str;
          if ( !Str )
          {
            v4 = aMagnitudeDeter;
            Str = aMagnitudeDeter;
          }
          strcpy((char *)(a2 + 133), v4);
          break;
        case 2:
          v5 = Str;
          if ( !Str )
          {
            v5 = aStandard;
            Str = aStandard;
          }
          strcpy((char *)(a2 + 266), v5);
          break;
        case 3:
          v6 = Str;
          if ( !Str )
          {
            v6 = a0001;
            Str = a0001;
          }
          *(double *)(a2 + 400) = strtod(v6, 0);
          break;
        case 4:
          v7 = Str;
          if ( !Str )
          {
            v7 = a00;
            Str = a00;
          }
          *(double *)(a2 + 408) = strtod(v7, 0);
          break;
        case 5:
          v8 = Str;
          if ( !Str )
          {
            v8 = a3600;
            Str = a3600;
          }
          *(double *)(a2 + 416) = strtod(v8, 0);
          break;
        case 6:
          v9 = Str;
          if ( !Str )
          {
            v9 = a00;
            Str = a00;
          }
          *(double *)(a2 + 424) = strtod(v9, 0);
          break;
        case 7:
          v10 = Str;
          if ( !Str )
          {
            v10 = a00;
            Str = a00;
          }
          *(double *)(a2 + 432) = strtod(v10, 0);
          break;
        case 8:
          v11 = Str;
          if ( !Str )
          {
            v11 = a00;
            Str = a00;
          }
          *(double *)(a2 + 440) = strtod(v11, 0);
          break;
        case 9:
          v12 = Str;
          if ( !Str )
          {
            v12 = a00;
            Str = a00;
          }
          *(double *)(a2 + 448) = strtod(v12, 0);
          break;
        case 10:
          v13 = Str;
          if ( !Str )
          {
            v13 = a00;
            Str = a00;
          }
          *(double *)(a2 + 456) = strtod(v13, 0);
          break;
        case 11:
          v14 = Str;
          if ( !Str )
          {
            v14 = a00;
            Str = a00;
          }
          *(double *)(a2 + 464) = strtod(v14, 0);
          break;
        case 12:
          v15 = Str;
          if ( !Str )
          {
            v15 = a00;
            Str = a00;
          }
          *(double *)(a2 + 472) = strtod(v15, 0);
          break;
        case 13:
          v16 = Str;
          if ( !Str )
          {
            v16 = a00;
            Str = a00;
          }
          *(double *)(a2 + 480) = strtod(v16, 0);
          break;
        case 14:
          v17 = Str;
          if ( !Str )
          {
            v17 = a00;
            Str = a00;
          }
          *(double *)(a2 + 488) = strtod(v17, 0);
          break;
        default:
          break;
      }
      v2 = (&v22)[++v20];
    }
    while ( strcmp((&v22)[v20], aEnd) );
  }
  return v21;
}
// 10009068: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10005B10) --------------------------------------------------------
int __cdecl sub_10005B10(int a1, char *Str)
{
  const char *v2; // edi
  int v3; // ebp
  char *v4; // ebx
  char *v5; // eax
  char *v6; // eax
  char *v7; // edi
  int v9; // [esp+10h] [ebp-14h]
  char *v10; // [esp+18h] [ebp-Ch]
  char *v11; // [esp+1Ch] [ebp-8h]
  char *v12; // [esp+20h] [ebp-4h]

  v2 = aMomKinIndepend;
  v10 = aMomKinIndToDep;
  v11 = aMomKinIndToDep_0;
  v12 = aEnd;
  v3 = 0;
  if ( strcmp(aMomKinIndepend, aEnd) )
  {
    v4 = Str;
    do
    {
      v9 = UF_MOM_ask_string(a1, v2 + 4, &Str);
      if ( v3 )
      {
        if ( v3 == 1 )
        {
          v6 = Str;
          if ( !Str )
          {
            v6 = a00;
            Str = a00;
          }
          *((double *)v4 + 17) = strtod(v6, 0);
        }
        else if ( v3 == 2 )
        {
          v5 = Str;
          if ( !Str )
          {
            v5 = a00;
            Str = a00;
          }
          *((double *)v4 + 18) = strtod(v5, 0);
        }
      }
      else
      {
        v7 = Str;
        if ( !Str )
        {
          v7 = aFront;
          Str = aFront;
        }
        strcpy(v4, v7);
      }
      v2 = (&v10)[v3++];
    }
    while ( strcmp(v2, aEnd) );
  }
  return v9;
}
// 10009068: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10005C60) --------------------------------------------------------
int __cdecl sub_10005C60(int a1, char *Str)
{
  const char *v2; // edi
  int v3; // ebp
  double *v4; // ebx
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  int v9; // [esp+10h] [ebp-14h]
  char *v10; // [esp+18h] [ebp-Ch]
  char *v11; // [esp+1Ch] [ebp-8h]
  char *v12; // [esp+20h] [ebp-4h]

  v2 = aMomKinToolChan;
  v10 = aMomKinClampTim;
  v11 = aMomKinFlushTim;
  v12 = aEnd;
  v3 = 0;
  if ( strcmp(aMomKinToolChan, aEnd) )
  {
    v4 = (double *)Str;
    do
    {
      v9 = UF_MOM_ask_string(a1, v2 + 4, &Str);
      if ( v3 )
      {
        if ( v3 == 1 )
        {
          v6 = Str;
          if ( !Str )
          {
            v6 = a05;
            Str = a05;
          }
          v4[1] = strtod(v6, 0);
        }
        else if ( v3 == 2 )
        {
          v5 = Str;
          if ( !Str )
          {
            v5 = a05;
            Str = a05;
          }
          v4[2] = strtod(v5, 0);
        }
      }
      else
      {
        v7 = Str;
        if ( !Str )
        {
          v7 = a30;
          Str = a30;
        }
        *v4 = strtod(v7, 0);
      }
      v2 = (&v10)[v3++];
    }
    while ( strcmp(v2, aEnd) );
  }
  return v9;
}
// 10009068: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10005DA0) --------------------------------------------------------
int __cdecl sub_10005DA0(int a1, int a2)
{
  char *v2; // edi
  char *v3; // edi
  char *v4; // edi
  char *v5; // edi
  char *v6; // edi
  char *v7; // edi
  char *v8; // edi
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  char *v13; // eax
  char *v14; // eax
  char *v15; // eax
  char *v16; // eax
  char *v17; // eax
  char *v18; // eax
  char *v19; // eax
  char *v20; // eax
  char *v21; // eax
  char *v22; // eax
  char *v23; // eax
  char *v24; // eax
  char *v25; // eax
  char *v26; // eax
  char *Str; // [esp+10h] [ebp-70h]
  int v29; // [esp+14h] [ebp-6Ch]
  int v30; // [esp+18h] [ebp-68h]
  char *v31; // [esp+1Ch] [ebp-64h]
  char *v32; // [esp+20h] [ebp-60h]
  char *v33; // [esp+24h] [ebp-5Ch]
  char *v34; // [esp+28h] [ebp-58h]
  char *v35; // [esp+2Ch] [ebp-54h]
  char *v36; // [esp+30h] [ebp-50h]
  char *v37; // [esp+34h] [ebp-4Ch]
  char *v38; // [esp+38h] [ebp-48h]
  char *v39; // [esp+3Ch] [ebp-44h]
  char *v40; // [esp+40h] [ebp-40h]
  char *v41; // [esp+44h] [ebp-3Ch]
  char *v42; // [esp+48h] [ebp-38h]
  char *v43; // [esp+4Ch] [ebp-34h]
  char *v44; // [esp+50h] [ebp-30h]
  char *v45; // [esp+54h] [ebp-2Ch]
  char *v46; // [esp+58h] [ebp-28h]
  char *v47; // [esp+5Ch] [ebp-24h]
  char *v48; // [esp+60h] [ebp-20h]
  char *v49; // [esp+64h] [ebp-1Ch]
  char *v50; // [esp+68h] [ebp-18h]
  char *v51; // [esp+6Ch] [ebp-14h]
  char *v52; // [esp+70h] [ebp-10h]
  char *v53; // [esp+74h] [ebp-Ch]
  char *v54; // [esp+78h] [ebp-8h]
  char *v55; // [esp+7Ch] [ebp-4h]

  v2 = aMomKinHolder1O;
  v31 = aMomKinHolder1O;
  v32 = aMomKinHolder2O;
  v33 = aMomKinHolder3O;
  v34 = aMomKinHolder4O;
  v35 = aMomKinHolder5O;
  v36 = aMomKinHolder6O;
  v37 = aMomKinHolder1O_0;
  v38 = aMomKinHolder1O_1;
  v39 = aMomKinHolder1O_2;
  v40 = aMomKinHolder2O_0;
  v41 = aMomKinHolder2O_1;
  v42 = aMomKinHolder2O_2;
  v43 = aMomKinHolder3O_0;
  v44 = aMomKinHolder3O_1;
  v45 = aMomKinHolder3O_2;
  v46 = aMomKinHolder4O_0;
  v47 = aMomKinHolder4O_1;
  v48 = aMomKinHolder4O_2;
  v49 = aMomKinHolder5O_0;
  v50 = aMomKinHolder5O_1;
  v51 = aMomKinHolder5O_2;
  v52 = aMomKinHolder6O_0;
  v53 = aMomKinHolder6O_1;
  v54 = aMomKinHolder6O_2;
  v55 = aEnd;
  v29 = 0;
  if ( strcmp(aMomKinHolder1O, aEnd) )
  {
    do
    {
      v30 = UF_MOM_ask_string(a1, v2 + 4, &Str);
      switch ( v29 )
      {
        case 0:
          v3 = Str;
          if ( !Str )
          {
            v3 = aPosz;
            Str = aPosz;
          }
          strcpy((char *)a2, v3);
          break;
        case 1:
          v4 = Str;
          if ( !Str )
          {
            v4 = aPosz;
            Str = aPosz;
          }
          strcpy((char *)(a2 + 133), v4);
          break;
        case 2:
          v5 = Str;
          if ( !Str )
          {
            v5 = aPosz;
            Str = aPosz;
          }
          strcpy((char *)(a2 + 266), v5);
          break;
        case 3:
          v6 = Str;
          if ( !Str )
          {
            v6 = aPosz;
            Str = aPosz;
          }
          strcpy((char *)(a2 + 399), v6);
          break;
        case 4:
          v7 = Str;
          if ( !Str )
          {
            v7 = aPosz;
            Str = aPosz;
          }
          strcpy((char *)(a2 + 532), v7);
          break;
        case 5:
          v8 = Str;
          if ( !Str )
          {
            v8 = aPosz;
            Str = aPosz;
          }
          strcpy((char *)(a2 + 665), v8);
          break;
        case 6:
          v9 = Str;
          if ( !Str )
          {
            v9 = a00;
            Str = a00;
          }
          *(double *)(a2 + 800) = strtod(v9, 0);
          break;
        case 7:
          v10 = Str;
          if ( !Str )
          {
            v10 = a00;
            Str = a00;
          }
          *(double *)(a2 + 808) = strtod(v10, 0);
          break;
        case 8:
          v11 = Str;
          if ( !Str )
          {
            v11 = a00;
            Str = a00;
          }
          *(double *)(a2 + 816) = strtod(v11, 0);
          break;
        case 9:
          v12 = Str;
          if ( !Str )
          {
            v12 = a00;
            Str = a00;
          }
          *(double *)(a2 + 824) = strtod(v12, 0);
          break;
        case 10:
          v13 = Str;
          if ( !Str )
          {
            v13 = a00;
            Str = a00;
          }
          *(double *)(a2 + 832) = strtod(v13, 0);
          break;
        case 11:
          v14 = Str;
          if ( !Str )
          {
            v14 = a00;
            Str = a00;
          }
          *(double *)(a2 + 840) = strtod(v14, 0);
          break;
        case 12:
          v15 = Str;
          if ( !Str )
          {
            v15 = a00;
            Str = a00;
          }
          *(double *)(a2 + 848) = strtod(v15, 0);
          break;
        case 13:
          v16 = Str;
          if ( !Str )
          {
            v16 = a00;
            Str = a00;
          }
          *(double *)(a2 + 856) = strtod(v16, 0);
          break;
        case 14:
          v17 = Str;
          if ( !Str )
          {
            v17 = a00;
            Str = a00;
          }
          *(double *)(a2 + 864) = strtod(v17, 0);
          break;
        case 15:
          v18 = Str;
          if ( !Str )
          {
            v18 = a00;
            Str = a00;
          }
          *(double *)(a2 + 872) = strtod(v18, 0);
          break;
        case 16:
          v19 = Str;
          if ( !Str )
          {
            v19 = a00;
            Str = a00;
          }
          *(double *)(a2 + 880) = strtod(v19, 0);
          break;
        case 17:
          v20 = Str;
          if ( !Str )
          {
            v20 = a00;
            Str = a00;
          }
          *(double *)(a2 + 888) = strtod(v20, 0);
          break;
        case 18:
          v21 = Str;
          if ( !Str )
          {
            v21 = a00;
            Str = a00;
          }
          *(double *)(a2 + 896) = strtod(v21, 0);
          break;
        case 19:
          v22 = Str;
          if ( !Str )
          {
            v22 = a00;
            Str = a00;
          }
          *(double *)(a2 + 904) = strtod(v22, 0);
          break;
        case 20:
          v23 = Str;
          if ( !Str )
          {
            v23 = a00;
            Str = a00;
          }
          *(double *)(a2 + 912) = strtod(v23, 0);
          break;
        case 21:
          v24 = Str;
          if ( !Str )
          {
            v24 = a00;
            Str = a00;
          }
          *(double *)(a2 + 920) = strtod(v24, 0);
          break;
        case 22:
          v25 = Str;
          if ( !Str )
          {
            v25 = a00;
            Str = a00;
          }
          *(double *)(a2 + 928) = strtod(v25, 0);
          break;
        case 23:
          v26 = Str;
          if ( !Str )
          {
            v26 = a00;
            Str = a00;
          }
          *(double *)(a2 + 936) = strtod(v26, 0);
          break;
        default:
          break;
      }
      v2 = (&v31)[++v29];
    }
    while ( strcmp((&v31)[v29], aEnd) );
  }
  return v30;
}
// 10009068: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (100063B0) --------------------------------------------------------
int __cdecl sub_100063B0(int a1, double *a2)
{
  char *v2; // edi
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  char *v13; // eax
  char *v14; // eax
  char *Str; // [esp+10h] [ebp-40h]
  int v17; // [esp+14h] [ebp-3Ch]
  int v18; // [esp+18h] [ebp-38h]
  char *v19; // [esp+1Ch] [ebp-34h]
  char *v20; // [esp+20h] [ebp-30h]
  char *v21; // [esp+24h] [ebp-2Ch]
  char *v22; // [esp+28h] [ebp-28h]
  char *v23; // [esp+2Ch] [ebp-24h]
  char *v24; // [esp+30h] [ebp-20h]
  char *v25; // [esp+34h] [ebp-1Ch]
  char *v26; // [esp+38h] [ebp-18h]
  char *v27; // [esp+3Ch] [ebp-14h]
  char *v28; // [esp+40h] [ebp-10h]
  char *v29; // [esp+44h] [ebp-Ch]
  char *v30; // [esp+48h] [ebp-8h]
  char *v31; // [esp+4Ch] [ebp-4h]

  v2 = aMomMsysOriginX;
  v19 = aMomMsysOriginX;
  v20 = aMomMsysOriginY;
  v21 = aMomMsysOriginZ;
  v22 = aMomMsysXAxisI;
  v23 = aMomMsysXAxisJ;
  v24 = aMomMsysXAxisK;
  v25 = aMomMsysYAxisI;
  v26 = aMomMsysYAxisJ;
  v27 = aMomMsysYAxisK;
  v28 = aMomMsysZAxisI;
  v29 = aMomMsysZAxisJ;
  v30 = aMomMsysZAxisK;
  v31 = aEnd;
  v17 = 0;
  if ( strcmp(aMomMsysOriginX, aEnd) )
  {
    do
    {
      v18 = UF_MOM_ask_string(a1, v2 + 4, &Str);
      switch ( v17 )
      {
        case 0:
          v3 = Str;
          if ( !Str )
          {
            v3 = a00;
            Str = a00;
          }
          *a2 = strtod(v3, 0);
          break;
        case 1:
          v4 = Str;
          if ( !Str )
          {
            v4 = a00;
            Str = a00;
          }
          a2[1] = strtod(v4, 0);
          break;
        case 2:
          v5 = Str;
          if ( !Str )
          {
            v5 = a00;
            Str = a00;
          }
          a2[2] = strtod(v5, 0);
          break;
        case 3:
          v6 = Str;
          if ( !Str )
          {
            v6 = a10;
            Str = a10;
          }
          a2[3] = strtod(v6, 0);
          break;
        case 4:
          v7 = Str;
          if ( !Str )
          {
            v7 = a00;
            Str = a00;
          }
          a2[4] = strtod(v7, 0);
          break;
        case 5:
          v8 = Str;
          if ( !Str )
          {
            v8 = a00;
            Str = a00;
          }
          a2[5] = strtod(v8, 0);
          break;
        case 6:
          v9 = Str;
          if ( !Str )
          {
            v9 = a00;
            Str = a00;
          }
          a2[6] = strtod(v9, 0);
          break;
        case 7:
          v10 = Str;
          if ( !Str )
          {
            v10 = a10;
            Str = a10;
          }
          a2[7] = strtod(v10, 0);
          break;
        case 8:
          v11 = Str;
          if ( !Str )
          {
            v11 = a00;
            Str = a00;
          }
          a2[8] = strtod(v11, 0);
          break;
        case 9:
          v12 = Str;
          if ( !Str )
          {
            v12 = a00;
            Str = a00;
          }
          a2[9] = strtod(v12, 0);
          break;
        case 10:
          v13 = Str;
          if ( !Str )
          {
            v13 = a00;
            Str = a00;
          }
          a2[10] = strtod(v13, 0);
          break;
        case 11:
          v14 = Str;
          if ( !Str )
          {
            v14 = a10;
            Str = a10;
          }
          a2[11] = strtod(v14, 0);
          break;
        default:
          break;
      }
      v2 = (&v19)[++v17];
    }
    while ( strcmp((&v19)[v17], aEnd) );
  }
  return v18;
}
// 10009068: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (100066D0) --------------------------------------------------------
int __cdecl sub_100066D0(int a1, double *a2)
{
  char *v2; // edi
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  char *v13; // eax
  char *v14; // eax
  char *Str; // [esp+10h] [ebp-40h]
  int v17; // [esp+14h] [ebp-3Ch]
  int v18; // [esp+18h] [ebp-38h]
  char *v19; // [esp+1Ch] [ebp-34h]
  char *v20; // [esp+20h] [ebp-30h]
  char *v21; // [esp+24h] [ebp-2Ch]
  char *v22; // [esp+28h] [ebp-28h]
  char *v23; // [esp+2Ch] [ebp-24h]
  char *v24; // [esp+30h] [ebp-20h]
  char *v25; // [esp+34h] [ebp-1Ch]
  char *v26; // [esp+38h] [ebp-18h]
  char *v27; // [esp+3Ch] [ebp-14h]
  char *v28; // [esp+40h] [ebp-10h]
  char *v29; // [esp+44h] [ebp-Ch]
  char *v30; // [esp+48h] [ebp-8h]
  char *v31; // [esp+4Ch] [ebp-4h]

  v2 = aMomMtsysOrigin;
  v19 = aMomMtsysOrigin;
  v20 = aMomMtsysOrigin_0;
  v21 = aMomMtsysOrigin_1;
  v22 = aMomMtsysXAxisI;
  v23 = aMomMtsysXAxisJ;
  v24 = aMomMtsysXAxisK;
  v25 = aMomMtsysYAxisI;
  v26 = aMomMtsysYAxisJ;
  v27 = aMomMtsysYAxisK;
  v28 = aMomMtsysZAxisI;
  v29 = aMomMtsysZAxisJ;
  v30 = aMomMtsysZAxisK;
  v31 = aEnd;
  v17 = 0;
  if ( strcmp(aMomMtsysOrigin, aEnd) )
  {
    do
    {
      v18 = UF_MOM_ask_string(a1, v2 + 4, &Str);
      switch ( v17 )
      {
        case 0:
          v3 = Str;
          if ( !Str )
          {
            v3 = a00;
            Str = a00;
          }
          a2[12] = strtod(v3, 0);
          break;
        case 1:
          v4 = Str;
          if ( !Str )
          {
            v4 = a00;
            Str = a00;
          }
          a2[13] = strtod(v4, 0);
          break;
        case 2:
          v5 = Str;
          if ( !Str )
          {
            v5 = a00;
            Str = a00;
          }
          a2[14] = strtod(v5, 0);
          break;
        case 3:
          v6 = Str;
          if ( !Str )
          {
            v6 = a10;
            Str = a10;
          }
          a2[15] = strtod(v6, 0);
          break;
        case 4:
          v7 = Str;
          if ( !Str )
          {
            v7 = a00;
            Str = a00;
          }
          a2[16] = strtod(v7, 0);
          break;
        case 5:
          v8 = Str;
          if ( !Str )
          {
            v8 = a00;
            Str = a00;
          }
          a2[17] = strtod(v8, 0);
          break;
        case 6:
          v9 = Str;
          if ( !Str )
          {
            v9 = a00;
            Str = a00;
          }
          a2[18] = strtod(v9, 0);
          break;
        case 7:
          v10 = Str;
          if ( !Str )
          {
            v10 = a10;
            Str = a10;
          }
          a2[19] = strtod(v10, 0);
          break;
        case 8:
          v11 = Str;
          if ( !Str )
          {
            v11 = a00;
            Str = a00;
          }
          a2[20] = strtod(v11, 0);
          break;
        case 9:
          v12 = Str;
          if ( !Str )
          {
            v12 = a00;
            Str = a00;
          }
          a2[21] = strtod(v12, 0);
          break;
        case 10:
          v13 = Str;
          if ( !Str )
          {
            v13 = a00;
            Str = a00;
          }
          a2[22] = strtod(v13, 0);
          break;
        case 11:
          v14 = Str;
          if ( !Str )
          {
            v14 = a10;
            Str = a10;
          }
          a2[23] = strtod(v14, 0);
          break;
        default:
          break;
      }
      v2 = (&v19)[++v17];
    }
    while ( strcmp((&v19)[v17], aEnd) );
  }
  return v18;
}
// 10009068: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10006A00) --------------------------------------------------------
int __cdecl sub_10006A00(int a1, char *Str)
{
  const char *v2; // edi
  int v3; // ebx
  char *v4; // ebp
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // edi
  char *v12; // eax
  char *v13; // eax
  int result; // eax
  char *v15; // [esp+10h] [ebp-24h]
  char *v16; // [esp+14h] [ebp-20h]
  char *v17; // [esp+18h] [ebp-1Ch]
  char *v18; // [esp+1Ch] [ebp-18h]
  char *v19; // [esp+20h] [ebp-14h]
  char *v20; // [esp+24h] [ebp-10h]
  char *v21; // [esp+28h] [ebp-Ch]
  char *v22; // [esp+2Ch] [ebp-8h]
  char *v23; // [esp+30h] [ebp-4h]

  v2 = aMomOriginX;
  v15 = aMomOriginY;
  v16 = aMomOriginZ;
  v17 = aMomTranslateX;
  v18 = aMomTranslateY;
  v19 = aMomTranslateZ;
  v20 = aMomToolType;
  v21 = aMomToolZOffset;
  v22 = aMomToolCorner1;
  v23 = aEnd;
  v3 = 0;
  if ( !strcmp(aMomOriginX, aEnd) )
    return 0;
  v4 = Str;
  do
  {
    UF_MOM_ask_string(a1, v2 + 4, &Str);
    switch ( v3 )
    {
      case 0:
        v5 = Str;
        if ( !Str )
        {
          v5 = a00;
          Str = a00;
        }
        *((double *)v4 + 27) = strtod(v5, 0);
        break;
      case 1:
        v6 = Str;
        if ( !Str )
        {
          v6 = a00;
          Str = a00;
        }
        *((double *)v4 + 28) = strtod(v6, 0);
        break;
      case 2:
        v7 = Str;
        if ( !Str )
        {
          v7 = a00;
          Str = a00;
        }
        *((double *)v4 + 29) = strtod(v7, 0);
        break;
      case 3:
        v8 = Str;
        if ( !Str )
        {
          v8 = a00;
          Str = a00;
        }
        *((double *)v4 + 24) = strtod(v8, 0);
        break;
      case 4:
        v9 = Str;
        if ( !Str )
        {
          v9 = a00;
          Str = a00;
        }
        *((double *)v4 + 25) = strtod(v9, 0);
        break;
      case 5:
        v10 = Str;
        if ( !Str )
        {
          v10 = a00;
          Str = a00;
        }
        *((double *)v4 + 26) = strtod(v10, 0);
        break;
      case 6:
        v11 = Str;
        if ( !Str )
        {
          v11 = aMill;
          Str = aMill;
        }
        strcpy(v4 + 240, v11);
        break;
      case 7:
        v12 = Str;
        if ( !Str )
        {
          v12 = a00;
          Str = a00;
        }
        *((double *)v4 + 47) = strtod(v12, 0);
        break;
      case 8:
        v13 = Str;
        if ( !Str )
        {
          v13 = a00;
          Str = a00;
        }
        *((double *)v4 + 48) = strtod(v13, 0);
        break;
      default:
        break;
    }
    v2 = (&v15)[v3++];
    result = strcmp(v2, aEnd);
  }
  while ( result );
  return result;
}
// 10009068: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10006CA0) --------------------------------------------------------
int __cdecl sub_10006CA0(int a1, char *Str)
{
  const char *v2; // edi
  int v3; // ebx
  double *v4; // ebp
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  int v12; // [esp+Ch] [ebp-20h]
  int v13; // [esp+Ch] [ebp-20h]
  char *v14; // [esp+14h] [ebp-18h]
  char *v15; // [esp+18h] [ebp-14h]
  char *v16; // [esp+1Ch] [ebp-10h]
  char *v17; // [esp+20h] [ebp-Ch]
  char *v18; // [esp+24h] [ebp-8h]
  char *v19; // [esp+28h] [ebp-4h]

  v2 = aMomMcsGotoX;
  v14 = aMomMcsGotoY;
  v15 = aMomMcsGotoZ;
  v16 = aMomToolAxisI;
  v17 = aMomToolAxisJ;
  v18 = aMomToolAxisK;
  v19 = aEnd;
  v3 = 0;
  if ( !strcmp(aMomMcsGotoX, aEnd) )
    return v12;
  v4 = (double *)Str;
  do
  {
    v13 = UF_MOM_ask_string(a1, v2 + 4, &Str);
    switch ( v3 )
    {
      case 0:
        v5 = Str;
        if ( !Str )
        {
          v5 = a00;
          Str = a00;
        }
        *v4 = strtod(v5, 0);
        break;
      case 1:
        v6 = Str;
        if ( !Str )
        {
          v6 = a00;
          Str = a00;
        }
        v4[1] = strtod(v6, 0);
        break;
      case 2:
        v7 = Str;
        if ( !Str )
        {
          v7 = a00;
          Str = a00;
        }
        v4[2] = strtod(v7, 0);
        break;
      case 3:
        v8 = Str;
        if ( !Str )
        {
          v8 = a00;
          Str = a00;
        }
        v4[3] = strtod(v8, 0);
        break;
      case 4:
        v9 = Str;
        if ( !Str )
        {
          v9 = a00;
          Str = a00;
        }
        v4[4] = strtod(v9, 0);
        break;
      case 5:
        v10 = Str;
        if ( !Str )
        {
          v10 = a00;
          Str = a00;
        }
        v4[5] = strtod(v10, 0);
        break;
      default:
        break;
    }
    v2 = (&v14)[v3++];
  }
  while ( strcmp(v2, aEnd) );
  return v13;
}
// 10009068: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10006E90) --------------------------------------------------------
int __cdecl sub_10006E90(int a1, double *a2)
{
  int v2; // edi
  const char *v3; // esi
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  int result; // eax
  char *Str; // [esp+Ch] [ebp-34h]
  int v15; // [esp+10h] [ebp-30h]
  int v16; // [esp+14h] [ebp-2Ch]
  char *v17; // [esp+18h] [ebp-28h]
  char *v18; // [esp+1Ch] [ebp-24h]
  char *v19; // [esp+20h] [ebp-20h]
  char *v20; // [esp+24h] [ebp-1Ch]
  char *v21; // [esp+28h] [ebp-18h]
  char *v22; // [esp+2Ch] [ebp-14h]
  char *v23; // [esp+30h] [ebp-10h]
  char *v24; // [esp+34h] [ebp-Ch]
  char *v25; // [esp+38h] [ebp-8h]
  char *v26; // [esp+3Ch] [ebp-4h]

  v17 = aMomOriginX;
  v18 = aMomOriginY;
  v19 = aMomOriginZ;
  v20 = aMomTranslateX;
  v21 = aMomTranslateY;
  v22 = aMomTranslateZ;
  v23 = aMomToolZOffset;
  v24 = aMomKinTrackCen;
  v25 = aMomToolCorner1;
  v26 = aEnd;
  v2 = 0;
  if ( strcmp(aMomOriginX, aEnd) )
  {
    v3 = aMomOriginX;
    while ( 1 )
    {
      v16 = UF_MOM_ask_string(a1, v3 + 4, &Str);
      switch ( v2 )
      {
        case 0:
          v4 = Str;
          if ( !Str )
          {
            v4 = a00;
            Str = a00;
          }
          *a2 = strtod(v4, 0);
          break;
        case 1:
          v5 = Str;
          if ( !Str )
          {
            v5 = a00;
            Str = a00;
          }
          a2[1] = strtod(v5, 0);
          break;
        case 2:
          v6 = Str;
          if ( !Str )
          {
            v6 = a00;
            Str = a00;
          }
          a2[2] = strtod(v6, 0);
          break;
        case 3:
          v7 = Str;
          if ( !Str )
          {
            v7 = a00;
            Str = a00;
          }
          a2[12] = strtod(v7, 0);
          break;
        case 4:
          v8 = Str;
          if ( !Str )
          {
            v8 = a00;
            Str = a00;
          }
          a2[13] = strtod(v8, 0);
          break;
        case 5:
          v9 = Str;
          if ( !Str )
          {
            v9 = a00;
            Str = a00;
          }
          a2[14] = strtod(v9, 0);
          break;
        case 6:
          v10 = Str;
          if ( !Str )
          {
            v10 = a00;
            Str = a00;
          }
          a2[15] = strtod(v10, 0);
          break;
        case 7:
          v11 = Str;
          if ( !Str )
          {
            v11 = a00;
            Str = a00;
          }
          *((_DWORD *)a2 + 32) = (signed __int64)strtod(v11, 0);
          break;
        case 8:
          v12 = Str;
          if ( !Str )
          {
            v12 = a00;
            Str = a00;
          }
          a2[17] = strtod(v12, 0);
          break;
        default:
          break;
      }
      v3 = (&v18)[v2];
      v15 = v2 + 1;
      if ( !strcmp(v3, aEnd) )
        break;
      v2 = v15;
    }
  }
  result = v16;
  qmemcpy(&unk_1000BF48, a2, 0x90u);
  return result;
}
// 10009068: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10007130) --------------------------------------------------------
int __cdecl sub_10007130(int a1, int a2)
{
  signed int v2; // eax
  int v3; // edx
  int v4; // ecx
  int v5; // edx
  int v6; // ecx
  int v7; // edx
  int v9; // [esp+Ch] [ebp-7Ch]
  char v10; // [esp+10h] [ebp-78h]
  char v11; // [esp+28h] [ebp-60h]
  int v12; // [esp+40h] [ebp-48h]
  int v13[5]; // [esp+44h] [ebp-44h]
  int v14; // [esp+58h] [ebp-30h]
  int v15[5]; // [esp+5Ch] [ebp-2Ch]
  int v16; // [esp+70h] [ebp-18h]
  int v17[5]; // [esp+74h] [ebp-14h]

  v2 = 0;
  do
  {
    v3 = dword_1000BF64[v2];
    *(int *)((char *)&v12 + v2 * 4) = dword_1000BF60[v2];
    v4 = dword_1000BF78[v2];
    v13[v2] = v3;
    v5 = dword_1000BF7C[v2];
    *(int *)((char *)&v14 + v2 * 4) = v4;
    v6 = dword_1000BF90[v2];
    v15[v2] = v5;
    v7 = dword_1000BF94[v2];
    *(int *)((char *)&v16 + v2 * 4) = v6;
    v17[v2] = v7;
    v2 += 2;
  }
  while ( v2 < 6 );
  if ( !dword_1000BFDC )
  {
    UF_VEC3_is_equal(a1 + 24, dword_1000BF90, -500134854, 1044740494, &v9);
    if ( !v9 )
    {
      printf(aWarningTheTool);
      uc1601(aWarningTheTool_0, 1);
    }
    dword_1000BFDC = 1;
  }
  UF_VEC3_copy(a1, &v10);
  UF_VEC3_copy(a1 + 24, &v11);
  UF_MTX3_vec_multiply(a1, &v12, a2);
  UF_MTX3_vec_multiply(a1 + 24, &v12, a2 + 24);
  return 0;
}
// 100090CC: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);
// 100090E8: using guessed type int __cdecl UF_VEC3_is_equal(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090F4: using guessed type int __cdecl UF_MTX3_vec_multiply(_DWORD, _DWORD, _DWORD);
// 10009108: using guessed type int __cdecl uc1601(_DWORD, _DWORD);
// 1000BF60: using guessed type int dword_1000BF60[];
// 1000BF64: using guessed type int dword_1000BF64[];
// 1000BF78: using guessed type int dword_1000BF78[];
// 1000BF7C: using guessed type int dword_1000BF7C[];
// 1000BF90: using guessed type int dword_1000BF90[];
// 1000BF94: using guessed type int dword_1000BF94[];
// 1000BFDC: using guessed type int dword_1000BFDC;
// 10007130: using guessed type int var_44[5];
// 10007130: using guessed type int var_2C[5];
// 10007130: using guessed type int var_14[5];

//----- (10007220) --------------------------------------------------------
int __cdecl sub_10007220(int a1, int a2)
{
  char v3; // [esp+10h] [ebp-18h]

  UF_VEC3_add(a1, &unk_1000BFA8, a2);
  UF_VEC3_sub(a1, &unk_1000BF48, a2);
  UF_VEC3_copy(a1 + 24, a2 + 24);
  UF_VEC3_scale(dword_1000BFC0, dword_1000BFC4, a2 + 24, &v3);
  UF_VEC3_add(a2, &v3, a2);
  if ( dword_1000BFC8 == 1 )
  {
    UF_VEC3_scale(dword_1000BFD0, dword_1000BFD4, a2 + 24, &v3);
    UF_VEC3_add(a2, &v3, a2);
  }
  return 0;
}
// 100090A4: using guessed type int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD);
// 100090B8: using guessed type int __cdecl UF_VEC3_add(_DWORD, _DWORD, _DWORD);
// 100090BC: using guessed type int __cdecl UF_VEC3_scale(_DWORD, _DWORD, _DWORD, _DWORD);
// 100090CC: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);
// 1000BFC0: using guessed type int dword_1000BFC0;
// 1000BFC4: using guessed type int dword_1000BFC4;
// 1000BFC8: using guessed type int dword_1000BFC8;
// 1000BFD0: using guessed type int dword_1000BFD0;
// 1000BFD4: using guessed type int dword_1000BFD4;

//----- (100072C0) --------------------------------------------------------
int __cdecl sub_100072C0(int a1, int a2, int a3)
{
  char *v3; // edi
  double *v4; // esi
  double v5; // ST28_8
  double v6; // ST28_8
  double v7; // ST28_8
  int v8; // edi
  char *v9; // esi
  char *v10; // edx
  int *v11; // ecx
  _DWORD *v12; // eax
  signed int v13; // esi
  int v14; // edi
  int v16; // [esp+18h] [ebp-148h]
  signed int v17; // [esp+1Ch] [ebp-144h]
  double v18; // [esp+20h] [ebp-140h]
  int v19; // [esp+28h] [ebp-138h]
  int v20; // [esp+2Ch] [ebp-134h]
  int v21; // [esp+30h] [ebp-130h]
  int v22; // [esp+34h] [ebp-12Ch]
  int v23; // [esp+38h] [ebp-128h]
  int v24; // [esp+3Ch] [ebp-124h]
  int v25; // [esp+40h] [ebp-120h]
  int v26; // [esp+44h] [ebp-11Ch]
  int v27; // [esp+48h] [ebp-118h]
  int v28; // [esp+4Ch] [ebp-114h]
  int v29; // [esp+50h] [ebp-110h]
  int v30; // [esp+54h] [ebp-10Ch]
  int v31; // [esp+58h] [ebp-108h]
  int v32; // [esp+5Ch] [ebp-104h]
  int v33; // [esp+60h] [ebp-100h]
  int v34; // [esp+64h] [ebp-FCh]
  int v35; // [esp+68h] [ebp-F8h]
  int v36; // [esp+6Ch] [ebp-F4h]
  char v37; // [esp+70h] [ebp-F0h]
  char v38; // [esp+88h] [ebp-D8h]

  v19 = 0;
  v20 = 1072693248;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 1072693248;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 1072693248;
  v16 = 0;
  v3 = &v38;
  v4 = (double *)(a3 + 8);
  v17 = 3;
  v18 = asin(1.0) * 0.01111111111111111;
  do
  {
    switch ( (unsigned int)(signed __int64)*(v4 - 1) )
    {
      case 1u:
        v7 = v18 * *v4 * -1.0;
        UF_MTX3_x_vec(&v19, &v37);
        UF_MTX3_rotate_about_axis(&v37, LODWORD(v7), HIDWORD(v7), v3);
        break;
      case 2u:
        v6 = v18 * *v4 * -1.0;
        UF_MTX3_y_vec(&v19, &v37);
        UF_MTX3_rotate_about_axis(&v37, LODWORD(v6), HIDWORD(v6), v3);
        break;
      case 3u:
        v5 = v18 * *v4 * -1.0;
        UF_MTX3_z_vec(&v19, &v37);
        UF_MTX3_rotate_about_axis(&v37, LODWORD(v5), HIDWORD(v5), v3);
        break;
      default:
        goto LABEL_9;
    }
    v3 += 72;
    ++v16;
LABEL_9:
    v4 += 2;
    --v17;
  }
  while ( v17 );
  v8 = v16;
  if ( v16 > 0 )
  {
    v9 = &v38;
    do
    {
      UF_MTX3_multiply(&v19, v9, &v19);
      v9 += 72;
      --v8;
    }
    while ( v8 );
  }
  v10 = (char *)&v19 - a2;
  v11 = &v25;
  v12 = (_DWORD *)(a2 + 48);
  v13 = 3;
  do
  {
    v14 = *(v11 - 6);
    v11 += 2;
    *(v12 - 6) = v14;
    *(v12 - 5) = *(v11 - 7);
    *v12 = *(v11 - 2);
    v12[1] = *(v11 - 1);
    v12[6] = *(_DWORD *)((char *)v12 + (_DWORD)v10);
    v12[7] = *(_DWORD *)((char *)v12 + (_DWORD)v10 + 4);
    v12 += 2;
    --v13;
  }
  while ( v13 );
  dword_1000BFDC = 0;
  return 0;
}
// 1000906C: using guessed type int __cdecl UF_MTX3_multiply(_DWORD, _DWORD, _DWORD);
// 10009070: using guessed type int __cdecl UF_MTX3_rotate_about_axis(_DWORD, _DWORD, _DWORD, _DWORD);
// 100090DC: using guessed type int __cdecl UF_MTX3_x_vec(_DWORD, _DWORD);
// 100090E0: using guessed type int __cdecl UF_MTX3_y_vec(_DWORD, _DWORD);
// 100090E4: using guessed type int __cdecl UF_MTX3_z_vec(_DWORD, _DWORD);
// 1000BFDC: using guessed type int dword_1000BFDC;

//----- (100074F0) --------------------------------------------------------
int __cdecl ufusr(int a1, _DWORD *a2)
{
  int result; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // [esp+0h] [ebp-8Ch]
  int v10; // [esp+4h] [ebp-88h]
  char Dest; // [esp+8h] [ebp-84h]

  v10 = 0;
  if ( sub_100076F0(&Dest) )
  {
    printf(aErrorUgpostAdv);
    uc1601(&Dest, 1);
    result = UF_terminate();
  }
  else
  {
    UF_MOM_ask_interp_from_param(a1, &v10);
    UF_MOM_ask_mom(a1, &v9);
    v3 = ((int (__cdecl *)(int, char *, signed int (__cdecl *)(int)))UF_MOM_extend_xlator)(
           v9,
           aMomLoadKinemat,
           sub_10007C40);
    sub_10007670((int)aZV18projsBatch, 112, (int)aUfMomExtendXla, v3);
    v4 = ((int (__cdecl *)(int, char *, int (__cdecl *)(int)))UF_MOM_extend_xlator)(v9, aMomConvertPoin, sub_100081E0);
    sub_10007670((int)aZV18projsBatch, 122, (int)aUfMomExtendXla_0, v4);
    v5 = ((int (__cdecl *)(int, char *, signed int (__cdecl *)(int, int, int, int)))UF_MOM_extend_xlator)(
           v9,
           aMomGetToolAttr,
           sub_10008300);
    sub_10007670((int)aZV18projsBatch, 132, (int)aUfMomExtendXla_1, v5);
    v6 = ((int (__cdecl *)(int, char *, signed int (__cdecl *)(int, int, signed int, int)))UF_MOM_extend_xlator)(
           v9,
           aMomRotateMachC,
           sub_100078F0);
    sub_10007670((int)aZV18projsBatch, 142, (int)aUfMomExtendXla_2, v6);
    v7 = ((int (__cdecl *)(int, char *, int (__cdecl *)(int)))UF_MOM_extend_xlator)(v9, aMomMapToRotate, sub_10007B50);
    sub_10007670((int)aZV18projsBatch, 152, (int)aUfMomExtendXla_3, v7);
    v8 = UF_MOM_extend_xlator(v9, aMomExitKinemat, (const char *)&UF_terminate);
    result = sub_10007670((int)aZV18projsBatch, 162, (int)aUfMomExtendXla_4, v8);
    dword_1000BFE0 = v9;
    *a2 = 0;
  }
  return result;
}
// 10009074: using guessed type int UF_MOM_extend_xlator(_DWORD, _DWORD, const char *, ...);
// 100090F8: using guessed type int __cdecl UF_MOM_ask_mom(_DWORD, _DWORD);
// 100090FC: using guessed type int __cdecl UF_MOM_ask_interp_from_param(_DWORD, _DWORD);
// 10009100: using guessed type int UF_terminate(void);
// 10009108: using guessed type int __cdecl uc1601(_DWORD, _DWORD);
// 1000BFE0: using guessed type int dword_1000BFE0;

//----- (10007670) --------------------------------------------------------
int __cdecl sub_10007670(int a1, int a2, int a3, int a4)
{
  char v5; // [esp+8h] [ebp-88h]

  if ( a4 )
  {
    printf(aSLineDS, a1, a2, a3);
    if ( UF_get_fail_message(a4, &v5) )
    {
      printf(aReturnedAD, a4);
      return a4;
    }
    printf(aReturnedErrorD, a4, &v5);
  }
  return a4;
}
// 10009084: using guessed type int __cdecl UF_get_fail_message(_DWORD, _DWORD);

//----- (100076F0) --------------------------------------------------------
int __cdecl sub_100076F0(char *Dest)
{
  int result; // eax
  int v2; // eax
  int v3; // [esp+4h] [ebp-Ch]
  double v4; // [esp+8h] [ebp-8h]

  UF_MISC_set_program_name(aUgpkin);
  if ( UF_initialize() )
  {
    sprintf(Dest, aErrorAdvancedK);
    result = 1;
  }
  else
  {
    UF_MISC_set_program_name(aKinematics);
    v2 = UF_get_release(&v3);
    sub_10007670((int)aZV18projsBatch, 196, (int)aUfGetReleaseUg, v2);
    v4 = strtod((const char *)(v3 + 1), 0);
    UF_free(v3);
    if ( v4 < 17.0 && sub_100077B0() )
    {
      sprintf(Dest, aErrorKinematic);
      result = 6;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}
// 10009058: using guessed type int __cdecl UF_free(_DWORD);
// 10009088: using guessed type int __cdecl UF_get_release(_DWORD);
// 1000908C: using guessed type int UF_initialize(void);
// 10009090: using guessed type int __cdecl UF_MISC_set_program_name(_DWORD);

//----- (100077B0) --------------------------------------------------------
signed int sub_100077B0()
{
  int v0; // esi
  signed int result; // eax
  time_t Time; // [esp+10h] [ebp-70h]
  time_t v3; // [esp+14h] [ebp-6Ch]
  char Dest; // [esp+18h] [ebp-68h]
  struct tm Tm; // [esp+38h] [ebp-48h]
  char v6; // [esp+5Ch] [ebp-24h]
  int v7; // [esp+70h] [ebp-10h]
  int v8; // [esp+78h] [ebp-8h]

  Tm.tm_min = 59;
  Tm.tm_sec = 59;
  Tm.tm_isdst = -1;
  Tm.tm_year = 101;
  Tm.tm_mon = 9;
  Tm.tm_mday = 30;
  Tm.tm_hour = 23;
  sprintf(&Dest, a02d02d04d, 9, 30, 2001);
  Time = mktime(&Tm);
  qmemcpy(&Tm, localtime(&Time), sizeof(Tm));
  Tm.tm_year += 1900;
  time(&v3);
  qmemcpy(&v6, localtime(&v3), 0x24u);
  v0 = 365 * (Tm.tm_year - (v7 + 1900)) - v8 + Tm.tm_yday - 30;
  printf(aExpirationDate, &Dest);
  if ( v0 > 0 )
  {
    printf(aRemainingDaysD, v0);
    result = 0;
  }
  else
  {
    printf(aS, aYourLicenseHas);
    result = 1;
  }
  return result;
}

//----- (100078F0) --------------------------------------------------------
signed int __cdecl sub_100078F0(int a1, int a2, signed int a3, int a4)
{
  signed int result; // eax
  int v5; // ebx
  int *v6; // ebp
  int v7; // esi
  int v8; // esi
  double *Memory; // [esp+Ch] [ebp-34h]
  int v10; // [esp+10h] [ebp-30h]
  int v11; // [esp+14h] [ebp-2Ch]
  int v12; // [esp+18h] [ebp-28h]
  int v13; // [esp+1Ch] [ebp-24h]
  int v14; // [esp+20h] [ebp-20h]
  int v15; // [esp+24h] [ebp-1Ch]
  int v16; // [esp+28h] [ebp-18h]
  int v17; // [esp+2Ch] [ebp-14h]
  int v18; // [esp+30h] [ebp-10h]
  int v19; // [esp+34h] [ebp-Ch]
  int v20; // [esp+38h] [ebp-8h]
  int v21; // [esp+3Ch] [ebp-4h]
  unsigned int v22; // [esp+4Ch] [ebp+Ch]

  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  Memory = (double *)malloc(0x90u);
  if ( a3 > 7 || a3 == 1 )
  {
    printf(aIncorrectNumbe);
    printf(aNumberOfArgume);
    result = 999;
  }
  else if ( a3 % 2 )
  {
    if ( a3 > 1 )
    {
      v5 = a4 + 4;
      v6 = &v10;
      v22 = (unsigned int)a3 >> 1;
      do
      {
        if ( !strcmp(*(const char **)v5, aAaxis) )
        {
          *v6 = 0;
          v6[1] = 1072693248;
        }
        else if ( !strcmp(*(const char **)v5, aBaxis) )
        {
          *v6 = 0;
          v6[1] = 0x40000000;
        }
        else if ( !strcmp(*(const char **)v5, aCaxis) )
        {
          *v6 = 0;
          v6[1] = 1074266112;
        }
        *((double *)v6 + 1) = strtod((const char *)*(_DWORD *)(v5 + 4), 0);
        v5 += 8;
        v6 += 4;
        --v22;
      }
      while ( v22 );
    }
    v7 = sub_100072C0(a1, (int)Memory, (int)&v10);
    if ( v7 )
    {
      printf(aSetRotdMcsMatr);
      result = v7;
    }
    else
    {
      v8 = sub_10006E90(a1, Memory);
      if ( v8 )
      {
        printf(aSetRotdOperati);
        result = v8;
      }
      else
      {
        if ( Memory )
          free(Memory);
        result = 0;
      }
    }
  }
  else
  {
    printf(aInsufficientNu);
    result = 999;
  }
  return result;
}

//----- (10007B50) --------------------------------------------------------
int __cdecl sub_10007B50(int a1)
{
  int v1; // edi
  int result; // eax
  int v3; // edi
  int v4; // edi
  int v5; // [esp+8h] [ebp-90h]
  int v6; // [esp+Ch] [ebp-8Ch]
  int v7; // [esp+10h] [ebp-88h]
  int v8; // [esp+14h] [ebp-84h]
  int v9; // [esp+18h] [ebp-80h]
  int v10; // [esp+1Ch] [ebp-7Ch]
  char Str; // [esp+38h] [ebp-60h]
  char v12; // [esp+68h] [ebp-30h]

  v1 = sub_10006CA0(a1, &Str);
  if ( v1 )
  {
    printf(aSetInputPointF);
    result = v1;
  }
  else
  {
    v3 = sub_10007220((int)&Str, (int)&v12);
    if ( v3 )
    {
      printf(aMomProcessInpu);
      result = v3;
    }
    else
    {
      v4 = sub_10007130((int)&v12, (int)&v5);
      if ( v4 )
      {
        printf(aMomTransferGot);
        result = v4;
      }
      else
      {
        UF_MOM_set_double(a1, aPosX, v5, v6);
        UF_MOM_set_double(a1, aPosY, v7, v8);
        UF_MOM_set_double(a1, aPosZ, v9, v10);
        result = 0;
      }
    }
  }
  return result;
}
// 10009094: using guessed type int __cdecl UF_MOM_set_double(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10007C40) --------------------------------------------------------
signed int __cdecl sub_10007C40(int a1)
{
  _DWORD *v1; // edi
  _DWORD *v2; // ebx
  int v4; // ecx
  int v5; // esi
  signed int v6; // eax
  double v7; // st7
  char *(__cdecl *v8)(const char *, const char *); // edi
  double *v9; // esi
  signed int v10; // eax
  signed int v11; // eax
  signed int v12; // eax
  int v13; // eax
  bool v14; // zf
  _DWORD *v15; // eax
  int v16; // edx
  int v17; // ecx
  int v18; // edx
  _DWORD *v19; // eax
  int v20; // edx
  int v21; // edx
  int v22; // eax
  char *v23; // [esp+Ch] [ebp-364h]
  char *v24; // [esp+10h] [ebp-360h]
  char *Memory; // [esp+14h] [ebp-35Ch]
  char *Str; // [esp+18h] [ebp-358h]
  char *v27; // [esp+1Ch] [ebp-354h]
  char *v28; // [esp+20h] [ebp-350h]
  char *v29; // [esp+24h] [ebp-34Ch]
  _DWORD *v30; // [esp+28h] [ebp-348h]
  char *v31; // [esp+2Ch] [ebp-344h]
  double v32[3]; // [esp+30h] [ebp-340h]
  int v33; // [esp+48h] [ebp-328h]
  int v34; // [esp+50h] [ebp-320h]
  int v35; // [esp+54h] [ebp-31Ch]
  char v36; // [esp+58h] [ebp-318h]
  char v37; // [esp+70h] [ebp-300h]
  char v38; // [esp+88h] [ebp-2E8h]
  bool v39; // [esp+A0h] [ebp-2D0h]
  int v40; // [esp+A8h] [ebp-2C8h]
  int v41; // [esp+ACh] [ebp-2C4h]
  int v42; // [esp+B0h] [ebp-2C0h]
  int v43; // [esp+B4h] [ebp-2BCh]
  int v44; // [esp+B8h] [ebp-2B8h]
  int v45; // [esp+BCh] [ebp-2B4h]
  int v46; // [esp+C0h] [ebp-2B0h]
  int v47; // [esp+C4h] [ebp-2ACh]
  int v48; // [esp+C8h] [ebp-2A8h]
  int v49; // [esp+CCh] [ebp-2A4h]
  int v50; // [esp+D0h] [ebp-2A0h]
  int v51; // [esp+D4h] [ebp-29Ch]
  double v52; // [esp+D8h] [ebp-298h]
  char v53; // [esp+E0h] [ebp-290h]
  double v54; // [esp+F0h] [ebp-280h]
  char v55; // [esp+F8h] [ebp-278h]
  double v56; // [esp+108h] [ebp-268h]
  char v57; // [esp+110h] [ebp-260h]
  double v58[3]; // [esp+128h] [ebp-248h]
  double v59[3]; // [esp+140h] [ebp-230h]
  double v60[3]; // [esp+158h] [ebp-218h]
  double v61[3]; // [esp+170h] [ebp-200h]
  char v62; // [esp+188h] [ebp-1E8h]
  char v63; // [esp+1A0h] [ebp-1D0h]
  char v64; // [esp+1B8h] [ebp-1B8h]
  char v65; // [esp+1D0h] [ebp-1A0h]
  char v66; // [esp+1E8h] [ebp-188h]
  char v67; // [esp+200h] [ebp-170h]
  int v68; // [esp+2A0h] [ebp-D0h]
  int v69; // [esp+2A4h] [ebp-CCh]
  int v70; // [esp+2A8h] [ebp-C8h]
  int v71; // [esp+2ACh] [ebp-C4h]
  char v72; // [esp+2B0h] [ebp-C0h]
  char v73; // [esp+2C8h] [ebp-A8h]
  char v74; // [esp+2E0h] [ebp-90h]
  char v75; // [esp+2F8h] [ebp-78h]
  char v76; // [esp+310h] [ebp-60h]
  char v77; // [esp+328h] [ebp-48h]
  char v78; // [esp+340h] [ebp-30h]
  char v79; // [esp+358h] [ebp-18h]

  v24 = (char *)malloc(0x358u);
  sub_10004810(a1, (int)v24);
  Memory = (char *)malloc(0x228u);
  sub_10004CB0(a1, Memory);
  v29 = (char *)malloc(0x120u);
  sub_10004EF0(a1, v29);
  v31 = (char *)malloc(0x40u);
  sub_100050A0(a1, v31);
  v23 = (char *)malloc(0x1F0u);
  sub_100052F0(a1, (int)v23);
  v1 = malloc(0x1F0u);
  v30 = v1;
  sub_10005700(a1, (int)v1);
  v28 = (char *)malloc(0x98u);
  sub_10005B10(a1, v28);
  Str = (char *)malloc(0x3B0u);
  sub_10005DA0(a1, (int)Str);
  v27 = (char *)malloc(0x18u);
  sub_10005C60(a1, v27);
  v2 = malloc(0x24u);
  if ( !v2 )
    return 1;
  v2[2] = v29;
  *v2 = v24;
  v2[1] = Memory;
  v2[6] = v28;
  v2[3] = v31;
  v2[4] = v23;
  v2[5] = v1;
  v2[7] = Str;
  v2[8] = v27;
  sub_100063B0(a1, v58);
  sub_100066D0(a1, v58);
  sub_10006A00(a1, (char *)v58);
  v4 = (int)(v1 + 108);
  v5 = (int)(v24 + 832);
  v6 = 0;
  do
  {
    v7 = v58[v6] + *(double *)(v23 - (char *)v1 + v4);
    ++v6;
    v4 += 8;
    v5 += 8;
    *(double *)((char *)&v54 + v6 * 8) = v7;
    *(double *)((char *)&v56 + v6 * 8) = v7 + *(double *)(v4 - 8);
    *(double *)((char *)&v52 + v6 * 8) = v7 + *(double *)(v5 - 8);
  }
  while ( v6 < 3 );
  qmemcpy(&v76, v58, 0x18u);
  qmemcpy(&v77, v59, 0x18u);
  qmemcpy(&v78, v60, 0x18u);
  qmemcpy(&v79, v61, 0x18u);
  qmemcpy(&v72, &v62, 0x18u);
  qmemcpy(&v73, &v63, 0x18u);
  qmemcpy(&v74, &v64, 0x18u);
  qmemcpy(&v75, &v65, 0x18u);
  v8 = strstr;
  if ( strstr(Str, SubStr) )
  {
    v9 = v59;
  }
  else if ( strstr(Str, aPosy) )
  {
    v9 = v60;
  }
  else
  {
    if ( !strstr(Str, aPosz) )
    {
      if ( strstr(Str, aNegx) )
      {
        v10 = 0;
        do
        {
          v32[v10] = -v59[v10];
          ++v10;
        }
        while ( v10 < 3 );
        goto LABEL_24;
      }
      if ( strstr(Str, aNegy) )
      {
        v11 = 0;
        do
        {
          v32[v11] = -v60[v11];
          ++v11;
        }
        while ( v11 < 3 );
        goto LABEL_24;
      }
      if ( strstr(Str, aNegz) )
      {
        v12 = 0;
        do
        {
          v32[v12] = -v61[v12];
          ++v12;
        }
        while ( v12 < 3 );
        goto LABEL_24;
      }
    }
    v9 = v61;
  }
  qmemcpy(v32, v9, sizeof(v32));
  v8 = strstr;
LABEL_24:
  if ( v8(v24, a5AxisDualTable) )
  {
    v33 = 2;
  }
  else if ( v8(v24, a5AxisDualHead) )
  {
    v33 = 1;
  }
  else if ( v8(v24, a5AxisHeadTable) )
  {
    v33 = 3;
  }
  v13 = *((_DWORD *)v24 + 200);
  v35 = *((_DWORD *)v24 + 201);
  v34 = v13;
  qmemcpy(&v36, &v66, 0x18u);
  qmemcpy(&v37, &v67, 0x18u);
  qmemcpy(&v38, v23 + 432, 0x18u);
  v14 = atoi(v24 + 133) == 1;
  v40 = v70;
  v41 = v71;
  v15 = (_DWORD *)v2[4];
  v39 = v14;
  v16 = v15[103];
  v42 = v15[102];
  v43 = v16;
  v17 = v15[104];
  v18 = v15[105];
  v19 = (_DWORD *)v2[5];
  v44 = v17;
  v45 = v18;
  v20 = v19[103];
  v46 = v19[102];
  v47 = v20;
  v21 = v19[105];
  v48 = v19[104];
  v49 = v21;
  v50 = v68;
  v51 = v69;
  if ( strstr(v24, a5AxisDualTable) )
  {
    v52 = 0.0;
  }
  else
  {
    v22 = *((_DWORD *)Memory + 135);
    LODWORD(v52) = *((_DWORD *)Memory + 134);
    HIDWORD(v52) = v22;
  }
  sub_10001000(&v72, &v76, &v55, (int)(v23 + 456), &v57, v30 + 114, &v53, v32, &v33);
  free(v2);
  if ( v24 )
    free(v24);
  if ( Memory )
    free(Memory);
  if ( v29 )
    free(v29);
  if ( v31 )
    free(v31);
  if ( v23 )
    free(v23);
  if ( v30 )
    free(v30);
  if ( v28 )
    free(v28);
  if ( Str )
    free(Str);
  if ( v27 )
    free(v27);
  return 0;
}
// 10007C40: using guessed type double var_230[3];
// 10007C40: using guessed type double var_218[3];
// 10007C40: using guessed type double var_200[3];
// 10007C40: using guessed type double var_340[3];

//----- (100081E0) --------------------------------------------------------
int __cdecl sub_100081E0(int a1)
{
  int v2; // [esp+8h] [ebp-208h]
  int v3; // [esp+Ch] [ebp-204h]
  int v4; // [esp+10h] [ebp-200h]
  int v5; // [esp+14h] [ebp-1FCh]
  int v6; // [esp+18h] [ebp-1F8h]
  int v7; // [esp+1Ch] [ebp-1F4h]
  int v8; // [esp+20h] [ebp-1F0h]
  int v9; // [esp+24h] [ebp-1ECh]
  int v10; // [esp+28h] [ebp-1E8h]
  int v11; // [esp+2Ch] [ebp-1E4h]
  int v12; // [esp+30h] [ebp-1E0h]
  int v13; // [esp+34h] [ebp-1DCh]
  int v14; // [esp+38h] [ebp-1D8h]
  int v15; // [esp+3Ch] [ebp-1D4h]
  int v16; // [esp+40h] [ebp-1D0h]
  int v17; // [esp+44h] [ebp-1CCh]
  int v18; // [esp+48h] [ebp-1C8h]
  int v19; // [esp+4Ch] [ebp-1C4h]
  int v20; // [esp+50h] [ebp-1C0h]
  int v21; // [esp+54h] [ebp-1BCh]
  char v22; // [esp+58h] [ebp-1B8h]
  char Str; // [esp+88h] [ebp-188h]

  sub_10006A00(a1, &Str);
  sub_10002530(&Str);
  sub_10006CA0(a1, &v22);
  sub_10002170(&v22, &v12, &v2);
  UF_MOM_set_double(a1, aPosX, v12, v13);
  UF_MOM_set_double(a1, aPosY, v14, v15);
  UF_MOM_set_double(a1, aPosZ, v16, v17);
  UF_MOM_set_double(a1, aPosA1, v18, v19);
  UF_MOM_set_double(a1, aPosA2, v20, v21);
  UF_MOM_set_double(a1, aAltPosX, v2, v3);
  UF_MOM_set_double(a1, aAltPosY, v4, v5);
  UF_MOM_set_double(a1, aAltPosZ, v6, v7);
  UF_MOM_set_double(a1, aAltPosA1, v8, v9);
  UF_MOM_set_double(a1, aAltPosA2, v10, v11);
  return 0;
}
// 10009094: using guessed type int __cdecl UF_MOM_set_double(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10008300) --------------------------------------------------------
signed int __cdecl sub_10008300(int a1, int a2, int a3, int a4)
{
  int v5; // [esp+Ch] [ebp-48Ch]
  const char *v6; // [esp+10h] [ebp-488h]
  int v7; // [esp+14h] [ebp-484h]
  char *v8; // [esp+1Ch] [ebp-47Ch]
  char v9; // [esp+24h] [ebp-474h]
  char v10; // [esp+44h] [ebp-454h]
  int v11; // [esp+78h] [ebp-420h]
  int v12; // [esp+7Ch] [ebp-41Ch]
  __int16 v13; // [esp+80h] [ebp-418h]
  char v14; // [esp+100h] [ebp-398h]
  int v15; // [esp+188h] [ebp-310h]
  char v16; // [esp+210h] [ebp-288h]
  char v17; // [esp+298h] [ebp-200h]

  v15 = dword_1000BB90;
  strcpy(&v16, "tool_attribute_text");
  v13 = word_1000BB8C;
  v5 = 0;
  v11 = dword_1000BB84;
  v12 = dword_1000BB88;
  if ( a3 != 2 )
  {
    strcpy(&v17, "Invalid number of arguments");
LABEL_5:
    printf(aErrorS, &v17);
    return 1;
  }
  if ( UF_MOM_ask_string(a1, &v11, &v6) )
  {
    strcpy(&v17, "No Tool Name obtained from UGPost");
    goto LABEL_5;
  }
  strcpy(&v9, v6);
  strcpy(&v10, *(const char **)(a4 + 4));
  if ( UF_OBJ_cycle_by_name(&v9, &v5) )
  {
    printf(aUfObjCycleByNa);
    return 1;
  }
  if ( !v5 )
    goto LABEL_16;
  v8 = &v14;
  if ( UF_ATTR_read_value(v5, &v10, 5, &v7) )
  {
    printf(aUfAttrReadValu);
    return 1;
  }
  if ( v7 != 5 )
LABEL_16:
    strcpy(&v14, (const char *)&v15);
  UF_MOM_set_string(a1, &v16, &v14);
  return 0;
}
// 10009068: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);
// 10009098: using guessed type int __cdecl UF_MOM_set_string(_DWORD, _DWORD, _DWORD);
// 1000909C: using guessed type int __cdecl UF_ATTR_read_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 100090A0: using guessed type int __cdecl UF_OBJ_cycle_by_name(_DWORD, _DWORD);
// 1000BB84: using guessed type int dword_1000BB84;
// 1000BB88: using guessed type int dword_1000BB88;
// 1000BB8C: using guessed type __int16 word_1000BB8C;
// 1000BB90: using guessed type int dword_1000BB90;

// ALL OK, 52 function(s) have been successfully decompiled
