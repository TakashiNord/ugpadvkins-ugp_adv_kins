/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2011 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Data declarations

extern char aReturnedErrorD[]; // idb
extern char aReturnedAD[]; // idb
extern char Format[]; // idb
extern char aKinematics[11]; // weak
extern char aErrorAdvancedK[]; // idb
extern char aUgpkin[13]; // weak
extern char aNumberOfArgume[]; // idb
extern char aIncorrectNumbe[]; // idb
extern char aSet_rotd_opera[]; // idb
extern char aSet_rotd_mcs_m[]; // idb
extern char aCaxis[6]; // weak
extern char aBaxis[6]; // weak
extern char aAaxis[6]; // weak
extern char aInsufficientNu[]; // idb
extern char aPos_z[6]; // weak
extern char aPos_y[6]; // weak
extern char aPos_x[6]; // weak
extern char aMom_transfer_g[]; // idb
extern char aMom_process_in[]; // idb
extern char aSet_input_poin[]; // idb
extern char a5_axis_head_ta[]; // idb
extern char a5_axis_dual_he[]; // idb
extern char a5_axis_dual_ta[]; // idb
extern char aNegz[]; // idb
extern char aNegy[]; // idb
extern char aNegx[]; // idb
extern char aPosz[]; // idb
extern char aPosy[]; // idb
extern char SubStr[]; // idb
extern char aAlt_pos_a2[11]; // weak
extern char aAlt_pos_a1[11]; // weak
extern char aAlt_pos_z[10]; // weak
extern char aAlt_pos_y[10]; // weak
extern char aAlt_pos_x[10]; // weak
extern char aPos_a2[7]; // weak
extern char aPos_a1[7]; // weak
extern char aUf_attr_read_v[]; // idb
extern char aUf_obj_cycle_b[]; // idb
extern char aNoToolNameObta[34]; // weak
extern char aErrorS[]; // idb
extern char aInvalidNumberO[28]; // weak
extern int dword_100095CC; // weak
extern int dword_100095D0; // weak
extern __int16 word_100095D4; // weak
extern int dword_100095D8; // weak
extern int dword_100095DC; // weak
extern int dword_100095E0; // weak
extern int dword_100095E4; // weak
extern int dword_100095E8; // weak
extern char aUf_mom_exten_4[87]; // weak
extern char aMom_exit_kinem[27]; // weak
extern char aUf_mom_exten_3[81]; // weak
extern char aMom_map_to_rot[24]; // weak
extern char aUf_mom_exten_2[75]; // weak
extern char aMom_rotate_mac[21]; // weak
extern char aUf_mom_exten_1[80]; // weak
extern char aMom_get_tool_a[23]; // weak
extern char aUf_mom_exten_0[69]; // weak
extern char aMom_convert_po[18]; // weak
extern char aOUgnx85Ip23Src[63]; // weak
extern char aUf_mom_extend_[73]; // weak
extern char aMom_load_kinem[20]; // weak
extern char aErrorUgpostAdv[]; // idb
extern _UNKNOWN unk_100098E0; // weak
extern _UNKNOWN unk_10009928; // weak
extern _UNKNOWN unk_10009970; // weak
extern char aWarningSameVal[]; // idb
extern char aComputingT11FT[]; // idb
extern char aComputingT10FT[]; // idb
extern char aAboutAdjusting[]; // idb
extern char aWarningDegener[]; // idb
extern char aInputPoint_4f_[]; // idb
extern char aStartingOld_pc[]; // idb
extern char asc_10009B9C[]; // idb
extern char aInit_t11Init_t[]; // idb
extern char aInit_t10Init_t[]; // idb
extern char aA1FD1FAlpha1FA[]; // idb
extern char aWarningToolAxi[]; // idb
extern char aLocalSecondary[]; // idb
extern char aLocalPrimaryax[]; // idb
extern char aSulzerCase[]; // idb
extern char aMcsysFFFFFFFFF[]; // idb
extern char aTool_vectorFFF[]; // idb
extern char aTool_machine_c[]; // idb
extern char aSecondary_mach[]; // idb
extern char aSecondaryFFF[]; // idb
extern char aPrimary_machin[]; // idb
extern char aPrimaryFFF[]; // idb
extern char aIs_5_axis_head[]; // idb
extern char aIs_5_axis_du_0[21]; // weak
extern char aIs_5_axis_dual[22]; // weak
extern char aIs_orthogonal_[]; // idb
extern char asc_10009E50[]; // idb
extern char aFinalUfuncAlt_[]; // idb
extern char aFinalUfuncMcoo[]; // idb
extern char a400_00[7]; // weak
extern char a0_0[4]; // weak
extern char asc_10009F1C[2]; // weak
extern char aIn[3]; // weak
extern char aNone[5]; // weak
extern char aMom_kin_rapid_[24]; // weak
extern char aMom_kin_pivot_[27]; // weak
extern char aMom_kin_read_a[31]; // weak
extern char aMom_kin_polar_[26]; // weak
extern char aMom_kin_output[20]; // weak
extern char aEnd[4]; // weak
extern char aMom_kin_nurbs_[26]; // weak
extern char a9999_9999[10]; // weak
extern char a0_0001[7]; // weak
extern char aXy[3]; // weak
extern char aFull_circle[12]; // weak
extern char aMom_kin_max_ar[23]; // weak
extern char aMom_kin_min_ar[23]; // weak
extern char aMom_kin_arc_va[24]; // weak
extern char aMom_kin_arc_ou[24]; // weak
extern char a99999_999[10]; // weak
extern char a99_999[7]; // weak
extern char a0_001[6]; // weak
extern char a999_999[8]; // weak
extern char aMom_kin_min_dp[16]; // weak
extern char aMom_kin_max_dp[16]; // weak
extern char aMom_kin_min_fr[16]; // weak
extern char aMom_kin_max_fr[16]; // weak
extern char aMom_kin_min__0[16]; // weak
extern char aMom_kin_max__0[16]; // weak
extern char aMom_kin_min_fp[16]; // weak
extern char aMom_kin_max_fp[16]; // weak
extern char a360_0[6]; // weak
extern char aStandard[9]; // weak
extern char aMagnitude_dete[31]; // weak
extern char aYz[3]; // weak
extern char aMom_kin_4th_13[27]; // weak
extern char aMom_kin_4th_12[27]; // weak
extern char aMom_kin_4th_11[26]; // weak
extern char aMom_kin_4th_10[26]; // weak
extern char aMom_kin_4th__9[26]; // weak
extern char aMom_kin_4th__8[33]; // weak
extern char aMom_kin_4th__7[33]; // weak
extern char aMom_kin_4th__6[33]; // weak
extern char aMom_kin_4th__5[22]; // weak
extern char aMom_kin_4th__4[27]; // weak
extern char aMom_kin_4th__3[27]; // weak
extern char aMom_kin_4th__2[26]; // weak
extern char aMom_kin_4th__1[26]; // weak
extern char aMom_kin_4th__0[27]; // weak
extern char aMom_kin_4th_ax[23]; // weak
extern char aMom_kin_5th_13[27]; // weak
extern char aMom_kin_5th_12[27]; // weak
extern char aMom_kin_5th_11[26]; // weak
extern char aMom_kin_5th_10[26]; // weak
extern char aMom_kin_5th__9[26]; // weak
extern char aMom_kin_5th__8[33]; // weak
extern char aMom_kin_5th__7[33]; // weak
extern char aMom_kin_5th__6[33]; // weak
extern char aMom_kin_5th__5[22]; // weak
extern char aMom_kin_5th__4[27]; // weak
extern char aMom_kin_5th__3[27]; // weak
extern char aMom_kin_5th__2[26]; // weak
extern char aMom_kin_5th__1[26]; // weak
extern char aMom_kin_5th__0[27]; // weak
extern char aMom_kin_5th_ax[23]; // weak
extern char aFront[6]; // weak
extern char aMom_kin_ind__0[32]; // weak
extern char aMom_kin_ind_to[32]; // weak
extern char aMom_kin_indepe[25]; // weak
extern char a3_0[4]; // weak
extern char a0_5[4]; // weak
extern char aMom_kin_flush_[19]; // weak
extern char aMom_kin_clamp_[19]; // weak
extern char aMom_kin_tool_c[25]; // weak
extern char aMom_kin_hol_22[25]; // weak
extern char aMom_kin_hol_21[25]; // weak
extern char aMom_kin_hol_20[25]; // weak
extern char aMom_kin_hol_19[25]; // weak
extern char aMom_kin_hol_18[25]; // weak
extern char aMom_kin_hol_17[25]; // weak
extern char aMom_kin_hol_16[25]; // weak
extern char aMom_kin_hol_15[25]; // weak
extern char aMom_kin_hol_14[25]; // weak
extern char aMom_kin_hol_13[25]; // weak
extern char aMom_kin_hol_12[25]; // weak
extern char aMom_kin_hol_11[25]; // weak
extern char aMom_kin_hol_10[25]; // weak
extern char aMom_kin_hold_9[25]; // weak
extern char aMom_kin_hold_8[25]; // weak
extern char aMom_kin_hold_7[25]; // weak
extern char aMom_kin_hold_6[25]; // weak
extern char aMom_kin_hold_5[25]; // weak
extern char aMom_kin_hold_4[28]; // weak
extern char aMom_kin_hold_3[28]; // weak
extern char aMom_kin_hold_2[28]; // weak
extern char aMom_kin_hold_1[28]; // weak
extern char aMom_kin_hold_0[28]; // weak
extern char aMom_kin_holder[28]; // weak
extern char aKin_4th_to_t_1[28]; // weak
extern char aKin_4th_to_t_0[28]; // weak
extern char aKin_4th_to_tra[28]; // weak
extern char a90_0[5]; // weak
extern char aCartesian[10]; // weak
extern char aT[2]; // weak
extern char a3_axis_mill[12]; // weak
extern char aMom_kin_gaug_0[25]; // weak
extern char aMom_kin_line_0[26]; // weak
extern char aMom_kin_5th_14[36]; // weak
extern char aMom_kin_tool_t[29]; // weak
extern char aMom_kin_mach_0[27]; // weak
extern char aMom_kin_linear[27]; // weak
extern char aMom_kin_coordi[24]; // weak
extern char aMom_kin_clsf_g[24]; // weak
extern char aMom_kin_wire_t[30]; // weak
extern char aMom_kin_track_[29]; // weak
extern char aMom_kin_machin[21]; // weak
extern char aMom_kin_gauge_[25]; // weak
extern char a1_0[4]; // weak
extern char aMom_msys_z_a_1[18]; // weak
extern char aMom_msys_z_a_0[18]; // weak
extern char aMom_msys_z_axi[18]; // weak
extern char aMom_msys_y_a_1[18]; // weak
extern char aMom_msys_y_a_0[18]; // weak
extern char aMom_msys_y_axi[18]; // weak
extern char aMom_msys_x_a_1[18]; // weak
extern char aMom_msys_x_a_0[18]; // weak
extern char aMom_msys_x_axi[18]; // weak
extern char aMom_msys_ori_1[18]; // weak
extern char aMom_msys_ori_0[18]; // weak
extern char aMom_msys_origi[18]; // weak
extern char aMom_mtsys_z__1[19]; // weak
extern char aMom_mtsys_z__0[19]; // weak
extern char aMom_mtsys_z_ax[19]; // weak
extern char aMom_mtsys_y__1[19]; // weak
extern char aMom_mtsys_y__0[19]; // weak
extern char aMom_mtsys_y_ax[19]; // weak
extern char aMom_mtsys_x__1[19]; // weak
extern char aMom_mtsys_x__0[19]; // weak
extern char aMom_mtsys_x_ax[19]; // weak
extern char aMom_mtsys_or_1[19]; // weak
extern char aMom_mtsys_or_0[19]; // weak
extern char aMom_mtsys_orig[19]; // weak
extern char aMill[5]; // weak
extern char aMom_tool_corne[24]; // weak
extern char aMom_tool_z_off[18]; // weak
extern char aMom_tool_type[14]; // weak
extern char aMom_translat_1[16]; // weak
extern char aMom_translat_0[16]; // weak
extern char aMom_translate_[16]; // weak
extern char aMom_origin_z[13]; // weak
extern char aMom_origin_y[13]; // weak
extern char aMom_origin_x[13]; // weak
extern char aMom_tool_axi_1[16]; // weak
extern char aMom_tool_axi_0[16]; // weak
extern char aMom_tool_axis_[16]; // weak
extern char aMom_mcs_goto_z[15]; // weak
extern char aMom_mcs_goto_y[15]; // weak
extern char aMom_mcs_goto_x[15]; // weak
extern char aWarningTheTo_0[119]; // weak
extern char aWarningTheTool[]; // idb
extern int dword_1000ADA0; // weak
extern _UNKNOWN unk_1000AE58; // weak
extern double dbl_1000C000; // weak
extern char byte_1000C008; // weak
extern char byte_1000C009; // weak
extern char byte_1000C00A; // weak
extern int dword_1000C248; // weak
extern double dbl_1000C250; // weak
extern double dbl_1000C258; // weak
extern double dbl_1000C260; // weak
extern double dbl_1000C268; // weak
extern int dword_1000C270; // weak
extern int dword_1000C274; // weak
extern int dword_1000C278; // weak
extern int dword_1000C27C; // weak
extern int dword_1000C280; // weak
extern int dword_1000C284; // weak
extern int dword_1000C288; // weak
extern int dword_1000C28C; // weak
extern int dword_1000C290; // weak
extern int dword_1000C294; // weak
extern int dword_1000C298; // weak
extern int dword_1000C29C; // weak
extern int dword_1000C2A0; // weak
extern int dword_1000C2A4; // weak
extern int dword_1000C2A8; // weak
extern int dword_1000C2AC; // weak
extern int dword_1000C2B0; // weak
extern int dword_1000C2B4; // weak
extern int dword_1000C2B8; // weak
extern int dword_1000C2BC; // weak
extern int dword_1000C2C0; // weak
extern int dword_1000C2C4; // weak
extern int dword_1000C2C8; // weak
extern int dword_1000C2CC; // weak
extern int dword_1000C2D0; // weak
extern int dword_1000C2D4; // weak
extern int dword_1000C2D8; // weak
extern int dword_1000C2DC; // weak
extern int dword_1000C2E0; // weak
extern int dword_1000C2E4; // weak
extern int dword_1000C2E8; // weak
extern int dword_1000C2EC; // weak
extern int dword_1000C2F0; // weak
extern int dword_1000C2F4; // weak
extern double dbl_1000C2F8; // weak
extern double dbl_1000C300; // weak
extern double dbl_1000C308; // weak
extern double dbl_1000C310; // weak
extern double dbl_1000C318; // weak
extern double dbl_1000C320; // weak
extern double dbl_1000C328; // weak
extern double dbl_1000C330; // weak
extern double dbl_1000C338; // weak
extern double dbl_1000C340; // weak
extern double dbl_1000C348; // weak
extern _UNKNOWN unk_1000C3C8; // weak
extern _UNKNOWN unk_1000C448; // weak
extern double dbl_1000C450; // weak
extern double dbl_1000C4E0; // weak
extern double dbl_1000C4E8; // weak
extern double dbl_1000C4F0; // weak
extern double dbl_1000C4F8; // weak
extern double dbl_1000C500; // weak
extern double dbl_1000C508; // weak
extern double dbl_1000C510; // weak
extern double dbl_1000C518; // weak
extern double dbl_1000C520; // weak
extern double dbl_1000C528; // weak
extern double dbl_1000C530; // weak
extern double dbl_1000C538; // weak
extern double dbl_1000C540; // weak
extern double dbl_1000C548; // weak
extern double dbl_1000C550; // weak
extern double dbl_1000C558; // weak
extern double dbl_1000C560; // weak
extern double dbl_1000C568; // weak
extern double dbl_1000C570; // weak
extern double dbl_1000C578; // weak
extern double dbl_1000C580; // weak
extern double dbl_1000C588; // weak
extern char byte_1000C590; // weak
extern _UNKNOWN unk_1000C598; // weak
extern _UNKNOWN unk_1000C5C0; // weak
extern _UNKNOWN unk_1000C5E8; // weak
extern double dbl_1000C600; // weak
extern double dbl_1000C608; // weak
extern double dbl_1000C610; // weak
extern double dbl_1000C618; // weak
extern double dbl_1000C620; // weak
extern double dbl_1000C628; // weak
extern double dbl_1000C630; // weak
extern double dbl_1000C638; // weak
extern double dbl_1000C640; // weak
extern _UNKNOWN unk_1000C648; // weak
extern double dbl_1000C660; // weak
extern int dword_1000C668; // weak
extern double dbl_1000C670; // weak
extern int dword_1000C678; // weak
extern _UNKNOWN unk_1000C680; // weak
extern int dword_1000C9AC; // weak

//-------------------------------------------------------------------------
// Function declarations

// int __usercall sub_10001000<eax>(int a1<eax>, int a2<edx>, int a3<ecx>, int a4<esi>);
int __cdecl sub_10001060(char *Dest); // idb
// int UF_terminate(); weak
int __cdecl sub_100010C0(int, int, int, int); // weak
int __cdecl sub_100012B0(int); // weak
signed int __cdecl sub_10001390(int Str);
int __cdecl sub_10001B00(int); // weak
signed int __cdecl sub_10001C00(int a1, int a2, char *a3, int a4);
int __cdecl ufusr(int a1, int a2);
// int __usercall sub_10001F60<eax>(int a1<eax>, int a2<ecx>, int a3<esi>, char a4);
// double __cdecl sub_10001F90(long double a1);
// int __usercall sub_10001FE0<eax>(int result<eax>, int _ECX<ecx>, double a3);
// int __usercall sub_100020C0<eax>(int a1<eax>, int a2<ecx>, int a3);
// int __usercall sub_10002190<eax>(int a1<eax>, int a2<esi>, double a3, double a4, signed int a5);
int __cdecl sub_10002320(int, double, int); // idb
int __cdecl sub_100023A0(int, double, int); // idb
double __fastcall sub_100023E0(int a1, int a2, int a3);
signed int __cdecl PtFuncCompare(int a1, int a2);
void __fastcall sub_10002440(int a1, int a2);
double __cdecl sub_10002590(double a1);
// void __usercall sub_100025C0(int a1<edx>, int a2<ebx>);
_DWORD __cdecl sub_100026F0(_DWORD); // weak
int __cdecl sub_10002780(int a1, int a2, int a3, int a4);
signed int __cdecl sub_10002840(int a1, signed int a2, int a3, int a4);
int __fastcall sub_10002C80(int a1, int a2, int a3, int a4, int a5);
// signed int __usercall sub_10002E80<eax>(int a1<eax>, int a2);
// int __usercall sub_10002FB0<eax>(int _ECX<ecx>, unsigned int a2<ebx>, unsigned int a3<esi>, int a4, int a5);
signed int __cdecl sub_100031D0(const void *a1, int a2, int a3);
int __cdecl sub_10003F40(int a1, int a2, int a3, int a4, int a5, int a6);
signed int __cdecl sub_10004160(int a1, const void *a2, int a3, int a4, int a5, int a6, int a7, int a8, const void *a9);
int __cdecl sub_10004F30(const void *a1, int a2, int a3);
double __cdecl sub_10005120(int a1, long double *a2);
// signed int __usercall sub_100051B0<eax>(int a1<eax>);
_DWORD __cdecl sub_100052D0(_DWORD); // weak
int __fastcall sub_10005310(int a1, int a2, char a3);
int __cdecl sub_10005330(int a1, int a2);
int __cdecl sub_10005500(int a1, int a2);
int __cdecl sub_10005670(int a1, int a2);
int __cdecl sub_10005870(int a1, int a2);
int __cdecl sub_10005BE0(int a1, int a2);
int __cdecl sub_10005F50(int a1, int a2);
int __cdecl sub_10006080(int a1, int a2);
int __cdecl sub_100061B0(int a1, int a2);
int __cdecl sub_100066D0(int a1, int a2);
int __cdecl sub_10006A80(int a1, int a2);
int __cdecl sub_10006D30(int a1, int a2);
_DWORD __cdecl sub_10007000(_DWORD, _DWORD); // weak
_DWORD __cdecl sub_10007250(_DWORD, _DWORD); // weak
int __cdecl sub_10007400(int, char *Str); // idb
_DWORD __cdecl sub_10007650(_DWORD, _DWORD); // weak
_DWORD __cdecl sub_10007750(_DWORD, _DWORD); // weak
_DWORD __cdecl sub_100077F0(_DWORD, _DWORD, _DWORD); // weak
// double __cdecl floor(double);
int __cdecl sub_10007DBB();
int (*__cdecl sub_10007E7F())(void);
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
int __cdecl sub_10008179();
// int __cdecl _clean_type_info_names_internal(_DWORD); weak
// BOOL __stdcall IsProcessorFeaturePresent(DWORD ProcessorFeature);
// BOOL __stdcall DisableThreadLibraryCalls(HMODULE hLibModule);
// double __cdecl ceil(double);
// void __cdecl qsort(void *Base, size_t NumOfElements, size_t SizeOfElements, int (__cdecl *PtFuncCompare)(const void *, const void *));
// double __usercall CIacos<st0>(double x<st0>); idb
// int __cdecl atoi(const char *Str);
// char *__cdecl strstr(const char *Str, const char *SubStr);
// void *__cdecl malloc(size_t Size);
// double __cdecl strtod(const char *Str, char **EndPtr);
// void __cdecl free(void *Memory);
// int sprintf(char *Dest, const char *Format, ...);
// int printf(const char *Format, ...);
// int __cdecl UF_MTX3_x_vec(_DWORD, _DWORD); weak
// int __cdecl UF_get_fail_message(_DWORD, _DWORD); weak
// int __cdecl UF_MTX3_rotate_about_axis(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_edit_rotation(_DWORD, _DWORD); weak
// int __cdecl UF_VEC3_scale(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_is_parallel(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_z_vec(_DWORD, _DWORD); weak
// int __cdecl UF_VEC3_distance(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_vec_multiply_t(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_is_zero(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_affine_comb(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_is_equal(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_allocate_memory(_DWORD, _DWORD); weak
// int __cdecl UF_free(_DWORD); weak
// int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_dot(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_copy(_DWORD, _DWORD); weak
// int __cdecl UF_VEC3_angle_between(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_vec3_multiply_t(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_add(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_rotation(_DWORD, _DWORD, _DWORD);
// int __cdecl UF_MTX4_ask_rotation(_DWORD, _DWORD); weak
// int __cdecl UF_MTX3_vec_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_vec3_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX4_vec_multiply(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MTX3_y_vec(_DWORD, _DWORD); weak
// int __cdecl UF_MTX4_csys_to_csys(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_VEC3_cross(_DWORD, _DWORD);
// int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MOM_ask_interp_from_param(_DWORD, _DWORD); weak
// int __cdecl UF_MOM_ask_mom(_DWORD, _DWORD); weak
// int __cdecl UF_MOM_extend_xlator(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_OBJ_cycle_by_name(_DWORD, _DWORD); weak
// int __cdecl UF_ATTR_read_value(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MOM_set_string(_DWORD, _DWORD, _DWORD); weak
// int __cdecl UF_MOM_set_double(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int UF_terminate(void); weak
// int __cdecl UF_MISC_set_program_name(_DWORD); weak
// int UF_initialize(void); weak
// int __cdecl UF_MTX3_copy(_DWORD, _DWORD); weak
// int __cdecl uc1601(_DWORD, _DWORD); weak


//----- (10001000) --------------------------------------------------------
int __usercall sub_10001000<eax>(int a1<eax>, int a2<edx>, int a3<ecx>, int a4<esi>)
{
  char v5; // [sp+0h] [bp-88h]@2

  if ( a4 )
  {
    printf("%s, line %d:  %s\n", a2, a3, a1);
    if ( UF_get_fail_message(a4, &v5) )
    {
      printf("    returned a %d\n", a4);
      return a4;
    }
    printf("    returned error %d:  %s\n", a4, &v5);
  }
  return a4;
}
// 100090B4: using guessed type int __cdecl UF_get_fail_message(_DWORD, _DWORD);

//----- (10001060) --------------------------------------------------------
signed int __cdecl sub_10001060(char *Dest)
{
  signed int result; // eax@2

  UF_MISC_set_program_name("<!<UGPKIN>!>");
  if ( UF_initialize() )
  {
    sprintf(Dest, "ERROR!: Advanced Kinematics Module Unavailable");
    result = 1;
  }
  else
  {
    UF_MISC_set_program_name("Kinematics");
    result = 0;
  }
  return result;
}
// 10009150: using guessed type int __cdecl UF_MISC_set_program_name(_DWORD);
// 10009154: using guessed type int UF_initialize(void);

//----- (100010C0) --------------------------------------------------------
signed int __cdecl sub_100010C0(int a1, int a2, signed int a3, int a4)
{
  signed int result; // eax@4
  signed int v5; // edi@5
  double *v6; // ebx@6
  double v7; // st7@8
  signed int v8; // esi@15
  void *v9; // ebx@17
  int v10; // esi@17
  double v11; // [sp+4h] [bp-34h]@1
  double v12; // [sp+Ch] [bp-2Ch]@1
  double v13; // [sp+14h] [bp-24h]@1
  double v14; // [sp+1Ch] [bp-1Ch]@1
  double v15; // [sp+24h] [bp-14h]@1
  double v16; // [sp+2Ch] [bp-Ch]@1
  void *Str; // [sp+34h] [bp-4h]@1

  v11 = 0.0;
  v12 = 0.0;
  v13 = 0.0;
  v14 = 0.0;
  v15 = 0.0;
  v16 = 0.0;
  Str = malloc(0x90u);
  if ( a3 > 7 || a3 == 1 )
  {
    printf(" Incorrect number of arguments\n");
    printf(" Number of arguments should be between 1 and 6\n ");
    result = 999;
  }
  else
  {
    if ( !(a3 % 2) )
    {
      printf(" Insufficient number of arguments, There should be               atleast 2 arguments\n ");
      return 999;
    }
    v5 = 1;
    if ( a3 > 1 )
    {
      v6 = &v11;
      while ( strcmp(*(const char **)(a4 + 4 * v5), "AAXIS") )
      {
        if ( !strcmp(*(const char **)(a4 + 4 * v5), "BAXIS") )
        {
          v7 = 2.0;
          goto LABEL_13;
        }
        if ( !strcmp(*(const char **)(a4 + 4 * v5), "CAXIS") )
        {
          v7 = 3.0;
          goto LABEL_13;
        }
LABEL_14:
        v6[1] = strtod((const char *)*(_DWORD *)(a4 + 4 * v5 + 4), 0);
        v5 += 2;
        v6 += 2;
        if ( v5 >= a3 )
          goto LABEL_15;
      }
      v7 = 1.0;
LABEL_13:
      *(_QWORD *)v6 = *(_QWORD *)&v7;
      goto LABEL_14;
    }
LABEL_15:
    v8 = sub_100077F0(a1, Str, &v11);
    if ( v8 )
    {
      printf(" SET_rotd_mcs_matrix failed in mom_rotate_mach_csys \n ");
      result = v8;
    }
    else
    {
      v9 = Str;
      v10 = sub_10007400(a1, (char *)Str);
      if ( v10 )
      {
        printf(" SET_rotd_operation_data failed in mom_rotate_mach_csys \n ");
        result = v10;
      }
      else
      {
        if ( v9 )
          free(v9);
        result = 0;
      }
    }
  }
  return result;
}
// 100010C0: using guessed type int __cdecl sub_100010C0(int, int, int, int);
// 100077F0: using guessed type _DWORD __cdecl sub_100077F0(_DWORD, _DWORD, _DWORD);

//----- (100012B0) --------------------------------------------------------
int __cdecl sub_100012B0(int a1)
{
  int v1; // edi@1
  int result; // eax@2
  int v3; // edi@3
  int v4; // edi@5
  char v5; // [sp+10h] [bp-90h]@3
  char v6; // [sp+40h] [bp-60h]@1
  double v7; // [sp+70h] [bp-30h]@5
  double v8; // [sp+78h] [bp-28h]@7
  _DWORD v9[8]; // [sp+80h] [bp-20h]@7

  v1 = sub_10007250(a1, &v6);
  if ( v1 )
  {
    printf(" SET_input_point failed in mom_map_to_rotated_csys\n ");
    result = v1;
  }
  else
  {
    v3 = sub_10007750(&v6, &v5);
    if ( v3 )
    {
      printf(" mom_process_input_gotos failed in mom_map_to_rotated_csys\n ");
      result = v3;
    }
    else
    {
      v4 = sub_10007650(&v5, &v7);
      if ( v4 )
      {
        printf(" mom_transfer_gotos_rotd_mcsys failed in mom_map_to_rotated_csys\n ");
        result = v4;
      }
      else
      {
        UF_MOM_set_double(a1, "pos_x", LODWORD(v7), HIDWORD(v7));
        UF_MOM_set_double(a1, "pos_y", LODWORD(v8), HIDWORD(v8));
        UF_MOM_set_double(a1, "pos_z", v9[0], v9[1]);
        result = 0;
      }
    }
  }
  return result;
}
// 100012B0: using guessed type int __cdecl sub_100012B0(int);
// 10007250: using guessed type _DWORD __cdecl sub_10007250(_DWORD, _DWORD);
// 10007650: using guessed type _DWORD __cdecl sub_10007650(_DWORD, _DWORD);
// 10007750: using guessed type _DWORD __cdecl sub_10007750(_DWORD, _DWORD);
// 10009148: using guessed type int __cdecl UF_MOM_set_double(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10001390) --------------------------------------------------------
signed int __cdecl sub_10001390(int Str)
{
  int v1; // esi@1
  int v2; // ebx@1
  void *v3; // edi@1
  void *v5; // eax@3
  int v6; // ecx@3
  void *v7; // edx@3
  void *v8; // eax@3
  int v9; // ecx@3
  void *v10; // ecx@3
  void *v11; // esi@3
  double v12; // st6@3
  double v13; // st7@3
  double v14; // st7@3
  double v15; // st6@3
  double v16; // st6@3
  double v17; // st7@3
  __int64 v18; // st7@4
  int v19; // edx@21
  int v20; // edx@21
  int v21; // eax@21
  int v22; // ecx@21
  int v23; // eax@21
  int v24; // ecx@21
  int v25; // eax@21
  double v26; // st7@22
  double v27; // [sp+Ch] [bp-35Ch]@3
  double v28; // [sp+14h] [bp-354h]@3
  double v29; // [sp+1Ch] [bp-34Ch]@3
  double v30; // [sp+24h] [bp-344h]@3
  double v31; // [sp+2Ch] [bp-33Ch]@3
  double v32; // [sp+34h] [bp-334h]@3
  double v33; // [sp+3Ch] [bp-32Ch]@3
  double v34; // [sp+44h] [bp-324h]@3
  double v35; // [sp+4Ch] [bp-31Ch]@3
  int v36; // [sp+54h] [bp-314h]@16
  double v37; // [sp+5Ch] [bp-30Ch]@21
  int v38; // [sp+64h] [bp-304h]@21
  int v39; // [sp+68h] [bp-300h]@21
  int v40; // [sp+6Ch] [bp-2FCh]@21
  int v41; // [sp+70h] [bp-2F8h]@21
  int v42; // [sp+74h] [bp-2F4h]@21
  int v43; // [sp+78h] [bp-2F0h]@21
  int v44; // [sp+7Ch] [bp-2ECh]@21
  int v45; // [sp+80h] [bp-2E8h]@21
  int v46; // [sp+84h] [bp-2E4h]@21
  int v47; // [sp+88h] [bp-2E0h]@21
  int v48; // [sp+8Ch] [bp-2DCh]@21
  int v49; // [sp+90h] [bp-2D8h]@21
  int v50; // [sp+94h] [bp-2D4h]@21
  int v51; // [sp+98h] [bp-2D0h]@21
  int v52; // [sp+9Ch] [bp-2CCh]@21
  int v53; // [sp+A0h] [bp-2C8h]@21
  int v54; // [sp+A4h] [bp-2C4h]@21
  int v55; // [sp+A8h] [bp-2C0h]@21
  bool v56; // [sp+ACh] [bp-2BCh]@21
  double v57; // [sp+B4h] [bp-2B4h]@21
  double v58; // [sp+BCh] [bp-2ACh]@21
  double v59; // [sp+C4h] [bp-2A4h]@21
  double v60; // [sp+CCh] [bp-29Ch]@21
  double v61; // [sp+D4h] [bp-294h]@21
  double v62; // [sp+DCh] [bp-28Ch]@21
  double v63; // [sp+E4h] [bp-284h]@24
  __int64 v64; // [sp+ECh] [bp-27Ch]@3
  __int64 v65; // [sp+F4h] [bp-274h]@3
  double v66; // [sp+FCh] [bp-26Ch]@3
  __int64 v67; // [sp+104h] [bp-264h]@3
  __int64 v68; // [sp+10Ch] [bp-25Ch]@3
  __int64 v69; // [sp+114h] [bp-254h]@3
  __int64 v70; // [sp+11Ch] [bp-24Ch]@3
  __int64 v71; // [sp+124h] [bp-244h]@3
  __int64 v72; // [sp+12Ch] [bp-23Ch]@3
  __int64 v73; // [sp+134h] [bp-234h]@3
  __int64 v74; // [sp+13Ch] [bp-22Ch]@3
  __int64 v75; // [sp+144h] [bp-224h]@3
  int v76; // [sp+14Ch] [bp-21Ch]@3
  int v77; // [sp+150h] [bp-218h]@3
  int v78; // [sp+154h] [bp-214h]@3
  int v79; // [sp+158h] [bp-210h]@3
  int v80; // [sp+15Ch] [bp-20Ch]@3
  int v81; // [sp+160h] [bp-208h]@3
  int v82; // [sp+164h] [bp-204h]@3
  int v83; // [sp+168h] [bp-200h]@3
  int v84; // [sp+16Ch] [bp-1FCh]@3
  int v85; // [sp+170h] [bp-1F8h]@3
  int v86; // [sp+174h] [bp-1F4h]@3
  int v87; // [sp+178h] [bp-1F0h]@3
  int v88; // [sp+17Ch] [bp-1ECh]@3
  int v89; // [sp+180h] [bp-1E8h]@3
  int v90; // [sp+184h] [bp-1E4h]@3
  int v91; // [sp+188h] [bp-1E0h]@3
  int v92; // [sp+18Ch] [bp-1DCh]@3
  int v93; // [sp+190h] [bp-1D8h]@3
  int v94; // [sp+194h] [bp-1D4h]@3
  int v95; // [sp+198h] [bp-1D0h]@3
  int v96; // [sp+19Ch] [bp-1CCh]@3
  int v97; // [sp+1A0h] [bp-1C8h]@3
  int v98; // [sp+1A4h] [bp-1C4h]@3
  int v99; // [sp+1A8h] [bp-1C0h]@3
  int v100; // [sp+1ACh] [bp-1BCh]@21
  int v101; // [sp+1B0h] [bp-1B8h]@21
  int v102; // [sp+1B4h] [bp-1B4h]@21
  int v103; // [sp+1B8h] [bp-1B0h]@21
  int v104; // [sp+1BCh] [bp-1ACh]@21
  int v105; // [sp+1C0h] [bp-1A8h]@21
  int v106; // [sp+1C4h] [bp-1A4h]@21
  int v107; // [sp+1C8h] [bp-1A0h]@21
  int v108; // [sp+1CCh] [bp-19Ch]@21
  int v109; // [sp+1D0h] [bp-198h]@21
  int v110; // [sp+1D4h] [bp-194h]@21
  int v111; // [sp+1D8h] [bp-190h]@21
  double v112; // [sp+264h] [bp-104h]@21
  double v113; // [sp+26Ch] [bp-FCh]@21
  __int64 v114; // [sp+274h] [bp-F4h]@3
  __int64 v115; // [sp+27Ch] [bp-ECh]@3
  double v116; // [sp+284h] [bp-E4h]@3
  __int64 v117; // [sp+28Ch] [bp-DCh]@3
  __int64 v118; // [sp+294h] [bp-D4h]@3
  __int64 v119; // [sp+29Ch] [bp-CCh]@3
  __int64 v120; // [sp+2A4h] [bp-C4h]@3
  __int64 v121; // [sp+2ACh] [bp-BCh]@3
  __int64 v122; // [sp+2B4h] [bp-B4h]@3
  __int64 v123; // [sp+2BCh] [bp-ACh]@3
  __int64 v124; // [sp+2C4h] [bp-A4h]@3
  __int64 v125; // [sp+2CCh] [bp-9Ch]@3
  int v126; // [sp+2D4h] [bp-94h]@3
  int v127; // [sp+2D8h] [bp-90h]@3
  int v128; // [sp+2DCh] [bp-8Ch]@3
  int v129; // [sp+2E0h] [bp-88h]@3
  int v130; // [sp+2E4h] [bp-84h]@3
  int v131; // [sp+2E8h] [bp-80h]@3
  int v132; // [sp+2ECh] [bp-7Ch]@3
  int v133; // [sp+2F0h] [bp-78h]@3
  int v134; // [sp+2F4h] [bp-74h]@3
  int v135; // [sp+2F8h] [bp-70h]@3
  int v136; // [sp+2FCh] [bp-6Ch]@3
  int v137; // [sp+300h] [bp-68h]@3
  int v138; // [sp+304h] [bp-64h]@3
  int v139; // [sp+308h] [bp-60h]@3
  int v140; // [sp+30Ch] [bp-5Ch]@3
  int v141; // [sp+310h] [bp-58h]@3
  int v142; // [sp+314h] [bp-54h]@3
  int v143; // [sp+318h] [bp-50h]@3
  int v144; // [sp+31Ch] [bp-4Ch]@3
  int v145; // [sp+320h] [bp-48h]@3
  int v146; // [sp+324h] [bp-44h]@3
  int v147; // [sp+328h] [bp-40h]@3
  int v148; // [sp+32Ch] [bp-3Ch]@3
  int v149; // [sp+330h] [bp-38h]@3
  void *v150; // [sp+334h] [bp-34h]@1
  void *v151; // [sp+338h] [bp-30h]@1
  void *v152; // [sp+33Ch] [bp-2Ch]@1
  void *v153; // [sp+340h] [bp-28h]@1
  void *Memory; // [sp+344h] [bp-24h]@1
  __int64 v155; // [sp+348h] [bp-20h]@4
  __int64 v156; // [sp+350h] [bp-18h]@4
  __int64 v157; // [sp+358h] [bp-10h]@15
  int v158; // [sp+360h] [bp-8h]@1
  int v159; // [sp+364h] [bp-4h]@1
  void *Stra; // [sp+370h] [bp+8h]@1

  v1 = Str;
  Memory = malloc(0x358u);
  sub_100066D0(Str, (int)Memory);
  v158 = (int)malloc(0x228u);
  sub_10005330(Str, v158);
  v150 = malloc(0x120u);
  sub_10005500(Str, (int)v150);
  v152 = malloc(0x40u);
  sub_10005670(Str, (int)v152);
  v2 = (int)malloc(0x1F0u);
  sub_10005870(Str, v2);
  v159 = (int)malloc(0x1F0u);
  sub_10005BE0(Str, v159);
  v151 = malloc(0x98u);
  sub_10005F50(Str, (int)v151);
  Stra = malloc(0x3B0u);
  sub_100061B0(v1, (int)Stra);
  v153 = malloc(0x18u);
  sub_10006080(v1, (int)v153);
  v3 = malloc(0x24u);
  if ( !v3 )
    return 1;
  v5 = Memory;
  v6 = v158;
  *((_DWORD *)v3 + 2) = v150;
  v7 = v151;
  *(_DWORD *)v3 = v5;
  v8 = v152;
  *((_DWORD *)v3 + 1) = v6;
  v9 = v159;
  *((_DWORD *)v3 + 6) = v7;
  *((_DWORD *)v3 + 3) = v8;
  *((_DWORD *)v3 + 5) = v9;
  v10 = v153;
  *((_DWORD *)v3 + 4) = v2;
  *((_DWORD *)v3 + 7) = Stra;
  *((_DWORD *)v3 + 8) = v10;
  sub_10006A80(v1, (int)&v64);
  sub_10006D30(v1, (int)&v64);
  sub_10007000(v1, &v64);
  v11 = Memory;
  v27 = *(double *)&v64 + *(double *)(v2 + 432);
  v12 = *(double *)(v159 + 432);
  v114 = v64;
  v115 = v65;
  v30 = v12 + v27;
  v13 = v27 + *((double *)Memory + 104);
  v117 = v67;
  v33 = v13;
  v14 = *(double *)(v2 + 440);
  v118 = v68;
  v28 = v14 + *(double *)&v65;
  v15 = *(double *)(v159 + 440);
  v120 = v70;
  v31 = v15 + v28;
  v34 = v28 + *((double *)Memory + 105);
  v29 = *(double *)(v2 + 448) + v66;
  v16 = *(double *)(v159 + 448) + v29;
  v116 = v66;
  v32 = v16;
  v17 = v29 + *((double *)Memory + 106);
  v119 = v69;
  v35 = v17;
  v121 = v71;
  v123 = v73;
  v122 = v72;
  v124 = v74;
  v126 = v76;
  v125 = v75;
  v129 = v79;
  v127 = v77;
  v128 = v78;
  v132 = v82;
  v130 = v80;
  v131 = v81;
  v135 = v85;
  v133 = v83;
  v134 = v84;
  v138 = v88;
  v136 = v86;
  v137 = v87;
  v141 = v91;
  v139 = v89;
  v140 = v90;
  v144 = v94;
  v142 = v92;
  v143 = v93;
  v147 = v97;
  v145 = v95;
  v146 = v96;
  v148 = v98;
  v149 = v99;
  if ( strstr((const char *)Stra, "POSX") )
  {
    v155 = v67;
    v156 = v68;
    v18 = v69;
  }
  else
  {
    if ( !strstr((const char *)Stra, "POSY") )
    {
      if ( !strstr((const char *)Stra, "POSZ") )
      {
        if ( strstr((const char *)Stra, "NEGX") )
        {
          *(double *)&v155 = -*(double *)&v67;
          *(double *)&v156 = -*(double *)&v68;
          *(double *)&v18 = -*(double *)&v69;
          goto LABEL_15;
        }
        if ( strstr((const char *)Stra, "NEGY") )
        {
          *(double *)&v155 = -*(double *)&v70;
          *(double *)&v156 = -*(double *)&v71;
          *(double *)&v18 = -*(double *)&v72;
          goto LABEL_15;
        }
        if ( strstr((const char *)Stra, "NEGZ") )
        {
          *(double *)&v155 = -*(double *)&v73;
          *(double *)&v156 = -*(double *)&v74;
          *(double *)&v18 = -*(double *)&v75;
          goto LABEL_15;
        }
      }
      v155 = v73;
      v156 = v74;
      v18 = v75;
      goto LABEL_15;
    }
    v155 = v70;
    v156 = v71;
    v18 = v72;
  }
LABEL_15:
  v157 = v18;
  if ( strstr((const char *)v11, "5_axis_dual_table") )
  {
    v36 = 2;
  }
  else
  {
    if ( strstr((const char *)v11, "5_axis_dual_head") )
    {
      v36 = 1;
    }
    else
    {
      if ( strstr((const char *)v11, "5_axis_head_table") )
        v36 = 3;
    }
  }
  v37 = *((double *)v11 + 100);
  v38 = v100;
  v41 = v103;
  v39 = v101;
  v40 = v102;
  v44 = v106;
  v42 = v104;
  v43 = v105;
  v47 = v109;
  v19 = *(_DWORD *)(v2 + 432);
  v45 = v107;
  v46 = v108;
  v50 = v19;
  v20 = *(_DWORD *)(v2 + 444);
  v48 = v110;
  v21 = *(_DWORD *)(v2 + 436);
  v49 = v111;
  v22 = *(_DWORD *)(v2 + 440);
  v53 = v20;
  v51 = v21;
  v23 = *(_DWORD *)(v2 + 448);
  v52 = v22;
  v24 = *(_DWORD *)(v2 + 452);
  v54 = v23;
  v55 = v24;
  v25 = atoi((const char *)v11 + 133);
  v57 = v113;
  v56 = v25 == 1;
  v58 = *(double *)(v2 + 408);
  v59 = *(double *)(v2 + 416);
  v60 = *(double *)(v159 + 408);
  v61 = *(double *)(v159 + 416);
  v62 = v112;
  if ( strstr((const char *)v11, "5_axis_dual_table") )
    v26 = 0.0;
  else
    v26 = *(double *)(v158 + 536);
  v63 = v26;
  sub_10004160((int)&v126, &v114, (int)&v27, v2 + 456, (int)&v30, v159 + 456, (int)&v33, (int)&v155, &v36);
  free(v3);
  free(v11);
  if ( v158 )
    free((void *)v158);
  if ( v150 )
    free(v150);
  if ( v152 )
    free(v152);
  free((void *)v2);
  free((void *)v159);
  if ( v151 )
    free(v151);
  if ( Stra )
    free(Stra);
  if ( v153 )
    free(v153);
  return 0;
}
// 10007000: using guessed type _DWORD __cdecl sub_10007000(_DWORD, _DWORD);

//----- (10001B00) --------------------------------------------------------
int __cdecl sub_10001B00(int a1)
{
  char v2; // [sp+10h] [bp-208h]@1
  char v3; // [sp+198h] [bp-80h]@1
  double v4; // [sp+1C8h] [bp-50h]@1
  double v5; // [sp+1D0h] [bp-48h]@1
  double v6; // [sp+1D8h] [bp-40h]@1
  double v7; // [sp+1E0h] [bp-38h]@1
  double v8; // [sp+1E8h] [bp-30h]@1
  double v9; // [sp+1F0h] [bp-28h]@1
  double v10; // [sp+1F8h] [bp-20h]@1
  double v11; // [sp+200h] [bp-18h]@1
  double v12; // [sp+208h] [bp-10h]@1
  double v13; // [sp+210h] [bp-8h]@1

  sub_10007000(a1, &v2);
  sub_100026F0(&v2);
  sub_10007250(a1, &v3);
  sub_10004F30(&v3, (int)&v4, (int)&v9);
  UF_MOM_set_double(a1, "pos_x", LODWORD(v4), HIDWORD(v4));
  UF_MOM_set_double(a1, "pos_y", LODWORD(v5), HIDWORD(v5));
  UF_MOM_set_double(a1, "pos_z", LODWORD(v6), HIDWORD(v6));
  UF_MOM_set_double(a1, "pos_a1", LODWORD(v7), HIDWORD(v7));
  UF_MOM_set_double(a1, "pos_a2", LODWORD(v8), HIDWORD(v8));
  UF_MOM_set_double(a1, "alt_pos_x", LODWORD(v9), HIDWORD(v9));
  UF_MOM_set_double(a1, "alt_pos_y", LODWORD(v10), HIDWORD(v10));
  UF_MOM_set_double(a1, "alt_pos_z", LODWORD(v11), HIDWORD(v11));
  UF_MOM_set_double(a1, "alt_pos_a1", LODWORD(v12), HIDWORD(v12));
  UF_MOM_set_double(a1, "alt_pos_a2", LODWORD(v13), HIDWORD(v13));
  return 0;
}
// 10001B00: using guessed type int __cdecl sub_10001B00(int);
// 100026F0: using guessed type _DWORD __cdecl sub_100026F0(_DWORD);
// 10007000: using guessed type _DWORD __cdecl sub_10007000(_DWORD, _DWORD);
// 10007250: using guessed type _DWORD __cdecl sub_10007250(_DWORD, _DWORD);
// 10009148: using guessed type int __cdecl UF_MOM_set_double(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10001C00) --------------------------------------------------------
signed int __cdecl sub_10001C00(int a1, int a2, char *a3, int a4)
{
  char *v5; // eax@6
  char *v6; // edx@6
  char v7; // cl@7
  char *v8; // eax@8
  char *v9; // edx@8
  char v10; // cl@9
  int v11; // eax@16
  char v12; // cl@17
  int v13; // eax@19
  char v14; // cl@20
  char v15; // [sp+8h] [bp-4ECh]@2
  __int16 v16; // [sp+28h] [bp-4CCh]@5
  char v17[132]; // [sp+208h] [bp-2ECh]@6
  int v18; // [sp+28Ch] [bp-268h]@1
  char v19[136]; // [sp+314h] [bp-1E0h]@13
  int v20; // [sp+39Ch] [bp-158h]@1
  int v21; // [sp+3A0h] [bp-154h]@1
  __int16 v22; // [sp+3A4h] [bp-150h]@1
  char v23[52]; // [sp+424h] [bp-D0h]@8
  int v24; // [sp+458h] [bp-9Ch]@1
  int v25; // [sp+45Ch] [bp-98h]@1
  int v26; // [sp+460h] [bp-94h]@1
  int v27; // [sp+464h] [bp-90h]@1
  int v28; // [sp+468h] [bp-8Ch]@1
  int v29; // [sp+4E0h] [bp-14h]@13
  int v30; // [sp+4E8h] [bp-Ch]@13
  int v31; // [sp+4F0h] [bp-4h]@1

  v24 = dword_100095D8;
  v25 = dword_100095DC;
  v26 = dword_100095E0;
  v27 = dword_100095E4;
  v28 = dword_100095E8;
  v31 = 0;
  v18 = 2105376;
  v20 = dword_100095CC;
  v21 = dword_100095D0;
  v22 = word_100095D4;
  if ( a3 != (char *)2 )
  {
    memcpy(&v15, "Invalid number of arguments", 0x1Cu);
LABEL_3:
    printf(" ERROR : %s \n ", &v15);
    return 1;
  }
  if ( UF_MOM_ask_string(a1, &v20, &a3) )
  {
    memcpy(&v15, "No Tool Name obtained from UGPost", 0x20u);
    v16 = *(_WORD *)"t";
    goto LABEL_3;
  }
  v5 = a3;
  v6 = (char *)(v17 - a3);
  do
  {
    v7 = *v5;
    v5[(_DWORD)v6] = *v5;
    ++v5;
  }
  while ( v7 );
  v8 = *(char **)(a4 + 4);
  v9 = (char *)(v23 - v8);
  do
  {
    v10 = *v8;
    v8[(_DWORD)v9] = *v8;
    ++v8;
  }
  while ( v10 );
  if ( UF_OBJ_cycle_by_name(v17, &v31) )
  {
    printf(" UF_OBJ_cycle_by_name could not get the tool_object_tag \n");
    return 1;
  }
  if ( v31 )
  {
    v30 = (int)v19;
    if ( UF_ATTR_read_value(v31, v23, 5, &v29) )
    {
      printf(" UF_ATTR_read_value could not return tool string \n");
      return 1;
    }
    if ( v29 != 5 )
    {
      v11 = 0;
      do
      {
        v12 = *((_BYTE *)&v18 + v11);
        v19[v11++] = v12;
      }
      while ( v12 );
    }
  }
  else
  {
    v13 = 0;
    do
    {
      v14 = *((_BYTE *)&v18 + v13);
      v19[v13++] = v14;
    }
    while ( v14 );
  }
  UF_MOM_set_string(a1, &v24, v19);
  return 0;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);
// 1000913C: using guessed type int __cdecl UF_OBJ_cycle_by_name(_DWORD, _DWORD);
// 10009140: using guessed type int __cdecl UF_ATTR_read_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 10009144: using guessed type int __cdecl UF_MOM_set_string(_DWORD, _DWORD, _DWORD);
// 100095CC: using guessed type int dword_100095CC;
// 100095D0: using guessed type int dword_100095D0;
// 100095D4: using guessed type __int16 word_100095D4;
// 100095D8: using guessed type int dword_100095D8;
// 100095DC: using guessed type int dword_100095DC;
// 100095E0: using guessed type int dword_100095E0;
// 100095E4: using guessed type int dword_100095E4;
// 100095E8: using guessed type int dword_100095E8;
// 10001C00: using guessed type char var_2EC[132];
// 10001C00: using guessed type char var_D0[52];
// 10001C00: using guessed type char var_1E0[136];

//----- (10001DF0) --------------------------------------------------------
int __cdecl ufusr(int a1, int a2)
{
  int result; // eax@2
  int v3; // eax@3
  int v4; // eax@3
  int v5; // eax@3
  int v6; // eax@3
  int v7; // eax@3
  int v8; // eax@3
  char Dest; // [sp+0h] [bp-8Ch]@1
  int v10; // [sp+84h] [bp-8h]@1
  int v11; // [sp+88h] [bp-4h]@3

  v10 = 0;
  if ( sub_10001060(&Dest) )
  {
    printf("ERROR : Ugpost Advanced Kinematics license not found \n");
    uc1601(&Dest, 1);
    result = UF_terminate();
  }
  else
  {
    UF_MOM_ask_interp_from_param(a1, &v10);
    UF_MOM_ask_mom(a1, &v11);
    v3 = UF_MOM_extend_xlator(v11, "MOM_load_kinematics", sub_10001390);
    sub_10001000(
      (int)"UF_MOM_extend_xlator ( mom, \"MOM_load_kinematics\", mom_load_kinematics )",
      (int)"O:\\ugnx85\\ip23\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      113,
      v3);
    v4 = UF_MOM_extend_xlator(v11, "MOM_convert_point", sub_10001B00);
    sub_10001000(
      (int)"UF_MOM_extend_xlator ( mom, \"MOM_convert_point\", mom_convert_point )",
      (int)"O:\\ugnx85\\ip23\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      123,
      v4);
    v5 = UF_MOM_extend_xlator(v11, "MOM_get_tool_attribute", sub_10001C00);
    sub_10001000(
      (int)"UF_MOM_extend_xlator ( mom , \"MOM_get_tool_attribute\", mom_get_tool_attribute )",
      (int)"O:\\ugnx85\\ip23\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      133,
      v5);
    v6 = UF_MOM_extend_xlator(v11, "MOM_rotate_mach_csys", sub_100010C0);
    sub_10001000(
      (int)"UF_MOM_extend_xlator ( mom, \"MOM_rotate_mach_csys\", mom_rotate_mach_csys )",
      (int)"O:\\ugnx85\\ip23\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      143,
      v6);
    v7 = UF_MOM_extend_xlator(v11, "MOM_map_to_rotated_csys", sub_100012B0);
    sub_10001000(
      (int)"UF_MOM_extend_xlator ( mom, \"MOM_map_to_rotated_csys\", mom_map_to_rotated_csys )",
      (int)"O:\\ugnx85\\ip23\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
      153,
      v7);
    v8 = UF_MOM_extend_xlator(v11, "MOM_exit_kinematics_module", UF_terminate);
    result = sub_10001000(
               (int)"UF_MOM_extend_xlator ( mom, \"MOM_exit_kinematics_module\", mom_exit_kinematics_module )",
               (int)"O:\\ugnx85\\ip23\\src\\ugpadvkins\\no\\ind\\uf_mom_add_ufun_tclexts.c",
               163,
               v8);
    dword_1000C248 = v11;
    *(_DWORD *)a2 = 0;
  }
  return result;
}
// 100010B0: using guessed type int UF_terminate();
// 100010C0: using guessed type int __cdecl sub_100010C0(int, int, int, int);
// 100012B0: using guessed type int __cdecl sub_100012B0(int);
// 10001B00: using guessed type int __cdecl sub_10001B00(int);
// 1000912C: using guessed type int __cdecl UF_MOM_ask_interp_from_param(_DWORD, _DWORD);
// 10009130: using guessed type int __cdecl UF_MOM_ask_mom(_DWORD, _DWORD);
// 10009134: using guessed type int __cdecl UF_MOM_extend_xlator(_DWORD, _DWORD, _DWORD);
// 1000914C: using guessed type int UF_terminate(void);
// 10009160: using guessed type int __cdecl uc1601(_DWORD, _DWORD);
// 1000C248: using guessed type int dword_1000C248;

//----- (10001F60) --------------------------------------------------------
int __usercall sub_10001F60<eax>(int a1<eax>, int a2<ecx>, int a3<esi>, char a4)
{
  UF_VEC3_cross(a2, a1);
  return UF_VEC3_unitize(a3, COERCE_UNSIGNED_INT64(1.0e-10), COERCE_UNSIGNED_INT64(1.0e-10) >> 32, &a4, a3);
}
// 10009128: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10001FE0) --------------------------------------------------------
int __usercall sub_10001FE0<eax>(int result<eax>, int _ECX<ecx>, double a3)
{
  __asm
  {
    fld     [ebp+arg_0]
    fld     st
    fcos
    fxch    st(1)
    fsin
    fld     qword ptr [eax]
    fmul    st, st
    fld     qword ptr [eax+8]
    fmul    st, st
    fld     qword ptr [eax+10h]
    fmul    st, st
    fstp    [ebp+var_8]
    fld1
    fld     st
    fsub    st, st(5)
    fld     st(1)
    fsub    st, st(4)
    fmul    st, st(6)
    faddp   st(4), st
    fxch    st(3)
    fstp    qword ptr [ecx]
    fld     qword ptr [eax+8]
    fmul    qword ptr [eax]
    fmul    st, st(3)
    fld     qword ptr [eax+10h]
    fmul    st, st(5)
    faddp   st(1), st
    fstp    qword ptr [ecx+8]
    fld     qword ptr [eax+10h]
    fmul    qword ptr [eax]
    fmul    st, st(3)
    fld     qword ptr [eax+8]
    fmul    st, st(5)
    fsubp   st(1), st
    fstp    qword ptr [ecx+10h]
    fldz
    fst     qword ptr [ecx+18h]
    fld     qword ptr [eax+8]
    fmul    qword ptr [eax]
    fmul    st, st(4)
    fld     qword ptr [eax+10h]
    fmul    st, st(6)
    fsubp   st(1), st
    fstp    qword ptr [ecx+20h]
    fld     st(1)
    fsub    st, st(3)
    fmul    st, st(6)
    faddp   st(3), st
    fxch    st(2)
    fstp    qword ptr [ecx+28h]
    fld     qword ptr [eax+10h]
    fmul    qword ptr [eax+8]
    fmul    st, st(3)
    fld     qword ptr [eax]
    fmul    st, st(5)
    faddp   st(1), st
    fstp    qword ptr [ecx+30h]
    fxch    st(1)
    fst     qword ptr [ecx+38h]
    fld     qword ptr [eax+10h]
    fmul    qword ptr [eax]
    fmul    st, st(3)
    fld     qword ptr [eax+8]
    fmul    st, st(5)
    faddp   st(1), st
    fstp    qword ptr [ecx+40h]
    fld     qword ptr [eax+10h]
    fmul    qword ptr [eax+8]
    fmulp   st(3), st
    fld     qword ptr [eax]
    fmulp   st(4), st
    fxch    st(2)
    fsubrp  st(3), st
    fxch    st(2)
    fstp    qword ptr [ecx+48h]
    fld     st(1)
    fld     [ebp+var_8]
    fsub    st(1), st
    fxch    st(1)
    fmulp   st(4), st
    faddp   st(3), st
    fxch    st(2)
    fstp    qword ptr [ecx+50h]
    fxch    st(1)
    fst     qword ptr [ecx+58h]
    fst     qword ptr [ecx+60h]
    fst     qword ptr [ecx+68h]
    fstp    qword ptr [ecx+70h]
    fstp    qword ptr [ecx+78h]
  }
  return result;
}
// 10001FE6: inconsistent fpu stack

//----- (100020C0) --------------------------------------------------------
int __usercall sub_100020C0<eax>(int a1<eax>, int a2<ecx>, int a3)
{
  int v3; // esi@1
  int v4; // edi@1
  char v6; // [sp+Ch] [bp-120h]@1
  char v7; // [sp+54h] [bp-D8h]@1
  char v8; // [sp+9Ch] [bp-90h]@1
  char v9; // [sp+B4h] [bp-78h]@1
  char v10; // [sp+CCh] [bp-60h]@1
  char v11; // [sp+E4h] [bp-48h]@1
  double v12; // [sp+FCh] [bp-30h]@1
  double v13; // [sp+104h] [bp-28h]@1
  double v14; // [sp+10Ch] [bp-20h]@1
  double v15; // [sp+114h] [bp-18h]@1
  double v16; // [sp+11Ch] [bp-10h]@1
  double v17; // [sp+124h] [bp-8h]@1

  v3 = a1;
  v4 = a2;
  UF_MTX3_copy(a1 + 24, &v7);
  UF_MTX3_copy(v4 + 24, &v6);
  v12 = *(double *)v3;
  v15 = *(double *)v4;
  v13 = *(double *)(v3 + 8);
  v16 = *(double *)(v4 + 8);
  v14 = *(double *)(v3 + 16);
  v17 = *(double *)(v4 + 16);
  UF_MTX3_x_vec(&v7, &v10);
  UF_MTX3_y_vec(&v7, &v8);
  UF_MTX3_x_vec(&v6, &v11);
  UF_MTX3_y_vec(&v6, &v9);
  return UF_MTX4_csys_to_csys(&v12, &v10, &v8, &v15, &v11, &v9, a3);
}
// 100090B0: using guessed type int __cdecl UF_MTX3_x_vec(_DWORD, _DWORD);
// 1000911C: using guessed type int __cdecl UF_MTX3_y_vec(_DWORD, _DWORD);
// 10009120: using guessed type int __cdecl UF_MTX4_csys_to_csys(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10009158: using guessed type int __cdecl UF_MTX3_copy(_DWORD, _DWORD);

//----- (10002190) --------------------------------------------------------
int __usercall sub_10002190<eax>(int a1<eax>, int a2<esi>, double a3, double a4, signed int a5)
{
  int v5; // edx@1
  int v6; // ecx@1
  int v7; // edx@1
  int v8; // ecx@1
  int v9; // edx@1
  int v10; // ecx@1
  int v11; // edx@1
  int result; // eax@1
  int v13; // ecx@1
  int v14; // edx@1
  char v15; // [sp+14h] [bp-258h]@1
  char v16; // [sp+94h] [bp-1D8h]@1
  char v17; // [sp+114h] [bp-158h]@1
  char v18; // [sp+15Ch] [bp-110h]@1
  char v19; // [sp+1DCh] [bp-90h]@1
  double v20; // [sp+1F4h] [bp-78h]@1
  double v21; // [sp+1FCh] [bp-70h]@1
  double v22; // [sp+204h] [bp-68h]@1
  char v23; // [sp+20Ch] [bp-60h]@1
  int v24; // [sp+224h] [bp-48h]@1
  int v25; // [sp+228h] [bp-44h]@1
  int v26; // [sp+22Ch] [bp-40h]@1
  int v27; // [sp+230h] [bp-3Ch]@1
  int v28; // [sp+234h] [bp-38h]@1
  int v29; // [sp+238h] [bp-34h]@1
  double v30; // [sp+244h] [bp-28h]@1
  int v31; // [sp+24Ch] [bp-20h]@1
  int v32; // [sp+250h] [bp-1Ch]@1
  int v33; // [sp+254h] [bp-18h]@1
  int v34; // [sp+258h] [bp-14h]@1
  int v35; // [sp+25Ch] [bp-10h]@1
  int v36; // [sp+260h] [bp-Ch]@1
  double v37; // [sp+264h] [bp-8h]@1

  v5 = *(_DWORD *)(a1 + 4);
  v31 = *(_DWORD *)a1;
  v6 = *(_DWORD *)(a1 + 8);
  v37 = (double)a5;
  v32 = v5;
  v7 = *(_DWORD *)(a1 + 12);
  v33 = v6;
  v8 = *(_DWORD *)(a1 + 16);
  v34 = v7;
  v9 = *(_DWORD *)(a1 + 20);
  v30 = *(double *)(dword_1000C2C4 + 8);
  v35 = v8;
  v20 = 0.0;
  v21 = 0.0;
  v22 = 0.0;
  v36 = v9;
  UF_MTX4_rotation(&dword_1000C2C8, &dbl_1000C2F8, COERCE_UNSIGNED_INT64(a4 * 57.29577951308235 * -1.0));
  sub_100052D0(&v18);
  UF_MTX4_ask_rotation(&v18, &v17);
  UF_MTX3_vec_multiply(&dbl_1000C310, &v17, &v23);
  UF_VEC3_unitize(&v23, LODWORD(v30), HIDWORD(v30), &a4, &v23);
  UF_MTX4_vec3_multiply(&v20, &v18, &v19);
  UF_MTX4_rotation(&v19, &v23, COERCE_UNSIGNED_INT64(a3 * 57.29577951308235 * -1.0));
  sub_100052D0(&v16);
  UF_MTX4_multiply(&v18, &v16, &v15);
  sub_100052D0(&v15);
  UF_MTX4_vec_multiply(&v31, &v15, &v24);
  v10 = v25;
  v11 = v26;
  *(_DWORD *)a2 = v24;
  result = v27;
  *(_DWORD *)(a2 + 4) = v10;
  v13 = v28;
  *(_DWORD *)(a2 + 8) = v11;
  v14 = v29;
  *(_DWORD *)(a2 + 12) = result;
  *(_DWORD *)(a2 + 16) = v13;
  *(_DWORD *)(a2 + 20) = v14;
  return result;
}
// 100052D0: using guessed type _DWORD __cdecl sub_100052D0(_DWORD);
// 10009108: using guessed type int __cdecl UF_MTX4_ask_rotation(_DWORD, _DWORD);
// 1000910C: using guessed type int __cdecl UF_MTX3_vec_multiply(_DWORD, _DWORD, _DWORD);
// 10009110: using guessed type int __cdecl UF_MTX4_vec3_multiply(_DWORD, _DWORD, _DWORD);
// 10009114: using guessed type int __cdecl UF_MTX4_multiply(_DWORD, _DWORD, _DWORD);
// 10009118: using guessed type int __cdecl UF_MTX4_vec_multiply(_DWORD, _DWORD, _DWORD);
// 10009128: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1000C2C4: using guessed type int dword_1000C2C4;
// 1000C2C8: using guessed type int dword_1000C2C8;
// 1000C2F8: using guessed type double dbl_1000C2F8;
// 1000C310: using guessed type double dbl_1000C310;

//----- (10002320) --------------------------------------------------------
int __cdecl sub_10002320(int a1, double a2, int a3)
{
  char v4; // [sp+Ch] [bp-E0h]@1
  char v5; // [sp+8Ch] [bp-60h]@1
  char v6; // [sp+D4h] [bp-18h]@1

  UF_MTX4_rotation(&dword_1000C2E0, &dbl_1000C310, COERCE_UNSIGNED_INT64(a2 * 57.29577951308235));
  sub_100052D0(&v4);
  UF_MTX4_ask_rotation(&v4, &v5);
  UF_MTX3_vec_multiply(&dword_1000C2C8, &v5, &v6);
  return UF_VEC3_add(a1, &v6, a3);
}
// 100052D0: using guessed type _DWORD __cdecl sub_100052D0(_DWORD);
// 10009100: using guessed type int __cdecl UF_VEC3_add(_DWORD, _DWORD, _DWORD);
// 10009108: using guessed type int __cdecl UF_MTX4_ask_rotation(_DWORD, _DWORD);
// 1000910C: using guessed type int __cdecl UF_MTX3_vec_multiply(_DWORD, _DWORD, _DWORD);
// 1000C2C8: using guessed type int dword_1000C2C8;
// 1000C2E0: using guessed type int dword_1000C2E0;
// 1000C310: using guessed type double dbl_1000C310;

//----- (100023A0) --------------------------------------------------------
int __cdecl sub_100023A0(int a1, double a2, int a3)
{
  int v3; // ecx@1
  char v5; // [sp+8h] [bp-80h]@1

  sub_10001FE0((int)&dbl_1000C2F8, (int)&v5, a2);
  sub_100052D0(v3);
  return UF_MTX4_vec3_multiply_t(a1, &v5, a3);
}
// 100052D0: using guessed type _DWORD __cdecl sub_100052D0(_DWORD);
// 100090FC: using guessed type int __cdecl UF_MTX4_vec3_multiply_t(_DWORD, _DWORD, _DWORD);
// 1000C2F8: using guessed type double dbl_1000C2F8;

//----- (100023E0) --------------------------------------------------------
double __fastcall sub_100023E0(int a1, int a2, int a3)
{
  double v4; // [sp+0h] [bp-8h]@1

  UF_VEC3_angle_between(a3, a2, a1, &v4);
  return v4;
}
// 100090F8: using guessed type int __cdecl UF_VEC3_angle_between(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10002400) --------------------------------------------------------
signed int __cdecl PtFuncCompare(int a1, int a2)
{
  signed int result; // eax@2

  if ( dbl_1000C000 < fabs(*(double *)a1 - *(double *)a2) )
  {
    if ( dbl_1000C000 + *(double *)a2 >= *(double *)a1 )
      result = -1;
    else
      result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1000C000: using guessed type double dbl_1000C000;

//----- (10002440) --------------------------------------------------------
void __fastcall sub_10002440(int a1, int a2)
{
  long double v2; // st7@1
  double v3; // st6@1
  double v4; // st5@4
  double v5; // st5@5
  double v6; // st4@7
  double v7; // st6@12
  double v8; // qt1@14
  double v9; // qt2@20
  long double v10; // st6@20
  double v11; // st7@20

  v2 = dbl_1000C000;
  v3 = 6.283185307179586;
  if ( dbl_1000C000 >= fabs(*(double *)a2 - *(double *)(a2 + 8))
    && fabs(*(double *)a1 - *(double *)(a1 + 8)) <= dbl_1000C000
    && fabs(*(double *)a2 - *(double *)a1) > dbl_1000C000 )
  {
    v4 = -dbl_1000C000;
    if ( -dbl_1000C000 <= *(double *)a2 )
    {
      if ( v4 <= *(double *)a1 )
      {
        v7 = dbl_1000C000;
        if ( dbl_1000C000 < *(double *)(a1 + 8) )
          *(double *)(a1 + 8) = *(double *)(a1 + 8) - 6.283185307179586;
        v8 = v7;
        v3 = 6.283185307179586;
        v2 = v8;
      }
      else
      {
        v6 = *(double *)a1 + 6.283185307179586;
        if ( fabs(v6 - *(double *)a2) <= dbl_1000C000 )
        {
          if ( v4 > *(double *)(a1 + 8) )
            *(double *)(a1 + 8) = *(double *)(a1 + 8) + 6.283185307179586;
        }
        else
        {
          *(_QWORD *)a1 = *(_QWORD *)&v6;
          if ( fabs(v6 - *(double *)(a1 + 8)) <= v2 )
            *(double *)(a1 + 8) = 6.283185307179586 - v6;
        }
      }
    }
    else
    {
      v5 = *(double *)a2 + 6.283185307179586;
      *(_QWORD *)a2 = *(_QWORD *)&v5;
      *(double *)(a2 + 8) = 6.283185307179586 - v5;
    }
  }
  if ( fabs(*(double *)a2 - *(double *)a1) <= v2 && fabs(*(double *)(a2 + 8) - *(double *)(a1 + 8)) <= v2 )
  {
    if ( -v2 <= *(double *)(a1 + 8) )
    {
      v9 = v3;
      v10 = v2;
      v11 = v9;
      if ( v10 >= *(double *)(a1 + 8) )
      {
        if ( fabs(*(double *)a2) <= v10 )
        {
          if ( fabs(*(double *)a1) <= v10 )
            *(_QWORD *)(a1 + 8) = *(_QWORD *)&v11;
        }
      }
      else
      {
        *(double *)(a1 + 8) = v11 - *(double *)(a1 + 8);
      }
    }
    else
    {
      *(double *)(a1 + 8) = v3 + *(double *)(a1 + 8);
    }
  }
}
// 1000C000: using guessed type double dbl_1000C000;

//----- (10002590) --------------------------------------------------------
double __cdecl sub_10002590(double a1)
{
  double result; // st7@2

  if ( a1 <= 0.0 )
  {
    result = a1;
    if ( a1 < 0.0 )
      result = a1 + 360.0;
  }
  else
  {
    result = a1 - 360.0;
  }
  return result;
}

//----- (100025C0) --------------------------------------------------------
void __usercall sub_100025C0(int a1<edx>, int a2<ebx>)
{
  int v2; // edx@1
  double v3; // st7@1
  int v4; // ecx@1
  int v5; // edx@3
  int v6; // ecx@3
  double v7; // st7@3
  char v8; // [sp+8h] [bp-28h]@6

  v3 = sub_10002590(*(double *)(a1 + 24));
  if ( fabs(*(double *)(v4 + 24) - v3) < fabs(*(double *)(v4 + 24) - *(double *)(v2 + 24)) )
    *(_QWORD *)(v2 + 24) = *(_QWORD *)&v3;
  v7 = sub_10002590(*(double *)(v2 + 32));
  if ( fabs(*(double *)(v6 + 32) - v7) < fabs(*(double *)(v6 + 32) - *(double *)(v5 + 32)) )
    *(_QWORD *)(v5 + 32) = *(_QWORD *)&v7;
  if ( fabs(*(double *)(v6 + 24) - *(double *)(a2 + 24)) < fabs(*(double *)(v6 + 24) - *(double *)(v5 + 24)) )
  {
    memcpy(&v8, (const void *)v5, 0x28u);
    memcpy((void *)v5, (const void *)a2, 0x28u);
    memcpy((void *)a2, &v8, 0x28u);
  }
  if ( *(double *)(dword_1000C2C4 + 104) - dbl_1000C000 >= *(double *)(v5 + 24)
    || *(double *)(dword_1000C2C4 + 112) + dbl_1000C000 <= *(double *)(v5 + 24) )
  {
    if ( *(double *)(dword_1000C2C4 + 120) - dbl_1000C000 < *(double *)(a2 + 24) )
    {
      if ( dbl_1000C000 + *(double *)(dword_1000C2C4 + 128) > *(double *)(a2 + 24) )
      {
        memcpy(&v8, (const void *)v5, 0x28u);
        memcpy((void *)v5, (const void *)a2, 0x28u);
        memcpy((void *)a2, &v8, 0x28u);
      }
    }
  }
}
// 1000C000: using guessed type double dbl_1000C000;
// 1000C2C4: using guessed type int dword_1000C2C4;

//----- (100026F0) --------------------------------------------------------
int __cdecl sub_100026F0(int a1)
{
  int v1; // ecx@1

  v1 = dword_1000C2C4;
  *(_DWORD *)(dword_1000C2C4 + 16) = *(_DWORD *)(a1 + 192);
  *(_DWORD *)(v1 + 20) = *(_DWORD *)(a1 + 196);
  *(_DWORD *)(v1 + 24) = *(_DWORD *)(a1 + 200);
  *(_DWORD *)(v1 + 28) = *(_DWORD *)(a1 + 204);
  *(_DWORD *)(v1 + 32) = *(_DWORD *)(a1 + 208);
  *(_DWORD *)(v1 + 36) = *(_DWORD *)(a1 + 212);
  *(_DWORD *)(v1 + 40) = *(_DWORD *)(a1 + 216);
  *(_DWORD *)(v1 + 44) = *(_DWORD *)(a1 + 220);
  *(_DWORD *)(v1 + 48) = *(_DWORD *)(a1 + 224);
  *(_DWORD *)(v1 + 52) = *(_DWORD *)(a1 + 228);
  *(_DWORD *)(v1 + 56) = *(_DWORD *)(a1 + 232);
  *(_DWORD *)(v1 + 60) = *(_DWORD *)(a1 + 236);
  *(double *)(v1 + 136) = *(double *)(a1 + 376);
  return 0;
}
// 100026F0: using guessed type _DWORD __cdecl sub_100026F0(_DWORD);
// 1000C2C4: using guessed type int dword_1000C2C4;

//----- (10002780) --------------------------------------------------------
int __cdecl sub_10002780(int a1, int a2, int a3, int a4)
{
  int result; // eax@2
  char v5; // [sp+8h] [bp-40h]@1
  double v6; // [sp+20h] [bp-28h]@1
  double v7; // [sp+28h] [bp-20h]@1
  double v8; // [sp+30h] [bp-18h]@1
  double v9; // [sp+38h] [bp-10h]@1
  double v10; // [sp+40h] [bp-8h]@2

  UF_VEC3_sub(a2 + 24, a2, &v6);
  UF_VEC3_sub(a1, a2, &v5);
  v9 = v7 * v7 + v6 * v6 + v8 * v8;
  if ( v9 <= 0.0 )
  {
    *(double *)a4 = 0.0;
    UF_VEC3_copy(a2, a3);
    result = 0;
  }
  else
  {
    UF_VEC3_dot(&v6, &v5, &v10);
    *(double *)a4 = v10 / v9;
    *(double *)a3 = *(double *)a4 * v6 + *(double *)a2;
    *(double *)(a3 + 8) = *(double *)a4 * v7 + *(double *)(a2 + 8);
    result = 0;
    *(double *)(a3 + 16) = *(double *)a4 * v8 + *(double *)(a2 + 16);
  }
  return result;
}
// 100090EC: using guessed type int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD);
// 100090F0: using guessed type int __cdecl UF_VEC3_dot(_DWORD, _DWORD, _DWORD);
// 100090F4: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);

//----- (10002840) --------------------------------------------------------
signed int __cdecl sub_10002840(int a1, signed int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // esi@1
  int v6; // eax@1
  int v7; // edi@2
  double v8; // st5@2
  int v9; // edx@3
  unsigned int v10; // ecx@3
  long double v11; // st4@4
  long double v12; // st4@6
  long double v13; // st4@8
  long double v14; // st4@10
  long double *v15; // edx@14
  int v16; // ecx@14
  long double v17; // st4@15
  int v18; // eax@19
  signed int v19; // ecx@20
  signed int v20; // edi@22
  int v21; // eax@23
  double v22; // st4@23
  int v23; // esi@23
  int v24; // eax@24
  unsigned int v25; // edi@24
  int v26; // edx@24
  int v27; // ebx@25
  double v28; // st3@25
  int v29; // edx@28
  int v30; // eax@29
  double v31; // st3@29
  double v32; // st4@33
  int v33; // edx@33
  int v34; // eax@34
  long double v35; // st3@34
  int v36; // edi@34
  int v37; // eax@35
  unsigned int v38; // esi@35
  int v39; // edx@35
  int v40; // ebx@36
  double v41; // st2@36
  int v42; // edx@39
  int v43; // esi@40
  double v44; // st2@40
  long double v45; // st3@42
  signed int result; // eax@44
  int v47; // edi@46
  int v48; // eax@47
  int v49; // esi@48
  int v50; // edi@48
  int v51; // edx@48
  int v52; // eax@48
  unsigned int v53; // esi@48
  int v54; // edi@48
  double v55; // st4@49
  double v56; // st4@49
  double v57; // st4@49
  double v58; // st4@49
  int v59; // edi@52
  int v60; // eax@52
  int v61; // edx@52
  double v62; // st4@53
  int v63; // eax@56
  int v64; // edx@56
  int v65; // edi@59
  double v66; // st4@59
  int v67; // eax@61
  unsigned int v68; // edx@61
  int v69; // esi@62
  int v70; // edx@65
  char v71; // [sp+Ch] [bp-20h]@1
  int v72; // [sp+10h] [bp-1Ch]@21
  int v73; // [sp+14h] [bp-18h]@21
  int v74; // [sp+18h] [bp-14h]@43
  int v75; // [sp+1Ch] [bp-10h]@23
  int v76; // [sp+20h] [bp-Ch]@1
  int v77; // [sp+24h] [bp-8h]@21
  int i; // [sp+28h] [bp-4h]@1

  v4 = a1;
  v5 = a2;
  v6 = UF_allocate_memory(8 * a2, &v71);
  *(double *)a4 = 1.0;
  v76 = v6;
  i = 0;
  if ( a2 <= 0 )
  {
LABEL_20:
    v19 = 0;
    if ( a2 > 0 )
    {
      v73 = a2 - 1;
      v77 = a1;
      v72 = a3 - a1;
      do
      {
        v20 = 0;
        i = 0;
        if ( v19 > 0 )
        {
          do
          {
            v21 = *(_DWORD *)(v4 + 4 * v20);
            v22 = *(double *)(v21 + 8 * v19);
            v23 = 0;
            v75 = *(_DWORD *)(v4 + 4 * v20);
            if ( v20 >= 4 )
            {
              v24 = v21 + 16;
              v25 = ((unsigned int)(v20 - 4) >> 2) + 1;
              v26 = v4 + 8;
              v23 = 4 * v25;
              do
              {
                v27 = *(_DWORD *)(v26 - 4);
                v28 = *(double *)(*(_DWORD *)(v26 - 8) + 8 * v19) * *(double *)(v24 - 16);
                v24 += 32;
                v26 += 16;
                --v25;
                v22 = v22
                    - v28
                    - *(double *)(v27 + 8 * v19) * *(double *)(v24 - 40)
                    - *(double *)(*(_DWORD *)(v26 - 16) + 8 * v19) * *(double *)(v24 - 32)
                    - *(double *)(*(_DWORD *)(v26 - 12) + 8 * v19) * *(double *)(v24 - 24);
              }
              while ( v25 );
              v21 = v75;
              v20 = i;
              v4 = a1;
            }
            if ( v23 < v20 )
            {
              v29 = v21 + 8 * v23;
              do
              {
                v30 = *(_DWORD *)(v4 + 4 * v23++);
                v31 = *(double *)(v30 + 8 * v19) * *(double *)v29;
                v29 += 8;
                v22 = v22 - v31;
              }
              while ( v23 < v20 );
              v21 = v75;
            }
            ++v20;
            *(_QWORD *)(v21 + 8 * v19) = *(_QWORD *)&v22;
            i = v20;
          }
          while ( v20 < v19 );
          v5 = a2;
        }
        v32 = 0.0;
        v33 = v19;
        for ( i = v19; v33 < v5; i = v33 )
        {
          v34 = *(_DWORD *)(v4 + 4 * v33);
          v35 = *(double *)(v34 + 8 * v19);
          v36 = 0;
          v75 = *(_DWORD *)(v4 + 4 * v33);
          if ( v19 >= 4 )
          {
            v37 = v34 + 16;
            v38 = ((unsigned int)(v19 - 4) >> 2) + 1;
            v39 = v4 + 8;
            v36 = 4 * v38;
            do
            {
              v40 = *(_DWORD *)(v39 - 4);
              v41 = *(double *)(*(_DWORD *)(v39 - 8) + 8 * v19) * *(double *)(v37 - 16);
              v37 += 32;
              v39 += 16;
              --v38;
              v35 = v35
                  - v41
                  - *(double *)(v40 + 8 * v19) * *(double *)(v37 - 40)
                  - *(double *)(*(_DWORD *)(v39 - 16) + 8 * v19) * *(double *)(v37 - 32)
                  - *(double *)(*(_DWORD *)(v39 - 12) + 8 * v19) * *(double *)(v37 - 24);
            }
            while ( v38 );
            v4 = a1;
            v34 = v75;
            v33 = i;
            v5 = a2;
          }
          if ( v36 < v19 )
          {
            v42 = v34 + 8 * v36;
            do
            {
              v43 = *(_DWORD *)(v4 + 4 * v36++);
              v44 = *(double *)(v43 + 8 * v19) * *(double *)v42;
              v42 += 8;
              v35 = v35 - v44;
            }
            while ( v36 < v19 );
            v5 = a2;
            v33 = i;
          }
          *(_QWORD *)(v34 + 8 * v19) = *(_QWORD *)&v35;
          v45 = fabs(v35) * *(double *)(v76 + 8 * v33);
          if ( v45 >= v32 )
          {
            v32 = v45;
            v74 = v33;
          }
          ++v33;
        }
        v47 = v74;
        if ( v19 != v74 )
        {
          v48 = 0;
          v75 = 0;
          if ( v5 >= 4 )
          {
            v49 = *(_DWORD *)(v4 + 4 * v74);
            v50 = *(_DWORD *)v77;
            v51 = v49 + 24;
            i = v49 - *(_DWORD *)v77;
            v52 = v50 + 8;
            v53 = ((unsigned int)(a2 - 4) >> 2) + 1;
            v75 = 4 * v53;
            v54 = i;
            do
            {
              v55 = *(double *)(v51 - 24);
              v52 += 32;
              v51 += 32;
              --v53;
              *(double *)(v51 - 56) = *(double *)(v52 - 40);
              *(_QWORD *)(v52 - 40) = *(_QWORD *)&v55;
              v56 = *(double *)(v54 + v52 - 32);
              *(double *)(v54 + v52 - 32) = *(double *)(v52 - 32);
              *(_QWORD *)(v52 - 32) = *(_QWORD *)&v56;
              v57 = *(double *)(v51 - 40);
              *(double *)(v51 - 40) = *(double *)(v52 - 24);
              *(_QWORD *)(v52 - 24) = *(_QWORD *)&v57;
              v58 = *(double *)(v51 - 32);
              *(double *)(v51 - 32) = *(double *)(v52 - 16);
              *(_QWORD *)(v52 - 16) = *(_QWORD *)&v58;
            }
            while ( v53 );
            v47 = v74;
            v5 = a2;
            v48 = v75;
          }
          if ( v48 < v5 )
          {
            v59 = *(_DWORD *)(v4 + 4 * v47) - *(_DWORD *)v77;
            v60 = *(_DWORD *)v77 + 8 * v48;
            v61 = v5 - v75;
            i = v59;
            do
            {
              v62 = *(double *)(v59 + v60);
              v60 += 8;
              --v61;
              *(double *)(v59 + v60 - 8) = *(double *)(v60 - 8);
              *(_QWORD *)(v60 - 8) = *(_QWORD *)&v62;
            }
            while ( v61 );
            v47 = v74;
          }
          *(double *)a4 = -*(double *)a4;
          *(double *)(v76 + 8 * v47) = *(double *)(v76 + 8 * v19);
        }
        v63 = v77;
        *(_DWORD *)(v77 + v72) = v47;
        v64 = *(_DWORD *)v63 + 8 * v19;
        if ( 0.0 == *(double *)v64 )
          *(double *)v64 = 9.999999999999999e-21;
        if ( v19 != v5 - 1 )
        {
          v65 = v19 + 1;
          v66 = 1.0 / *(double *)v64;
          if ( v19 + 1 < v5 )
          {
            if ( v73 >= 4 )
            {
              v67 = v77 + 12;
              v68 = ((unsigned int)(v5 - v65 - 4) >> 2) + 1;
              v65 += 4 * v68;
              do
              {
                v69 = *(_DWORD *)(v67 - 8);
                v67 += 16;
                --v68;
                *(double *)(v69 + 8 * v19) = *(double *)(v69 + 8 * v19) * v66;
                *(double *)(*(_DWORD *)(v67 - 20) + 8 * v19) = *(double *)(*(_DWORD *)(v67 - 20) + 8 * v19) * v66;
                *(double *)(*(_DWORD *)(v67 - 16) + 8 * v19) = *(double *)(*(_DWORD *)(v67 - 16) + 8 * v19) * v66;
                *(double *)(*(_DWORD *)(v67 - 12) + 8 * v19) = *(double *)(*(_DWORD *)(v67 - 12) + 8 * v19) * v66;
              }
              while ( v68 );
              v5 = a2;
            }
            for ( ; v65 < v5; *(double *)(v70 + 8 * v19) = *(double *)(v70 + 8 * v19) * v66 )
              v70 = *(_DWORD *)(v4 + 4 * v65++);
          }
        }
        --v73;
        v77 += 4;
        ++v19;
      }
      while ( v19 < v5 );
    }
    UF_free(v76);
    result = 0;
  }
  else
  {
    while ( 1 )
    {
      v7 = 0;
      v8 = 0.0;
      if ( a2 >= 4 )
      {
        v9 = *(_DWORD *)(a1 + 4 * i) + 16;
        v10 = ((unsigned int)(a2 - 4) >> 2) + 1;
        v7 = 4 * v10;
        do
        {
          v11 = fabs(*(double *)(v9 - 16));
          if ( v11 > v8 )
            v8 = v11;
          v12 = fabs(*(double *)(v9 - 8));
          if ( v12 > v8 )
            v8 = v12;
          v13 = fabs(*(double *)v9);
          if ( v13 > v8 )
            v8 = v13;
          v14 = fabs(*(double *)(v9 + 8));
          if ( v14 > v8 )
            v8 = v14;
          v9 += 32;
          --v10;
        }
        while ( v10 );
      }
      if ( v7 < a2 )
      {
        v15 = (long double *)(*(_DWORD *)(a1 + 4 * i) + 8 * v7);
        v16 = a2 - v7;
        do
        {
          v17 = fabs(*v15);
          if ( v17 > v8 )
            v8 = v17;
          ++v15;
          --v16;
        }
        while ( v16 );
      }
      if ( 0.0 == v8 )
        break;
      v18 = i + 1;
      i = v18;
      *(double *)(v76 + 8 * v18 - 8) = 1.0 / v8;
      if ( v18 >= a2 )
        goto LABEL_20;
    }
    UF_free(v76);
    result = 1;
  }
  return result;
}
// 100090E4: using guessed type int __cdecl UF_allocate_memory(_DWORD, _DWORD);
// 100090E8: using guessed type int __cdecl UF_free(_DWORD);

//----- (10002C80) --------------------------------------------------------
int __fastcall sub_10002C80(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax@1
  int v6; // esi@1
  int v7; // edi@1
  int v8; // ebx@2
  int v9; // eax@2
  int v10; // eax@4
  double v11; // st6@4
  int v12; // eax@5
  int v13; // eax@7
  int v14; // esi@7
  int v15; // ecx@7
  unsigned int v16; // eax@7
  double v17; // st5@8
  double v18; // st5@8
  int v19; // ecx@11
  int v20; // esi@11
  int v21; // eax@11
  double v22; // st5@12
  int v23; // edi@17
  int v24; // ebx@18
  int v25; // esi@18
  int v26; // ecx@19
  double v27; // st7@19
  int v28; // eax@21
  int v29; // ecx@21
  int v30; // esi@21
  unsigned int v31; // eax@21
  int v32; // ecx@21
  double v33; // st6@22
  double v34; // st6@22
  int v35; // ecx@25
  int v36; // eax@25
  double v37; // st6@26
  double v38; // st7@28
  int v39; // [sp+Ch] [bp-18h]@7
  int v40; // [sp+Ch] [bp-18h]@18
  int v41; // [sp+10h] [bp-14h]@21
  int v42; // [sp+14h] [bp-10h]@0
  int v43; // [sp+14h] [bp-10h]@18
  signed int v44; // [sp+18h] [bp-Ch]@1
  int v45; // [sp+18h] [bp-Ch]@18
  int v46; // [sp+1Ch] [bp-8h]@2
  int v47; // [sp+1Ch] [bp-8h]@18
  int v48; // [sp+20h] [bp-4h]@5
  int v49; // [sp+20h] [bp-4h]@19

  result = a4;
  v6 = a3;
  v7 = 0;
  v44 = 0;
  if ( a4 > 0 )
  {
    v8 = v42;
    v9 = a5 - a3;
    v46 = a3;
    while ( 1 )
    {
      v10 = *(_DWORD *)(v6 + v9);
      v11 = *(double *)(a2 + 8 * v10);
      *(double *)(a2 + 8 * v10) = *(double *)(a2 + 8 * v7);
      if ( v44 )
      {
        v12 = v8;
        v48 = v8;
        if ( v8 < v7 )
        {
          if ( v7 - v8 >= 4 )
          {
            v13 = *(_DWORD *)v6;
            v14 = *(_DWORD *)v6 + 8 * v8 + 24;
            v39 = v13 - a2;
            v15 = a2 + 8 * v8 + 8;
            v16 = ((unsigned int)(v7 - v8 - 4) >> 2) + 1;
            v48 = v8 + 4 * v16;
            do
            {
              v17 = *(double *)(v15 - 8);
              v15 += 32;
              v18 = v17 * *(double *)(v14 - 24);
              v14 += 32;
              --v16;
              v11 = v11
                  - v18
                  - *(double *)(v15 + v39 - 32) * *(double *)(v15 - 32)
                  - *(double *)(v15 - 24) * *(double *)(v14 - 40)
                  - *(double *)(v15 - 16) * *(double *)(v14 - 32);
            }
            while ( v16 );
            v6 = v46;
            v8 = v42;
            v12 = v48;
          }
          if ( v12 < v7 )
          {
            v19 = *(_DWORD *)v6 - a2;
            v20 = v7 - v48;
            v21 = a2 + 8 * v12;
            do
            {
              v22 = *(double *)(v21 + v19);
              v21 += 8;
              --v20;
              v11 = v11 - v22 * *(double *)(v21 - 8);
            }
            while ( v20 );
            v6 = v46;
          }
        }
      }
      else
      {
        if ( 0.0 != v11 )
        {
          v8 = v7;
          v44 = 1;
          v42 = v7;
        }
      }
      result = a4;
      *(_QWORD *)(a2 + 8 * v7++) = *(_QWORD *)&v11;
      v6 += 4;
      v46 = v6;
      if ( v7 >= a4 )
        break;
      v9 = a5 - a3;
    }
  }
  v23 = result - 1;
  if ( result - 1 >= 0 )
  {
    result = result - v23 - 1;
    v24 = v23 + 1;
    v25 = a2 + 8 * v23;
    v43 = v23 + 1;
    v45 = a2 + 8 * v23;
    v47 = result;
    v40 = 32 - a2;
    do
    {
      v26 = a4;
      v27 = *(double *)v25;
      v49 = v24;
      if ( v24 < a4 )
      {
        if ( result >= 4 )
        {
          v28 = *(_DWORD *)(a3 + 4 * v23);
          v29 = v25 + v40;
          v30 = v25 + v40 + v28;
          v41 = v28 - a2;
          v31 = ((unsigned int)(a4 - v24 - 4) >> 2) + 1;
          v49 = v24 + 4 * v31;
          v32 = v29 + a2 - 16;
          do
          {
            v33 = *(double *)(v32 - 8);
            v32 += 32;
            v34 = v33 * *(double *)(v30 - 24);
            v30 += 32;
            --v31;
            v27 = v27
                - v34
                - *(double *)(v41 + v32 - 32) * *(double *)(v32 - 32)
                - *(double *)(v32 - 24) * *(double *)(v30 - 40)
                - *(double *)(v32 - 16) * *(double *)(v30 - 32);
          }
          while ( v31 );
          v24 = v43;
          v25 = v45;
          result = v47;
          v26 = a4;
        }
        if ( v49 < v26 )
        {
          v35 = v26 - v49;
          v36 = a2 + 8 * v49;
          do
          {
            v37 = *(double *)(*(_DWORD *)(a3 + 4 * v23) - a2 + v36);
            v36 += 8;
            --v35;
            v27 = v27 - v37 * *(double *)(v36 - 8);
          }
          while ( v35 );
          v25 = v45;
          result = v47;
        }
      }
      v38 = v27 / *(double *)(*(_DWORD *)(a3 + 4 * v23) + 8 * v23);
      ++result;
      --v24;
      v25 -= 8;
      --v23;
      v47 = result;
      v43 = v24;
      v45 = v25;
      *(_QWORD *)(v25 + 8) = *(_QWORD *)&v38;
    }
    while ( v23 >= 0 );
  }
  return result;
}

//----- (10002E80) --------------------------------------------------------
signed int __usercall sub_10002E80<eax>(int a1<eax>, int a2)
{
  double v2; // st7@1
  signed int result; // eax@1
  signed int v4; // edi@2
  int v5; // esi@2
  char v6; // [sp+0h] [bp-C8h]@1
  char v7; // [sp+10h] [bp-B8h]@1
  double v8; // [sp+18h] [bp-B0h]@1
  double v9; // [sp+20h] [bp-A8h]@1
  double v10; // [sp+28h] [bp-A0h]@1
  double v11; // [sp+30h] [bp-98h]@1
  double v12; // [sp+38h] [bp-90h]@1
  double v13; // [sp+40h] [bp-88h]@1
  double v14; // [sp+48h] [bp-80h]@1
  double v15; // [sp+50h] [bp-78h]@1
  double v16; // [sp+58h] [bp-70h]@1
  double v17; // [sp+60h] [bp-68h]@1
  double v18; // [sp+68h] [bp-60h]@1
  double v19; // [sp+70h] [bp-58h]@1
  double v20; // [sp+78h] [bp-50h]@1
  double v21; // [sp+80h] [bp-48h]@1
  double v22; // [sp+88h] [bp-40h]@1
  double v23; // [sp+90h] [bp-38h]@1
  double *v24; // [sp+98h] [bp-30h]@1
  double *v25; // [sp+9Ch] [bp-2Ch]@1
  double *v26; // [sp+A0h] [bp-28h]@1
  double *v27; // [sp+A4h] [bp-24h]@1
  double v28; // [sp+A8h] [bp-20h]@3
  double v29; // [sp+B0h] [bp-18h]@3
  double v30; // [sp+B8h] [bp-10h]@3
  double v31; // [sp+C0h] [bp-8h]@3

  v20 = *(double *)a1;
  v25 = &v16;
  v16 = *(double *)(a1 + 32);
  v8 = *(double *)(a1 + 64);
  v26 = &v8;
  v12 = *(double *)(a1 + 96);
  v21 = *(double *)(a1 + 8);
  v17 = *(double *)(a1 + 40);
  v9 = *(double *)(a1 + 72);
  v13 = *(double *)(a1 + 104);
  v22 = *(double *)(a1 + 16);
  v18 = *(double *)(a1 + 48);
  v10 = *(double *)(a1 + 80);
  v14 = *(double *)(a1 + 112);
  v23 = *(double *)(a1 + 24);
  v19 = *(double *)(a1 + 56);
  v11 = *(double *)(a1 + 88);
  v2 = *(double *)(a1 + 120);
  v24 = &v20;
  v15 = v2;
  v27 = &v12;
  result = sub_10002840((int)&v24, 4, (int)&v6, (int)&v7);
  if ( !result )
  {
    v4 = 0;
    v5 = a2 + 64;
    do
    {
      v28 = 0.0;
      v29 = 0.0;
      v30 = 0.0;
      v31 = 0.0;
      *(&v28 + v4) = 1.0;
      result = sub_10002C80((int)&v6, (int)&v28, (int)&v24, 4, (int)&v6);
      *(_QWORD *)(v5 - 64) = *(_QWORD *)&v28;
      ++v4;
      *(_QWORD *)(v5 - 32) = *(_QWORD *)&v29;
      v5 += 8;
      *(_QWORD *)(v5 - 8) = *(_QWORD *)&v30;
      *(_QWORD *)(v5 + 24) = *(_QWORD *)&v31;
    }
    while ( v4 < 4 );
  }
  return result;
}

//----- (10002FB0) --------------------------------------------------------
int __usercall sub_10002FB0<eax>(int _ECX<ecx>, unsigned int a2<ebx>, unsigned int a3<esi>, int a4, int a5)
{
  double v8; // ST08_8@5
  double v9; // ST00_8@5
  __int64 v10; // ST04_8@5
  __int64 v11; // ST08_8@5
  double v15; // ST08_8@9
  double v16; // ST00_8@9
  __int64 v17; // ST04_8@9
  __int64 v18; // ST08_8@9
  int result; // eax@12
  unsigned __int64 v20; // [sp+18h] [bp-E4h]@2
  double Base; // [sp+20h] [bp-DCh]@8
  double v34; // [sp+B0h] [bp-4Ch]@1
  char v39; // [sp+D8h] [bp-24h]@5
  char v40; // [sp+E0h] [bp-1Ch]@5
  int v41; // [sp+F8h] [bp-4h]@5

  __asm { fldz }
  _EAX = a5;
  __asm
  {
    fst     [ebp+var_4C]
    fstp    [ebp+var_44]
    fld1
    fstp    [ebp+var_3C]
    fld     qword ptr [eax]
    fld     qword ptr [eax+8]
    fld     qword ptr [ecx]
    fst     [ebp+var_34]
    fld     qword ptr [ecx+8]
    fst     [ebp+var_2C]
    fxch    st(3)
    fst     [ebp+var_AC]
    fld     st
    fld     ds:dbl_100099C8
    fmul    st(1), st
    fxch    st(1)
    fst     [ebp+var_A4]
    fld     st(2)
    fld     ds:dbl_100099C0
    fadd    st(1), st
    fxch    st(1)
    fstp    [ebp+var_9C]
    fld     st
    fsubrp  st(4), st
    fxch    st(3)
    fstp    [ebp+var_94]
    fld     st(2)
    fsub    st, st(1)
    fstp    [ebp+var_8C]
    fadd    st, st(2)
    fstp    [ebp+var_84]
    fxch    st(3)
    fst     [ebp+var_7C]
    fld     st
    fmul    st, st(4)
    fst     [ebp+var_74]
    fld     st(1)
    fadd    st, st(3)
    fstp    [ebp+var_6C]
    fld     st(2)
    fsubrp  st(2), st
    fxch    st(1)
    fstp    [ebp+var_64]
    fld     st(1)
    fsub    st, st(1)
    fstp    [ebp+var_5C]
    faddp   st(1), st
    fstp    [ebp+var_54]
    fld     st
    fsub    st, st(3)
    fabs
    fcomp   dbl_1000C000
    fnstsw  ax
  }
  if ( __SETP__(BYTE1(_EAX) & 0x41, 0) )
  {
    __asm { fstp    st(2) }
    v20 = __PAIR__(a2, a3);
    __asm { fstp    st }
    _EBX = 0;
    _EDI = 0;
  }
  else
  {
    __asm
    {
      fxch    st(2)
      fmulp   st(1), st
    }
    v20 = __PAIR__(a2, a3);
    _EBX = 0;
    __asm { fstp    qword ptr [ecx+8] }
    _EDI = 0;
  }
  while ( 1 )
  {
    __asm
    {
      fstp    [esp+0FCh+var_F4]
      fld     [ebp+edi*8+var_AC]
      fstp    [esp+0FCh+var_FC]
    }
    sub_10002190(a4, (int)&v40, v9, v8, 0);
    __asm
    {
      fld     dbl_1000C000
      fstp    [esp+0F8h+var_FC+4]
    }
    UF_VEC3_unitize(&v40, v10, HIDWORD(v10), &v39, &v40);
    __asm
    {
      fld     dbl_1000C000
      fstp    [esp+0F4h+var_F4]
    }
    UF_VEC3_is_equal(&v34, &v40, v11, HIDWORD(v11), &v41);
    if ( v41 )
    {
      __asm { fld     [ebp+edi*8+var_AC] }
      ++_EBX;
      __asm { fstp    [ebp+ebx*8+var_E4] }
    }
    ++_EDI;
    if ( _EDI >= 6 )
      break;
    __asm { fld     [ebp+var_34] }
  }
  qsort(&Base, _EBX - 1, 8u, (int (__cdecl *)(const void *, const void *))PtFuncCompare);
  __asm { fld     [ebp+Base] }
  _ECX = a5;
  __asm { fstp    qword ptr [ecx] }
  _EBX = 0;
  _EDI = 0;
  do
  {
    __asm
    {
      fld     [ebp+var_2C]
      fstp    [esp+0FCh+var_F4]
      fld     [ebp+edi*8+var_7C]
      fstp    [esp+0FCh+var_FC]
    }
    sub_10002190(a4, (int)&v40, v16, v15, 0);
    __asm
    {
      fld     dbl_1000C000
      fstp    [esp+0F8h+var_FC+4]
    }
    UF_VEC3_unitize(&v40, v17, HIDWORD(v17), &v39, &v40);
    __asm
    {
      fld     dbl_1000C000
      fstp    [esp+0F4h+var_F4]
    }
    UF_VEC3_is_equal(&v34, &v40, v18, HIDWORD(v18), &v41);
    if ( v41 )
    {
      __asm { fld     [ebp+edi*8+var_7C] }
      ++_EBX;
      __asm { fstp    [ebp+ebx*8+var_E4] }
    }
    ++_EDI;
  }
  while ( _EDI < 6 );
  qsort(&Base, _EBX - 1, 8u, (int (__cdecl *)(const void *, const void *))PtFuncCompare);
  __asm { fld     [ebp+Base] }
  result = a5;
  __asm { fstp    qword ptr [eax+8] }
  return result;
}
// 10002FB9: inconsistent fpu stack
// 10002FB0: could not find valid save-restore pair for ebx
// 10002FB0: could not find valid save-restore pair for esi
// 100090E0: using guessed type int __cdecl UF_VEC3_is_equal(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10009128: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (100031D0) --------------------------------------------------------
signed int __cdecl sub_100031D0(const void *a1, int a2, int a3)
{
  bool v3; // zf@1
  __int64 v7; // ST2C_8@2
  __int64 v8; // ST24_8@2
  __int64 v9; // ST1C_8@2
  __int64 v10; // ST14_8@2
  __int64 v11; // ST0C_8@2
  __int64 v12; // ST04_8@2
  __int64 v13; // ST28_8@6
  signed int result; // eax@7
  __int64 v15; // ST24_8@8
  unsigned int v16; // esi@8
  int v17; // ecx@8
  long double v18; // ST2C_8@10
  long double v20; // ST2C_8@11
  long double v25; // ST2C_8@21
  __int64 v34; // ST2C_8@46
  __int64 v35; // ST24_8@46
  __int64 v36; // ST1C_8@46
  __int64 v37; // ST14_8@46
  __int64 v38; // ST0C_8@46
  __int64 v39; // ST04_8@46
  __int64 v40; // ST2C_8@46
  int v47; // eax@71
  int v49; // eax@72
  int v50; // ecx@72
  int v51; // edx@72
  int v52; // esi@72
  int v53; // esi@72
  int v54; // eax@72
  __int64 v55; // ST2C_8@76
  __int64 v56; // ST24_8@76
  __int64 v57; // ST1C_8@76
  __int64 v58; // ST14_8@76
  __int64 v59; // ST2C_8@76
  __int64 v60; // ST24_8@76
  __int64 v61; // ST1C_8@76
  __int64 v62; // ST14_8@76
  double v63; // ST28_8@78
  double v64; // ST20_8@78
  double v65; // ST28_8@78
  double v66; // ST20_8@78
  double v67; // ST28_8@80
  double v68; // ST28_8@80
  signed int v69; // esi@81
  int v70; // eax@82
  int v72; // eax@87
  __int64 v73; // ST24_8@88
  __int64 v74; // ST24_8@88
  double v75; // ST28_8@88
  double v76; // ST28_8@88
  double v77; // ST28_8@90
  __int64 v78; // ST24_8@90
  void (__cdecl *v80)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // esi@90
  __int64 v81; // ST24_8@90
  double v83; // ST28_8@92
  double v84; // ST20_8@92
  double v85; // ST28_8@92
  double v86; // ST20_8@92
  __int64 v87; // ST24_8@92
  __int64 v88; // ST24_8@92
  __int64 v90; // ST24_8@92
  __int64 v92; // ST24_8@93
  int *v97; // [sp+28h] [bp-DCh]@90
  int v98; // [sp+2Ch] [bp-D8h]@90
  int v99; // [sp+3Ch] [bp-C8h]@4
  int v100; // [sp+40h] [bp-C4h]@72
  int v101; // [sp+44h] [bp-C0h]@72
  int v102; // [sp+48h] [bp-BCh]@72
  int v103; // [sp+4Ch] [bp-B8h]@72
  int v104; // [sp+50h] [bp-B4h]@72
  char v105; // [sp+54h] [bp-B0h]@4
  char v107; // [sp+74h] [bp-90h]@8
  char v109; // [sp+84h] [bp-80h]@92
  double v110; // [sp+8Ch] [bp-78h]@78
  int v112[2]; // [sp+9Ch] [bp-68h]@8
  int v116; // [sp+BCh] [bp-48h]@90
  double v117; // [sp+C4h] [bp-40h]@78
  int v119; // [sp+D4h] [bp-30h]@1
  double v121; // [sp+E0h] [bp-24h]@14
  double v123; // [sp+F0h] [bp-14h]@10
  char v125; // [sp+103h] [bp-1h]@1

  v3 = byte_1000C590 == 0;
  __asm { fldz }
  _EAX = a2;
  _EBX = a3;
  __asm
  {
    fst     qword ptr [ebx]
    fst     qword ptr [eax]
    fst     qword ptr [ebx+8]
  }
  _EDI = a1;
  __asm
  {
    fst     qword ptr [eax+8]
    fst     qword ptr [ebx+10h]
  }
  v125 = 0;
  __asm { fst     qword ptr [eax+10h] }
  v119 = 0;
  __asm
  {
    fst     qword ptr [ebx+18h]
    fst     qword ptr [eax+18h]
    fst     qword ptr [ebx+20h]
    fstp    qword ptr [eax+20h]
  }
  if ( !v3 )
  {
    printf("\n------------------------------------------------------\n");
    __asm
    {
      fld     qword ptr [edi+28h]
      fstp    qword ptr [esp+104h+var_DC]
      fld     qword ptr [edi+20h]
      fstp    [esp+104h+var_E4]
      fld     qword ptr [edi+18h]
      fstp    [esp+104h+var_EC]
      fld     qword ptr [edi+10h]
      fstp    [esp+104h+var_F4]
      fld     qword ptr [edi+8]
      fstp    [esp+104h+var_FC]
      fld     qword ptr [edi]
      fstp    [esp+104h+var_104]
    }
    printf("Starting old_pcoord_t[] = (%f,%f,%f,%f,%f,%f)\n", v12, v11, v10, v9, v8, v7);
  }
  if ( dword_1000C2C0 == 3 )
  {
    UF_MTX3_vec_multiply_t(a1, &unk_10009970, &v99);
    UF_MTX3_vec_multiply_t((char *)a1 + 24, &unk_10009970, &v105);
  }
  else
  {
    memcpy(&v99, a1, 0x30u);
    _EDI = a1;
  }
  __asm
  {
    fld     dbl_1000C000
    fstp    [esp+0E0h+var_E4+4]
  }
  UF_VEC3_is_zero(&v105, v13, HIDWORD(v13), &a3);
  if ( a3 )
    return 4;
  __asm
  {
    fld     dbl_1000C000
    fstp    [esp+0E4h+var_E4]
  }
  UF_VEC3_unitize(&v105, v15, HIDWORD(v15), &v107, v112);
  __asm { fld     qword ptr [ebp+var_68] }
  v16 = dword_1000C2C4;
  __asm
  {
    fst     [ebp+var_88]
    fld     [ebp+var_60]
  }
  v17 = *(_DWORD *)dword_1000C2C4;
  __asm
  {
    fst     [ebp+var_98]
    fld     [ebp+var_58]
    fst     [ebp+var_70]
  }
  if ( v17 != 3 )
  {
    __asm
    {
      fld     dbl_1000C378
      fmul    st, st(2)
      fld     dbl_1000C358
      fmul    st, st(4)
      faddp   st(1), st
      fld     dbl_1000C398
      fmul    st, st(2)
      faddp   st(1), st
      fld     dbl_1000C380
      fmul    st, st(3)
      fld     dbl_1000C360
      fmul    st, st(5)
      faddp   st(1), st
      fld     dbl_1000C3A0
      fmul    st, st(3)
      faddp   st(1), st
      fmul    dbl_1000C568
      fsubp   st(1), st
      fld     dbl_1000C558
      fmul    st(1), st
      fxch    st(1)
      fstp    [ebp+var_2C]
      fld     dbl_1000C368
      fmul    st, st(3)
      fld     dbl_1000C348
      fmul    st, st(5)
      faddp   st(1), st
      fld     dbl_1000C388
      fmul    st, st(3)
      faddp   st(1), st
      fld     dbl_1000C370
      fmulp   st(4), st
      fld     dbl_1000C350
      fmulp   st(5), st
      fxch    st(3)
      faddp   st(4), st
      fld     dbl_1000C390
      fmulp   st(2), st
      fxch    st(3)
      faddp   st(1), st
      fld     dbl_1000C550
      fld     st
      fabs
      fld     dbl_1000C000
      fcom    st(1)
      fnstsw  ax
      fstp    st(1)
    }
    if ( HIBYTE(_AX) & 1 )
    {
      if ( v17 == 1 )
      {
        __asm { fld     dbl_1000C548 }
      }
      else
      {
        if ( v17 == 2 )
          __asm { fld     dbl_1000C548 }
        else
          __asm { fld     [ebp+var_38] }
      }
      __asm
      {
        fsub    [ebp+var_2C]
        fdiv    st, st(2)
        fstp    [ebp+var_2C]
        fldz
      }
    }
    else
    {
      __asm { fldz }
      v125 = 1;
      __asm { fst     [ebp+var_2C] }
    }
    __asm
    {
      fld     st(3)
      fmul    st, st(4)
      fld     st(5)
      fmul    st, st(6)
      faddp   st(1), st
      fsqrt
      fld     st(5)
      fabs
      fcomp   st(3)
      fnstsw  ax
    }
    if ( __SETP__(HIBYTE(_AX) & 0x41, 0) )
      goto LABEL_115;
    __asm
    {
      fld     st(4)
      fabs
      fcomp   st(3)
      fnstsw  ax
    }
    if ( __SETP__(HIBYTE(_AX) & 0x41, 0) )
    {
LABEL_115:
      __asm
      {
        fxch    st(5)
        fxch    st(1)
        fxch    st(4)
        fxch    st(1)
        fpatan
        fstp    [ebp+var_50]
        fxch    st(3)
        fxch    st(2)
      }
    }
    else
    {
      __asm
      {
        fstp    st(4)
        fstp    st(4)
        fxch    st(3)
        fst     [ebp+var_50]
      }
    }
    __asm
    {
      fld     st(2)
      fabs
      fcomp   st(4)
      fnstsw  ax
    }
    if ( __SETP__(HIBYTE(_AX) & 0x41, 0) )
    {
      __asm
      {
        fld     [ebp+var_2C]
        fdivrp  st(3), st
        fxch    st(2)
      }
    }
    else
    {
      __asm
      {
        fstp    st(2)
        fld     st(1)
      }
    }
    __asm
    {
      fst     [ebp+var_2C]
      fld     st
      fabs
      fld     st(4)
      fld1
      fadd    st(1), st
      fxch    st(2)
      fcompp
      fnstsw  ax
    }
    if ( HIBYTE(_AX) & 0x41 )
    {
      __asm
      {
        fld     st(1)
        fmul    st, st(2)
        fsubr   st, st(1)
        fld     st
        fabs
        fcomp   st(6)
        fnstsw  ax
      }
      if ( !__SETP__(HIBYTE(_AX) & 0x41, 0) )
      {
        __asm
        {
          fstp    st
          fld     st(3)
        }
      }
      __asm
      {
        fld     st(2)
        fsubrp  st(2), st
        fxch    st(1)
        fabs
        fcomp   st(5)
        fnstsw  ax
      }
      if ( __SETP__(HIBYTE(_AX) & 0x41, 0) )
      {
        __asm { fsqrt }
      }
      else
      {
        __asm
        {
          fstp    st
          fld     st(2)
        }
      }
      __asm { fld     st }
      _ECX = 0;
      __asm
      {
        fld     st(2)
        fxch    st(1)
        fpatan
        fadd    [ebp+var_50]
        fstp    [ebp+var_14]
        fchs
        fpatan
        fadd    [ebp+var_50]
        fstp    [ebp+var_C]
        fld     dbl_1000C540
        fabs
        fstp    [ebp+var_2C]
      }
    }
    else
    {
      __asm
      {
        fstp    st(1)
        fstp    st(2)
        fstp    st
        fstp    st(2)
        fstp    st
        fstp    st
        fld     qword ptr [edi+28h]
        fstp    qword ptr [esp+104h+var_DC]
        fld     qword ptr [edi+20h]
        fstp    [esp+104h+var_E4]
        fld     qword ptr [edi+18h]
        fstp    [esp+104h+var_EC]
        fld     qword ptr [edi+10h]
        fstp    [esp+104h+var_F4]
        fld     qword ptr [edi+8]
        fstp    [esp+104h+var_FC]
        fld     qword ptr [edi]
        fstp    [esp+104h+var_104]
      }
      printf("INPUT Point =%-.4f,%-.4f,%-.4f,%-.8f,%-.8f,%-.8f\n", v39, v38, v37, v36, v35, v34);
      __asm
      {
        fld     [ebp+var_2C]
        fstp    qword ptr [esp+0DCh+var_DC]
      }
      printf("WARNING: Degenerated G_lambda(%f) out of range (-1, 1)\n", v40);
      __asm
      {
        fldz
        fst     [ebp+var_C]
        fst     [ebp+var_14]
      }
      v125 = 1;
      __asm { fld     dbl_1000C000 }
      _ECX = 0;
      __asm
      {
        fld     dbl_1000C558
        fld     dbl_1000C550
        fxch    st(1)
        fxch    st(3)
        fxch    st(1)
        fld     dbl_1000C540
        fabs
        fstp    [ebp+var_2C]
      }
    }
    while ( 1 )
    {
      __asm
      {
        fld     [ebp+ecx+var_14]
        fsin
        fld     [ebp+ecx+var_14]
        fcos
        fxch    st(4)
        fcom    [ebp+var_2C]
        fnstsw  ax
      }
      if ( HIBYTE(_AX) & 1 )
      {
        __asm
        {
          fstp    st(3)
          fstp    st(2)
          fld     st(1)
          fmul    st, st(4)
          fchs
          fld     st(3)
          fmulp   st(5), st
          fxch    st(1)
          fmul    dbl_1000C568
          fchs
          fstp    [ebp+var_50]
          fld     st(1)
          fmul    dbl_1000C370
          fld     st(3)
          fmul    dbl_1000C368
          faddp   st(1), st
          fld     dbl_1000C560
          fmul    dbl_1000C380
          fsubp   st(1), st
          fmul    [ebp+var_98]
          fld     st(2)
          fmul    dbl_1000C350
          fld     st(4)
          fmul    dbl_1000C348
          faddp   st(1), st
          fld     dbl_1000C560
          fmul    dbl_1000C360
          fsubp   st(1), st
          fmul    [ebp+var_88]
          faddp   st(1), st
          fxch    st(2)
          fmul    dbl_1000C390
          fxch    st(3)
          fmul    dbl_1000C388
          faddp   st(3), st
          fld     dbl_1000C560
          fmul    dbl_1000C3A0
          fsubp   st(3), st
          fxch    st(2)
          fmul    [ebp+var_70]
          faddp   st(1), st
          fdiv    dbl_1000C540
          fstp    [ebp+var_38]
          fld     st(1)
          fmul    dbl_1000C370
          fld     st(1)
          fmul    dbl_1000C368
          faddp   st(1), st
          fld     dbl_1000C550
          fld     dbl_1000C378
          fmul    st, st(1)
          faddp   st(2), st
          fld     [ebp+var_50]
          fld     dbl_1000C380
          fmul    st, st(1)
          faddp   st(3), st
          fxch    st(2)
          fmul    [ebp+var_98]
          fld     st(4)
          fmul    dbl_1000C350
          fld     st(4)
          fmul    dbl_1000C348
          faddp   st(1), st
          fld     st(2)
          fmul    dbl_1000C358
          faddp   st(1), st
          fld     st(3)
          fmul    dbl_1000C360
          faddp   st(1), st
          fmul    [ebp+var_88]
          faddp   st(1), st
          fxch    st(4)
          fmul    dbl_1000C390
          fxch    st(3)
          fmul    dbl_1000C388
          faddp   st(3), st
          fld     dbl_1000C398
          fmul    st, st(1)
          faddp   st(3), st
          fxch    st(1)
          fmul    dbl_1000C3A0
          faddp   st(2), st
          fxch    st(1)
          fmul    [ebp+var_70]
          faddp   st(2), st
          fxch    st(1)
          fdiv    dbl_1000C540
          fchs
          fldz
          fld     dbl_1000C000
          fld     [ebp+var_38]
          fld     dbl_1000C558
          fxch    st(5)
          fxch    st(2)
          fxch    st(4)
          fxch    st(1)
        }
      }
      else
      {
        __asm
        {
          fstp    st(4)
          fstp    st
          fld     st(1)
          fld     st(2)
        }
      }
      __asm
      {
        fld     st
        fabs
        fcomp   st(5)
        fnstsw  ax
      }
      if ( __SETP__(HIBYTE(_AX) & 0x41, 0) )
        goto LABEL_117;
      __asm
      {
        fld     st(1)
        fabs
        fcomp   st(5)
        fnstsw  ax
      }
      if ( __SETP__(HIBYTE(_AX) & 0x41, 0) )
      {
LABEL_117:
        __asm
        {
          fxch    st(1)
          fpatan
          fstp    [ebp+ecx+var_24]
          fxch    st(1)
        }
      }
      else
      {
        __asm { fstp    st(1) }
        v125 = 1;
        __asm
        {
          fstp    st
          fxch    st(1)
          fst     [ebp+ecx+var_24]
        }
      }
      _ECX += 8;
      if ( _ECX >= 16 )
        break;
      __asm { fxch    st(1) }
    }
    v16 = dword_1000C2C4;
    __asm
    {
      fstp    st
      fstp    st
      fstp    st(1)
    }
    goto LABEL_63;
  }
  if ( dword_1000C2C0 )
  {
    if ( dword_1000C2C0 != 1 && dword_1000C2C0 != 3 )
    {
      __asm
      {
        fstp    st
        fstp    st
        fstp    st
      }
      return 2;
    }
    __asm
    {
      fld     dbl_1000C320
      fld     st
      fld1
      fsub    st(1), st
      fxch    st(1)
      fabs
      fld     dbl_1000C000
      fcom    st(1)
      fnstsw  ax
      fstp    st(1)
    }
    if ( !(HIBYTE(_AX) & 1) )
      goto LABEL_116;
    __asm
    {
      fld     st(2)
      fmul    st, st(3)
      fsub    st(4), st
      fsubr   st, st(2)
      fdivp   st(4), st
      fld     st(3)
      fabs
      fld     st(1)
      fadd    st, st(3)
      fcompp
      fnstsw  ax
    }
    if ( __SETP__(HIBYTE(_AX) & 5, 0) )
    {
      __asm
      {
        fstp    st(4)
        fstp    st(4)
        fstp    st
        fstp    st(2)
        fstp    st
        fstp    qword ptr [esp+0DCh+var_DC]
      }
      sub_10001F90(v25);
      __asm
      {
        fst     [ebp+var_14]
        fchs
        fstp    [ebp+var_C]
        fld     [ebp+var_60]
        fld     qword ptr [ebp+var_68]
        fld     dbl_1000C000
        fld     dbl_1000C320
        fld1
        fxch    st(3)
        fxch    st(4)
        fxch    st(3)
      }
    }
    else
    {
LABEL_116:
      __asm { fstp    st(3) }
      v125 = 1;
      __asm
      {
        fld     dbl_1000C260
        fstp    [ebp+var_14]
        fld     dbl_1000C268
        fstp    [ebp+var_C]
      }
    }
    __asm { fld     st(1) }
    _ECX = 0;
    __asm
    {
      fmul    dbl_1000C310
      fstp    [ebp+var_70]
      fxch    st(1)
      fmul    dbl_1000C318
      fstp    [ebp+var_88]
    }
    do
    {
      __asm
      {
        fld     [ebp+ecx+var_14]
        fsin
        fld     [ebp+ecx+var_14]
        fcos
        fsubr   st, st(2)
        fld     [ebp+var_70]
        fmul    st, st(1)
        fld     dbl_1000C318
        fmul    st, st(3)
        faddp   st(1), st
        fxch    st(1)
        fmul    [ebp+var_88]
        fld     dbl_1000C310
        fmulp   st(3), st
        fsubrp  st(2), st
        fld     st(1)
        fmul    st, st(5)
        fld     st(1)
        fmul    st, st(7)
        faddp   st(1), st
        fxch    st(1)
        fmul    st, st(5)
        fxch    st(2)
        fmul    st, st(6)
        fsubp   st(2), st
        fld     st(1)
        fabs
        fcomp   st(4)
        fnstsw  ax
      }
      if ( __SETP__(HIBYTE(_AX) & 0x41, 0) )
        goto LABEL_118;
      __asm
      {
        fld     st
        fabs
        fcomp   st(4)
        fnstsw  ax
      }
      if ( __SETP__(HIBYTE(_AX) & 0x41, 0) )
      {
LABEL_118:
        __asm { fpatan }
      }
      else
      {
        __asm { fstp    st(1) }
        v125 = 1;
        __asm
        {
          fstp    st
          fld     dbl_1000C250[ecx]
        }
      }
      __asm { fstp    [ebp+ecx+var_24] }
      _ECX += 8;
    }
    while ( _ECX < 16 );
    __asm
    {
      fstp    st(2)
      fstp    st(2)
      fstp    st
    }
LABEL_63:
    if ( !v125 )
      goto LABEL_67;
    goto LABEL_64;
  }
  __asm
  {
    fstp    st
    fstp    st(1)
    fchs
    fstp    [ebp+var_14]
    fld     [ebp+var_58]
    fmul    st, st
    fld     qword ptr [ebp+var_68]
    fmul    st, st
    faddp   st(1), st
    fsqrt
    fst     [ebp+var_70]
    fstp    qword ptr [esp+0DCh+var_DC]
  }
  sub_10001F90(v18);
  __asm
  {
    fst     [ebp+var_C]
    fsubr   [ebp+var_14]
    fabs
    fld     dbl_1000C000
    fcom    st(1)
    fnstsw  ax
    fstp    st(1)
  }
  if ( !(HIBYTE(_AX) & 1) )
  {
    __asm
    {
      fstp    st
      fld     [ebp+var_70]
      fchs
      fstp    qword ptr [esp+0DCh+var_DC]
    }
    sub_10001F90(v20);
    __asm
    {
      fstp    [ebp+var_C]
      fld     dbl_1000C000
    }
  }
  __asm
  {
    fld     qword ptr [ebp+var_68]
    fld     st
    fabs
    fcomp   st(2)
    fnstsw  ax
    fld     [ebp+var_58]
  }
  if ( __SETP__(HIBYTE(_AX) & 0x41, 0) )
    goto LABEL_119;
  __asm
  {
    fld     st
    fabs
    fcomp   st(3)
    fnstsw  ax
  }
  if ( __SETP__(HIBYTE(_AX) & 0x41, 0) )
  {
LABEL_119:
    __asm
    {
      fld     st
      fld     st(2)
      fxch    st(1)
      fpatan
      fstp    [ebp+var_24]
      fxch    st(1)
      fchs
      fxch    st(1)
      fchs
      fpatan
      fstp    [ebp+var_1C]
    }
    goto LABEL_67;
  }
  __asm { fstp    st }
  v125 = 1;
  __asm
  {
    fstp    st
    fld     dbl_1000C250
    fstp    [ebp+var_24]
    fld     dbl_1000C258
    fstp    [ebp+var_1C]
  }
LABEL_64:
  if ( *(_DWORD *)v16 != 3 )
  {
    __asm
    {
      fld     dbl_1000C260
      fstp    [ebp+var_14]
      fld     dbl_1000C268
      fstp    [ebp+var_C]
      fld     dbl_1000C250
      fstp    [ebp+var_24]
      fld     dbl_1000C258
      fstp    [ebp+var_1C]
    }
  }
  v119 = 1;
LABEL_67:
  if ( byte_1000C009 && (*(_DWORD *)v16 == 2 || *(_DWORD *)v16 == 3) )
  {
    __asm { fstp    st }
    sub_10002440((int)&v121, (int)&v123);
    __asm { fld     [ebp+var_14] }
    result = v119;
    __asm
    {
      fstp    dbl_1000C338
      fld     [ebp+var_C]
      fstp    dbl_1000C340
      fld     [ebp+var_24]
      fstp    dbl_1000C328
      fld     [ebp+var_1C]
      fstp    dbl_1000C330
    }
    return result;
  }
  v47 = *(_DWORD *)v16;
  if ( *(_DWORD *)v16 == 1 )
  {
    _EDI = a2;
    v49 = v99;
    v50 = v100;
    v51 = v101;
    v52 = v102;
    *(_DWORD *)a2 = v99;
    *(_DWORD *)(a2 + 4) = v50;
    *(_DWORD *)(a2 + 8) = v51;
    *(_DWORD *)(a2 + 12) = v52;
    *(_DWORD *)(a2 + 16) = v103;
    v53 = v104;
    *(_DWORD *)(a2 + 20) = v104;
    *(_DWORD *)_EBX = v49;
    v54 = v103;
    *(_DWORD *)(_EBX + 4) = v50;
    *(_DWORD *)(_EBX + 8) = v51;
    *(_DWORD *)(_EBX + 12) = v102;
    *(_DWORD *)(_EBX + 16) = v54;
    *(_DWORD *)(_EBX + 20) = v53;
    goto LABEL_87;
  }
  if ( v47 != 2 && v47 != 3 )
  {
    _EDI = a2;
  }
  else
  {
    __asm { fstp    st }
    if ( byte_1000C590 )
    {
      v16 = (unsigned int)printf;
      printf("About adjusting theta with initial angle...\n");
      __asm
      {
        fld     dbl_1000C328
        fld     ds:dbl_10009308
        fmul    st(1), st
        fld     [ebp+var_24]
        fsub    st(2), st
        fld     ds:dbl_100099D0
        fmul    st(3), st
        fxch    st(3)
        fstp    qword ptr [esp+0F4h+var_DC]
        fld     dbl_1000C338
        fmulp   st(2), st
        fld     [ebp+var_14]
        fsub    st(2), st
        fxch    st(2)
        fmul    st, st(3)
        fstp    [esp+0F4h+var_E4]
        fmul    st, st(2)
        fstp    [esp+0F4h+var_EC]
        fmulp   st(1), st
        fstp    [esp+0F4h+var_F4]
      }
      printf("computing t1[0]=%f, t2[0]=%f, (Init_T1[0]*2-t1[0])=%f,(Init_T2[0]*2-t2[0])=%f\n", v58, v57, v56, v55);
      __asm
      {
        fld     dbl_1000C330
        fld     ds:dbl_10009308
        fmul    st(1), st
        fld     [ebp+var_1C]
        fsub    st(2), st
        fld     ds:dbl_100099D0
        fmul    st(3), st
        fxch    st(3)
        fstp    qword ptr [esp+0F4h+var_DC]
        fld     dbl_1000C340
        fmulp   st(2), st
        fld     [ebp+var_C]
        fsub    st(2), st
        fxch    st(2)
        fmul    st, st(3)
        fstp    [esp+0F4h+var_E4]
        fmul    st, st(2)
        fstp    [esp+0F4h+var_EC]
        fmulp   st(1), st
        fstp    [esp+0F4h+var_F4]
      }
      printf("computing t1[1]=%f, t2[1]=%f, (Init_T1[1]*2-t1[1])=%f,(Init_T2[1]*2-t2[1])=%f\n", v62, v61, v60, v59);
    }
    sub_10002440((int)&v121, (int)&v123);
    if ( *(_DWORD *)dword_1000C2C4 == 2 )
    {
      __asm
      {
        fld     [ebp+var_14]
        fstp    [ebp+var_78]
        fld     [ebp+var_C]
        fstp    [ebp+var_70]
        fld     [ebp+var_24]
        fstp    [ebp+var_40]
        fld     [ebp+var_1C]
        fstp    [ebp+var_38]
      }
      sub_10002FB0((int)&v117, _EBX, v16, (int)v112, (int)&v110);
      __asm { fld     [ebp+var_78] }
      _EDI = a2;
      __asm
      {
        fst     [ebp+var_14]
        fld     [ebp+var_70]
        fstp    [ebp+var_C]
        fld     [ebp+var_40]
        fst     [ebp+var_24]
        fld     [ebp+var_38]
        fstp    [ebp+var_1C]
        fstp    [esp+0E8h+var_E4+4]
        fstp    [esp+0E8h+var_EC+4]
      }
      sub_10002190((int)&v99, a2, v64, v63, 1);
      __asm
      {
        fld     [ebp+var_38]
        fstp    [esp+0E8h+var_E4+4]
        fld     [ebp+var_70]
        fstp    [esp+0E8h+var_EC+4]
      }
      sub_10002190((int)&v99, _EBX, v66, v65, 1);
LABEL_79:
      __asm { fld     dbl_1000C000 }
      goto LABEL_87;
    }
    _EDI = a2;
    __asm
    {
      fld     [ebp+var_24]
      fchs
      fstp    [esp+0E0h+var_E4+4]
    }
    sub_100023A0((int)&v99, v67, a2);
    __asm
    {
      fld     [ebp+var_1C]
      fchs
      fstp    [esp+0E0h+var_E4+4]
    }
    sub_100023A0((int)&v99, v68, _EBX);
    if ( dword_1000C2C0 != 3 )
      goto LABEL_79;
    v69 = 0;
    do
    {
      v70 = a2;
      if ( v69 )
        v70 = _EBX;
      UF_MTX3_vec_multiply_t(v70, &unk_10009928, v70);
      ++v69;
    }
    while ( v69 < 2 );
    __asm { fld     dbl_1000C000 }
  }
LABEL_87:
  _ECX = dword_1000C2C4;
  v72 = *(_DWORD *)dword_1000C2C4;
  if ( *(_DWORD *)dword_1000C2C4 == 1 )
  {
    __asm
    {
      fstp    st
      fld     qword ptr [ecx+90h]
      fadd    qword ptr [ecx+88h]
      fst     [ebp+var_38]
      fstp    [esp+0E4h+var_E4]
    }
    UF_VEC3_affine_comb(_EDI, v73, HIDWORD(v73), v112, _EDI);
    __asm
    {
      fld     [ebp+var_38]
      fstp    [esp+0E4h+var_E4]
    }
    UF_VEC3_affine_comb(_EBX, v74, HIDWORD(v74), v112, _EBX);
    __asm
    {
      fld     [ebp+var_14]
      fstp    [esp+0E0h+var_E4+4]
    }
    sub_10002320(_EDI, v75, _EDI);
    __asm
    {
      fld     [ebp+var_C]
      fstp    [esp+0E0h+var_E4+4]
    }
    sub_10002320(_EBX, v76, _EBX);
LABEL_94:
    __asm { fld     dbl_1000C000 }
    goto LABEL_95;
  }
  if ( v72 == 3 )
  {
    __asm
    {
      fstp    st
      fld     [ebp+var_24]
      fchs
      fstp    [esp+0E0h+var_E4+4]
    }
    sub_100023A0((int)v112, v77, (int)&v116);
    __asm
    {
      fld     dbl_1000C000
      fstp    [esp+0E4h+var_E4]
    }
    UF_VEC3_unitize(&v116, v78, HIDWORD(v78), &v107, &v116);
    _EDX = dword_1000C2C4;
    __asm { fld     qword ptr [edx+88h] }
    v80 = UF_VEC3_affine_comb;
    __asm { fstp    [esp+0E4h+var_E4] }
    UF_VEC3_affine_comb(_EDI, v81, HIDWORD(v81), &v116, _EDI);
    _ECX = dword_1000C2C4;
    __asm { fld     qword ptr [ecx+88h] }
    v98 = _EBX;
    v97 = &v116;
LABEL_93:
    __asm { fstp    [esp+0E4h+var_E4] }
    v80(_EBX, v92, HIDWORD(v92), v97, v98);
    goto LABEL_94;
  }
  if ( v72 == 2 )
  {
    __asm
    {
      fstp    st
      fld     [ebp+var_24]
      fstp    [esp+0E8h+var_E4+4]
      fld     [ebp+var_14]
      fstp    [esp+0E8h+var_EC+4]
    }
    sub_10002190((int)v112, (int)&v116, v84, v83, 0);
    __asm
    {
      fld     [ebp+var_1C]
      fstp    [esp+0E8h+var_E4+4]
      fld     [ebp+var_C]
      fstp    [esp+0E8h+var_EC+4]
    }
    sub_10002190((int)v112, (int)&v109, v86, v85, 0);
    __asm
    {
      fld     dbl_1000C000
      fstp    [esp+0E4h+var_E4]
    }
    UF_VEC3_unitize(&v116, v87, HIDWORD(v87), &v107, &v116);
    __asm
    {
      fld     dbl_1000C000
      fstp    [esp+0E4h+var_E4]
    }
    UF_VEC3_unitize(&v109, v88, HIDWORD(v88), &v107, &v109);
    _EAX = dword_1000C2C4;
    __asm { fld     qword ptr [eax+88h] }
    v80 = UF_VEC3_affine_comb;
    __asm { fstp    [esp+0E4h+var_E4] }
    UF_VEC3_affine_comb(_EDI, v90, HIDWORD(v90), &v116, _EDI);
    _EDX = dword_1000C2C4;
    __asm { fld     qword ptr [edx+88h] }
    v98 = _EBX;
    v97 = (int *)&v109;
    goto LABEL_93;
  }
LABEL_95:
  v3 = byte_1000C008 == 0;
  __asm
  {
    fld     [ebp+var_14]
    fld     st
    fld     ds:dbl_100099D0
    fmul    st(1), st
    fxch    st(1)
    fstp    qword ptr [edi+18h]
    fld     [ebp+var_C]
    fld     st
    fmul    st, st(2)
    fstp    qword ptr [ebx+18h]
    fld     [ebp+var_24]
    fld     st
    fmul    st, st(3)
    fstp    qword ptr [edi+20h]
    fld     [ebp+var_1C]
    fmulp   st(3), st
    fxch    st(2)
    fstp    qword ptr [ebx+20h]
  }
  if ( !v3 && *(_DWORD *)dword_1000C2C4 != 3 )
  {
    __asm
    {
      fld     qword ptr [edi+20h]
      fld     ds:dbl_10009A28
      fsub    st(1), st
      fxch    st(1)
      fst     qword ptr [edi+20h]
      fld     ds:dbl_10009A20
      fcom    st(1)
      fnstsw  ax
      fld     ds:dbl_100099E0
    }
    if ( HIBYTE(_AX) & 0x41 )
    {
      __asm { fstp    st(2) }
    }
    else
    {
      __asm
      {
        fadd    st(2), st
        fxch    st(2)
        fstp    qword ptr [edi+20h]
      }
    }
    __asm
    {
      fld     qword ptr [ebx+20h]
      fsubrp  st(3), st
      fxch    st(2)
      fst     qword ptr [ebx+20h]
      fcom    st(2)
      fnstsw  ax
      fstp    st(2)
    }
    if ( __SETP__(HIBYTE(_AX) & 5, 0) )
    {
      __asm
      {
        fstp    st(1)
        fstp    st
      }
    }
    else
    {
      __asm
      {
        faddp   st(1), st
        fstp    qword ptr [ebx+20h]
      }
    }
  }
  if ( v125 && *(_DWORD *)dword_1000C2C4 != 3 )
  {
    *(_DWORD *)(_EDI + 24) = dword_1000C2B0;
    *(_DWORD *)(_EDI + 28) = dword_1000C2B4;
    *(_DWORD *)(_EDI + 32) = dword_1000C2B8;
    *(_DWORD *)(_EDI + 36) = dword_1000C2BC;
    *(_DWORD *)(_EBX + 24) = dword_1000C288;
    *(_DWORD *)(_EBX + 28) = dword_1000C28C;
    *(_DWORD *)(_EBX + 32) = dword_1000C290;
    *(_DWORD *)(_EBX + 36) = dword_1000C294;
  }
  if ( byte_1000C590 )
  {
    __asm
    {
      fsubp   st(2), st
      fxch    st(1)
      fabs
      fcomp   st(2)
      fnstsw  ax
    }
    if ( !__SETP__(HIBYTE(_AX) & 0x41, 0) )
    {
      __asm
      {
        fsub    [ebp+var_1C]
        fabs
        fcompp
        fnstsw  ax
      }
      if ( !__SETP__(HIBYTE(_AX) & 0x41, 0) )
        printf("WARNING: same value of rotary produced:\n");
      goto LABEL_112;
    }
  }
  else
  {
    __asm
    {
      fstp    st
      fstp    st(1)
    }
  }
  __asm
  {
    fstp    st(1)
    fstp    st
  }
LABEL_112:
  __asm { fld     [ebp+var_14] }
  result = v119;
  memcpy(&dword_1000C298, (const void *)a2, 0x28u);
  memcpy(&dword_1000C270, (const void *)_EBX, 0x28u);
  __asm
  {
    fstp    dbl_1000C260
    fld     [ebp+var_C]
    fstp    dbl_1000C268
    fld     [ebp+var_24]
    fstp    dbl_1000C250
    fld     [ebp+var_1C]
    fstp    dbl_1000C258
  }
  return result;
}
// 100031E0: inconsistent fpu stack
// 100090D4: using guessed type int __cdecl UF_MTX3_vec_multiply_t(_DWORD, _DWORD, _DWORD);
// 100090D8: using guessed type int __cdecl UF_VEC3_is_zero(_DWORD, _DWORD, _DWORD, _DWORD);
// 100090DC: using guessed type int __cdecl UF_VEC3_affine_comb(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10009128: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1000C008: using guessed type char byte_1000C008;
// 1000C009: using guessed type char byte_1000C009;
// 1000C270: using guessed type int dword_1000C270;
// 1000C288: using guessed type int dword_1000C288;
// 1000C28C: using guessed type int dword_1000C28C;
// 1000C290: using guessed type int dword_1000C290;
// 1000C294: using guessed type int dword_1000C294;
// 1000C298: using guessed type int dword_1000C298;
// 1000C2B0: using guessed type int dword_1000C2B0;
// 1000C2B4: using guessed type int dword_1000C2B4;
// 1000C2B8: using guessed type int dword_1000C2B8;
// 1000C2BC: using guessed type int dword_1000C2BC;
// 1000C2C0: using guessed type int dword_1000C2C0;
// 1000C2C4: using guessed type int dword_1000C2C4;
// 1000C590: using guessed type char byte_1000C590;

//----- (10003F40) --------------------------------------------------------
int __cdecl sub_10003F40(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax@3
  char v23; // [sp+Ch] [bp-70h]@1
  double v24; // [sp+24h] [bp-58h]@1
  double v27; // [sp+3Ch] [bp-40h]@1
  double v30; // [sp+54h] [bp-28h]@1
  double v31; // [sp+5Ch] [bp-20h]@1
  double v32; // [sp+64h] [bp-18h]@1
  double v33; // [sp+6Ch] [bp-10h]@1
  double v34; // [sp+74h] [bp-8h]@1

  _ESI = a1;
  UF_VEC3_sub(a1 + 24, a1, &v27);
  _EDI = a2;
  UF_VEC3_sub(a1, a2, &v23);
  UF_VEC3_sub(_EDI + 24, _EDI, &v24);
  UF_VEC3_dot(&v27, &v23, &v31);
  UF_VEC3_dot(&v24, &v27, &v32);
  UF_VEC3_dot(&v24, &v23, &v30);
  UF_VEC3_dot(&v24, &v24, &v33);
  UF_VEC3_dot(&v27, &v27, &v34);
  __asm
  {
    fld     [ebp+var_10]
    fld     st
    fldz
    fld     st
    fucomp  st(2)
    fnstsw  ax
    fstp    st(1)
  }
  if ( !__SETP__(HIBYTE(_AX) & 0x44, 0) )
  {
    __asm
    {
      fstp    st
      fstp    st
    }
    UF_VEC3_copy(a2, a4);
    __asm { fldz }
    _EDX = a6;
    __asm
    {
      fst     qword ptr [edx]
      fld     [ebp+var_8]
      fucompp
      fnstsw  ax
    }
    if ( !__SETP__(HIBYTE(_AX) & 0x44, 0) )
    {
      UF_VEC3_copy(a1, a3);
      __asm { fldz }
      _ECX = a5;
      __asm { fstp    qword ptr [ecx] }
      return 0;
    }
    result = sub_10002780(a4, a1, a3, a5);
    if ( result )
      return result;
    return 0;
  }
  __asm
  {
    fld     [ebp+var_8]
    fld     st
    fld     st(2)
    fucompp
    fnstsw  ax
  }
  if ( !__SETP__(HIBYTE(_AX) & 0x44, 0) )
  {
    __asm
    {
      fstp    st
      fstp    st
      fstp    st
    }
    UF_VEC3_copy(a1, a3);
    __asm { fldz }
    _EDX = a5;
    __asm { fstp    qword ptr [edx] }
    return 0;
  }
  __asm
  {
    fld     [ebp+var_18]
    fld     st
    fmul    st, st(1)
    fxch    st(2)
    fmul    st, st(4)
    fld     st(2)
    fsub    st, st(1)
    fld     st
    fld     st(5)
    fucompp
    fnstsw  ax
  }
  if ( __SETP__(HIBYTE(_AX) & 0x44, 0) )
  {
    __asm
    {
      fxch    st(3)
      fdivrp  st(1), st
      fcom    st(3)
      fnstsw  ax
      fstp    st(3)
      fxch    st(2)
    }
    if ( !__SETP__(HIBYTE(_AX) & 5, 0) )
      __asm { fchs }
    __asm
    {
      fld     dbl_1000C000
      fadd    st, st
      fld1
      fsubrp  st(1), st
      fcompp
      fnstsw  ax
    }
    if ( __SETP__(HIBYTE(_AX) & 0x41, 0) )
    {
      __asm { fld     st(2) }
      _EAX = a5;
      __asm { fmul    [ebp+var_20] }
      _ECX = a6;
      __asm { fld     [ebp+var_28] }
      _EDX = a3;
      __asm { fld     st }
      _EBX = a4;
      __asm
      {
        fmul    st, st(4)
        fsubp   st(2), st
        fxch    st(1)
        fdivrp  st(2), st
        fxch    st(1)
        fst     qword ptr [eax]
        fmulp   st(2), st
        faddp   st(1), st
        fdivrp  st(1), st
        fstp    qword ptr [ecx]
        fld     qword ptr [eax]
        fmul    [ebp+var_40]
        fadd    qword ptr [esi]
        fstp    qword ptr [edx]
        fld     qword ptr [ecx]
        fmul    [ebp+var_58]
        fadd    qword ptr [edi]
        fstp    qword ptr [ebx]
        fld     qword ptr [eax]
        fmul    [ebp+var_38]
        fadd    qword ptr [esi+8]
        fstp    qword ptr [edx+8]
        fld     qword ptr [ecx]
        fmul    [ebp+var_50]
        fadd    qword ptr [edi+8]
        fstp    qword ptr [ebx+8]
        fld     qword ptr [eax]
      }
      result = 0;
      __asm
      {
        fmul    [ebp+var_30]
        fadd    qword ptr [esi+10h]
        fstp    qword ptr [edx+10h]
        fld     qword ptr [ecx]
        fmul    [ebp+var_48]
        fadd    qword ptr [edi+10h]
        fstp    qword ptr [ebx+10h]
      }
      return result;
    }
  }
  else
  {
    __asm
    {
      fstp    st(2)
      fstp    st(2)
      fstp    st(1)
    }
  }
  __asm
  {
    fstp    st(1)
    fstp    st
    fstp    st
  }
  UF_VEC3_copy(a1, a3);
  __asm { fldz }
  _EAX = a5;
  __asm { fstp    qword ptr [eax] }
  result = sub_10002780(a3, a2, a4, a6);
  if ( !result )
    return 0;
  return result;
}
// 10003FC0: inconsistent fpu stack
// 100090EC: using guessed type int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD);
// 100090F0: using guessed type int __cdecl UF_VEC3_dot(_DWORD, _DWORD, _DWORD);
// 100090F4: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);

//----- (10004160) --------------------------------------------------------
signed int __cdecl sub_10004160(int a1, const void *a2, int a3, int a4, int a5, int a6, int a7, int a8, const void *a9)
{
  int v9; // ebx@1
  int v10; // edx@1
  int v11; // eax@1
  signed int result; // eax@4
  double v13; // ST5C_8@6
  int v14; // esi@13
  bool v15; // zf@15
  double v16; // st7@24
  int v17; // edi@25
  double v18; // ST5C_8@31
  double v19; // st7@33
  double v20; // ST5C_8@35
  double v21; // ST5C_8@39
  double v22; // st7@41
  double v23; // st3@41
  double v24; // st4@41
  double v25; // st6@41
  double v26; // st2@41
  double v27; // st5@41
  double v28; // st6@41
  double v29; // st7@41
  double v30; // st5@41
  double v31; // st7@45
  double v32; // st7@50
  double v33; // st7@53
  double v34; // st4@53
  double v35; // st5@53
  double v36; // st6@53
  double v37; // st2@53
  double v38; // st5@53
  double v39; // st6@53
  double v40; // st7@53
  double v41; // st5@53
  double v42; // st7@56
  int v43; // esi@59
  double v44; // st7@61
  int v45; // eax@64
  int v46; // edx@64
  int v47; // ecx@64
  int v48; // eax@64
  int v49; // edx@64
  double v50; // ST5C_8@64
  double v51; // ST5C_8@64
  int v52; // ecx@67
  int v53; // edx@67
  int v54; // ecx@67
  int v55; // edx@67
  int v56; // eax@67
  int v57; // edx@67
  int v58; // ecx@67
  int v59; // edx@67
  int v60; // ecx@67
  int v61; // edx@67
  const char *v62; // [sp+5Ch] [bp-21Ch]@9
  char v63; // [sp+6Ch] [bp-20Ch]@67
  char v64; // [sp+7Ch] [bp-1FCh]@16
  char v65; // [sp+94h] [bp-1E4h]@67
  char v66; // [sp+A4h] [bp-1D4h]@16
  int v67; // [sp+BCh] [bp-1BCh]@64
  int v68; // [sp+C0h] [bp-1B8h]@64
  int v69; // [sp+C4h] [bp-1B4h]@64
  int v70; // [sp+C8h] [bp-1B0h]@64
  int v71; // [sp+CCh] [bp-1ACh]@64
  int v72; // [sp+D0h] [bp-1A8h]@64
  char v73; // [sp+D4h] [bp-1A4h]@64
  char v74; // [sp+ECh] [bp-18Ch]@64
  double v75; // [sp+104h] [bp-174h]@64
  double v76; // [sp+10Ch] [bp-16Ch]@64
  double v77; // [sp+114h] [bp-164h]@64
  char v78; // [sp+11Ch] [bp-15Ch]@41
  double v79; // [sp+134h] [bp-144h]@41
  double v80; // [sp+13Ch] [bp-13Ch]@41
  double v81; // [sp+144h] [bp-134h]@41
  double v82; // [sp+14Ch] [bp-12Ch]@41
  double v83; // [sp+154h] [bp-124h]@41
  double v84; // [sp+15Ch] [bp-11Ch]@41
  double v85; // [sp+164h] [bp-114h]@41
  double v86; // [sp+16Ch] [bp-10Ch]@41
  double v87; // [sp+174h] [bp-104h]@41
  double v88; // [sp+17Ch] [bp-FCh]@41
  double v89; // [sp+184h] [bp-F4h]@41
  double v90; // [sp+18Ch] [bp-ECh]@41
  char v91; // [sp+194h] [bp-E4h]@6
  int v92; // [sp+1ACh] [bp-CCh]@67
  int v93; // [sp+1B0h] [bp-C8h]@67
  int v94; // [sp+1B4h] [bp-C4h]@67
  int v95; // [sp+1B8h] [bp-C0h]@67
  int v96; // [sp+1BCh] [bp-BCh]@67
  int v97; // [sp+1C0h] [bp-B8h]@67
  int v98; // [sp+1C4h] [bp-B4h]@16
  int v99; // [sp+1C8h] [bp-B0h]@67
  int v100; // [sp+1CCh] [bp-ACh]@67
  int v101; // [sp+1D0h] [bp-A8h]@67
  int v102; // [sp+1D4h] [bp-A4h]@67
  int v103; // [sp+1D8h] [bp-A0h]@67
  char v104; // [sp+1DCh] [bp-9Ch]@7
  char v105; // [sp+1F4h] [bp-84h]@41
  double v106; // [sp+20Ch] [bp-6Ch]@1
  double v107; // [sp+214h] [bp-64h]@53
  double v108; // [sp+21Ch] [bp-5Ch]@53
  double v109; // [sp+224h] [bp-54h]@1
  double v110; // [sp+22Ch] [bp-4Ch]@41
  double v111; // [sp+234h] [bp-44h]@41
  double v112; // [sp+23Ch] [bp-3Ch]@17
  double v113; // [sp+244h] [bp-34h]@1
  double v114; // [sp+24Ch] [bp-2Ch]@41
  double v115; // [sp+254h] [bp-24h]@41
  double v116; // [sp+25Ch] [bp-1Ch]@41
  char v117; // [sp+264h] [bp-14h]@41
  int v118; // [sp+268h] [bp-10h]@1
  long double v119; // [sp+26Ch] [bp-Ch]@1
  int v120; // [sp+274h] [bp-4h]@5

  v9 = a3;
  dword_1000C2E0 = *(_DWORD *)a3;
  dword_1000C2E4 = *(_DWORD *)(a3 + 4);
  dword_1000C2E8 = *(_DWORD *)(a3 + 8);
  dword_1000C2EC = *(_DWORD *)(a3 + 12);
  dword_1000C2F0 = *(_DWORD *)(a3 + 16);
  dword_1000C2F4 = *(_DWORD *)(a3 + 20);
  dword_1000C2C8 = *(_DWORD *)a5;
  dword_1000C2CC = *(_DWORD *)(a5 + 4);
  dword_1000C2D0 = *(_DWORD *)(a5 + 8);
  dword_1000C2D4 = *(_DWORD *)(a5 + 12);
  dword_1000C2D8 = *(_DWORD *)(a5 + 16);
  v10 = *(_DWORD *)(a5 + 20);
  v118 = 0;
  dword_1000C2DC = v10;
  UF_VEC3_copy(a4, &v109);
  UF_VEC3_copy(a6, &v113);
  UF_VEC3_copy(a8, &v106);
  dbl_1000C560 = 0.0;
  dbl_1000C568 = 0.0;
  dbl_1000C570 = 0.0;
  dbl_1000C578 = 0.0;
  memcpy(&unk_1000C448, a9, 0x98u);
  dbl_1000C580 = 0.0;
  dbl_1000C588 = 0.0;
  dbl_1000C000 = dbl_1000C450;
  memcpy(&dbl_1000C4E0, a2, 0x60u);
  dbl_1000C340 = 0.0;
  dbl_1000C338 = 0.0;
  dbl_1000C330 = 0.0;
  dbl_1000C328 = 0.0;
  dbl_1000C268 = 0.0;
  dbl_1000C260 = 0.0;
  dbl_1000C258 = 0.0;
  dbl_1000C250 = 0.0;
  byte_1000C590 = 0;
  dword_1000C2C4 = (int)&unk_1000C448;
  UF_VEC3_unitize(a4, LODWORD(dbl_1000C450), HIDWORD(dbl_1000C450), &v119, &dbl_1000C310);
  UF_VEC3_unitize(a6, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), &v119, &dbl_1000C2F8);
  dword_1000C298 = 0;
  dword_1000C29C = 0;
  dword_1000C2A0 = 0;
  dword_1000C2A4 = 0;
  dword_1000C2A8 = 0;
  dword_1000C2AC = 0;
  dword_1000C2B0 = 0;
  dword_1000C2B4 = 0;
  dword_1000C2B8 = 0;
  dword_1000C2BC = 0;
  dword_1000C270 = 0;
  dword_1000C274 = 0;
  dword_1000C278 = 0;
  dword_1000C27C = 0;
  dword_1000C280 = 0;
  dword_1000C284 = 0;
  dword_1000C288 = 0;
  dword_1000C28C = 0;
  dword_1000C290 = 0;
  dword_1000C294 = 0;
  v11 = *(_DWORD *)dword_1000C2C4;
  byte_1000C009 = 1;
  byte_1000C00A = 1;
  if ( v11 != 1 && v11 != 2 && v11 != 3 )
    return 2;
  UF_VEC3_is_parallel(&v109, &v113, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), &v120);
  BYTE3(a2) = v120 != 0;
  UF_VEC3_is_parallel(&v109, &v106, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), &v120);
  BYTE3(a9) = v120 != 0;
  UF_VEC3_is_parallel(&v113, &v106, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), &v120);
  BYTE3(a3) = v120 != 0;
  if ( !BYTE3(a9) )
  {
    v13 = v119;
    sub_10001F60((int)&v106, (int)&v109, (int)&v91, SLOBYTE(v13));
  }
  UF_VEC3_cross(&v109, &v113);
  UF_VEC3_is_parallel(&v104, &v106, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), &v120);
  byte_1000C008 = v120 != 0;
  if ( byte_1000C590 )
  {
    printf("\n\n======================================================================\n");
    printf("Is_orthogonal_case = %d, ", (unsigned __int8)byte_1000C008);
    if ( *(_DWORD *)dword_1000C2C4 == 2 )
    {
      v62 = "is_5_axis_dual_table\n";
    }
    else
    {
      if ( *(_DWORD *)dword_1000C2C4 == 1 )
        v62 = "is_5_axis_dual_head\n";
      else
        v62 = "is_5_axis_head_table\n";
    }
    printf(v62);
    printf("primary=(%f,%f,%f)\n", *(double *)a4, *(double *)(a4 + 8), *(double *)(a4 + 16));
    printf("primary_machine_center=(%f,%f,%f)\n", *(double *)v9, *(double *)(v9 + 8), *(double *)(v9 + 16));
    printf("secondary=(%f,%f,%f)\n", *(double *)a6, *(double *)(a6 + 8), *(double *)(a6 + 16));
    v14 = a5;
    printf("secondary_machine_center=(%f,%f,%f)\n", *(double *)a5, *(double *)(a5 + 8), *(double *)(a5 + 16));
    printf("tool_machine_center=(%f,%f,%f)\n", *(double *)a7, *(double *)(a7 + 8), *(double *)(a7 + 16));
    printf("tool_vector=(%f,%f,%f)\n", *(double *)a8, *(double *)(a8 + 8), *(double *)(a8 + 16));
    printf(
      "Mcsys= (%f,%f,%f) (%f,%f,%f) (%f,%f,%f)  (%f,%f,%f)\n",
      *(_QWORD *)&dbl_1000C4E0,
      *(_QWORD *)&dbl_1000C4E8,
      *(_QWORD *)&dbl_1000C4F0,
      *(_QWORD *)&dbl_1000C4F8,
      *(_QWORD *)&dbl_1000C500,
      *(_QWORD *)&dbl_1000C508,
      *(_QWORD *)&dbl_1000C510,
      *(_QWORD *)&dbl_1000C518,
      *(_QWORD *)&dbl_1000C520,
      *(_QWORD *)&dbl_1000C528,
      *(_QWORD *)&dbl_1000C530,
      *(_QWORD *)&dbl_1000C538);
  }
  else
  {
    v14 = a5;
  }
  v15 = *(_DWORD *)dword_1000C2C4 == 3;
  dword_1000C2C0 = -1;
  if ( v15 )
  {
    UF_MTX3_x_vec(&unk_100098E0, &v66);
    UF_MTX3_y_vec(&unk_100098E0, &v64);
    UF_MTX3_z_vec(&unk_100098E0, &v98);
    UF_VEC3_is_equal(a8, &v98, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), &a9);
    if ( a9 )
    {
      UF_VEC3_is_equal(a4, &v66, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), &a5);
      v17 = a6;
      UF_VEC3_is_equal(a6, &v64, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), &a3);
      UF_VEC3_is_equal(v17, &v98, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), &a2);
      if ( a5 && a3 )
      {
        result = v118;
        dword_1000C2C0 = 0;
        byte_1000C009 = 0;
      }
      else
      {
        if ( a2 )
        {
          result = v118;
          dword_1000C2C0 = 1;
          byte_1000C009 = 0;
        }
        else
        {
          v118 = 2;
          result = 2;
          byte_1000C009 = 0;
        }
      }
      return result;
    }
    UF_VEC3_is_equal(a8, &v64, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), &v118);
    UF_VEC3_is_equal(&v109, &v98, LODWORD(dbl_1000C000), HIDWORD(dbl_1000C000), (char *)&v112 + 4);
    if ( byte_1000C008 || !BYTE3(a3) || !v118 || !HIDWORD(v112) )
      return 2;
    dword_1000C2C0 = 3;
    UF_MTX3_vec_multiply_t(&dbl_1000C310, &unk_10009970, &dbl_1000C310);
    UF_MTX3_vec_multiply_t(&dbl_1000C2F8, &unk_10009970, &dbl_1000C2F8);
    if ( byte_1000C590 )
    {
      printf("Sulzer case:\n");
      printf(
        "local PrimaryAxis=(%f,%f,%f)\n",
        *(_QWORD *)&dbl_1000C310,
        *(_QWORD *)&dbl_1000C318,
        *(_QWORD *)&dbl_1000C320);
      printf(
        "local SecondaryAxis=(%f,%f,%f)\n",
        *(_QWORD *)&dbl_1000C2F8,
        *(_QWORD *)&dbl_1000C300,
        *(_QWORD *)&dbl_1000C308);
    }
  }
  if ( BYTE3(a2) )
  {
    v16 = 0.0;
  }
  else
  {
    v18 = v119;
    sub_10001F60((int)&v113, (int)&v109, (int)&v91, SLOBYTE(v18));
    v16 = sub_100023E0((int)&v91, (int)&v113, (int)&v109);
    v14 = a5;
  }
  dbl_1000C580 = v16;
  if ( BYTE3(a3) )
  {
    printf("WARNING: Tool axis is parallelled with secondary axis that may cause unresolved rotaries");
    v19 = 0.0;
  }
  else
  {
    if ( fabs(v16) <= dbl_1000C000 )
    {
      v20 = v119;
      sub_10001F60((int)&v106, (int)&v113, (int)&v91, SLOBYTE(v20));
      if ( fabs(v119) <= dbl_1000C000 )
        return 3;
      v14 = a5;
    }
    if ( byte_1000C008 )
    {
      v21 = v119;
      sub_10001F60((int)&v106, (int)&v113, (int)&v66, SLOBYTE(v21));
      v19 = sub_100023E0((int)&v66, (int)&v106, (int)&v113);
      v14 = a5;
    }
    else
    {
      v19 = sub_100023E0((int)&v91, (int)&v106, (int)&v113);
    }
  }
  dbl_1000C588 = v19;
  v22 = *(double *)v9 - v109 * 1000000.0;
  v23 = *(double *)v14;
  v24 = *(double *)v14 - v113 * 1000000.0;
  v79 = *(double *)v9 + v109 * 1000000.0;
  v85 = v23 + v113 * 1000000.0;
  v82 = v22;
  v88 = v24;
  v25 = *(double *)(v9 + 8) - v110 * 1000000.0;
  v26 = *(double *)(v14 + 8);
  v27 = *(double *)(v14 + 8) + v114 * 1000000.0;
  v80 = *(double *)(v9 + 8) + v110 * 1000000.0;
  v86 = v27;
  v83 = v25;
  v89 = v26 - v114 * 1000000.0;
  v28 = *(double *)(v9 + 16) - v111 * 1000000.0;
  v29 = *(double *)(v14 + 16) - 1000000.0 * v115;
  v30 = *(double *)(v14 + 16) + 1000000.0 * v115;
  v81 = *(double *)(v9 + 16) + v111 * 1000000.0;
  v87 = v30;
  v84 = v28;
  v90 = v29;
  if ( sub_10003F40((int)&v79, (int)&v85, (int)&v78, (int)&v105, (int)&v116, (int)&v117) )
    return 5;
  UF_VEC3_distance(&v78, &v105, &dbl_1000C560);
  if ( dbl_1000C000 >= dbl_1000C560 )
  {
    v31 = 0.0;
  }
  else
  {
    UF_VEC3_sub(&v105, &v78, &v104);
    UF_VEC3_dot(&v104, &v91, &v112);
    if ( v112 >= 0.0 )
      goto LABEL_48;
    v31 = -dbl_1000C560;
  }
  dbl_1000C560 = v31;
LABEL_48:
  UF_VEC3_distance(&v105, v9, &dbl_1000C568);
  if ( dbl_1000C000 >= dbl_1000C568 )
  {
    v32 = 0.0;
  }
  else
  {
    UF_VEC3_sub(&v105, v9, &v104);
    UF_VEC3_dot(&v104, &v109, &v112);
    if ( v112 >= 0.0 )
      goto LABEL_53;
    v32 = -dbl_1000C568;
  }
  dbl_1000C568 = v32;
LABEL_53:
  v33 = *(double *)v14 - v113 * 1000000.0;
  v34 = *(double *)a7 - v106 * 1000000.0;
  v35 = *(double *)a7 + v106 * 1000000.0;
  v79 = *(double *)v14 + v113 * 1000000.0;
  v85 = v35;
  v82 = v33;
  v88 = v34;
  v36 = *(double *)(v14 + 8) - v114 * 1000000.0;
  v37 = *(double *)(a7 + 8);
  v38 = v107 * 1000000.0 + *(double *)(a7 + 8);
  v80 = *(double *)(v14 + 8) + v114 * 1000000.0;
  v86 = v38;
  v83 = v36;
  v89 = v37 - v107 * 1000000.0;
  v39 = *(double *)(v14 + 16) - v115 * 1000000.0;
  v40 = *(double *)(a7 + 16) - 1000000.0 * v108;
  v41 = *(double *)(a7 + 16) + 1000000.0 * v108;
  v81 = *(double *)(v14 + 16) + v115 * 1000000.0;
  v87 = v41;
  v84 = v39;
  v90 = v40;
  if ( sub_10003F40((int)&v79, (int)&v85, (int)&v78, (int)&v105, (int)&v116, (int)&v117) )
    return 5;
  UF_VEC3_distance(&v78, &v105, &dbl_1000C570);
  if ( dbl_1000C000 >= dbl_1000C570 )
  {
    v42 = 0.0;
  }
  else
  {
    UF_VEC3_sub(&v105, &v78, &v104);
    UF_VEC3_dot(&v104, &v91, &v116);
    if ( v116 >= 0.0 )
      goto LABEL_59;
    v42 = -dbl_1000C570;
  }
  dbl_1000C570 = v42;
LABEL_59:
  v43 = a7;
  UF_VEC3_distance(&v105, a7, &dbl_1000C578);
  if ( dbl_1000C000 >= dbl_1000C578 )
  {
    v44 = 0.0;
    goto LABEL_63;
  }
  UF_VEC3_sub(&v105, v43, &v104);
  UF_VEC3_dot(&v104, &v113, &v116);
  if ( v116 < 0.0 )
  {
    v44 = -dbl_1000C578;
LABEL_63:
    dbl_1000C578 = v44;
  }
  v45 = *(_DWORD *)(v9 + 8);
  v46 = *(_DWORD *)(v9 + 4);
  v67 = *(_DWORD *)v9;
  v47 = *(_DWORD *)(v9 + 12);
  v69 = v45;
  v48 = *(_DWORD *)(v9 + 20);
  v68 = v46;
  v49 = *(_DWORD *)(v9 + 16);
  v70 = v47;
  v72 = v48;
  v50 = v119;
  v71 = v49;
  sub_10001F60((int)&v113, (int)&v109, (int)&v73, SLOBYTE(v50));
  v75 = v109;
  v76 = v110;
  v77 = v111;
  v51 = v119;
  sub_10001F60((int)&v73, (int)&v109, (int)&v74, SLOBYTE(v51));
  sub_100020C0((int)&v67, a1, (int)&unk_1000C3C8);
  sub_10002E80((int)&unk_1000C3C8, (int)&dbl_1000C348);
  dbl_1000C550 = sin(dbl_1000C580);
  dbl_1000C540 = sin(dbl_1000C588);
  dbl_1000C558 = cos(dbl_1000C580);
  dbl_1000C548 = cos(dbl_1000C588);
  if ( byte_1000C590 )
    printf(
      "A1=%f,D1=%f,Alpha1=%f,A2=%f,D2=%f,Alpha2=%f\n",
      *(_QWORD *)&dbl_1000C560,
      *(_QWORD *)&dbl_1000C568,
      dbl_1000C580 * 57.29577951308235,
      *(_QWORD *)&dbl_1000C570,
      *(_QWORD *)&dbl_1000C578,
      dbl_1000C588 * 57.29577951308235);
  if ( *(_DWORD *)dword_1000C2C4 == 2 )
  {
    v52 = *(_DWORD *)(a7 + 4);
    v92 = *(_DWORD *)a7;
    v53 = *(_DWORD *)(a7 + 8);
    v93 = v52;
    v54 = *(_DWORD *)(a7 + 12);
    v94 = v53;
    v55 = *(_DWORD *)(a7 + 16);
    v56 = *(_DWORD *)(a7 + 20);
    v95 = v54;
    v96 = v55;
    v97 = v56;
    v57 = *(_DWORD *)(a8 + 4);
    v98 = *(_DWORD *)a8;
    v58 = *(_DWORD *)(a8 + 8);
    v99 = v57;
    v59 = *(_DWORD *)(a8 + 12);
    v100 = v58;
    v60 = *(_DWORD *)(a8 + 16);
    v101 = v59;
    v61 = *(_DWORD *)(a8 + 20);
    v102 = v60;
    v103 = v61;
    sub_100031D0(&v92, (int)&v63, (int)&v65);
    if ( byte_1000C590 )
    {
      printf("Init_T1[0], Init_T2[0] = (%f,%f)\n", 57.29577951308235 * dbl_1000C338, dbl_1000C328 * 57.29577951308235);
      printf("Init_T1[1], Init_T2[1] = (%f,%f)\n", 57.29577951308235 * dbl_1000C340, dbl_1000C330 * 57.29577951308235);
    }
  }
  result = 0;
  byte_1000C009 = 0;
  return result;
}
// 100090B0: using guessed type int __cdecl UF_MTX3_x_vec(_DWORD, _DWORD);
// 100090C8: using guessed type int __cdecl UF_VEC3_is_parallel(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090CC: using guessed type int __cdecl UF_MTX3_z_vec(_DWORD, _DWORD);
// 100090D0: using guessed type int __cdecl UF_VEC3_distance(_DWORD, _DWORD, _DWORD);
// 100090D4: using guessed type int __cdecl UF_MTX3_vec_multiply_t(_DWORD, _DWORD, _DWORD);
// 100090E0: using guessed type int __cdecl UF_VEC3_is_equal(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090EC: using guessed type int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD);
// 100090F0: using guessed type int __cdecl UF_VEC3_dot(_DWORD, _DWORD, _DWORD);
// 100090F4: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);
// 1000911C: using guessed type int __cdecl UF_MTX3_y_vec(_DWORD, _DWORD);
// 10009128: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1000C000: using guessed type double dbl_1000C000;
// 1000C008: using guessed type char byte_1000C008;
// 1000C009: using guessed type char byte_1000C009;
// 1000C00A: using guessed type char byte_1000C00A;
// 1000C250: using guessed type double dbl_1000C250;
// 1000C258: using guessed type double dbl_1000C258;
// 1000C260: using guessed type double dbl_1000C260;
// 1000C268: using guessed type double dbl_1000C268;
// 1000C270: using guessed type int dword_1000C270;
// 1000C274: using guessed type int dword_1000C274;
// 1000C278: using guessed type int dword_1000C278;
// 1000C27C: using guessed type int dword_1000C27C;
// 1000C280: using guessed type int dword_1000C280;
// 1000C284: using guessed type int dword_1000C284;
// 1000C288: using guessed type int dword_1000C288;
// 1000C28C: using guessed type int dword_1000C28C;
// 1000C290: using guessed type int dword_1000C290;
// 1000C294: using guessed type int dword_1000C294;
// 1000C298: using guessed type int dword_1000C298;
// 1000C29C: using guessed type int dword_1000C29C;
// 1000C2A0: using guessed type int dword_1000C2A0;
// 1000C2A4: using guessed type int dword_1000C2A4;
// 1000C2A8: using guessed type int dword_1000C2A8;
// 1000C2AC: using guessed type int dword_1000C2AC;
// 1000C2B0: using guessed type int dword_1000C2B0;
// 1000C2B4: using guessed type int dword_1000C2B4;
// 1000C2B8: using guessed type int dword_1000C2B8;
// 1000C2BC: using guessed type int dword_1000C2BC;
// 1000C2C0: using guessed type int dword_1000C2C0;
// 1000C2C4: using guessed type int dword_1000C2C4;
// 1000C2C8: using guessed type int dword_1000C2C8;
// 1000C2CC: using guessed type int dword_1000C2CC;
// 1000C2D0: using guessed type int dword_1000C2D0;
// 1000C2D4: using guessed type int dword_1000C2D4;
// 1000C2D8: using guessed type int dword_1000C2D8;
// 1000C2DC: using guessed type int dword_1000C2DC;
// 1000C2E0: using guessed type int dword_1000C2E0;
// 1000C2E4: using guessed type int dword_1000C2E4;
// 1000C2E8: using guessed type int dword_1000C2E8;
// 1000C2EC: using guessed type int dword_1000C2EC;
// 1000C2F0: using guessed type int dword_1000C2F0;
// 1000C2F4: using guessed type int dword_1000C2F4;
// 1000C2F8: using guessed type double dbl_1000C2F8;
// 1000C300: using guessed type double dbl_1000C300;
// 1000C308: using guessed type double dbl_1000C308;
// 1000C310: using guessed type double dbl_1000C310;
// 1000C318: using guessed type double dbl_1000C318;
// 1000C320: using guessed type double dbl_1000C320;
// 1000C328: using guessed type double dbl_1000C328;
// 1000C330: using guessed type double dbl_1000C330;
// 1000C338: using guessed type double dbl_1000C338;
// 1000C340: using guessed type double dbl_1000C340;
// 1000C348: using guessed type double dbl_1000C348;
// 1000C450: using guessed type double dbl_1000C450;
// 1000C4E0: using guessed type double dbl_1000C4E0;
// 1000C4E8: using guessed type double dbl_1000C4E8;
// 1000C4F0: using guessed type double dbl_1000C4F0;
// 1000C4F8: using guessed type double dbl_1000C4F8;
// 1000C500: using guessed type double dbl_1000C500;
// 1000C508: using guessed type double dbl_1000C508;
// 1000C510: using guessed type double dbl_1000C510;
// 1000C518: using guessed type double dbl_1000C518;
// 1000C520: using guessed type double dbl_1000C520;
// 1000C528: using guessed type double dbl_1000C528;
// 1000C530: using guessed type double dbl_1000C530;
// 1000C538: using guessed type double dbl_1000C538;
// 1000C540: using guessed type double dbl_1000C540;
// 1000C548: using guessed type double dbl_1000C548;
// 1000C550: using guessed type double dbl_1000C550;
// 1000C558: using guessed type double dbl_1000C558;
// 1000C560: using guessed type double dbl_1000C560;
// 1000C568: using guessed type double dbl_1000C568;
// 1000C570: using guessed type double dbl_1000C570;
// 1000C578: using guessed type double dbl_1000C578;
// 1000C580: using guessed type double dbl_1000C580;
// 1000C588: using guessed type double dbl_1000C588;
// 1000C590: using guessed type char byte_1000C590;

//----- (10004F30) --------------------------------------------------------
signed int __cdecl sub_10004F30(const void *a1, int a2, int a3)
{
  const void *v3; // ebx@1
  signed int v4; // esi@3
  bool v5; // zf@8
  char v7; // [sp+34h] [bp-98h]@1
  char v8[40]; // [sp+64h] [bp-68h]@1
  char v9[40]; // [sp+8Ch] [bp-40h]@1
  double v10; // [sp+B4h] [bp-18h]@2
  double v11; // [sp+BCh] [bp-10h]@2
  double v12; // [sp+C4h] [bp-8h]@2
  signed int v13; // [sp+D4h] [bp+8h]@1

  v3 = a1;
  memcpy(&v7, a1, 0x30u);
  UF_VEC3_add(&v7, dword_1000C2C4 + 16, &v7);
  UF_VEC3_sub(&v7, dword_1000C2C4 + 40, &v7);
  v13 = sub_100031D0(&v7, (int)v9, (int)v8);
  UF_VEC3_add(v9, dword_1000C2C4 + 64, v9);
  UF_VEC3_add(v8, dword_1000C2C4 + 64, v8);
  if ( *(_BYTE *)(dword_1000C2C4 + 88) )
  {
    v10 = *((double *)v3 + 3);
    v11 = *((double *)v3 + 4);
    v12 = *((double *)v3 + 5);
    UF_VEC3_scale(
      COERCE_UNSIGNED_INT64(*(double *)(dword_1000C2C4 + 96)),
      COERCE_UNSIGNED_INT64(*(double *)(dword_1000C2C4 + 96)) >> 32,
      &v10,
      &v10);
    UF_VEC3_add(v9, &v10, v9);
    UF_VEC3_add(v8, &v10, v8);
  }
  v4 = 0;
  do
  {
    *(double *)&v9[v4] = sub_10005120((int)&v9[v4], (long double *)(dword_1000C2C4 + 8));
    *(double *)&v8[v4] = sub_10005120((int)&v8[v4], (long double *)(dword_1000C2C4 + 8));
    v4 += 8;
  }
  while ( v4 <= 16 );
  if ( byte_1000C00A )
    byte_1000C00A = 0;
  else
    sub_100025C0((int)v9, (int)v8);
  v5 = byte_1000C590 == 0;
  memcpy((void *)a2, v9, 0x28u);
  memcpy((void *)a3, v8, 0x28u);
  memcpy(&unk_1000C5C0, (const void *)a2, 0x28u);
  memcpy(&unk_1000C598, (const void *)a3, 0x28u);
  if ( !v5 )
  {
    printf(
      "final ufunc mcoord[] = (%f,%f,%f), (%f,%f)\n",
      *(double *)a2,
      *(double *)(a2 + 8),
      *(double *)(a2 + 16),
      *(double *)(a2 + 24),
      *(double *)(a2 + 32));
    printf(
      "final ufunc alt_mcoord[] = (%f,%f,%f), (%f,%f)\n",
      *(double *)a3,
      *(double *)(a3 + 8),
      *(double *)(a3 + 16),
      *(double *)(a3 + 24),
      *(double *)(a3 + 32));
  }
  return v13;
}
// 100090C4: using guessed type int __cdecl UF_VEC3_scale(_DWORD, _DWORD, _DWORD, _DWORD);
// 100090EC: using guessed type int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD);
// 10009100: using guessed type int __cdecl UF_VEC3_add(_DWORD, _DWORD, _DWORD);
// 1000C00A: using guessed type char byte_1000C00A;
// 1000C2C4: using guessed type int dword_1000C2C4;
// 1000C590: using guessed type char byte_1000C590;
// 10004F30: using guessed type char var_68[40];
// 10004F30: using guessed type char var_40[40];

//----- (10005120) --------------------------------------------------------
double __cdecl sub_10005120(int a1, long double *a2)
{
  double result; // st7@2
  long double v3; // st7@3
  long double v4; // st7@3
  double v5; // [sp+8h] [bp-8h]@3

  if ( fabs(fabs(*a2)) > 1.0e-10 )
  {
    v3 = 1.0 / *a2;
    v5 = v3;
    v4 = v3 * *(double *)a1;
    if ( v4 >= 0.000001 )
    {
      result = floor(v4 + 0.5) / v5;
    }
    else
    {
      if ( v4 <= -0.000001 )
        result = ceil(v4 - 0.5) / v5;
      else
        result = 0.0 / v5;
    }
  }
  else
  {
    result = 0.0;
  }
  return result;
}

//----- (100051B0) --------------------------------------------------------
signed int __usercall sub_100051B0<eax>(int a1<eax>)
{
  int v1; // esi@1
  double v2; // st6@1
  signed int v3; // ecx@1
  double v4; // st4@1
  double v5; // qt0@2
  long double v6; // st3@3
  double v7; // qt1@4
  double v8; // st4@4
  double v9; // st6@4
  double v10; // qt2@5
  double v11; // st3@7
  signed int result; // eax@13
  char v13; // [sp+1Ch] [bp-98h]@1
  char v14; // [sp+64h] [bp-50h]@1
  char v15; // [sp+7Ch] [bp-38h]@1
  char v16; // [sp+94h] [bp-20h]@1
  char v17; // [sp+ACh] [bp-8h]@11

  v1 = a1;
  UF_VEC3_copy(a1, &v16);
  UF_VEC3_copy(v1 + 24, &v15);
  UF_VEC3_copy(v1 + 48, &v14);
  UF_MTX3_copy(v1, &v13);
  v2 = 0.0;
  v3 = 0;
  v4 = -1.0;
  while ( 1 )
  {
    v6 = fabs(*(double *)(v1 + 8 * v3));
    if ( v6 > 1.0e-10 )
    {
      v10 = v4;
      v8 = v2;
      v9 = v10;
      if ( fabs(v6 - 1.0) <= 1.0e-10 )
      {
        if ( v8 >= *(double *)(v1 + 8 * v3) )
          v11 = v9;
        else
          v11 = 1.0;
        *(_QWORD *)(v1 + 8 * v3) = *(_QWORD *)&v11;
      }
    }
    else
    {
      v7 = v4;
      v8 = v2;
      v9 = v7;
      *(_QWORD *)(v1 + 8 * v3) = *(_QWORD *)&v8;
    }
    ++v3;
    if ( v3 >= 9 )
      break;
    v5 = v8;
    v4 = v9;
    v2 = v5;
  }
  if ( UF_VEC3_unitize(&v16, COERCE_UNSIGNED_INT64(1.0e-10), COERCE_UNSIGNED_INT64(1.0e-10) >> 32, &v17, &v16)
    && UF_VEC3_unitize(&v15, COERCE_UNSIGNED_INT64(1.0e-10), COERCE_UNSIGNED_INT64(1.0e-10) >> 32, &v17, &v15) )
  {
    UF_VEC3_cross(&v16, &v15);
    UF_VEC3_cross(&v14, &v16);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100090F4: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);
// 10009128: using guessed type int __cdecl UF_VEC3_unitize(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10009158: using guessed type int __cdecl UF_MTX3_copy(_DWORD, _DWORD);

//----- (100052D0) --------------------------------------------------------
signed int __cdecl sub_100052D0(int a1)
{
  signed int v1; // edi@1
  char v3; // [sp+8h] [bp-48h]@1

  UF_MTX4_ask_rotation(a1, &v3);
  v1 = sub_100051B0((int)&v3);
  UF_MTX4_edit_rotation(a1, &v3);
  return v1;
}
// 100052D0: using guessed type _DWORD __cdecl sub_100052D0(_DWORD);
// 100090C0: using guessed type int __cdecl UF_MTX4_edit_rotation(_DWORD, _DWORD);
// 10009108: using guessed type int __cdecl UF_MTX4_ask_rotation(_DWORD, _DWORD);

//----- (10005310) --------------------------------------------------------
int __fastcall sub_10005310(int a1, int a2, char a3)
{
  return UF_MOM_ask_string(a2, a1, &a3);
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10005330) --------------------------------------------------------
int __cdecl sub_10005330(int a1, int a2)
{
  const char *v2; // esi@1
  int i; // ebx@1
  char *v4; // eax@3
  int v5; // edx@5
  char v6; // cl@6
  char *v7; // eax@8
  int v8; // edx@10
  char v9; // cl@11
  char *v10; // eax@13
  int v11; // edx@15
  char v12; // cl@16
  char *v13; // eax@18
  int v14; // edx@20
  char v15; // cl@21
  char *v16; // eax@23
  char *v17; // eax@26
  int v19; // [sp+Ch] [bp-20h]@1
  int v20; // [sp+10h] [bp-1Ch]@1
  int v21; // [sp+14h] [bp-18h]@1
  int v22; // [sp+18h] [bp-14h]@1
  int v23; // [sp+1Ch] [bp-10h]@1
  char v24[4]; // [sp+20h] [bp-Ch]@1
  int v25; // [sp+24h] [bp-8h]@2
  char *Str; // [sp+28h] [bp-4h]@2

  v2 = "mom_kin_nurbs_output_type";
  v19 = (int)"mom_kin_output_unit";
  v20 = (int)"mom_kin_polar_radius_side";
  v21 = (int)"mom_kin_read_ahead_next_motion";
  v22 = (int)"mom_kin_pivot_gauge_offset";
  v23 = (int)"mom_kin_rapid_feed_rate";
  *(_DWORD *)v24 = "END";
  for ( i = 0; strcmp(v2, "END"); ++i )
  {
    v25 = UF_MOM_ask_string(a1, v2 + 4, &Str);
    switch ( i )
    {
      case 0:
        v4 = Str;
        if ( !Str )
        {
          v4 = "NONE";
          Str = "NONE";
        }
        v5 = a2 - (_DWORD)v4;
        do
        {
          v6 = *v4;
          v4[v5] = *v4;
          ++v4;
        }
        while ( v6 );
        break;
      case 1:
        v7 = Str;
        if ( !Str )
        {
          v7 = "IN";
          Str = "IN";
        }
        v8 = a2 - (_DWORD)v7 + 133;
        do
        {
          v9 = *v7;
          v7[v8] = *v7;
          ++v7;
        }
        while ( v9 );
        break;
      case 2:
        v10 = Str;
        if ( !Str )
        {
          v10 = "NONE";
          Str = "NONE";
        }
        v11 = a2 - (_DWORD)v10 + 266;
        do
        {
          v12 = *v10;
          v10[v11] = *v10;
          ++v10;
        }
        while ( v12 );
        break;
      case 3:
        v13 = Str;
        if ( !Str )
        {
          v13 = "F";
          Str = "F";
        }
        v14 = a2 - (_DWORD)v13 + 399;
        do
        {
          v15 = *v13;
          v13[v14] = *v13;
          ++v13;
        }
        while ( v15 );
        break;
      case 4:
        v16 = Str;
        if ( !Str )
        {
          v16 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 536) = strtod(v16, 0);
        break;
      case 5:
        v17 = Str;
        if ( !Str )
        {
          v17 = "400.00";
          Str = "400.00";
        }
        *(double *)(a2 + 544) = strtod(v17, 0);
        break;
      default:
        break;
    }
    v2 = (const char *)*(&v19 + i);
  }
  return v25;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10005500) --------------------------------------------------------
int __cdecl sub_10005500(int a1, int a2)
{
  const char *v2; // esi@1
  int i; // ebx@1
  char *v4; // eax@3
  int v5; // edx@5
  char v6; // cl@6
  char *v7; // eax@8
  int v8; // edx@10
  char v9; // cl@11
  char *v10; // eax@13
  char *v11; // eax@16
  int v13; // [sp+Ch] [bp-18h]@1
  int v14; // [sp+10h] [bp-14h]@1
  int v15; // [sp+14h] [bp-10h]@1
  char v16[4]; // [sp+18h] [bp-Ch]@1
  int v17; // [sp+1Ch] [bp-8h]@2
  char *Str; // [sp+20h] [bp-4h]@2

  v2 = "mom_kin_arc_output_mode";
  v13 = (int)"mom_kin_arc_valid_plane";
  v14 = (int)"mom_kin_min_arc_radius";
  v15 = (int)"mom_kin_max_arc_radius";
  *(_DWORD *)v16 = "END";
  for ( i = 0; strcmp(v2, "END"); ++i )
  {
    v17 = UF_MOM_ask_string(a1, v2 + 4, &Str);
    switch ( i )
    {
      case 0:
        v4 = Str;
        if ( !Str )
        {
          v4 = "FULL_CIRCLE";
          Str = "FULL_CIRCLE";
        }
        v5 = a2 - (_DWORD)v4;
        do
        {
          v6 = *v4;
          v4[v5] = *v4;
          ++v4;
        }
        while ( v6 );
        break;
      case 1:
        v7 = Str;
        if ( !Str )
        {
          v7 = "XY";
          Str = "XY";
        }
        v8 = a2 - (_DWORD)v7 + 133;
        do
        {
          v9 = *v7;
          v7[v8] = *v7;
          ++v7;
        }
        while ( v9 );
        break;
      case 2:
        v10 = Str;
        if ( !Str )
        {
          v10 = "0.0001";
          Str = "0.0001";
        }
        *(double *)(a2 + 272) = strtod(v10, 0);
        break;
      case 3:
        v11 = Str;
        if ( !Str )
        {
          v11 = "9999.9999";
          Str = "9999.9999";
        }
        *(double *)(a2 + 280) = strtod(v11, 0);
        break;
      default:
        break;
    }
    v2 = (const char *)*(&v13 + i);
  }
  return v17;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10005670) --------------------------------------------------------
int __cdecl sub_10005670(int a1, int a2)
{
  const char *v2; // esi@1
  int i; // ebx@1
  char *v4; // eax@3
  char *v5; // eax@6
  char *v6; // eax@9
  char *v7; // eax@12
  char *v8; // eax@15
  char *v9; // eax@18
  char *v10; // eax@21
  char *v11; // eax@24
  int v13; // [sp+Ch] [bp-28h]@1
  int v14; // [sp+10h] [bp-24h]@1
  int v15; // [sp+14h] [bp-20h]@1
  int v16; // [sp+18h] [bp-1Ch]@1
  int v17; // [sp+1Ch] [bp-18h]@1
  int v18; // [sp+20h] [bp-14h]@1
  int v19; // [sp+24h] [bp-10h]@1
  char v20[4]; // [sp+28h] [bp-Ch]@1
  int v21; // [sp+2Ch] [bp-8h]@2
  char *Str; // [sp+30h] [bp-4h]@2

  v2 = "mom_kin_max_fpm";
  v13 = (int)"mom_kin_min_fpm";
  v14 = (int)"mom_kin_max_fpr";
  v15 = (int)"mom_kin_min_fpr";
  v16 = (int)"mom_kin_max_frn";
  v17 = (int)"mom_kin_min_frn";
  v18 = (int)"mom_kin_max_dpm";
  v19 = (int)"mom_kin_min_dpm";
  *(_DWORD *)v20 = "END";
  for ( i = 0; strcmp(v2, "END"); ++i )
  {
    v21 = UF_MOM_ask_string(a1, v2 + 4, &Str);
    switch ( i )
    {
      case 0:
        v4 = Str;
        if ( !Str )
        {
          v4 = "999.999";
          Str = "999.999";
        }
        *(double *)a2 = strtod(v4, 0);
        break;
      case 1:
        v5 = Str;
        if ( !Str )
        {
          v5 = "0.001";
          Str = "0.001";
        }
        *(double *)(a2 + 32) = strtod(v5, 0);
        break;
      case 2:
        v6 = Str;
        if ( !Str )
        {
          v6 = "99.999";
          Str = "99.999";
        }
        *(double *)(a2 + 8) = strtod(v6, 0);
        break;
      case 3:
        v7 = Str;
        if ( !Str )
        {
          v7 = "0.001";
          Str = "0.001";
        }
        *(double *)(a2 + 40) = strtod(v7, 0);
        break;
      case 4:
        v8 = Str;
        if ( !Str )
        {
          v8 = "99999.999";
          Str = "99999.999";
        }
        *(double *)(a2 + 16) = strtod(v8, 0);
        break;
      case 5:
        v9 = Str;
        if ( !Str )
        {
          v9 = "0.001";
          Str = "0.001";
        }
        *(double *)(a2 + 48) = strtod(v9, 0);
        break;
      case 6:
        v10 = Str;
        if ( !Str )
        {
          v10 = "99.999";
          Str = "99.999";
        }
        *(double *)(a2 + 24) = strtod(v10, 0);
        break;
      case 7:
        v11 = Str;
        if ( !Str )
        {
          v11 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 56) = strtod(v11, 0);
        break;
      default:
        break;
    }
    v2 = (const char *)*(&v13 + i);
  }
  return v21;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10005870) --------------------------------------------------------
int __cdecl sub_10005870(int a1, int a2)
{
  const char *v2; // esi@1
  int i; // ebx@1
  char *v4; // eax@3
  int v5; // edx@5
  char v6; // cl@6
  char *v7; // eax@8
  int v8; // edx@10
  char v9; // cl@11
  char *v10; // eax@13
  int v11; // edx@15
  char v12; // cl@16
  char *v13; // eax@18
  char *v14; // eax@21
  char *v15; // eax@24
  char *v16; // eax@27
  char *v17; // eax@30
  char *v18; // eax@33
  char *v19; // eax@36
  char *v20; // eax@39
  char *v21; // eax@42
  char *v22; // eax@45
  char *v23; // eax@48
  char *v24; // eax@51
  int v26; // [sp+Ch] [bp-44h]@1
  int v27; // [sp+10h] [bp-40h]@1
  int v28; // [sp+14h] [bp-3Ch]@1
  int v29; // [sp+18h] [bp-38h]@1
  int v30; // [sp+1Ch] [bp-34h]@1
  int v31; // [sp+20h] [bp-30h]@1
  int v32; // [sp+24h] [bp-2Ch]@1
  int v33; // [sp+28h] [bp-28h]@1
  int v34; // [sp+2Ch] [bp-24h]@1
  int v35; // [sp+30h] [bp-20h]@1
  int v36; // [sp+34h] [bp-1Ch]@1
  int v37; // [sp+38h] [bp-18h]@1
  int v38; // [sp+3Ch] [bp-14h]@1
  int v39; // [sp+40h] [bp-10h]@1
  char v40[4]; // [sp+44h] [bp-Ch]@1
  int v41; // [sp+48h] [bp-8h]@2
  char *Str; // [sp+4Ch] [bp-4h]@2

  v2 = "mom_kin_4th_axis_plane";
  v26 = (int)"mom_kin_4th_axis_direction";
  v27 = (int)"mom_kin_4th_axis_rotation";
  v28 = (int)"mom_kin_4th_axis_min_incr";
  v29 = (int)"mom_kin_4th_axis_min_limit";
  v30 = (int)"mom_kin_4th_axis_max_limit";
  v31 = (int)"mom_kin_4th_axis_zero";
  v32 = (int)"mom_kin_4th_axis_center_offset_x";
  v33 = (int)"mom_kin_4th_axis_center_offset_y";
  v34 = (int)"mom_kin_4th_axis_center_offset_z";
  v35 = (int)"mom_kin_4th_axis_vector_i";
  v36 = (int)"mom_kin_4th_axis_vector_j";
  v37 = (int)"mom_kin_4th_axis_vector_k";
  v38 = (int)"mom_kin_4th_axis_angles_a1";
  v39 = (int)"mom_kin_4th_axis_angles_a2";
  *(_DWORD *)v40 = "END";
  for ( i = 0; strcmp(v2, "END"); ++i )
  {
    v41 = UF_MOM_ask_string(a1, v2 + 4, &Str);
    switch ( i )
    {
      case 0:
        v4 = Str;
        if ( !Str )
        {
          v4 = "YZ";
          Str = "YZ";
        }
        v5 = a2 - (_DWORD)v4;
        do
        {
          v6 = *v4;
          v4[v5] = *v4;
          ++v4;
        }
        while ( v6 );
        break;
      case 1:
        v7 = Str;
        if ( !Str )
        {
          v7 = "MAGNITUDE_DETERMINES_DIRECTION";
          Str = "MAGNITUDE_DETERMINES_DIRECTION";
        }
        v8 = a2 - (_DWORD)v7 + 133;
        do
        {
          v9 = *v7;
          v7[v8] = *v7;
          ++v7;
        }
        while ( v9 );
        break;
      case 2:
        v10 = Str;
        if ( !Str )
        {
          v10 = "STANDARD";
          Str = "STANDARD";
        }
        v11 = a2 - (_DWORD)v10 + 266;
        do
        {
          v12 = *v10;
          v10[v11] = *v10;
          ++v10;
        }
        while ( v12 );
        break;
      case 3:
        v13 = Str;
        if ( !Str )
        {
          v13 = "0.001";
          Str = "0.001";
        }
        *(double *)(a2 + 400) = strtod(v13, 0);
        break;
      case 4:
        v14 = Str;
        if ( !Str )
        {
          v14 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 408) = strtod(v14, 0);
        break;
      case 5:
        v15 = Str;
        if ( !Str )
        {
          v15 = "360.0";
          Str = "360.0";
        }
        *(double *)(a2 + 416) = strtod(v15, 0);
        break;
      case 6:
        v16 = Str;
        if ( !Str )
        {
          v16 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 424) = strtod(v16, 0);
        break;
      case 7:
        v17 = Str;
        if ( !Str )
        {
          v17 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 432) = strtod(v17, 0);
        break;
      case 8:
        v18 = Str;
        if ( !Str )
        {
          v18 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 440) = strtod(v18, 0);
        break;
      case 9:
        v19 = Str;
        if ( !Str )
        {
          v19 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 448) = strtod(v19, 0);
        break;
      case 10:
        v20 = Str;
        if ( !Str )
        {
          v20 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 456) = strtod(v20, 0);
        break;
      case 11:
        v21 = Str;
        if ( !Str )
        {
          v21 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 464) = strtod(v21, 0);
        break;
      case 12:
        v22 = Str;
        if ( !Str )
        {
          v22 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 472) = strtod(v22, 0);
        break;
      case 13:
        v23 = Str;
        if ( !Str )
        {
          v23 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 480) = strtod(v23, 0);
        break;
      case 14:
        v24 = Str;
        if ( !Str )
        {
          v24 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 488) = strtod(v24, 0);
        break;
      default:
        break;
    }
    v2 = (const char *)*(&v26 + i);
  }
  return v41;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10005BE0) --------------------------------------------------------
int __cdecl sub_10005BE0(int a1, int a2)
{
  const char *v2; // esi@1
  int i; // ebx@1
  char *v4; // eax@3
  int v5; // edx@5
  char v6; // cl@6
  char *v7; // eax@8
  int v8; // edx@10
  char v9; // cl@11
  char *v10; // eax@13
  int v11; // edx@15
  char v12; // cl@16
  char *v13; // eax@18
  char *v14; // eax@21
  char *v15; // eax@24
  char *v16; // eax@27
  char *v17; // eax@30
  char *v18; // eax@33
  char *v19; // eax@36
  char *v20; // eax@39
  char *v21; // eax@42
  char *v22; // eax@45
  char *v23; // eax@48
  char *v24; // eax@51
  int v26; // [sp+Ch] [bp-44h]@1
  int v27; // [sp+10h] [bp-40h]@1
  int v28; // [sp+14h] [bp-3Ch]@1
  int v29; // [sp+18h] [bp-38h]@1
  int v30; // [sp+1Ch] [bp-34h]@1
  int v31; // [sp+20h] [bp-30h]@1
  int v32; // [sp+24h] [bp-2Ch]@1
  int v33; // [sp+28h] [bp-28h]@1
  int v34; // [sp+2Ch] [bp-24h]@1
  int v35; // [sp+30h] [bp-20h]@1
  int v36; // [sp+34h] [bp-1Ch]@1
  int v37; // [sp+38h] [bp-18h]@1
  int v38; // [sp+3Ch] [bp-14h]@1
  int v39; // [sp+40h] [bp-10h]@1
  char v40[4]; // [sp+44h] [bp-Ch]@1
  int v41; // [sp+48h] [bp-8h]@2
  char *Str; // [sp+4Ch] [bp-4h]@2

  v2 = "mom_kin_5th_axis_plane";
  v26 = (int)"mom_kin_5th_axis_direction";
  v27 = (int)"mom_kin_5th_axis_rotation";
  v28 = (int)"mom_kin_5th_axis_min_incr";
  v29 = (int)"mom_kin_5th_axis_min_limit";
  v30 = (int)"mom_kin_5th_axis_max_limit";
  v31 = (int)"mom_kin_5th_axis_zero";
  v32 = (int)"mom_kin_5th_axis_center_offset_x";
  v33 = (int)"mom_kin_5th_axis_center_offset_y";
  v34 = (int)"mom_kin_5th_axis_center_offset_z";
  v35 = (int)"mom_kin_5th_axis_vector_i";
  v36 = (int)"mom_kin_5th_axis_vector_j";
  v37 = (int)"mom_kin_5th_axis_vector_k";
  v38 = (int)"mom_kin_5th_axis_angles_a1";
  v39 = (int)"mom_kin_5th_axis_angles_a2";
  *(_DWORD *)v40 = "END";
  for ( i = 0; strcmp(v2, "END"); ++i )
  {
    v41 = UF_MOM_ask_string(a1, v2 + 4, &Str);
    switch ( i )
    {
      case 0:
        v4 = Str;
        if ( !Str )
        {
          v4 = "YZ";
          Str = "YZ";
        }
        v5 = a2 - (_DWORD)v4;
        do
        {
          v6 = *v4;
          v4[v5] = *v4;
          ++v4;
        }
        while ( v6 );
        break;
      case 1:
        v7 = Str;
        if ( !Str )
        {
          v7 = "MAGNITUDE_DETERMINES_DIRECTION";
          Str = "MAGNITUDE_DETERMINES_DIRECTION";
        }
        v8 = a2 - (_DWORD)v7 + 133;
        do
        {
          v9 = *v7;
          v7[v8] = *v7;
          ++v7;
        }
        while ( v9 );
        break;
      case 2:
        v10 = Str;
        if ( !Str )
        {
          v10 = "STANDARD";
          Str = "STANDARD";
        }
        v11 = a2 - (_DWORD)v10 + 266;
        do
        {
          v12 = *v10;
          v10[v11] = *v10;
          ++v10;
        }
        while ( v12 );
        break;
      case 3:
        v13 = Str;
        if ( !Str )
        {
          v13 = "0.001";
          Str = "0.001";
        }
        *(double *)(a2 + 400) = strtod(v13, 0);
        break;
      case 4:
        v14 = Str;
        if ( !Str )
        {
          v14 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 408) = strtod(v14, 0);
        break;
      case 5:
        v15 = Str;
        if ( !Str )
        {
          v15 = "360.0";
          Str = "360.0";
        }
        *(double *)(a2 + 416) = strtod(v15, 0);
        break;
      case 6:
        v16 = Str;
        if ( !Str )
        {
          v16 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 424) = strtod(v16, 0);
        break;
      case 7:
        v17 = Str;
        if ( !Str )
        {
          v17 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 432) = strtod(v17, 0);
        break;
      case 8:
        v18 = Str;
        if ( !Str )
        {
          v18 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 440) = strtod(v18, 0);
        break;
      case 9:
        v19 = Str;
        if ( !Str )
        {
          v19 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 448) = strtod(v19, 0);
        break;
      case 10:
        v20 = Str;
        if ( !Str )
        {
          v20 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 456) = strtod(v20, 0);
        break;
      case 11:
        v21 = Str;
        if ( !Str )
        {
          v21 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 464) = strtod(v21, 0);
        break;
      case 12:
        v22 = Str;
        if ( !Str )
        {
          v22 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 472) = strtod(v22, 0);
        break;
      case 13:
        v23 = Str;
        if ( !Str )
        {
          v23 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 480) = strtod(v23, 0);
        break;
      case 14:
        v24 = Str;
        if ( !Str )
        {
          v24 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 488) = strtod(v24, 0);
        break;
      default:
        break;
    }
    v2 = (const char *)*(&v26 + i);
  }
  return v41;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10005F50) --------------------------------------------------------
int __cdecl sub_10005F50(int a1, int a2)
{
  const char *v2; // esi@1
  int i; // edi@1
  char *v4; // eax@5
  char *v5; // eax@8
  char *v6; // eax@11
  int v7; // edx@13
  char v8; // cl@14
  int v10; // [sp+Ch] [bp-14h]@1
  int v11; // [sp+10h] [bp-10h]@1
  char v12[4]; // [sp+14h] [bp-Ch]@1
  int v13; // [sp+18h] [bp-8h]@2
  char *Str; // [sp+1Ch] [bp-4h]@2

  v2 = "mom_kin_independent_head";
  v10 = (int)"mom_kin_ind_to_dependent_head_x";
  v11 = (int)"mom_kin_ind_to_dependent_head_z";
  *(_DWORD *)v12 = "END";
  for ( i = 0; strcmp(v2, "END"); ++i )
  {
    v13 = UF_MOM_ask_string(a1, v2 + 4, &Str);
    if ( i )
    {
      if ( i == 1 )
      {
        v5 = Str;
        if ( !Str )
        {
          v5 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 136) = strtod(v5, 0);
      }
      else
      {
        if ( i == 2 )
        {
          v4 = Str;
          if ( !Str )
          {
            v4 = "0.0";
            Str = "0.0";
          }
          *(double *)(a2 + 144) = strtod(v4, 0);
        }
      }
    }
    else
    {
      v6 = Str;
      if ( !Str )
      {
        v6 = "FRONT";
        Str = "FRONT";
      }
      v7 = a2 - (_DWORD)v6;
      do
      {
        v8 = *v6;
        v6[v7] = *v6;
        ++v6;
      }
      while ( v8 );
    }
    v2 = (const char *)*(&v10 + i);
  }
  return v13;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10006080) --------------------------------------------------------
int __cdecl sub_10006080(int a1, int a2)
{
  const char *v2; // esi@1
  int i; // edi@1
  char *v4; // eax@5
  char *v5; // eax@8
  char *v6; // eax@11
  int v8; // [sp+Ch] [bp-14h]@1
  int v9; // [sp+10h] [bp-10h]@1
  char v10[4]; // [sp+14h] [bp-Ch]@1
  int v11; // [sp+18h] [bp-8h]@2
  char *Str; // [sp+1Ch] [bp-4h]@2

  v2 = "mom_kin_tool_change_time";
  v8 = (int)"mom_kin_clamp_time";
  v9 = (int)"mom_kin_flush_time";
  *(_DWORD *)v10 = "END";
  for ( i = 0; strcmp(v2, "END"); ++i )
  {
    v11 = UF_MOM_ask_string(a1, v2 + 4, &Str);
    if ( i )
    {
      if ( i == 1 )
      {
        v5 = Str;
        if ( !Str )
        {
          v5 = "0.5";
          Str = "0.5";
        }
        *(double *)(a2 + 8) = strtod(v5, 0);
      }
      else
      {
        if ( i == 2 )
        {
          v4 = Str;
          if ( !Str )
          {
            v4 = "0.5";
            Str = "0.5";
          }
          *(double *)(a2 + 16) = strtod(v4, 0);
        }
      }
    }
    else
    {
      v6 = Str;
      if ( !Str )
      {
        v6 = "3.0";
        Str = "3.0";
      }
      *(double *)a2 = strtod(v6, 0);
    }
    v2 = (const char *)*(&v8 + i);
  }
  return v11;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (100061B0) --------------------------------------------------------
int __cdecl sub_100061B0(int a1, int a2)
{
  const char *v2; // esi@1
  int i; // ebx@1
  char *v4; // eax@3
  int v5; // edx@5
  char v6; // cl@6
  char *v7; // eax@8
  int v8; // edx@10
  char v9; // cl@11
  char *v10; // eax@13
  int v11; // edx@15
  char v12; // cl@16
  char *v13; // eax@18
  int v14; // edx@20
  char v15; // cl@21
  char *v16; // eax@23
  int v17; // edx@25
  char v18; // cl@26
  char *v19; // eax@28
  int v20; // edx@30
  char v21; // cl@31
  char *v22; // eax@33
  char *v23; // eax@36
  char *v24; // eax@39
  char *v25; // eax@42
  char *v26; // eax@45
  char *v27; // eax@48
  char *v28; // eax@51
  char *v29; // eax@54
  char *v30; // eax@57
  char *v31; // eax@60
  char *v32; // eax@63
  char *v33; // eax@66
  char *v34; // eax@69
  char *v35; // eax@72
  char *v36; // eax@75
  char *v37; // eax@78
  char *v38; // eax@81
  char *v39; // eax@84
  int v41; // [sp+Ch] [bp-68h]@1
  int v42; // [sp+10h] [bp-64h]@1
  int v43; // [sp+14h] [bp-60h]@1
  int v44; // [sp+18h] [bp-5Ch]@1
  int v45; // [sp+1Ch] [bp-58h]@1
  int v46; // [sp+20h] [bp-54h]@1
  int v47; // [sp+24h] [bp-50h]@1
  int v48; // [sp+28h] [bp-4Ch]@1
  int v49; // [sp+2Ch] [bp-48h]@1
  int v50; // [sp+30h] [bp-44h]@1
  int v51; // [sp+34h] [bp-40h]@1
  int v52; // [sp+38h] [bp-3Ch]@1
  int v53; // [sp+3Ch] [bp-38h]@1
  int v54; // [sp+40h] [bp-34h]@1
  int v55; // [sp+44h] [bp-30h]@1
  int v56; // [sp+48h] [bp-2Ch]@1
  int v57; // [sp+4Ch] [bp-28h]@1
  int v58; // [sp+50h] [bp-24h]@1
  int v59; // [sp+54h] [bp-20h]@1
  int v60; // [sp+58h] [bp-1Ch]@1
  int v61; // [sp+5Ch] [bp-18h]@1
  int v62; // [sp+60h] [bp-14h]@1
  int v63; // [sp+64h] [bp-10h]@1
  char v64[4]; // [sp+68h] [bp-Ch]@1
  int v65; // [sp+6Ch] [bp-8h]@2
  char *Str; // [sp+70h] [bp-4h]@2

  v2 = "mom_kin_holder1_orientation";
  v41 = (int)"mom_kin_holder2_orientation";
  v42 = (int)"mom_kin_holder3_orientation";
  v43 = (int)"mom_kin_holder4_orientation";
  v44 = (int)"mom_kin_holder5_orientation";
  v45 = (int)"mom_kin_holder6_orientation";
  v46 = (int)"mom_kin_holder1_offset_x";
  v47 = (int)"mom_kin_holder1_offset_y";
  v48 = (int)"mom_kin_holder1_offset_z";
  v49 = (int)"mom_kin_holder2_offset_x";
  v50 = (int)"mom_kin_holder2_offset_y";
  v51 = (int)"mom_kin_holder2_offset_z";
  v52 = (int)"mom_kin_holder3_offset_x";
  v53 = (int)"mom_kin_holder3_offset_y";
  v54 = (int)"mom_kin_holder3_offset_z";
  v55 = (int)"mom_kin_holder4_offset_x";
  v56 = (int)"mom_kin_holder4_offset_y";
  v57 = (int)"mom_kin_holder4_offset_z";
  v58 = (int)"mom_kin_holder5_offset_x";
  v59 = (int)"mom_kin_holder5_offset_y";
  v60 = (int)"mom_kin_holder5_offset_z";
  v61 = (int)"mom_kin_holder6_offset_x";
  v62 = (int)"mom_kin_holder6_offset_y";
  v63 = (int)"mom_kin_holder6_offset_z";
  *(_DWORD *)v64 = "END";
  for ( i = 0; strcmp(v2, "END"); ++i )
  {
    v65 = UF_MOM_ask_string(a1, v2 + 4, &Str);
    switch ( i )
    {
      case 0:
        v4 = Str;
        if ( !Str )
        {
          v4 = "POSZ";
          Str = "POSZ";
        }
        v5 = a2 - (_DWORD)v4;
        do
        {
          v6 = *v4;
          v4[v5] = *v4;
          ++v4;
        }
        while ( v6 );
        break;
      case 1:
        v7 = Str;
        if ( !Str )
        {
          v7 = "POSZ";
          Str = "POSZ";
        }
        v8 = a2 - (_DWORD)v7 + 133;
        do
        {
          v9 = *v7;
          v7[v8] = *v7;
          ++v7;
        }
        while ( v9 );
        break;
      case 2:
        v10 = Str;
        if ( !Str )
        {
          v10 = "POSZ";
          Str = "POSZ";
        }
        v11 = a2 - (_DWORD)v10 + 266;
        do
        {
          v12 = *v10;
          v10[v11] = *v10;
          ++v10;
        }
        while ( v12 );
        break;
      case 3:
        v13 = Str;
        if ( !Str )
        {
          v13 = "POSZ";
          Str = "POSZ";
        }
        v14 = a2 - (_DWORD)v13 + 399;
        do
        {
          v15 = *v13;
          v13[v14] = *v13;
          ++v13;
        }
        while ( v15 );
        break;
      case 4:
        v16 = Str;
        if ( !Str )
        {
          v16 = "POSZ";
          Str = "POSZ";
        }
        v17 = a2 - (_DWORD)v16 + 532;
        do
        {
          v18 = *v16;
          v16[v17] = *v16;
          ++v16;
        }
        while ( v18 );
        break;
      case 5:
        v19 = Str;
        if ( !Str )
        {
          v19 = "POSZ";
          Str = "POSZ";
        }
        v20 = a2 - (_DWORD)v19 + 665;
        do
        {
          v21 = *v19;
          v19[v20] = *v19;
          ++v19;
        }
        while ( v21 );
        break;
      case 6:
        v22 = Str;
        if ( !Str )
        {
          v22 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 800) = strtod(v22, 0);
        break;
      case 7:
        v23 = Str;
        if ( !Str )
        {
          v23 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 808) = strtod(v23, 0);
        break;
      case 8:
        v24 = Str;
        if ( !Str )
        {
          v24 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 816) = strtod(v24, 0);
        break;
      case 9:
        v25 = Str;
        if ( !Str )
        {
          v25 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 824) = strtod(v25, 0);
        break;
      case 10:
        v26 = Str;
        if ( !Str )
        {
          v26 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 832) = strtod(v26, 0);
        break;
      case 11:
        v27 = Str;
        if ( !Str )
        {
          v27 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 840) = strtod(v27, 0);
        break;
      case 12:
        v28 = Str;
        if ( !Str )
        {
          v28 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 848) = strtod(v28, 0);
        break;
      case 13:
        v29 = Str;
        if ( !Str )
        {
          v29 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 856) = strtod(v29, 0);
        break;
      case 14:
        v30 = Str;
        if ( !Str )
        {
          v30 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 864) = strtod(v30, 0);
        break;
      case 15:
        v31 = Str;
        if ( !Str )
        {
          v31 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 872) = strtod(v31, 0);
        break;
      case 16:
        v32 = Str;
        if ( !Str )
        {
          v32 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 880) = strtod(v32, 0);
        break;
      case 17:
        v33 = Str;
        if ( !Str )
        {
          v33 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 888) = strtod(v33, 0);
        break;
      case 18:
        v34 = Str;
        if ( !Str )
        {
          v34 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 896) = strtod(v34, 0);
        break;
      case 19:
        v35 = Str;
        if ( !Str )
        {
          v35 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 904) = strtod(v35, 0);
        break;
      case 20:
        v36 = Str;
        if ( !Str )
        {
          v36 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 912) = strtod(v36, 0);
        break;
      case 21:
        v37 = Str;
        if ( !Str )
        {
          v37 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 920) = strtod(v37, 0);
        break;
      case 22:
        v38 = Str;
        if ( !Str )
        {
          v38 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 928) = strtod(v38, 0);
        break;
      case 23:
        v39 = Str;
        if ( !Str )
        {
          v39 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 936) = strtod(v39, 0);
        break;
      default:
        break;
    }
    v2 = (const char *)*(&v41 + i);
  }
  return v65;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (100066D0) --------------------------------------------------------
int __cdecl sub_100066D0(int a1, int a2)
{
  const char *v2; // esi@1
  int v3; // edi@1
  char *v4; // eax@3
  int v5; // edx@5
  char v6; // cl@6
  char *v7; // eax@8
  int v8; // edx@10
  char v9; // cl@11
  char *v10; // eax@13
  int v11; // edx@15
  char v12; // cl@16
  char *v13; // eax@18
  int v14; // edx@20
  char v15; // cl@21
  char *v16; // eax@23
  int v17; // edx@25
  char v18; // cl@26
  char *v19; // eax@28
  int v20; // edx@30
  char v21; // cl@31
  char *v22; // eax@33
  char *v23; // eax@36
  char *v24; // eax@39
  char *v25; // eax@42
  char *v26; // ecx@45
  int v27; // eax@46
  char *v28; // ecx@50
  int v29; // eax@51
  char *v30; // ecx@55
  int v31; // eax@56
  char v33; // [sp+8h] [bp-98h]@51
  char v34; // [sp+24h] [bp-7Ch]@56
  char v35; // [sp+40h] [bp-60h]@46
  int v36; // [sp+5Ch] [bp-44h]@1
  int v37; // [sp+60h] [bp-40h]@1
  int v38; // [sp+64h] [bp-3Ch]@1
  int v39; // [sp+68h] [bp-38h]@1
  int v40; // [sp+6Ch] [bp-34h]@1
  int v41; // [sp+70h] [bp-30h]@1
  int v42; // [sp+74h] [bp-2Ch]@1
  int v43; // [sp+78h] [bp-28h]@1
  int v44; // [sp+7Ch] [bp-24h]@1
  int v45; // [sp+80h] [bp-20h]@1
  int v46; // [sp+84h] [bp-1Ch]@1
  int v47; // [sp+88h] [bp-18h]@1
  int v48; // [sp+8Ch] [bp-14h]@1
  char v49[4]; // [sp+90h] [bp-10h]@1
  int v50; // [sp+94h] [bp-Ch]@2
  int i; // [sp+98h] [bp-8h]@1
  char *Str; // [sp+9Ch] [bp-4h]@2

  v2 = "mom_kin_machine_type";
  v3 = 0;
  v46 = (int)"mom_kin_gauge_to_pivot_x";
  v48 = (int)"mom_kin_gauge_to_pivot_x";
  v36 = (int)"mom_kin_machine_type";
  v37 = (int)"mom_kin_track_center_of_ball";
  v38 = (int)"mom_kin_wire_tilt_output_type";
  v39 = (int)"mom_kin_clsf_generation";
  v40 = (int)"mom_kin_coordinate_type";
  v41 = (int)"mom_kin_linearization_flag";
  v42 = (int)"mom_kin_machine_resolution";
  v43 = (int)"mom_kin_tool_tracking_height";
  v44 = (int)"mom_kin_5th_axis_inclination_to_4th";
  v45 = (int)"mom_kin_linearization_tol";
  v47 = (int)"mom_kin_gauge_to_pivot_y";
  *(_DWORD *)v49 = "END";
  for ( i = 0; strcmp(v2, "END"); ++i )
  {
    v50 = UF_MOM_ask_string(a1, v2 + 4, &Str);
    switch ( v3 )
    {
      case 0:
        v4 = Str;
        if ( !Str )
        {
          v4 = "3_axis_mill";
          Str = "3_axis_mill";
        }
        v5 = a2 - (_DWORD)v4;
        do
        {
          v6 = *v4;
          v4[v5] = *v4;
          ++v4;
        }
        while ( v6 );
        break;
      case 1:
        v7 = Str;
        if ( !Str )
        {
          v7 = "T";
          Str = "T";
        }
        v8 = a2 - (_DWORD)v7 + 133;
        do
        {
          v9 = *v7;
          v7[v8] = *v7;
          ++v7;
        }
        while ( v9 );
        break;
      case 2:
        v10 = Str;
        if ( !Str )
        {
          v10 = "NONE";
          Str = "NONE";
        }
        v11 = a2 - (_DWORD)v10 + 266;
        do
        {
          v12 = *v10;
          v10[v11] = *v10;
          ++v10;
        }
        while ( v12 );
        break;
      case 3:
        v13 = Str;
        if ( !Str )
        {
          v13 = "F";
          Str = "F";
        }
        v14 = a2 - (_DWORD)v13 + 399;
        do
        {
          v15 = *v13;
          v13[v14] = *v13;
          ++v13;
        }
        while ( v15 );
        break;
      case 4:
        v16 = Str;
        if ( !Str )
        {
          v16 = "CARTESIAN";
          Str = "CARTESIAN";
        }
        v17 = a2 - (_DWORD)v16 + 532;
        do
        {
          v18 = *v16;
          v16[v17] = *v16;
          ++v16;
        }
        while ( v18 );
        break;
      case 5:
        v19 = Str;
        if ( !Str )
        {
          v19 = "F";
          Str = "F";
        }
        v20 = a2 - (_DWORD)v19 + 665;
        do
        {
          v21 = *v19;
          v19[v20] = *v19;
          ++v19;
        }
        while ( v21 );
        break;
      case 6:
        v22 = Str;
        if ( !Str )
        {
          v22 = "0.0001";
          Str = "0.0001";
        }
        *(double *)(a2 + 800) = strtod(v22, 0);
        break;
      case 7:
        v23 = Str;
        if ( !Str )
        {
          v23 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 808) = strtod(v23, 0);
        break;
      case 8:
        v24 = Str;
        if ( !Str )
        {
          v24 = "90.0";
          Str = "90.0";
        }
        *(double *)(a2 + 816) = strtod(v24, 0);
        break;
      case 9:
        v25 = Str;
        if ( !Str )
        {
          v25 = "0.0001";
          Str = "0.0001";
        }
        *(double *)(a2 + 824) = strtod(v25, 0);
        break;
      case 10:
        v26 = Str;
        if ( !Str )
        {
          memcpy(&v35, "kin_4th_to_tracking_point_x", 0x1Cu);
          v27 = sub_10005310((int)&v35, a1, 0);
          v26 = Str;
          if ( !Str || v27 )
          {
            v26 = "0.0";
            Str = "0.0";
          }
        }
        *(double *)(a2 + 832) = strtod(v26, 0);
        break;
      case 11:
        v28 = Str;
        if ( !Str )
        {
          memcpy(&v33, "kin_4th_to_tracking_point_y", 0x1Cu);
          v29 = sub_10005310((int)&v33, a1, 0);
          v28 = Str;
          if ( !Str || v29 )
          {
            v28 = "0.0";
            Str = "0.0";
          }
        }
        *(double *)(a2 + 840) = strtod(v28, 0);
        break;
      case 12:
        v30 = Str;
        if ( !Str )
        {
          memcpy(&v34, "kin_4th_to_tracking_point_z", 0x1Cu);
          v31 = sub_10005310((int)&v34, a1, 0);
          v30 = Str;
          if ( !Str || v31 )
          {
            v30 = "0.0";
            Str = "0.0";
          }
        }
        *(double *)(a2 + 848) = strtod(v30, 0);
        break;
      default:
        break;
    }
    v2 = (const char *)*(&v37 + i);
    v3 = i + 1;
  }
  return v50;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10006A80) --------------------------------------------------------
int __cdecl sub_10006A80(int a1, int a2)
{
  const char *v2; // esi@1
  int i; // ebx@1
  char *v4; // eax@3
  char *v5; // eax@6
  char *v6; // eax@9
  char *v7; // eax@12
  char *v8; // eax@15
  char *v9; // eax@18
  char *v10; // eax@21
  char *v11; // eax@24
  char *v12; // eax@27
  char *v13; // eax@30
  char *v14; // eax@33
  char *v15; // eax@36
  int v17; // [sp+Ch] [bp-38h]@1
  int v18; // [sp+10h] [bp-34h]@1
  int v19; // [sp+14h] [bp-30h]@1
  int v20; // [sp+18h] [bp-2Ch]@1
  int v21; // [sp+1Ch] [bp-28h]@1
  int v22; // [sp+20h] [bp-24h]@1
  int v23; // [sp+24h] [bp-20h]@1
  int v24; // [sp+28h] [bp-1Ch]@1
  int v25; // [sp+2Ch] [bp-18h]@1
  int v26; // [sp+30h] [bp-14h]@1
  int v27; // [sp+34h] [bp-10h]@1
  char v28[4]; // [sp+38h] [bp-Ch]@1
  int v29; // [sp+3Ch] [bp-8h]@2
  char *Str; // [sp+40h] [bp-4h]@2

  v2 = "mom_msys_origin_x";
  v17 = (int)"mom_msys_origin_y";
  v18 = (int)"mom_msys_origin_z";
  v19 = (int)"mom_msys_x_axis_i";
  v20 = (int)"mom_msys_x_axis_j";
  v21 = (int)"mom_msys_x_axis_k";
  v22 = (int)"mom_msys_y_axis_i";
  v23 = (int)"mom_msys_y_axis_j";
  v24 = (int)"mom_msys_y_axis_k";
  v25 = (int)"mom_msys_z_axis_i";
  v26 = (int)"mom_msys_z_axis_j";
  v27 = (int)"mom_msys_z_axis_k";
  *(_DWORD *)v28 = "END";
  for ( i = 0; strcmp(v2, "END"); ++i )
  {
    v29 = UF_MOM_ask_string(a1, v2 + 4, &Str);
    switch ( i )
    {
      case 0:
        v4 = Str;
        if ( !Str )
        {
          v4 = "0.0";
          Str = "0.0";
        }
        *(double *)a2 = strtod(v4, 0);
        break;
      case 1:
        v5 = Str;
        if ( !Str )
        {
          v5 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 8) = strtod(v5, 0);
        break;
      case 2:
        v6 = Str;
        if ( !Str )
        {
          v6 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 16) = strtod(v6, 0);
        break;
      case 3:
        v7 = Str;
        if ( !Str )
        {
          v7 = "1.0";
          Str = "1.0";
        }
        *(double *)(a2 + 24) = strtod(v7, 0);
        break;
      case 4:
        v8 = Str;
        if ( !Str )
        {
          v8 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 32) = strtod(v8, 0);
        break;
      case 5:
        v9 = Str;
        if ( !Str )
        {
          v9 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 40) = strtod(v9, 0);
        break;
      case 6:
        v10 = Str;
        if ( !Str )
        {
          v10 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 48) = strtod(v10, 0);
        break;
      case 7:
        v11 = Str;
        if ( !Str )
        {
          v11 = "1.0";
          Str = "1.0";
        }
        *(double *)(a2 + 56) = strtod(v11, 0);
        break;
      case 8:
        v12 = Str;
        if ( !Str )
        {
          v12 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 64) = strtod(v12, 0);
        break;
      case 9:
        v13 = Str;
        if ( !Str )
        {
          v13 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 72) = strtod(v13, 0);
        break;
      case 10:
        v14 = Str;
        if ( !Str )
        {
          v14 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 80) = strtod(v14, 0);
        break;
      case 11:
        v15 = Str;
        if ( !Str )
        {
          v15 = "1.0";
          Str = "1.0";
        }
        *(double *)(a2 + 88) = strtod(v15, 0);
        break;
      default:
        break;
    }
    v2 = (const char *)*(&v17 + i);
  }
  return v29;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10006D30) --------------------------------------------------------
int __cdecl sub_10006D30(int a1, int a2)
{
  const char *v2; // esi@1
  int i; // ebx@1
  char *v4; // eax@3
  char *v5; // eax@6
  char *v6; // eax@9
  char *v7; // eax@12
  char *v8; // eax@15
  char *v9; // eax@18
  char *v10; // eax@21
  char *v11; // eax@24
  char *v12; // eax@27
  char *v13; // eax@30
  char *v14; // eax@33
  char *v15; // eax@36
  int v17; // [sp+Ch] [bp-38h]@1
  int v18; // [sp+10h] [bp-34h]@1
  int v19; // [sp+14h] [bp-30h]@1
  int v20; // [sp+18h] [bp-2Ch]@1
  int v21; // [sp+1Ch] [bp-28h]@1
  int v22; // [sp+20h] [bp-24h]@1
  int v23; // [sp+24h] [bp-20h]@1
  int v24; // [sp+28h] [bp-1Ch]@1
  int v25; // [sp+2Ch] [bp-18h]@1
  int v26; // [sp+30h] [bp-14h]@1
  int v27; // [sp+34h] [bp-10h]@1
  char v28[4]; // [sp+38h] [bp-Ch]@1
  int v29; // [sp+3Ch] [bp-8h]@2
  char *Str; // [sp+40h] [bp-4h]@2

  v2 = "mom_mtsys_origin_x";
  v17 = (int)"mom_mtsys_origin_y";
  v18 = (int)"mom_mtsys_origin_z";
  v19 = (int)"mom_mtsys_x_axis_i";
  v20 = (int)"mom_mtsys_x_axis_j";
  v21 = (int)"mom_mtsys_x_axis_k";
  v22 = (int)"mom_mtsys_y_axis_i";
  v23 = (int)"mom_mtsys_y_axis_j";
  v24 = (int)"mom_mtsys_y_axis_k";
  v25 = (int)"mom_mtsys_z_axis_i";
  v26 = (int)"mom_mtsys_z_axis_j";
  v27 = (int)"mom_mtsys_z_axis_k";
  *(_DWORD *)v28 = "END";
  for ( i = 0; strcmp(v2, "END"); ++i )
  {
    v29 = UF_MOM_ask_string(a1, v2 + 4, &Str);
    switch ( i )
    {
      case 0:
        v4 = Str;
        if ( !Str )
        {
          v4 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 96) = strtod(v4, 0);
        break;
      case 1:
        v5 = Str;
        if ( !Str )
        {
          v5 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 104) = strtod(v5, 0);
        break;
      case 2:
        v6 = Str;
        if ( !Str )
        {
          v6 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 112) = strtod(v6, 0);
        break;
      case 3:
        v7 = Str;
        if ( !Str )
        {
          v7 = "1.0";
          Str = "1.0";
        }
        *(double *)(a2 + 120) = strtod(v7, 0);
        break;
      case 4:
        v8 = Str;
        if ( !Str )
        {
          v8 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 128) = strtod(v8, 0);
        break;
      case 5:
        v9 = Str;
        if ( !Str )
        {
          v9 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 136) = strtod(v9, 0);
        break;
      case 6:
        v10 = Str;
        if ( !Str )
        {
          v10 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 144) = strtod(v10, 0);
        break;
      case 7:
        v11 = Str;
        if ( !Str )
        {
          v11 = "1.0";
          Str = "1.0";
        }
        *(double *)(a2 + 152) = strtod(v11, 0);
        break;
      case 8:
        v12 = Str;
        if ( !Str )
        {
          v12 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 160) = strtod(v12, 0);
        break;
      case 9:
        v13 = Str;
        if ( !Str )
        {
          v13 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 168) = strtod(v13, 0);
        break;
      case 10:
        v14 = Str;
        if ( !Str )
        {
          v14 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 176) = strtod(v14, 0);
        break;
      case 11:
        v15 = Str;
        if ( !Str )
        {
          v15 = "1.0";
          Str = "1.0";
        }
        *(double *)(a2 + 184) = strtod(v15, 0);
        break;
      default:
        break;
    }
    v2 = (const char *)*(&v17 + i);
  }
  return v29;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10007000) --------------------------------------------------------
int __cdecl sub_10007000(int a1, int a2)
{
  const char *v2; // esi@1
  int i; // ebx@1
  char *v4; // eax@3
  char *v5; // eax@6
  char *v6; // eax@9
  char *v7; // eax@12
  char *v8; // eax@15
  char *v9; // eax@18
  char *v10; // eax@21
  int v11; // edx@23
  char v12; // cl@24
  char *v13; // eax@26
  char *v14; // eax@29
  int v16; // [sp+Ch] [bp-28h]@1
  int v17; // [sp+10h] [bp-24h]@1
  int v18; // [sp+14h] [bp-20h]@1
  int v19; // [sp+18h] [bp-1Ch]@1
  int v20; // [sp+1Ch] [bp-18h]@1
  int v21; // [sp+20h] [bp-14h]@1
  int v22; // [sp+24h] [bp-10h]@1
  int v23; // [sp+28h] [bp-Ch]@1
  char v24[4]; // [sp+2Ch] [bp-8h]@1
  char *Str; // [sp+30h] [bp-4h]@2

  v2 = "mom_origin_x";
  v16 = (int)"mom_origin_y";
  v17 = (int)"mom_origin_z";
  v18 = (int)"mom_translate_x";
  v19 = (int)"mom_translate_y";
  v20 = (int)"mom_translate_z";
  v21 = (int)"mom_tool_type";
  v22 = (int)"mom_tool_z_offset";
  v23 = (int)"mom_tool_corner1_radius";
  *(_DWORD *)v24 = "END";
  for ( i = 0; strcmp(v2, "END"); ++i )
  {
    UF_MOM_ask_string(a1, v2 + 4, &Str);
    switch ( i )
    {
      case 0:
        v4 = Str;
        if ( !Str )
        {
          v4 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 216) = strtod(v4, 0);
        break;
      case 1:
        v5 = Str;
        if ( !Str )
        {
          v5 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 224) = strtod(v5, 0);
        break;
      case 2:
        v6 = Str;
        if ( !Str )
        {
          v6 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 232) = strtod(v6, 0);
        break;
      case 3:
        v7 = Str;
        if ( !Str )
        {
          v7 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 192) = strtod(v7, 0);
        break;
      case 4:
        v8 = Str;
        if ( !Str )
        {
          v8 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 200) = strtod(v8, 0);
        break;
      case 5:
        v9 = Str;
        if ( !Str )
        {
          v9 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 208) = strtod(v9, 0);
        break;
      case 6:
        v10 = Str;
        if ( !Str )
        {
          v10 = "MILL";
          Str = "MILL";
        }
        v11 = a2 - (_DWORD)v10 + 240;
        do
        {
          v12 = *v10;
          v10[v11] = *v10;
          ++v10;
        }
        while ( v12 );
        break;
      case 7:
        v13 = Str;
        if ( !Str )
        {
          v13 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 376) = strtod(v13, 0);
        break;
      case 8:
        v14 = Str;
        if ( !Str )
        {
          v14 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 384) = strtod(v14, 0);
        break;
      default:
        break;
    }
    v2 = (const char *)*(&v16 + i);
  }
  return 0;
}
// 10007000: using guessed type _DWORD __cdecl sub_10007000(_DWORD, _DWORD);
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10007250) --------------------------------------------------------
int __cdecl sub_10007250(int a1, int a2)
{
  const char *v2; // esi@1
  int i; // ebx@1
  char *v4; // eax@3
  char *v5; // eax@6
  char *v6; // eax@9
  char *v7; // eax@12
  char *v8; // eax@15
  char *v9; // eax@18
  int v11; // [sp+Ch] [bp-20h]@1
  int v12; // [sp+10h] [bp-1Ch]@1
  int v13; // [sp+14h] [bp-18h]@1
  int v14; // [sp+18h] [bp-14h]@1
  int v15; // [sp+1Ch] [bp-10h]@1
  char v16[4]; // [sp+20h] [bp-Ch]@1
  int v17; // [sp+24h] [bp-8h]@2
  char *Str; // [sp+28h] [bp-4h]@2

  v2 = "mom_mcs_goto_x";
  v11 = (int)"mom_mcs_goto_y";
  v12 = (int)"mom_mcs_goto_z";
  v13 = (int)"mom_tool_axis_i";
  v14 = (int)"mom_tool_axis_j";
  v15 = (int)"mom_tool_axis_k";
  *(_DWORD *)v16 = "END";
  for ( i = 0; strcmp(v2, "END"); ++i )
  {
    v17 = UF_MOM_ask_string(a1, v2 + 4, &Str);
    switch ( i )
    {
      case 0:
        v4 = Str;
        if ( !Str )
        {
          v4 = "0.0";
          Str = "0.0";
        }
        *(double *)a2 = strtod(v4, 0);
        break;
      case 1:
        v5 = Str;
        if ( !Str )
        {
          v5 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 8) = strtod(v5, 0);
        break;
      case 2:
        v6 = Str;
        if ( !Str )
        {
          v6 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 16) = strtod(v6, 0);
        break;
      case 3:
        v7 = Str;
        if ( !Str )
        {
          v7 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 24) = strtod(v7, 0);
        break;
      case 4:
        v8 = Str;
        if ( !Str )
        {
          v8 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 32) = strtod(v8, 0);
        break;
      case 5:
        v9 = Str;
        if ( !Str )
        {
          v9 = "0.0";
          Str = "0.0";
        }
        *(double *)(a2 + 40) = strtod(v9, 0);
        break;
      default:
        break;
    }
    v2 = (const char *)*(&v11 + i);
  }
  return v17;
}
// 10007250: using guessed type _DWORD __cdecl sub_10007250(_DWORD, _DWORD);
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10007400) --------------------------------------------------------
int __cdecl sub_10007400(int a1, char *Str)
{
  const char *v2; // edi@1
  int v3; // ebx@1
  char *i; // esi@1
  const char *v5; // eax@3
  const char *v6; // eax@6
  const char *v7; // eax@9
  const char *v8; // eax@12
  const char *v9; // eax@15
  const char *v10; // eax@18
  const char *v11; // eax@21
  const char *v12; // eax@24
  const char *v13; // eax@27
  int result; // eax@31
  int v15; // [sp+10h] [bp-28h]@1
  int v16; // [sp+14h] [bp-24h]@1
  int v17; // [sp+18h] [bp-20h]@1
  int v18; // [sp+1Ch] [bp-1Ch]@1
  int v19; // [sp+20h] [bp-18h]@1
  int v20; // [sp+24h] [bp-14h]@1
  int v21; // [sp+28h] [bp-10h]@1
  int v22; // [sp+2Ch] [bp-Ch]@1
  char v23[4]; // [sp+30h] [bp-8h]@1
  int v24; // [sp+34h] [bp-4h]@2

  v2 = "mom_origin_x";
  v15 = (int)"mom_origin_y";
  v16 = (int)"mom_origin_z";
  v17 = (int)"mom_translate_x";
  v18 = (int)"mom_translate_y";
  v19 = (int)"mom_translate_z";
  v20 = (int)"mom_tool_z_offset";
  v21 = (int)"mom_kin_track_center_of_ball";
  v22 = (int)"mom_tool_corner1_radius";
  *(_DWORD *)v23 = "END";
  v3 = 0;
  for ( i = Str; strcmp(v2, "END"); ++v3 )
  {
    v24 = UF_MOM_ask_string(a1, v2 + 4, &Str);
    switch ( v3 )
    {
      case 0:
        v5 = Str;
        if ( !Str )
        {
          v5 = "0.0";
          Str = "0.0";
        }
        *(double *)i = strtod(v5, 0);
        break;
      case 1:
        v6 = Str;
        if ( !Str )
        {
          v6 = "0.0";
          Str = "0.0";
        }
        *((double *)i + 1) = strtod(v6, 0);
        break;
      case 2:
        v7 = Str;
        if ( !Str )
        {
          v7 = "0.0";
          Str = "0.0";
        }
        *((double *)i + 2) = strtod(v7, 0);
        break;
      case 3:
        v8 = Str;
        if ( !Str )
        {
          v8 = "0.0";
          Str = "0.0";
        }
        *((double *)i + 12) = strtod(v8, 0);
        break;
      case 4:
        v9 = Str;
        if ( !Str )
        {
          v9 = "0.0";
          Str = "0.0";
        }
        *((double *)i + 13) = strtod(v9, 0);
        break;
      case 5:
        v10 = Str;
        if ( !Str )
        {
          v10 = "0.0";
          Str = "0.0";
        }
        *((double *)i + 14) = strtod(v10, 0);
        break;
      case 6:
        v11 = Str;
        if ( !Str )
        {
          v11 = "0.0";
          Str = "0.0";
        }
        *((double *)i + 15) = strtod(v11, 0);
        break;
      case 7:
        v12 = Str;
        if ( !Str )
        {
          v12 = "0.0";
          Str = "0.0";
        }
        *((_DWORD *)i + 32) = (signed int)strtod(v12, 0);
        break;
      case 8:
        v13 = Str;
        if ( !Str )
        {
          v13 = "0.0";
          Str = "0.0";
        }
        *((double *)i + 17) = strtod(v13, 0);
        break;
      default:
        break;
    }
    v2 = (const char *)*(&v15 + v3);
  }
  result = v24;
  memcpy(&unk_1000C5E8, i, 0x90u);
  return result;
}
// 10009138: using guessed type int __cdecl UF_MOM_ask_string(_DWORD, _DWORD, _DWORD);

//----- (10007650) --------------------------------------------------------
int __cdecl sub_10007650(int a1, int a2)
{
  int v2; // esi@1
  int v3; // ebx@5
  double v5; // [sp+18h] [bp-78h]@1
  double v6; // [sp+20h] [bp-70h]@1
  double v7; // [sp+28h] [bp-68h]@1
  double v8; // [sp+30h] [bp-60h]@1
  double v9; // [sp+38h] [bp-58h]@1
  double v10; // [sp+40h] [bp-50h]@1
  double v11; // [sp+48h] [bp-48h]@1
  double v12; // [sp+50h] [bp-40h]@1
  double v13; // [sp+58h] [bp-38h]@1
  char v14; // [sp+60h] [bp-30h]@5
  char v15; // [sp+78h] [bp-18h]@5

  v5 = dbl_1000C600;
  v8 = dbl_1000C618;
  v2 = a1;
  v11 = dbl_1000C630;
  v6 = dbl_1000C608;
  v9 = dbl_1000C620;
  v12 = dbl_1000C638;
  v7 = dbl_1000C610;
  v10 = dbl_1000C628;
  v13 = dbl_1000C640;
  if ( !dword_1000C678 )
  {
    UF_VEC3_is_equal(
      a1 + 24,
      &dbl_1000C630,
      COERCE_UNSIGNED_INT64(0.00000001),
      COERCE_UNSIGNED_INT64(0.00000001) >> 32,
      &a1);
    if ( !a1 )
    {
      printf("WARNING  The tool axis is not matching with the                 rotated MCS-Z axis. The output may be INCORRECT\n");
      uc1601(
        "WARNING  The tool axis is not matching with the *                     rotated MCS-Z axis. The output may be INCORRECT\n",
        1);
    }
    dword_1000C678 = 1;
  }
  UF_VEC3_copy(v2, &v15);
  UF_VEC3_copy(v2 + 24, &v14);
  v3 = a2;
  UF_MTX3_vec_multiply(v2, &v5, a2);
  UF_MTX3_vec_multiply(v2 + 24, &v5, v3 + 24);
  return 0;
}
// 10007650: using guessed type _DWORD __cdecl sub_10007650(_DWORD, _DWORD);
// 100090E0: using guessed type int __cdecl UF_VEC3_is_equal(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090F4: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);
// 1000910C: using guessed type int __cdecl UF_MTX3_vec_multiply(_DWORD, _DWORD, _DWORD);
// 10009160: using guessed type int __cdecl uc1601(_DWORD, _DWORD);
// 1000C600: using guessed type double dbl_1000C600;
// 1000C608: using guessed type double dbl_1000C608;
// 1000C610: using guessed type double dbl_1000C610;
// 1000C618: using guessed type double dbl_1000C618;
// 1000C620: using guessed type double dbl_1000C620;
// 1000C628: using guessed type double dbl_1000C628;
// 1000C630: using guessed type double dbl_1000C630;
// 1000C638: using guessed type double dbl_1000C638;
// 1000C640: using guessed type double dbl_1000C640;
// 1000C678: using guessed type int dword_1000C678;

//----- (10007750) --------------------------------------------------------
int __cdecl sub_10007750(int a1, int a2)
{
  char v3; // [sp+1Ch] [bp-18h]@1

  UF_VEC3_add(a1, &unk_1000C648, a2);
  UF_VEC3_sub(a1, &unk_1000C5E8, a2);
  UF_VEC3_copy(a1 + 24, a2 + 24);
  UF_VEC3_scale(LODWORD(dbl_1000C660), HIDWORD(dbl_1000C660), a2 + 24, &v3);
  UF_VEC3_add(a2, &v3, a2);
  if ( dword_1000C668 == 1 )
  {
    UF_VEC3_scale(LODWORD(dbl_1000C670), HIDWORD(dbl_1000C670), a2 + 24, &v3);
    UF_VEC3_add(a2, &v3, a2);
  }
  return 0;
}
// 10007750: using guessed type _DWORD __cdecl sub_10007750(_DWORD, _DWORD);
// 100090C4: using guessed type int __cdecl UF_VEC3_scale(_DWORD, _DWORD, _DWORD, _DWORD);
// 100090EC: using guessed type int __cdecl UF_VEC3_sub(_DWORD, _DWORD, _DWORD);
// 100090F4: using guessed type int __cdecl UF_VEC3_copy(_DWORD, _DWORD);
// 10009100: using guessed type int __cdecl UF_VEC3_add(_DWORD, _DWORD, _DWORD);
// 1000C660: using guessed type double dbl_1000C660;
// 1000C668: using guessed type int dword_1000C668;
// 1000C670: using guessed type double dbl_1000C670;

//----- (100077F0) --------------------------------------------------------
int __cdecl sub_100077F0(int a1, int a2, int a3)
{
  long double v3; // st7@1
  char *v4; // edi@1
  double v5; // st6@1
  int v6; // esi@1
  int v7; // edi@10
  char *v8; // esi@11
  char v10; // [sp+18h] [bp-150h]@1
  char v11; // [sp+F0h] [bp-78h]@5
  long double v12; // [sp+108h] [bp-60h]@1
  double v13; // [sp+110h] [bp-58h]@1
  double v14; // [sp+118h] [bp-50h]@1
  double v15; // [sp+120h] [bp-48h]@1
  double v16; // [sp+128h] [bp-40h]@1
  double v17; // [sp+130h] [bp-38h]@1
  double v18; // [sp+138h] [bp-30h]@1
  double v19; // [sp+140h] [bp-28h]@1
  double v20; // [sp+148h] [bp-20h]@1
  double v21; // [sp+150h] [bp-18h]@1
  long double v22; // [sp+158h] [bp-10h]@5
  int v23; // [sp+160h] [bp-8h]@1
  int v24; // [sp+164h] [bp-4h]@1

  v13 = 1.0;
  v14 = 0.0;
  v15 = 0.0;
  v16 = 0.0;
  v18 = 0.0;
  v19 = 0.0;
  v20 = 0.0;
  v17 = 1.0;
  v21 = 1.0;
  v3 = asin(1.0) * 0.01111111111111111;
  v24 = 0;
  v12 = v3;
  v4 = &v10;
  v5 = -1.0;
  v6 = a3 + 8;
  v23 = 3;
  do
  {
    if ( (signed int)*(double *)(v6 - 8) == 1 )
    {
      v22 = v3 * v5 * *(double *)v6;
      UF_MTX3_x_vec(&v13, &v11);
    }
    else
    {
      if ( (signed int)*(double *)(v6 - 8) == 2 )
      {
        v22 = v3 * v5 * *(double *)v6;
        UF_MTX3_y_vec(&v13, &v11);
      }
      else
      {
        if ( (signed int)*(double *)(v6 - 8) != 3 )
          goto LABEL_9;
        v22 = v3 * v5 * *(double *)v6;
        UF_MTX3_z_vec(&v13, &v11);
      }
    }
    UF_MTX3_rotate_about_axis(&v11, LODWORD(v22), HIDWORD(v22), v4);
    v3 = v12;
    ++v24;
    v5 = -1.0;
    v4 += 72;
LABEL_9:
    v6 += 16;
    --v23;
  }
  while ( v23 );
  v7 = v24;
  if ( v24 > 0 )
  {
    v8 = &v10;
    do
    {
      UF_MTX3_multiply(&v13, v8, &v13);
      v8 += 72;
      --v7;
    }
    while ( v7 );
  }
  *(_QWORD *)(a2 + 24) = *(_QWORD *)&v13;
  *(_QWORD *)(a2 + 48) = *(_QWORD *)&v16;
  dword_1000C678 = 0;
  *(_QWORD *)(a2 + 72) = *(_QWORD *)&v19;
  *(_QWORD *)(a2 + 32) = *(_QWORD *)&v14;
  *(_QWORD *)(a2 + 56) = *(_QWORD *)&v17;
  *(_QWORD *)(a2 + 80) = *(_QWORD *)&v20;
  *(_QWORD *)(a2 + 40) = *(_QWORD *)&v15;
  *(_QWORD *)(a2 + 64) = *(_QWORD *)&v18;
  *(_QWORD *)(a2 + 88) = *(_QWORD *)&v21;
  return 0;
}
// 100077F0: could not find valid save-restore pair for edi
// 100077F0: could not find valid save-restore pair for esi
// 100077F0: using guessed type _DWORD __cdecl sub_100077F0(_DWORD, _DWORD, _DWORD);
// 100090B0: using guessed type int __cdecl UF_MTX3_x_vec(_DWORD, _DWORD);
// 100090B8: using guessed type int __cdecl UF_MTX3_rotate_about_axis(_DWORD, _DWORD, _DWORD, _DWORD);
// 100090BC: using guessed type int __cdecl UF_MTX3_multiply(_DWORD, _DWORD, _DWORD);
// 100090CC: using guessed type int __cdecl UF_MTX3_z_vec(_DWORD, _DWORD);
// 1000911C: using guessed type int __cdecl UF_MTX3_y_vec(_DWORD, _DWORD);
// 1000C678: using guessed type int dword_1000C678;

//----- (10007DBB) --------------------------------------------------------
int __cdecl sub_10007DBB()
{
  return _clean_type_info_names_internal(&unk_1000C680);
}
// 1000818A: using guessed type int __cdecl _clean_type_info_names_internal(_DWORD);

//----- (10007E7F) --------------------------------------------------------
int (*__cdecl sub_10007E7F())(void)
{
  int (*result)(void); // eax@1
  unsigned int v1; // edi@1

  result = (int (*)(void))&unk_1000AE58;
  v1 = (unsigned int)&unk_1000AE58;
  if ( &unk_1000AE58 < &unk_1000AE58 )
  {
    do
    {
      result = *(int (**)(void))v1;
      if ( *(_DWORD *)v1 )
        result = (int (*)(void))result();
      v1 += 4;
    }
    while ( v1 < (unsigned int)&unk_1000AE58 );
  }
  return result;
}

//----- (10008034) --------------------------------------------------------
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
  if ( fdwReason == 1 && !dword_1000ADA0 )
    DisableThreadLibraryCalls(hinstDLL);
  return 1;
}
// 1000ADA0: using guessed type int dword_1000ADA0;

//----- (10008179) --------------------------------------------------------
int __cdecl sub_10008179()
{
  dword_1000C9AC = IsProcessorFeaturePresent(0xAu);
  return 0;
}
// 1000C9AC: using guessed type int dword_1000C9AC;

// ALL OK, 54 function(s) have been successfully decompiled
